/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  DEFAULT_SETTINGS: () => DEFAULT_SETTINGS,
  default: () => LLMPlugin2
});
module.exports = __toCommonJS(main_exports);
var import_obsidian16 = require("obsidian");

// src/Assistants/AssistantHandler.ts
var Assistants = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  push(assistant2) {
    try {
      let assistants = this.plugin.settings.assistants;
      assistants.push(assistant2);
      this.plugin.settings.assistants = assistants;
      this.plugin.saveSettings();
      return true;
    } catch (e3) {
      return false;
    }
  }
  reset() {
    this.plugin.settings.assistants = [];
    this.plugin.saveSettings();
  }
};

// src/History/HistoryHandler.ts
var History = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  push(message_context) {
    try {
      let history = this.plugin.settings.promptHistory;
      history.push(message_context);
      if (history.length > 10) {
        history.remove(history[0]);
      }
      this.plugin.settings.promptHistory = history;
      this.plugin.saveSettings();
      return true;
    } catch (e3) {
      return false;
    }
  }
  update(index, messages2) {
    this.plugin.settings.promptHistory[index].messages = messages2;
    this.plugin.saveSettings();
  }
  reset() {
    this.plugin.settings.promptHistory = [];
    this.plugin.saveSettings();
  }
  //take in an index from the selected chat history
  //overwrite history with new prompt/additional prompt
  overwriteHistory(messages2, index) {
    const historyItem = this.plugin.settings.promptHistory[index];
    historyItem.messages = messages2;
    this.plugin.settings.promptHistory[index] = historyItem;
    this.plugin.saveSettings();
  }
};

// src/Plugin/Components/AssistantsContainer.ts
var import_obsidian4 = require("obsidian");

// src/utils/constants.ts
var claude = "claude";
var claudeCode = "claudeCode";
var openAI = "openAI";
var gemini = "gemini";
var GPT4All = "GPT4All";
var claudeCodeEndpoint = "claudeCodeAgent";
var claudeSonnetJuneModel = "claude-3-5-sonnet-20240620";
var geminiModel = "gemini-1.5-flash";
var gemini2FlashModel = "gemini-2.0-flash-exp";
var gemini2FlashThinkingModel = "gemini-2.0-flash-thinking-exp-1219";
var gemini2FlashStableModel = "gemini-2.0-flash";
var gemini2FlashLiteModel = "gemini-2.0-flash-lite";
var gemini25ProModel = "gemini-2.5-pro";
var gemini25FlashModel = "gemini-2.5-flash";
var gemini25FlashLiteModel = "gemini-2.5-flash-lite";
var gemini3ProPreviewModel = "gemini-3-pro-preview";
var geminiFlashLatestModel = "gemini-flash-latest";
var geminiFlashLiteLatestModel = "gemini-flash-lite-latest";
var openAIModel = "gpt-3.5-turbo";
var messages = "messages";
var assistant = "assistant";
var chat = "chat";

// src/utils/models.ts
var openAIModels = {
  "ChatGPT-3.5 turbo": {
    model: "gpt-3.5-turbo",
    type: "openAI",
    endpoint: chat,
    url: "/chat/completions"
  },
  "GPT-4o": {
    model: "gpt-4o",
    type: "openAI",
    endpoint: chat,
    url: "/chat/completions"
  }
};
var models = {
  ...openAIModels,
  "ChatGPT-3.5 turbo GPT4All": {
    model: "gpt4all-gpt-3.5-turbo.rmodel",
    type: GPT4All,
    endpoint: chat,
    url: "/v1/chat/completions"
  },
  "Mistral OpenOrca": {
    model: "mistral-7b-openorca.Q4_0.gguf",
    type: GPT4All,
    endpoint: chat,
    url: "/v1/chat/completions"
  },
  "Mistral Instruct": {
    model: "mistral-7b-instruct-v0.1.Q4_0.gguf",
    type: GPT4All,
    endpoint: chat,
    url: "/v1/chat/completions"
  },
  "GPT4All Falcon": {
    model: "gpt4all-falcon-newbpe-q4_0.gguf",
    type: GPT4All,
    endpoint: chat,
    url: "/v1/chat/completions"
  },
  "Orca 2 (Medium)": {
    model: "orca-2-7b.Q4_0.gguf",
    type: GPT4All,
    endpoint: chat,
    url: "/v1/chat/completions"
  },
  "Orca 2 (Full)": {
    model: "orca-2-13b.Q4_0.gguf",
    type: GPT4All,
    endpoint: chat,
    url: "/v1/chat/completions"
  },
  "Mini Orca (Small)": {
    model: "orca-mini-3b-gguf2-q4_0.gguf",
    type: GPT4All,
    endpoint: chat,
    url: "/v1/chat/completions"
  },
  "MPT Chat": {
    model: "mpt-7b-chat-newbpe-q4_0.gguf",
    type: GPT4All,
    endpoint: chat,
    url: "/v1/chat/completions"
  },
  "Wizard v1.2": {
    model: "wizardlm-13b-v1.2.Q4_0.gguf",
    type: GPT4All,
    endpoint: chat,
    url: "/v1/chat/completions"
  },
  "Hermes 13B": {
    model: "nous-hermes-llama2-13b.Q4_0.gguf",
    type: GPT4All,
    endpoint: chat,
    url: "/v1/chat/completions"
  },
  "Hermes 7B": {
    model: "Nous-Hermes-2-Mistral-7B-DPO.Q4_0.gguf",
    type: GPT4All,
    endpoint: chat,
    url: "/v1/chat/completions"
  },
  Snoozy: {
    model: "gpt4all-13b-snoozy-q4_0.gguf",
    type: GPT4All,
    endpoint: chat,
    url: "/v1/chat/completions"
  },
  "EM German Mistral": {
    model: "em_german_mistral_v01.Q4_0.gguf",
    type: GPT4All,
    endpoint: chat,
    url: "/v1/chat/completions"
  },
  // Claude Models
  "Claude-3-5-Sonnet-20240620": {
    model: "claude-3-5-sonnet-20240620",
    type: claude,
    endpoint: messages,
    // We will not consume these so can we remove them?
    url: "/v1/messages"
  },
  // Gemini Models
  "Gemini-1.5-flash": {
    model: geminiModel,
    type: gemini,
    endpoint: "gemini",
    url: "gemini"
  },
  "Gemini-3-Pro-Preview": {
    model: gemini3ProPreviewModel,
    type: gemini,
    endpoint: "gemini",
    url: "gemini"
  },
  "Gemini-2.5-Pro": {
    model: gemini25ProModel,
    type: gemini,
    endpoint: "gemini",
    url: "gemini"
  },
  "Gemini-Flash-Latest": {
    model: geminiFlashLatestModel,
    type: gemini,
    endpoint: "gemini",
    url: "gemini"
  },
  "Gemini-Flash-Lite-Latest": {
    model: geminiFlashLiteLatestModel,
    type: gemini,
    endpoint: "gemini",
    url: "gemini"
  },
  "Gemini-2.5-Flash": {
    model: gemini25FlashModel,
    type: gemini,
    endpoint: "gemini",
    url: "gemini"
  },
  "Gemini-2.5-Flash-Lite": {
    model: gemini25FlashLiteModel,
    type: gemini,
    endpoint: "gemini",
    url: "gemini"
  },
  "Gemini-2.0-Flash": {
    model: gemini2FlashStableModel,
    type: gemini,
    endpoint: "gemini",
    url: "gemini"
  },
  "Gemini-2.0-Flash-Lite": {
    model: gemini2FlashLiteModel,
    type: gemini,
    endpoint: "gemini",
    url: "gemini"
  },
  "Gemini-2.0-flash-exp": {
    model: gemini2FlashModel,
    type: gemini,
    endpoint: "gemini",
    url: "gemini"
  },
  "Gemini-2.0-flash-thinking-exp": {
    model: gemini2FlashThinkingModel,
    type: gemini,
    endpoint: "gemini",
    url: "gemini"
  },
  // Claude Code (Agent SDK)
  "Claude Code": {
    model: "claude-code",
    type: claudeCode,
    endpoint: claudeCodeEndpoint,
    url: ""
  },
  "DALL\xB7E 3": {
    model: "dall-e-3",
    type: "openAI",
    endpoint: "images",
    url: "/images/generations"
  },
  "DALL\xB7E 2": {
    model: "dall-e-2",
    type: "openAI",
    endpoint: "images",
    url: "/images/generations"
  }
};
var modelNames = {
  "mistral-7b-openorca.Q4_0.gguf": "Mistral OpenOrca",
  "mistral-7b-instruct-v0.1.Q4_0.gguf": "Mistral Instruct",
  "gpt4all-falcon-newbpe-q4_0.gguf": "GPT4All Falcon",
  "orca-2-7b.Q4_0.gguf": "Orca 2 (Medium)",
  "orca-2-13b.Q4_0.gguf": "Orca 2 (Full)",
  "orca-mini-3b-gguf2-q4_0.gguf": "Mini Orca (Small)",
  "mpt-7b-chat-newbpe-q4_0.gguf": "MPT Chat",
  "wizardlm-13b-v1.2.Q4_0.gguf": "Wizard v1.2",
  "nous-hermes-llama2-13b.Q4_0.gguf": "Hermes 13B",
  "Nous-Hermes-2-Mistral-7B-DPO.Q4_0.gguf": "Hermes 7B",
  "gpt4all-gpt-3.5-turbo.rmodel": "ChatGPT-3.5 turbo GPT4All",
  "gpt4all-13b-snoozy-q4_0.gguf": "Snoozy",
  "em_german_mistral_v01.Q4_0.gguf": "EM German Mistral",
  "gpt-3.5-turbo": "ChatGPT-3.5 turbo",
  "gpt-4o": "GPT-4o",
  "claude-3-5-sonnet-20240620": "Claude-3-5-Sonnet-20240620",
  "gemini-1.5-flash": "Gemini-1.5-flash",
  "gemini-3-pro-preview": "Gemini-3-Pro-Preview",
  "gemini-2.5-pro": "Gemini-2.5-Pro",
  "gemini-flash-latest": "Gemini-Flash-Latest",
  "gemini-flash-lite-latest": "Gemini-Flash-Lite-Latest",
  "gemini-2.5-flash": "Gemini-2.5-Flash",
  "gemini-2.5-flash-lite": "Gemini-2.5-Flash-Lite",
  "gemini-2.0-flash": "Gemini-2.0-Flash",
  "gemini-2.0-flash-lite": "Gemini-2.0-Flash-Lite",
  "gemini-2.0-flash-exp": "Gemini-2.0-flash-exp",
  "gemini-2.0-flash-thinking-exp-1219": "Gemini-2.0-flash-thinking-exp",
  "claude-code": "Claude Code",
  // "text-embedding-3-small": "Text Embedding 3 (Small)",
  "dall-e-3": "DALL\xB7E 3",
  "dall-e-2": "DALL\xB7E 2"
};

// src/utils/utils.ts
var import_obsidian3 = require("obsidian");

// node_modules/openai/internal/tslib.mjs
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

// node_modules/openai/internal/utils/uuid.mjs
var uuid4 = function() {
  const { crypto: crypto2 } = globalThis;
  if (crypto2 == null ? void 0 : crypto2.randomUUID) {
    uuid4 = crypto2.randomUUID.bind(crypto2);
    return crypto2.randomUUID();
  }
  const u8 = new Uint8Array(1);
  const randomByte = crypto2 ? () => crypto2.getRandomValues(u8)[0] : () => Math.random() * 255 & 255;
  return "10000000-1000-4000-8000-100000000000".replace(/[018]/g, (c) => (+c ^ randomByte() & 15 >> +c / 4).toString(16));
};

// node_modules/openai/internal/errors.mjs
function isAbortError(err) {
  return typeof err === "object" && err !== null && // Spec-compliant fetch implementations
  ("name" in err && err.name === "AbortError" || // Expo fetch
  "message" in err && String(err.message).includes("FetchRequestCanceledException"));
}
var castToError = (err) => {
  if (err instanceof Error)
    return err;
  if (typeof err === "object" && err !== null) {
    try {
      if (Object.prototype.toString.call(err) === "[object Error]") {
        const error = new Error(err.message, err.cause ? { cause: err.cause } : {});
        if (err.stack)
          error.stack = err.stack;
        if (err.cause && !error.cause)
          error.cause = err.cause;
        if (err.name)
          error.name = err.name;
        return error;
      }
    } catch (e3) {
    }
    try {
      return new Error(JSON.stringify(err));
    } catch (e3) {
    }
  }
  return new Error(err);
};

// node_modules/openai/core/error.mjs
var OpenAIError = class extends Error {
};
var APIError = class _APIError extends OpenAIError {
  constructor(status, error, message, headers) {
    super(`${_APIError.makeMessage(status, error, message)}`);
    this.status = status;
    this.headers = headers;
    this.requestID = headers == null ? void 0 : headers.get("x-request-id");
    this.error = error;
    const data = error;
    this.code = data == null ? void 0 : data["code"];
    this.param = data == null ? void 0 : data["param"];
    this.type = data == null ? void 0 : data["type"];
  }
  static makeMessage(status, error, message) {
    const msg = (error == null ? void 0 : error.message) ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
    if (status && msg) {
      return `${status} ${msg}`;
    }
    if (status) {
      return `${status} status code (no body)`;
    }
    if (msg) {
      return msg;
    }
    return "(no status code or body)";
  }
  static generate(status, errorResponse, message, headers) {
    if (!status || !headers) {
      return new APIConnectionError({ message, cause: castToError(errorResponse) });
    }
    const error = errorResponse == null ? void 0 : errorResponse["error"];
    if (status === 400) {
      return new BadRequestError(status, error, message, headers);
    }
    if (status === 401) {
      return new AuthenticationError(status, error, message, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError(status, error, message, headers);
    }
    if (status === 404) {
      return new NotFoundError(status, error, message, headers);
    }
    if (status === 409) {
      return new ConflictError(status, error, message, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError(status, error, message, headers);
    }
    if (status === 429) {
      return new RateLimitError(status, error, message, headers);
    }
    if (status >= 500) {
      return new InternalServerError(status, error, message, headers);
    }
    return new _APIError(status, error, message, headers);
  }
};
var APIUserAbortError = class extends APIError {
  constructor({ message } = {}) {
    super(void 0, void 0, message || "Request was aborted.", void 0);
  }
};
var APIConnectionError = class extends APIError {
  constructor({ message, cause }) {
    super(void 0, void 0, message || "Connection error.", void 0);
    if (cause)
      this.cause = cause;
  }
};
var APIConnectionTimeoutError = class extends APIConnectionError {
  constructor({ message } = {}) {
    super({ message: message != null ? message : "Request timed out." });
  }
};
var BadRequestError = class extends APIError {
};
var AuthenticationError = class extends APIError {
};
var PermissionDeniedError = class extends APIError {
};
var NotFoundError = class extends APIError {
};
var ConflictError = class extends APIError {
};
var UnprocessableEntityError = class extends APIError {
};
var RateLimitError = class extends APIError {
};
var InternalServerError = class extends APIError {
};
var LengthFinishReasonError = class extends OpenAIError {
  constructor() {
    super(`Could not parse response content as the length limit was reached`);
  }
};
var ContentFilterFinishReasonError = class extends OpenAIError {
  constructor() {
    super(`Could not parse response content as the request was rejected by the content filter`);
  }
};
var InvalidWebhookSignatureError = class extends Error {
  constructor(message) {
    super(message);
  }
};

// node_modules/openai/internal/utils/values.mjs
var startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;
var isAbsoluteURL = (url) => {
  return startsWithSchemeRegexp.test(url);
};
var isArray = (val) => (isArray = Array.isArray, isArray(val));
var isReadonlyArray = isArray;
function maybeObj(x3) {
  if (typeof x3 !== "object") {
    return {};
  }
  return x3 != null ? x3 : {};
}
function isEmptyObj(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function isObj(obj) {
  return obj != null && typeof obj === "object" && !Array.isArray(obj);
}
var validatePositiveInteger = (name, n3) => {
  if (typeof n3 !== "number" || !Number.isInteger(n3)) {
    throw new OpenAIError(`${name} must be an integer`);
  }
  if (n3 < 0) {
    throw new OpenAIError(`${name} must be a positive integer`);
  }
  return n3;
};
var safeJSON = (text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return void 0;
  }
};

// node_modules/openai/internal/utils/sleep.mjs
var sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

// node_modules/openai/version.mjs
var VERSION = "6.18.0";

// node_modules/openai/internal/detect-platform.mjs
var isRunningInBrowser = () => {
  return (
    // @ts-ignore
    typeof window !== "undefined" && // @ts-ignore
    typeof window.document !== "undefined" && // @ts-ignore
    typeof navigator !== "undefined"
  );
};
function getDetectedPlatform() {
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return "deno";
  }
  if (typeof EdgeRuntime !== "undefined") {
    return "edge";
  }
  if (Object.prototype.toString.call(typeof globalThis.process !== "undefined" ? globalThis.process : 0) === "[object process]") {
    return "node";
  }
  return "unknown";
}
var getPlatformProperties = () => {
  var _a5, _b, _c, _d, _e;
  const detectedPlatform = getDetectedPlatform();
  if (detectedPlatform === "deno") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(Deno.build.os),
      "X-Stainless-Arch": normalizeArch(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : (_b = (_a5 = Deno.version) == null ? void 0 : _a5.deno) != null ? _b : "unknown"
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": globalThis.process.version
    };
  }
  if (detectedPlatform === "node") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform((_c = globalThis.process.platform) != null ? _c : "unknown"),
      "X-Stainless-Arch": normalizeArch((_d = globalThis.process.arch) != null ? _d : "unknown"),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": (_e = globalThis.process.version) != null ? _e : "unknown"
    };
  }
  const browserInfo = getBrowserInfo();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function getBrowserInfo() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
var normalizeArch = (arch) => {
  if (arch === "x32")
    return "x32";
  if (arch === "x86_64" || arch === "x64")
    return "x64";
  if (arch === "arm")
    return "arm";
  if (arch === "aarch64" || arch === "arm64")
    return "arm64";
  if (arch)
    return `other:${arch}`;
  return "unknown";
};
var normalizePlatform = (platform) => {
  platform = platform.toLowerCase();
  if (platform.includes("ios"))
    return "iOS";
  if (platform === "android")
    return "Android";
  if (platform === "darwin")
    return "MacOS";
  if (platform === "win32")
    return "Windows";
  if (platform === "freebsd")
    return "FreeBSD";
  if (platform === "openbsd")
    return "OpenBSD";
  if (platform === "linux")
    return "Linux";
  if (platform)
    return `Other:${platform}`;
  return "Unknown";
};
var _platformHeaders;
var getPlatformHeaders = () => {
  return _platformHeaders != null ? _platformHeaders : _platformHeaders = getPlatformProperties();
};

// node_modules/openai/internal/shims.mjs
function getDefaultFetch() {
  if (typeof fetch !== "undefined") {
    return fetch;
  }
  throw new Error("`fetch` is not defined as a global; Either pass `fetch` to the client, `new OpenAI({ fetch })` or polyfill the global, `globalThis.fetch = fetch`");
}
function makeReadableStream(...args) {
  const ReadableStream2 = globalThis.ReadableStream;
  if (typeof ReadableStream2 === "undefined") {
    throw new Error("`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`");
  }
  return new ReadableStream2(...args);
}
function ReadableStreamFrom(iterable) {
  let iter = Symbol.asyncIterator in iterable ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();
  return makeReadableStream({
    start() {
    },
    async pull(controller) {
      const { done, value } = await iter.next();
      if (done) {
        controller.close();
      } else {
        controller.enqueue(value);
      }
    },
    async cancel() {
      var _a5;
      await ((_a5 = iter.return) == null ? void 0 : _a5.call(iter));
    }
  });
}
function ReadableStreamToAsyncIterable(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result == null ? void 0 : result.done)
          reader.releaseLock();
        return result;
      } catch (e3) {
        reader.releaseLock();
        throw e3;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
async function CancelReadableStream(stream) {
  var _a5, _b;
  if (stream === null || typeof stream !== "object")
    return;
  if (stream[Symbol.asyncIterator]) {
    await ((_b = (_a5 = stream[Symbol.asyncIterator]()).return) == null ? void 0 : _b.call(_a5));
    return;
  }
  const reader = stream.getReader();
  const cancelPromise = reader.cancel();
  reader.releaseLock();
  await cancelPromise;
}

// node_modules/openai/internal/request-options.mjs
var FallbackEncoder = ({ headers, body }) => {
  return {
    bodyHeaders: {
      "content-type": "application/json"
    },
    body: JSON.stringify(body)
  };
};

// node_modules/openai/internal/qs/formats.mjs
var default_format = "RFC3986";
var default_formatter = (v3) => String(v3);
var formatters = {
  RFC1738: (v3) => String(v3).replace(/%20/g, "+"),
  RFC3986: default_formatter
};
var RFC1738 = "RFC1738";

// node_modules/openai/internal/qs/utils.mjs
var has = (obj, key) => {
  var _a5;
  return has = (_a5 = Object.hasOwn) != null ? _a5 : Function.prototype.call.bind(Object.prototype.hasOwnProperty), has(obj, key);
};
var hex_table = /* @__PURE__ */ (() => {
  const array = [];
  for (let i3 = 0; i3 < 256; ++i3) {
    array.push("%" + ((i3 < 16 ? "0" : "") + i3.toString(16)).toUpperCase());
  }
  return array;
})();
var limit = 1024;
var encode = (str2, _defaultEncoder, charset, _kind, format) => {
  if (str2.length === 0) {
    return str2;
  }
  let string = str2;
  if (typeof str2 === "symbol") {
    string = Symbol.prototype.toString.call(str2);
  } else if (typeof str2 !== "string") {
    string = String(str2);
  }
  if (charset === "iso-8859-1") {
    return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
      return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
    });
  }
  let out = "";
  for (let j3 = 0; j3 < string.length; j3 += limit) {
    const segment = string.length >= limit ? string.slice(j3, j3 + limit) : string;
    const arr = [];
    for (let i3 = 0; i3 < segment.length; ++i3) {
      let c = segment.charCodeAt(i3);
      if (c === 45 || // -
      c === 46 || // .
      c === 95 || // _
      c === 126 || // ~
      c >= 48 && c <= 57 || // 0-9
      c >= 65 && c <= 90 || // a-z
      c >= 97 && c <= 122 || // A-Z
      format === RFC1738 && (c === 40 || c === 41)) {
        arr[arr.length] = segment.charAt(i3);
        continue;
      }
      if (c < 128) {
        arr[arr.length] = hex_table[c];
        continue;
      }
      if (c < 2048) {
        arr[arr.length] = hex_table[192 | c >> 6] + hex_table[128 | c & 63];
        continue;
      }
      if (c < 55296 || c >= 57344) {
        arr[arr.length] = hex_table[224 | c >> 12] + hex_table[128 | c >> 6 & 63] + hex_table[128 | c & 63];
        continue;
      }
      i3 += 1;
      c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i3) & 1023);
      arr[arr.length] = hex_table[240 | c >> 18] + hex_table[128 | c >> 12 & 63] + hex_table[128 | c >> 6 & 63] + hex_table[128 | c & 63];
    }
    out += arr.join("");
  }
  return out;
};
function is_buffer(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
}
function maybe_map(val, fn) {
  if (isArray(val)) {
    const mapped = [];
    for (let i3 = 0; i3 < val.length; i3 += 1) {
      mapped.push(fn(val[i3]));
    }
    return mapped;
  }
  return fn(val);
}

// node_modules/openai/internal/qs/stringify.mjs
var array_prefix_generators = {
  brackets(prefix) {
    return String(prefix) + "[]";
  },
  comma: "comma",
  indices(prefix, key) {
    return String(prefix) + "[" + key + "]";
  },
  repeat(prefix) {
    return String(prefix);
  }
};
var push_to_array = function(arr, value_or_array) {
  Array.prototype.push.apply(arr, isArray(value_or_array) ? value_or_array : [value_or_array]);
};
var toISOString;
var defaults = {
  addQueryPrefix: false,
  allowDots: false,
  allowEmptyArrays: false,
  arrayFormat: "indices",
  charset: "utf-8",
  charsetSentinel: false,
  delimiter: "&",
  encode: true,
  encodeDotInKeys: false,
  encoder: encode,
  encodeValuesOnly: false,
  format: default_format,
  formatter: default_formatter,
  /** @deprecated */
  indices: false,
  serializeDate(date) {
    return (toISOString != null ? toISOString : toISOString = Function.prototype.call.bind(Date.prototype.toISOString))(date);
  },
  skipNulls: false,
  strictNullHandling: false
};
function is_non_nullish_primitive(v3) {
  return typeof v3 === "string" || typeof v3 === "number" || typeof v3 === "boolean" || typeof v3 === "symbol" || typeof v3 === "bigint";
}
var sentinel = {};
function inner_stringify(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
  let obj = object;
  let tmp_sc = sideChannel;
  let step = 0;
  let find_flag = false;
  while ((tmp_sc = tmp_sc.get(sentinel)) !== void 0 && !find_flag) {
    const pos = tmp_sc.get(object);
    step += 1;
    if (typeof pos !== "undefined") {
      if (pos === step) {
        throw new RangeError("Cyclic object value");
      } else {
        find_flag = true;
      }
    }
    if (typeof tmp_sc.get(sentinel) === "undefined") {
      step = 0;
    }
  }
  if (typeof filter === "function") {
    obj = filter(prefix, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate == null ? void 0 : serializeDate(obj);
  } else if (generateArrayPrefix === "comma" && isArray(obj)) {
    obj = maybe_map(obj, function(value) {
      if (value instanceof Date) {
        return serializeDate == null ? void 0 : serializeDate(value);
      }
      return value;
    });
  }
  if (obj === null) {
    if (strictNullHandling) {
      return encoder && !encodeValuesOnly ? (
        // @ts-expect-error
        encoder(prefix, defaults.encoder, charset, "key", format)
      ) : prefix;
    }
    obj = "";
  }
  if (is_non_nullish_primitive(obj) || is_buffer(obj)) {
    if (encoder) {
      const key_value = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
      return [
        (formatter == null ? void 0 : formatter(key_value)) + "=" + // @ts-expect-error
        (formatter == null ? void 0 : formatter(encoder(obj, defaults.encoder, charset, "value", format)))
      ];
    }
    return [(formatter == null ? void 0 : formatter(prefix)) + "=" + (formatter == null ? void 0 : formatter(String(obj)))];
  }
  const values = [];
  if (typeof obj === "undefined") {
    return values;
  }
  let obj_keys;
  if (generateArrayPrefix === "comma" && isArray(obj)) {
    if (encodeValuesOnly && encoder) {
      obj = maybe_map(obj, encoder);
    }
    obj_keys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
  } else if (isArray(filter)) {
    obj_keys = filter;
  } else {
    const keys = Object.keys(obj);
    obj_keys = sort ? keys.sort(sort) : keys;
  }
  const encoded_prefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
  const adjusted_prefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encoded_prefix + "[]" : encoded_prefix;
  if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
    return adjusted_prefix + "[]";
  }
  for (let j3 = 0; j3 < obj_keys.length; ++j3) {
    const key = obj_keys[j3];
    const value = (
      // @ts-ignore
      typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key]
    );
    if (skipNulls && value === null) {
      continue;
    }
    const encoded_key = allowDots && encodeDotInKeys ? key.replace(/\./g, "%2E") : key;
    const key_prefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjusted_prefix, encoded_key) : adjusted_prefix : adjusted_prefix + (allowDots ? "." + encoded_key : "[" + encoded_key + "]");
    sideChannel.set(object, step);
    const valueSideChannel = /* @__PURE__ */ new WeakMap();
    valueSideChannel.set(sentinel, sideChannel);
    push_to_array(values, inner_stringify(
      value,
      key_prefix,
      generateArrayPrefix,
      commaRoundTrip,
      allowEmptyArrays,
      strictNullHandling,
      skipNulls,
      encodeDotInKeys,
      // @ts-ignore
      generateArrayPrefix === "comma" && encodeValuesOnly && isArray(obj) ? null : encoder,
      filter,
      sort,
      allowDots,
      serializeDate,
      format,
      formatter,
      encodeValuesOnly,
      charset,
      valueSideChannel
    ));
  }
  return values;
}
function normalize_stringify_options(opts = defaults) {
  if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  }
  if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
    throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
  }
  if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
    throw new TypeError("Encoder has to be a function.");
  }
  const charset = opts.charset || defaults.charset;
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  let format = default_format;
  if (typeof opts.format !== "undefined") {
    if (!has(formatters, opts.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    format = opts.format;
  }
  const formatter = formatters[format];
  let filter = defaults.filter;
  if (typeof opts.filter === "function" || isArray(opts.filter)) {
    filter = opts.filter;
  }
  let arrayFormat;
  if (opts.arrayFormat && opts.arrayFormat in array_prefix_generators) {
    arrayFormat = opts.arrayFormat;
  } else if ("indices" in opts) {
    arrayFormat = opts.indices ? "indices" : "repeat";
  } else {
    arrayFormat = defaults.arrayFormat;
  }
  if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  }
  const allowDots = typeof opts.allowDots === "undefined" ? !!opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
  return {
    addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
    // @ts-ignore
    allowDots,
    allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
    arrayFormat,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
    commaRoundTrip: !!opts.commaRoundTrip,
    delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
    encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
    encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
    encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
    filter,
    format,
    formatter,
    serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
    skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
    // @ts-ignore
    sort: typeof opts.sort === "function" ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
  };
}
function stringify(object, opts = {}) {
  let obj = object;
  const options = normalize_stringify_options(opts);
  let obj_keys;
  let filter;
  if (typeof options.filter === "function") {
    filter = options.filter;
    obj = filter("", obj);
  } else if (isArray(options.filter)) {
    filter = options.filter;
    obj_keys = filter;
  }
  const keys = [];
  if (typeof obj !== "object" || obj === null) {
    return "";
  }
  const generateArrayPrefix = array_prefix_generators[options.arrayFormat];
  const commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
  if (!obj_keys) {
    obj_keys = Object.keys(obj);
  }
  if (options.sort) {
    obj_keys.sort(options.sort);
  }
  const sideChannel = /* @__PURE__ */ new WeakMap();
  for (let i3 = 0; i3 < obj_keys.length; ++i3) {
    const key = obj_keys[i3];
    if (options.skipNulls && obj[key] === null) {
      continue;
    }
    push_to_array(keys, inner_stringify(
      obj[key],
      key,
      // @ts-expect-error
      generateArrayPrefix,
      commaRoundTrip,
      options.allowEmptyArrays,
      options.strictNullHandling,
      options.skipNulls,
      options.encodeDotInKeys,
      options.encode ? options.encoder : null,
      options.filter,
      options.sort,
      options.allowDots,
      options.serializeDate,
      options.format,
      options.formatter,
      options.encodeValuesOnly,
      options.charset,
      sideChannel
    ));
  }
  const joined = keys.join(options.delimiter);
  let prefix = options.addQueryPrefix === true ? "?" : "";
  if (options.charsetSentinel) {
    if (options.charset === "iso-8859-1") {
      prefix += "utf8=%26%2310003%3B&";
    } else {
      prefix += "utf8=%E2%9C%93&";
    }
  }
  return joined.length > 0 ? prefix + joined : "";
}

// node_modules/openai/internal/utils/bytes.mjs
function concatBytes(buffers) {
  let length = 0;
  for (const buffer of buffers) {
    length += buffer.length;
  }
  const output = new Uint8Array(length);
  let index = 0;
  for (const buffer of buffers) {
    output.set(buffer, index);
    index += buffer.length;
  }
  return output;
}
var encodeUTF8_;
function encodeUTF8(str2) {
  let encoder;
  return (encodeUTF8_ != null ? encodeUTF8_ : (encoder = new globalThis.TextEncoder(), encodeUTF8_ = encoder.encode.bind(encoder)))(str2);
}
var decodeUTF8_;
function decodeUTF8(bytes) {
  let decoder;
  return (decodeUTF8_ != null ? decodeUTF8_ : (decoder = new globalThis.TextDecoder(), decodeUTF8_ = decoder.decode.bind(decoder)))(bytes);
}

// node_modules/openai/internal/decoders/line.mjs
var _LineDecoder_buffer;
var _LineDecoder_carriageReturnIndex;
var LineDecoder = class {
  constructor() {
    _LineDecoder_buffer.set(this, void 0);
    _LineDecoder_carriageReturnIndex.set(this, void 0);
    __classPrivateFieldSet(this, _LineDecoder_buffer, new Uint8Array(), "f");
    __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, "f");
  }
  decode(chunk) {
    if (chunk == null) {
      return [];
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? encodeUTF8(chunk) : chunk;
    __classPrivateFieldSet(this, _LineDecoder_buffer, concatBytes([__classPrivateFieldGet(this, _LineDecoder_buffer, "f"), binaryChunk]), "f");
    const lines = [];
    let patternIndex;
    while ((patternIndex = findNewlineIndex(__classPrivateFieldGet(this, _LineDecoder_buffer, "f"), __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f"))) != null) {
      if (patternIndex.carriage && __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") == null) {
        __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, patternIndex.index, "f");
        continue;
      }
      if (__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") != null && (patternIndex.index !== __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") + 1 || patternIndex.carriage)) {
        lines.push(decodeUTF8(__classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(0, __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") - 1)));
        __classPrivateFieldSet(this, _LineDecoder_buffer, __classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f")), "f");
        __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, "f");
        continue;
      }
      const endIndex = __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") !== null ? patternIndex.preceding - 1 : patternIndex.preceding;
      const line = decodeUTF8(__classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(0, endIndex));
      lines.push(line);
      __classPrivateFieldSet(this, _LineDecoder_buffer, __classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(patternIndex.index), "f");
      __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, "f");
    }
    return lines;
  }
  flush() {
    if (!__classPrivateFieldGet(this, _LineDecoder_buffer, "f").length) {
      return [];
    }
    return this.decode("\n");
  }
};
_LineDecoder_buffer = /* @__PURE__ */ new WeakMap(), _LineDecoder_carriageReturnIndex = /* @__PURE__ */ new WeakMap();
LineDecoder.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r"]);
LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
function findNewlineIndex(buffer, startIndex) {
  const newline = 10;
  const carriage = 13;
  for (let i3 = startIndex != null ? startIndex : 0; i3 < buffer.length; i3++) {
    if (buffer[i3] === newline) {
      return { preceding: i3, index: i3 + 1, carriage: false };
    }
    if (buffer[i3] === carriage) {
      return { preceding: i3, index: i3 + 1, carriage: true };
    }
  }
  return null;
}
function findDoubleNewlineIndex(buffer) {
  const newline = 10;
  const carriage = 13;
  for (let i3 = 0; i3 < buffer.length - 1; i3++) {
    if (buffer[i3] === newline && buffer[i3 + 1] === newline) {
      return i3 + 2;
    }
    if (buffer[i3] === carriage && buffer[i3 + 1] === carriage) {
      return i3 + 2;
    }
    if (buffer[i3] === carriage && buffer[i3 + 1] === newline && i3 + 3 < buffer.length && buffer[i3 + 2] === carriage && buffer[i3 + 3] === newline) {
      return i3 + 4;
    }
  }
  return -1;
}

// node_modules/openai/internal/utils/log.mjs
var levelNumbers = {
  off: 0,
  error: 200,
  warn: 300,
  info: 400,
  debug: 500
};
var parseLogLevel = (maybeLevel, sourceName, client) => {
  if (!maybeLevel) {
    return void 0;
  }
  if (hasOwn(levelNumbers, maybeLevel)) {
    return maybeLevel;
  }
  loggerFor(client).warn(`${sourceName} was set to ${JSON.stringify(maybeLevel)}, expected one of ${JSON.stringify(Object.keys(levelNumbers))}`);
  return void 0;
};
function noop() {
}
function makeLogFn(fnLevel, logger, logLevel) {
  if (!logger || levelNumbers[fnLevel] > levelNumbers[logLevel]) {
    return noop;
  } else {
    return logger[fnLevel].bind(logger);
  }
}
var noopLogger = {
  error: noop,
  warn: noop,
  info: noop,
  debug: noop
};
var cachedLoggers = /* @__PURE__ */ new WeakMap();
function loggerFor(client) {
  var _a5;
  const logger = client.logger;
  const logLevel = (_a5 = client.logLevel) != null ? _a5 : "off";
  if (!logger) {
    return noopLogger;
  }
  const cachedLogger = cachedLoggers.get(logger);
  if (cachedLogger && cachedLogger[0] === logLevel) {
    return cachedLogger[1];
  }
  const levelLogger = {
    error: makeLogFn("error", logger, logLevel),
    warn: makeLogFn("warn", logger, logLevel),
    info: makeLogFn("info", logger, logLevel),
    debug: makeLogFn("debug", logger, logLevel)
  };
  cachedLoggers.set(logger, [logLevel, levelLogger]);
  return levelLogger;
}
var formatRequestDetails = (details) => {
  if (details.options) {
    details.options = { ...details.options };
    delete details.options["headers"];
  }
  if (details.headers) {
    details.headers = Object.fromEntries((details.headers instanceof Headers ? [...details.headers] : Object.entries(details.headers)).map(([name, value]) => [
      name,
      name.toLowerCase() === "authorization" || name.toLowerCase() === "cookie" || name.toLowerCase() === "set-cookie" ? "***" : value
    ]));
  }
  if ("retryOfRequestLogID" in details) {
    if (details.retryOfRequestLogID) {
      details.retryOf = details.retryOfRequestLogID;
    }
    delete details.retryOfRequestLogID;
  }
  return details;
};

// node_modules/openai/core/streaming.mjs
var _Stream_client;
var Stream = class _Stream {
  constructor(iterator, controller, client) {
    this.iterator = iterator;
    _Stream_client.set(this, void 0);
    this.controller = controller;
    __classPrivateFieldSet(this, _Stream_client, client, "f");
  }
  static fromSSEResponse(response, controller, client) {
    let consumed = false;
    const logger = client ? loggerFor(client) : console;
    async function* iterator() {
      if (consumed) {
        throw new OpenAIError("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const sse of _iterSSEMessages(response, controller)) {
          if (done)
            continue;
          if (sse.data.startsWith("[DONE]")) {
            done = true;
            continue;
          }
          if (sse.event === null || !sse.event.startsWith("thread.")) {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e3) {
              logger.error(`Could not parse message into JSON:`, sse.data);
              logger.error(`From chunk:`, sse.raw);
              throw e3;
            }
            if (data && data.error) {
              throw new APIError(void 0, data.error, void 0, response.headers);
            }
            yield data;
          } else {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e3) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e3;
            }
            if (sse.event == "error") {
              throw new APIError(void 0, data.error, data.message, void 0);
            }
            yield { event: sse.event, data };
          }
        }
        done = true;
      } catch (e3) {
        if (isAbortError(e3))
          return;
        throw e3;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new _Stream(iterator, controller, client);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(readableStream, controller, client) {
    let consumed = false;
    async function* iterLines() {
      const lineDecoder = new LineDecoder();
      const iter = ReadableStreamToAsyncIterable(readableStream);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          yield line;
        }
      }
      for (const line of lineDecoder.flush()) {
        yield line;
      }
    }
    async function* iterator() {
      if (consumed) {
        throw new OpenAIError("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const line of iterLines()) {
          if (done)
            continue;
          if (line)
            yield JSON.parse(line);
        }
        done = true;
      } catch (e3) {
        if (isAbortError(e3))
          return;
        throw e3;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new _Stream(iterator, controller, client);
  }
  [(_Stream_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const left = [];
    const right = [];
    const iterator = this.iterator();
    const teeIterator = (queue) => {
      return {
        next: () => {
          if (queue.length === 0) {
            const result = iterator.next();
            left.push(result);
            right.push(result);
          }
          return queue.shift();
        }
      };
    };
    return [
      new _Stream(() => teeIterator(left), this.controller, __classPrivateFieldGet(this, _Stream_client, "f")),
      new _Stream(() => teeIterator(right), this.controller, __classPrivateFieldGet(this, _Stream_client, "f"))
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const self2 = this;
    let iter;
    return makeReadableStream({
      async start() {
        iter = self2[Symbol.asyncIterator]();
      },
      async pull(ctrl) {
        try {
          const { value, done } = await iter.next();
          if (done)
            return ctrl.close();
          const bytes = encodeUTF8(JSON.stringify(value) + "\n");
          ctrl.enqueue(bytes);
        } catch (err) {
          ctrl.error(err);
        }
      },
      async cancel() {
        var _a5;
        await ((_a5 = iter.return) == null ? void 0 : _a5.call(iter));
      }
    });
  }
};
async function* _iterSSEMessages(response, controller) {
  if (!response.body) {
    controller.abort();
    if (typeof globalThis.navigator !== "undefined" && globalThis.navigator.product === "ReactNative") {
      throw new OpenAIError(`The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api`);
    }
    throw new OpenAIError(`Attempted to iterate over a response with no body`);
  }
  const sseDecoder = new SSEDecoder();
  const lineDecoder = new LineDecoder();
  const iter = ReadableStreamToAsyncIterable(response.body);
  for await (const sseChunk of iterSSEChunks(iter)) {
    for (const line of lineDecoder.decode(sseChunk)) {
      const sse = sseDecoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  for (const line of lineDecoder.flush()) {
    const sse = sseDecoder.decode(line);
    if (sse)
      yield sse;
  }
}
async function* iterSSEChunks(iterator) {
  let data = new Uint8Array();
  for await (const chunk of iterator) {
    if (chunk == null) {
      continue;
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? encodeUTF8(chunk) : chunk;
    let newData = new Uint8Array(data.length + binaryChunk.length);
    newData.set(data);
    newData.set(binaryChunk, data.length);
    data = newData;
    let patternIndex;
    while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {
      yield data.slice(0, patternIndex);
      data = data.slice(patternIndex);
    }
  }
  if (data.length > 0) {
    yield data;
  }
}
var SSEDecoder = class {
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length)
        return null;
      const sse = {
        event: this.event,
        data: this.data.join("\n"),
        raw: this.chunks
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _, value] = partition(line, ":");
    if (value.startsWith(" ")) {
      value = value.substring(1);
    }
    if (fieldname === "event") {
      this.event = value;
    } else if (fieldname === "data") {
      this.data.push(value);
    }
    return null;
  }
};
function partition(str2, delimiter) {
  const index = str2.indexOf(delimiter);
  if (index !== -1) {
    return [str2.substring(0, index), delimiter, str2.substring(index + delimiter.length)];
  }
  return [str2, "", ""];
}

// node_modules/openai/internal/parse.mjs
async function defaultParseResponse(client, props) {
  const { response, requestLogID, retryOfRequestLogID, startTime } = props;
  const body = await (async () => {
    var _a5;
    if (props.options.stream) {
      loggerFor(client).debug("response", response.status, response.url, response.headers, response.body);
      if (props.options.__streamClass) {
        return props.options.__streamClass.fromSSEResponse(response, props.controller, client);
      }
      return Stream.fromSSEResponse(response, props.controller, client);
    }
    if (response.status === 204) {
      return null;
    }
    if (props.options.__binaryResponse) {
      return response;
    }
    const contentType = response.headers.get("content-type");
    const mediaType = (_a5 = contentType == null ? void 0 : contentType.split(";")[0]) == null ? void 0 : _a5.trim();
    const isJSON = (mediaType == null ? void 0 : mediaType.includes("application/json")) || (mediaType == null ? void 0 : mediaType.endsWith("+json"));
    if (isJSON) {
      const contentLength = response.headers.get("content-length");
      if (contentLength === "0") {
        return void 0;
      }
      const json = await response.json();
      return addRequestID(json, response);
    }
    const text = await response.text();
    return text;
  })();
  loggerFor(client).debug(`[${requestLogID}] response parsed`, formatRequestDetails({
    retryOfRequestLogID,
    url: response.url,
    status: response.status,
    body,
    durationMs: Date.now() - startTime
  }));
  return body;
}
function addRequestID(value, response) {
  if (!value || typeof value !== "object" || Array.isArray(value)) {
    return value;
  }
  return Object.defineProperty(value, "_request_id", {
    value: response.headers.get("x-request-id"),
    enumerable: false
  });
}

// node_modules/openai/core/api-promise.mjs
var _APIPromise_client;
var APIPromise = class _APIPromise extends Promise {
  constructor(client, responsePromise, parseResponse2 = defaultParseResponse) {
    super((resolve) => {
      resolve(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse2;
    _APIPromise_client.set(this, void 0);
    __classPrivateFieldSet(this, _APIPromise_client, client, "f");
  }
  _thenUnwrap(transform) {
    return new _APIPromise(__classPrivateFieldGet(this, _APIPromise_client, "f"), this.responsePromise, async (client, props) => addRequestID(transform(await this.parseResponse(client, props), props), props.response));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
   * to your `tsconfig.json`.
   */
  asResponse() {
    return this.responsePromise.then((p3) => p3.response);
  }
  /**
   * Gets the parsed response data, the raw `Response` instance and the ID of the request,
   * returned via the X-Request-ID header which is useful for debugging requests and reporting
   * issues to OpenAI.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
   * to your `tsconfig.json`.
   */
  async withResponse() {
    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
    return { data, response, request_id: response.headers.get("x-request-id") };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then((data) => this.parseResponse(__classPrivateFieldGet(this, _APIPromise_client, "f"), data));
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
};
_APIPromise_client = /* @__PURE__ */ new WeakMap();

// node_modules/openai/core/pagination.mjs
var _AbstractPage_client;
var AbstractPage = class {
  constructor(client, response, body, options) {
    _AbstractPage_client.set(this, void 0);
    __classPrivateFieldSet(this, _AbstractPage_client, client, "f");
    this.options = options;
    this.response = response;
    this.body = body;
  }
  hasNextPage() {
    const items = this.getPaginatedItems();
    if (!items.length)
      return false;
    return this.nextPageRequestOptions() != null;
  }
  async getNextPage() {
    const nextOptions = this.nextPageRequestOptions();
    if (!nextOptions) {
      throw new OpenAIError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    }
    return await __classPrivateFieldGet(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
  }
  async *iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async *[(_AbstractPage_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
};
var PagePromise = class extends APIPromise {
  constructor(client, request, Page3) {
    super(client, request, async (client2, props) => new Page3(client2, props.response, await defaultParseResponse(client2, props), props.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
};
var Page = class extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
    this.object = body.object;
  }
  getPaginatedItems() {
    var _a5;
    return (_a5 = this.data) != null ? _a5 : [];
  }
  nextPageRequestOptions() {
    return null;
  }
};
var CursorPage = class extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
    this.has_more = body.has_more || false;
  }
  getPaginatedItems() {
    var _a5;
    return (_a5 = this.data) != null ? _a5 : [];
  }
  hasNextPage() {
    if (this.has_more === false) {
      return false;
    }
    return super.hasNextPage();
  }
  nextPageRequestOptions() {
    var _a5;
    const data = this.getPaginatedItems();
    const id = (_a5 = data[data.length - 1]) == null ? void 0 : _a5.id;
    if (!id) {
      return null;
    }
    return {
      ...this.options,
      query: {
        ...maybeObj(this.options.query),
        after: id
      }
    };
  }
};
var ConversationCursorPage = class extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
    this.has_more = body.has_more || false;
    this.last_id = body.last_id || "";
  }
  getPaginatedItems() {
    var _a5;
    return (_a5 = this.data) != null ? _a5 : [];
  }
  hasNextPage() {
    if (this.has_more === false) {
      return false;
    }
    return super.hasNextPage();
  }
  nextPageRequestOptions() {
    const cursor = this.last_id;
    if (!cursor) {
      return null;
    }
    return {
      ...this.options,
      query: {
        ...maybeObj(this.options.query),
        after: cursor
      }
    };
  }
};

// node_modules/openai/internal/uploads.mjs
var checkFileSupport = () => {
  var _a5;
  if (typeof File === "undefined") {
    const { process: process2 } = globalThis;
    const isOldNode = typeof ((_a5 = process2 == null ? void 0 : process2.versions) == null ? void 0 : _a5.node) === "string" && parseInt(process2.versions.node.split(".")) < 20;
    throw new Error("`File` is not defined as a global, which is required for file uploads." + (isOldNode ? " Update to Node 20 LTS or newer, or set `globalThis.File` to `import('node:buffer').File`." : ""));
  }
};
function makeFile(fileBits, fileName, options) {
  checkFileSupport();
  return new File(fileBits, fileName != null ? fileName : "unknown_file", options);
}
function getName(value) {
  return (typeof value === "object" && value !== null && ("name" in value && value.name && String(value.name) || "url" in value && value.url && String(value.url) || "filename" in value && value.filename && String(value.filename) || "path" in value && value.path && String(value.path)) || "").split(/[\\/]/).pop() || void 0;
}
var isAsyncIterable = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
var maybeMultipartFormRequestOptions = async (opts, fetch2) => {
  if (!hasUploadableValue(opts.body))
    return opts;
  return { ...opts, body: await createForm(opts.body, fetch2) };
};
var multipartFormRequestOptions = async (opts, fetch2) => {
  return { ...opts, body: await createForm(opts.body, fetch2) };
};
var supportsFormDataMap = /* @__PURE__ */ new WeakMap();
function supportsFormData(fetchObject) {
  const fetch2 = typeof fetchObject === "function" ? fetchObject : fetchObject.fetch;
  const cached = supportsFormDataMap.get(fetch2);
  if (cached)
    return cached;
  const promise = (async () => {
    try {
      const FetchResponse = "Response" in fetch2 ? fetch2.Response : (await fetch2("data:,")).constructor;
      const data = new FormData();
      if (data.toString() === await new FetchResponse(data).text()) {
        return false;
      }
      return true;
    } catch (e3) {
      return true;
    }
  })();
  supportsFormDataMap.set(fetch2, promise);
  return promise;
}
var createForm = async (body, fetch2) => {
  if (!await supportsFormData(fetch2)) {
    throw new TypeError("The provided fetch function does not support file uploads with the current global FormData class.");
  }
  const form = new FormData();
  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));
  return form;
};
var isNamedBlob = (value) => value instanceof Blob && "name" in value;
var isUploadable = (value) => typeof value === "object" && value !== null && (value instanceof Response || isAsyncIterable(value) || isNamedBlob(value));
var hasUploadableValue = (value) => {
  if (isUploadable(value))
    return true;
  if (Array.isArray(value))
    return value.some(hasUploadableValue);
  if (value && typeof value === "object") {
    for (const k in value) {
      if (hasUploadableValue(value[k]))
        return true;
    }
  }
  return false;
};
var addFormValue = async (form, key, value) => {
  if (value === void 0)
    return;
  if (value == null) {
    throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);
  }
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    form.append(key, String(value));
  } else if (value instanceof Response) {
    form.append(key, makeFile([await value.blob()], getName(value)));
  } else if (isAsyncIterable(value)) {
    form.append(key, makeFile([await new Response(ReadableStreamFrom(value)).blob()], getName(value)));
  } else if (isNamedBlob(value)) {
    form.append(key, value, getName(value));
  } else if (Array.isArray(value)) {
    await Promise.all(value.map((entry) => addFormValue(form, key + "[]", entry)));
  } else if (typeof value === "object") {
    await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));
  } else {
    throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
  }
};

// node_modules/openai/internal/to-file.mjs
var isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
var isFileLike = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
var isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
async function toFile(value, name, options) {
  checkFileSupport();
  value = await value;
  if (isFileLike(value)) {
    if (value instanceof File) {
      return value;
    }
    return makeFile([await value.arrayBuffer()], value.name);
  }
  if (isResponseLike(value)) {
    const blob = await value.blob();
    name || (name = new URL(value.url).pathname.split(/[\\/]/).pop());
    return makeFile(await getBytes(blob), name, options);
  }
  const parts = await getBytes(value);
  name || (name = getName(value));
  if (!(options == null ? void 0 : options.type)) {
    const type = parts.find((part) => typeof part === "object" && "type" in part && part.type);
    if (typeof type === "string") {
      options = { ...options, type };
    }
  }
  return makeFile(parts, name, options);
}
async function getBytes(value) {
  var _a5;
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
  value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(value instanceof Blob ? value : await value.arrayBuffer());
  } else if (isAsyncIterable(value)) {
    for await (const chunk of value) {
      parts.push(...await getBytes(chunk));
    }
  } else {
    const constructor = (_a5 = value == null ? void 0 : value.constructor) == null ? void 0 : _a5.name;
    throw new Error(`Unexpected data type: ${typeof value}${constructor ? `; constructor: ${constructor}` : ""}${propsForError(value)}`);
  }
  return parts;
}
function propsForError(value) {
  if (typeof value !== "object" || value === null)
    return "";
  const props = Object.getOwnPropertyNames(value);
  return `; props: [${props.map((p3) => `"${p3}"`).join(", ")}]`;
}

// node_modules/openai/core/resource.mjs
var APIResource = class {
  constructor(client) {
    this._client = client;
  }
};

// node_modules/openai/internal/utils/path.mjs
function encodeURIPath(str2) {
  return str2.replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]+/g, encodeURIComponent);
}
var EMPTY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.create(null));
var createPathTagFunction = (pathEncoder = encodeURIPath) => function path4(statics, ...params) {
  if (statics.length === 1)
    return statics[0];
  let postPath = false;
  const invalidSegments = [];
  const path5 = statics.reduce((previousValue, currentValue, index) => {
    var _a5, _b, _c;
    if (/[?#]/.test(currentValue)) {
      postPath = true;
    }
    const value = params[index];
    let encoded = (postPath ? encodeURIComponent : pathEncoder)("" + value);
    if (index !== params.length && (value == null || typeof value === "object" && // handle values from other realms
    value.toString === ((_c = Object.getPrototypeOf((_b = Object.getPrototypeOf((_a5 = value.hasOwnProperty) != null ? _a5 : EMPTY)) != null ? _b : EMPTY)) == null ? void 0 : _c.toString))) {
      encoded = value + "";
      invalidSegments.push({
        start: previousValue.length + currentValue.length,
        length: encoded.length,
        error: `Value of type ${Object.prototype.toString.call(value).slice(8, -1)} is not a valid path parameter`
      });
    }
    return previousValue + currentValue + (index === params.length ? "" : encoded);
  }, "");
  const pathOnly = path5.split(/[?#]/, 1)[0];
  const invalidSegmentPattern = /(?<=^|\/)(?:\.|%2e){1,2}(?=\/|$)/gi;
  let match;
  while ((match = invalidSegmentPattern.exec(pathOnly)) !== null) {
    invalidSegments.push({
      start: match.index,
      length: match[0].length,
      error: `Value "${match[0]}" can't be safely passed as a path parameter`
    });
  }
  invalidSegments.sort((a, b3) => a.start - b3.start);
  if (invalidSegments.length > 0) {
    let lastEnd = 0;
    const underline = invalidSegments.reduce((acc, segment) => {
      const spaces = " ".repeat(segment.start - lastEnd);
      const arrows = "^".repeat(segment.length);
      lastEnd = segment.start + segment.length;
      return acc + spaces + arrows;
    }, "");
    throw new OpenAIError(`Path parameters result in path with invalid segments:
${invalidSegments.map((e3) => e3.error).join("\n")}
${path5}
${underline}`);
  }
  return path5;
};
var path = /* @__PURE__ */ createPathTagFunction(encodeURIPath);

// node_modules/openai/resources/chat/completions/messages.mjs
var Messages = class extends APIResource {
  /**
   * Get the messages in a stored chat completion. Only Chat Completions that have
   * been created with the `store` parameter set to `true` will be returned.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const chatCompletionStoreMessage of client.chat.completions.messages.list(
   *   'completion_id',
   * )) {
   *   // ...
   * }
   * ```
   */
  list(completionID, query = {}, options) {
    return this._client.getAPIList(path`/chat/completions/${completionID}/messages`, CursorPage, { query, ...options });
  }
};

// node_modules/openai/lib/parser.mjs
function isChatCompletionFunctionTool(tool) {
  return tool !== void 0 && "function" in tool && tool.function !== void 0;
}
function isAutoParsableResponseFormat(response_format) {
  return (response_format == null ? void 0 : response_format["$brand"]) === "auto-parseable-response-format";
}
function isAutoParsableTool(tool) {
  return (tool == null ? void 0 : tool["$brand"]) === "auto-parseable-tool";
}
function maybeParseChatCompletion(completion, params) {
  if (!params || !hasAutoParseableInput(params)) {
    return {
      ...completion,
      choices: completion.choices.map((choice) => {
        assertToolCallsAreChatCompletionFunctionToolCalls(choice.message.tool_calls);
        return {
          ...choice,
          message: {
            ...choice.message,
            parsed: null,
            ...choice.message.tool_calls ? {
              tool_calls: choice.message.tool_calls
            } : void 0
          }
        };
      })
    };
  }
  return parseChatCompletion(completion, params);
}
function parseChatCompletion(completion, params) {
  const choices = completion.choices.map((choice) => {
    var _a5, _b;
    if (choice.finish_reason === "length") {
      throw new LengthFinishReasonError();
    }
    if (choice.finish_reason === "content_filter") {
      throw new ContentFilterFinishReasonError();
    }
    assertToolCallsAreChatCompletionFunctionToolCalls(choice.message.tool_calls);
    return {
      ...choice,
      message: {
        ...choice.message,
        ...choice.message.tool_calls ? {
          tool_calls: (_b = (_a5 = choice.message.tool_calls) == null ? void 0 : _a5.map((toolCall) => parseToolCall(params, toolCall))) != null ? _b : void 0
        } : void 0,
        parsed: choice.message.content && !choice.message.refusal ? parseResponseFormat(params, choice.message.content) : null
      }
    };
  });
  return { ...completion, choices };
}
function parseResponseFormat(params, content) {
  var _a5, _b;
  if (((_a5 = params.response_format) == null ? void 0 : _a5.type) !== "json_schema") {
    return null;
  }
  if (((_b = params.response_format) == null ? void 0 : _b.type) === "json_schema") {
    if ("$parseRaw" in params.response_format) {
      const response_format = params.response_format;
      return response_format.$parseRaw(content);
    }
    return JSON.parse(content);
  }
  return null;
}
function parseToolCall(params, toolCall) {
  var _a5;
  const inputTool = (_a5 = params.tools) == null ? void 0 : _a5.find((inputTool2) => {
    var _a6;
    return isChatCompletionFunctionTool(inputTool2) && ((_a6 = inputTool2.function) == null ? void 0 : _a6.name) === toolCall.function.name;
  });
  return {
    ...toolCall,
    function: {
      ...toolCall.function,
      parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.function.arguments) : (inputTool == null ? void 0 : inputTool.function.strict) ? JSON.parse(toolCall.function.arguments) : null
    }
  };
}
function shouldParseToolCall(params, toolCall) {
  var _a5;
  if (!params || !("tools" in params) || !params.tools) {
    return false;
  }
  const inputTool = (_a5 = params.tools) == null ? void 0 : _a5.find((inputTool2) => {
    var _a6;
    return isChatCompletionFunctionTool(inputTool2) && ((_a6 = inputTool2.function) == null ? void 0 : _a6.name) === toolCall.function.name;
  });
  return isChatCompletionFunctionTool(inputTool) && (isAutoParsableTool(inputTool) || (inputTool == null ? void 0 : inputTool.function.strict) || false);
}
function hasAutoParseableInput(params) {
  var _a5, _b;
  if (isAutoParsableResponseFormat(params.response_format)) {
    return true;
  }
  return (_b = (_a5 = params.tools) == null ? void 0 : _a5.some((t) => isAutoParsableTool(t) || t.type === "function" && t.function.strict === true)) != null ? _b : false;
}
function assertToolCallsAreChatCompletionFunctionToolCalls(toolCalls) {
  for (const toolCall of toolCalls || []) {
    if (toolCall.type !== "function") {
      throw new OpenAIError(`Currently only \`function\` tool calls are supported; Received \`${toolCall.type}\``);
    }
  }
}
function validateInputTools(tools) {
  for (const tool of tools != null ? tools : []) {
    if (tool.type !== "function") {
      throw new OpenAIError(`Currently only \`function\` tool types support auto-parsing; Received \`${tool.type}\``);
    }
    if (tool.function.strict !== true) {
      throw new OpenAIError(`The \`${tool.function.name}\` tool is not marked with \`strict: true\`. Only strict function tools can be auto-parsed`);
    }
  }
}

// node_modules/openai/lib/chatCompletionUtils.mjs
var isAssistantMessage = (message) => {
  return (message == null ? void 0 : message.role) === "assistant";
};
var isToolMessage = (message) => {
  return (message == null ? void 0 : message.role) === "tool";
};

// node_modules/openai/lib/EventStream.mjs
var _EventStream_instances;
var _EventStream_connectedPromise;
var _EventStream_resolveConnectedPromise;
var _EventStream_rejectConnectedPromise;
var _EventStream_endPromise;
var _EventStream_resolveEndPromise;
var _EventStream_rejectEndPromise;
var _EventStream_listeners;
var _EventStream_ended;
var _EventStream_errored;
var _EventStream_aborted;
var _EventStream_catchingPromiseCreated;
var _EventStream_handleError;
var EventStream = class {
  constructor() {
    _EventStream_instances.add(this);
    this.controller = new AbortController();
    _EventStream_connectedPromise.set(this, void 0);
    _EventStream_resolveConnectedPromise.set(this, () => {
    });
    _EventStream_rejectConnectedPromise.set(this, () => {
    });
    _EventStream_endPromise.set(this, void 0);
    _EventStream_resolveEndPromise.set(this, () => {
    });
    _EventStream_rejectEndPromise.set(this, () => {
    });
    _EventStream_listeners.set(this, {});
    _EventStream_ended.set(this, false);
    _EventStream_errored.set(this, false);
    _EventStream_aborted.set(this, false);
    _EventStream_catchingPromiseCreated.set(this, false);
    __classPrivateFieldSet(this, _EventStream_connectedPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet(this, _EventStream_resolveConnectedPromise, resolve, "f");
      __classPrivateFieldSet(this, _EventStream_rejectConnectedPromise, reject, "f");
    }), "f");
    __classPrivateFieldSet(this, _EventStream_endPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet(this, _EventStream_resolveEndPromise, resolve, "f");
      __classPrivateFieldSet(this, _EventStream_rejectEndPromise, reject, "f");
    }), "f");
    __classPrivateFieldGet(this, _EventStream_connectedPromise, "f").catch(() => {
    });
    __classPrivateFieldGet(this, _EventStream_endPromise, "f").catch(() => {
    });
  }
  _run(executor) {
    setTimeout(() => {
      executor().then(() => {
        this._emitFinal();
        this._emit("end");
      }, __classPrivateFieldGet(this, _EventStream_instances, "m", _EventStream_handleError).bind(this));
    }, 0);
  }
  _connected() {
    if (this.ended)
      return;
    __classPrivateFieldGet(this, _EventStream_resolveConnectedPromise, "f").call(this);
    this._emit("connect");
  }
  get ended() {
    return __classPrivateFieldGet(this, _EventStream_ended, "f");
  }
  get errored() {
    return __classPrivateFieldGet(this, _EventStream_errored, "f");
  }
  get aborted() {
    return __classPrivateFieldGet(this, _EventStream_aborted, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  on(event, listener) {
    const listeners = __classPrivateFieldGet(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet(this, _EventStream_listeners, "f")[event] = []);
    listeners.push({ listener });
    return this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  off(event, listener) {
    const listeners = __classPrivateFieldGet(this, _EventStream_listeners, "f")[event];
    if (!listeners)
      return this;
    const index = listeners.findIndex((l3) => l3.listener === listener);
    if (index >= 0)
      listeners.splice(index, 1);
    return this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  once(event, listener) {
    const listeners = __classPrivateFieldGet(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet(this, _EventStream_listeners, "f")[event] = []);
    listeners.push({ listener, once: true });
    return this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(event) {
    return new Promise((resolve, reject) => {
      __classPrivateFieldSet(this, _EventStream_catchingPromiseCreated, true, "f");
      if (event !== "error")
        this.once("error", reject);
      this.once(event, resolve);
    });
  }
  async done() {
    __classPrivateFieldSet(this, _EventStream_catchingPromiseCreated, true, "f");
    await __classPrivateFieldGet(this, _EventStream_endPromise, "f");
  }
  _emit(event, ...args) {
    if (__classPrivateFieldGet(this, _EventStream_ended, "f")) {
      return;
    }
    if (event === "end") {
      __classPrivateFieldSet(this, _EventStream_ended, true, "f");
      __classPrivateFieldGet(this, _EventStream_resolveEndPromise, "f").call(this);
    }
    const listeners = __classPrivateFieldGet(this, _EventStream_listeners, "f")[event];
    if (listeners) {
      __classPrivateFieldGet(this, _EventStream_listeners, "f")[event] = listeners.filter((l3) => !l3.once);
      listeners.forEach(({ listener }) => listener(...args));
    }
    if (event === "abort") {
      const error = args[0];
      if (!__classPrivateFieldGet(this, _EventStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
        Promise.reject(error);
      }
      __classPrivateFieldGet(this, _EventStream_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet(this, _EventStream_rejectEndPromise, "f").call(this, error);
      this._emit("end");
      return;
    }
    if (event === "error") {
      const error = args[0];
      if (!__classPrivateFieldGet(this, _EventStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
        Promise.reject(error);
      }
      __classPrivateFieldGet(this, _EventStream_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet(this, _EventStream_rejectEndPromise, "f").call(this, error);
      this._emit("end");
    }
  }
  _emitFinal() {
  }
};
_EventStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_endPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_listeners = /* @__PURE__ */ new WeakMap(), _EventStream_ended = /* @__PURE__ */ new WeakMap(), _EventStream_errored = /* @__PURE__ */ new WeakMap(), _EventStream_aborted = /* @__PURE__ */ new WeakMap(), _EventStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _EventStream_instances = /* @__PURE__ */ new WeakSet(), _EventStream_handleError = function _EventStream_handleError2(error) {
  __classPrivateFieldSet(this, _EventStream_errored, true, "f");
  if (error instanceof Error && error.name === "AbortError") {
    error = new APIUserAbortError();
  }
  if (error instanceof APIUserAbortError) {
    __classPrivateFieldSet(this, _EventStream_aborted, true, "f");
    return this._emit("abort", error);
  }
  if (error instanceof OpenAIError) {
    return this._emit("error", error);
  }
  if (error instanceof Error) {
    const openAIError = new OpenAIError(error.message);
    openAIError.cause = error;
    return this._emit("error", openAIError);
  }
  return this._emit("error", new OpenAIError(String(error)));
};

// node_modules/openai/lib/RunnableFunction.mjs
function isRunnableFunctionWithParse(fn) {
  return typeof fn.parse === "function";
}

// node_modules/openai/lib/AbstractChatCompletionRunner.mjs
var _AbstractChatCompletionRunner_instances;
var _AbstractChatCompletionRunner_getFinalContent;
var _AbstractChatCompletionRunner_getFinalMessage;
var _AbstractChatCompletionRunner_getFinalFunctionToolCall;
var _AbstractChatCompletionRunner_getFinalFunctionToolCallResult;
var _AbstractChatCompletionRunner_calculateTotalUsage;
var _AbstractChatCompletionRunner_validateParams;
var _AbstractChatCompletionRunner_stringifyFunctionCallResult;
var DEFAULT_MAX_CHAT_COMPLETIONS = 10;
var AbstractChatCompletionRunner = class extends EventStream {
  constructor() {
    super(...arguments);
    _AbstractChatCompletionRunner_instances.add(this);
    this._chatCompletions = [];
    this.messages = [];
  }
  _addChatCompletion(chatCompletion) {
    var _a5;
    this._chatCompletions.push(chatCompletion);
    this._emit("chatCompletion", chatCompletion);
    const message = (_a5 = chatCompletion.choices[0]) == null ? void 0 : _a5.message;
    if (message)
      this._addMessage(message);
    return chatCompletion;
  }
  _addMessage(message, emit = true) {
    if (!("content" in message))
      message.content = null;
    this.messages.push(message);
    if (emit) {
      this._emit("message", message);
      if (isToolMessage(message) && message.content) {
        this._emit("functionToolCallResult", message.content);
      } else if (isAssistantMessage(message) && message.tool_calls) {
        for (const tool_call of message.tool_calls) {
          if (tool_call.type === "function") {
            this._emit("functionToolCall", tool_call.function);
          }
        }
      }
    }
  }
  /**
   * @returns a promise that resolves with the final ChatCompletion, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletion.
   */
  async finalChatCompletion() {
    await this.done();
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (!completion)
      throw new OpenAIError("stream ended without producing a ChatCompletion");
    return completion;
  }
  /**
   * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalContent() {
    await this.done();
    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,
   * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalMessage() {
    await this.done();
    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
  }
  /**
   * @returns a promise that resolves with the content of the final FunctionCall, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalFunctionToolCall() {
    await this.done();
    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCall).call(this);
  }
  async finalFunctionToolCallResult() {
    await this.done();
    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCallResult).call(this);
  }
  async totalUsage() {
    await this.done();
    return __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this);
  }
  allChatCompletions() {
    return [...this._chatCompletions];
  }
  _emitFinal() {
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (completion)
      this._emit("finalChatCompletion", completion);
    const finalMessage = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
    if (finalMessage)
      this._emit("finalMessage", finalMessage);
    const finalContent = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
    if (finalContent)
      this._emit("finalContent", finalContent);
    const finalFunctionCall = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCall).call(this);
    if (finalFunctionCall)
      this._emit("finalFunctionToolCall", finalFunctionCall);
    const finalFunctionCallResult = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCallResult).call(this);
    if (finalFunctionCallResult != null)
      this._emit("finalFunctionToolCallResult", finalFunctionCallResult);
    if (this._chatCompletions.some((c) => c.usage)) {
      this._emit("totalUsage", __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this));
    }
  }
  async _createChatCompletion(client, params, options) {
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_validateParams).call(this, params);
    const chatCompletion = await client.chat.completions.create({ ...params, stream: false }, { ...options, signal: this.controller.signal });
    this._connected();
    return this._addChatCompletion(parseChatCompletion(chatCompletion, params));
  }
  async _runChatCompletion(client, params, options) {
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    return await this._createChatCompletion(client, params, options);
  }
  async _runTools(client, params, options) {
    var _a5, _b, _c;
    const role = "tool";
    const { tool_choice = "auto", stream, ...restParams } = params;
    const singleFunctionToCall = typeof tool_choice !== "string" && tool_choice.type === "function" && ((_a5 = tool_choice == null ? void 0 : tool_choice.function) == null ? void 0 : _a5.name);
    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
    const inputTools = params.tools.map((tool) => {
      if (isAutoParsableTool(tool)) {
        if (!tool.$callback) {
          throw new OpenAIError("Tool given to `.runTools()` that does not have an associated function");
        }
        return {
          type: "function",
          function: {
            function: tool.$callback,
            name: tool.function.name,
            description: tool.function.description || "",
            parameters: tool.function.parameters,
            parse: tool.$parseRaw,
            strict: true
          }
        };
      }
      return tool;
    });
    const functionsByName = {};
    for (const f of inputTools) {
      if (f.type === "function") {
        functionsByName[f.function.name || f.function.function.name] = f.function;
      }
    }
    const tools = "tools" in params ? inputTools.map((t) => t.type === "function" ? {
      type: "function",
      function: {
        name: t.function.name || t.function.function.name,
        parameters: t.function.parameters,
        description: t.function.description,
        strict: t.function.strict
      }
    } : t) : void 0;
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    for (let i3 = 0; i3 < maxChatCompletions; ++i3) {
      const chatCompletion = await this._createChatCompletion(client, {
        ...restParams,
        tool_choice,
        tools,
        messages: [...this.messages]
      }, options);
      const message = (_b = chatCompletion.choices[0]) == null ? void 0 : _b.message;
      if (!message) {
        throw new OpenAIError(`missing message in ChatCompletion response`);
      }
      if (!((_c = message.tool_calls) == null ? void 0 : _c.length)) {
        return;
      }
      for (const tool_call of message.tool_calls) {
        if (tool_call.type !== "function")
          continue;
        const tool_call_id = tool_call.id;
        const { name, arguments: args } = tool_call.function;
        const fn = functionsByName[name];
        if (!fn) {
          const content2 = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${Object.keys(functionsByName).map((name2) => JSON.stringify(name2)).join(", ")}. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        } else if (singleFunctionToCall && singleFunctionToCall !== name) {
          const content2 = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        let parsed;
        try {
          parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
        } catch (error) {
          const content2 = error instanceof Error ? error.message : String(error);
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        const rawContent = await fn.function(parsed, this);
        const content = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
        this._addMessage({ role, tool_call_id, content });
        if (singleFunctionToCall) {
          return;
        }
      }
    }
    return;
  }
};
_AbstractChatCompletionRunner_instances = /* @__PURE__ */ new WeakSet(), _AbstractChatCompletionRunner_getFinalContent = function _AbstractChatCompletionRunner_getFinalContent2() {
  var _a5;
  return (_a5 = __classPrivateFieldGet(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this).content) != null ? _a5 : null;
}, _AbstractChatCompletionRunner_getFinalMessage = function _AbstractChatCompletionRunner_getFinalMessage2() {
  var _a5, _b;
  let i3 = this.messages.length;
  while (i3-- > 0) {
    const message = this.messages[i3];
    if (isAssistantMessage(message)) {
      const ret = {
        ...message,
        content: (_a5 = message.content) != null ? _a5 : null,
        refusal: (_b = message.refusal) != null ? _b : null
      };
      return ret;
    }
  }
  throw new OpenAIError("stream ended without producing a ChatCompletionMessage with role=assistant");
}, _AbstractChatCompletionRunner_getFinalFunctionToolCall = function _AbstractChatCompletionRunner_getFinalFunctionToolCall2() {
  var _a5, _b;
  for (let i3 = this.messages.length - 1; i3 >= 0; i3--) {
    const message = this.messages[i3];
    if (isAssistantMessage(message) && ((_a5 = message == null ? void 0 : message.tool_calls) == null ? void 0 : _a5.length)) {
      return (_b = message.tool_calls.filter((x3) => x3.type === "function").at(-1)) == null ? void 0 : _b.function;
    }
  }
  return;
}, _AbstractChatCompletionRunner_getFinalFunctionToolCallResult = function _AbstractChatCompletionRunner_getFinalFunctionToolCallResult2() {
  for (let i3 = this.messages.length - 1; i3 >= 0; i3--) {
    const message = this.messages[i3];
    if (isToolMessage(message) && message.content != null && typeof message.content === "string" && this.messages.some((x3) => {
      var _a5;
      return x3.role === "assistant" && ((_a5 = x3.tool_calls) == null ? void 0 : _a5.some((y3) => y3.type === "function" && y3.id === message.tool_call_id));
    })) {
      return message.content;
    }
  }
  return;
}, _AbstractChatCompletionRunner_calculateTotalUsage = function _AbstractChatCompletionRunner_calculateTotalUsage2() {
  const total = {
    completion_tokens: 0,
    prompt_tokens: 0,
    total_tokens: 0
  };
  for (const { usage } of this._chatCompletions) {
    if (usage) {
      total.completion_tokens += usage.completion_tokens;
      total.prompt_tokens += usage.prompt_tokens;
      total.total_tokens += usage.total_tokens;
    }
  }
  return total;
}, _AbstractChatCompletionRunner_validateParams = function _AbstractChatCompletionRunner_validateParams2(params) {
  if (params.n != null && params.n > 1) {
    throw new OpenAIError("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.");
  }
}, _AbstractChatCompletionRunner_stringifyFunctionCallResult = function _AbstractChatCompletionRunner_stringifyFunctionCallResult2(rawContent) {
  return typeof rawContent === "string" ? rawContent : rawContent === void 0 ? "undefined" : JSON.stringify(rawContent);
};

// node_modules/openai/lib/ChatCompletionRunner.mjs
var ChatCompletionRunner = class _ChatCompletionRunner extends AbstractChatCompletionRunner {
  static runTools(client, params, options) {
    const runner = new _ChatCompletionRunner();
    const opts = {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    runner._run(() => runner._runTools(client, params, opts));
    return runner;
  }
  _addMessage(message, emit = true) {
    super._addMessage(message, emit);
    if (isAssistantMessage(message) && message.content) {
      this._emit("content", message.content);
    }
  }
};

// node_modules/openai/_vendor/partial-json-parser/parser.mjs
var STR = 1;
var NUM = 2;
var ARR = 4;
var OBJ = 8;
var NULL = 16;
var BOOL = 32;
var NAN = 64;
var INFINITY = 128;
var MINUS_INFINITY = 256;
var INF = INFINITY | MINUS_INFINITY;
var SPECIAL = NULL | BOOL | INF | NAN;
var ATOM = STR | NUM | SPECIAL;
var COLLECTION = ARR | OBJ;
var ALL = ATOM | COLLECTION;
var Allow = {
  STR,
  NUM,
  ARR,
  OBJ,
  NULL,
  BOOL,
  NAN,
  INFINITY,
  MINUS_INFINITY,
  INF,
  SPECIAL,
  ATOM,
  COLLECTION,
  ALL
};
var PartialJSON = class extends Error {
};
var MalformedJSON = class extends Error {
};
function parseJSON(jsonString, allowPartial = Allow.ALL) {
  if (typeof jsonString !== "string") {
    throw new TypeError(`expecting str, got ${typeof jsonString}`);
  }
  if (!jsonString.trim()) {
    throw new Error(`${jsonString} is empty`);
  }
  return _parseJSON(jsonString.trim(), allowPartial);
}
var _parseJSON = (jsonString, allow) => {
  const length = jsonString.length;
  let index = 0;
  const markPartialJSON = (msg) => {
    throw new PartialJSON(`${msg} at position ${index}`);
  };
  const throwMalformedError = (msg) => {
    throw new MalformedJSON(`${msg} at position ${index}`);
  };
  const parseAny = () => {
    skipBlank();
    if (index >= length)
      markPartialJSON("Unexpected end of input");
    if (jsonString[index] === '"')
      return parseStr();
    if (jsonString[index] === "{")
      return parseObj();
    if (jsonString[index] === "[")
      return parseArr();
    if (jsonString.substring(index, index + 4) === "null" || Allow.NULL & allow && length - index < 4 && "null".startsWith(jsonString.substring(index))) {
      index += 4;
      return null;
    }
    if (jsonString.substring(index, index + 4) === "true" || Allow.BOOL & allow && length - index < 4 && "true".startsWith(jsonString.substring(index))) {
      index += 4;
      return true;
    }
    if (jsonString.substring(index, index + 5) === "false" || Allow.BOOL & allow && length - index < 5 && "false".startsWith(jsonString.substring(index))) {
      index += 5;
      return false;
    }
    if (jsonString.substring(index, index + 8) === "Infinity" || Allow.INFINITY & allow && length - index < 8 && "Infinity".startsWith(jsonString.substring(index))) {
      index += 8;
      return Infinity;
    }
    if (jsonString.substring(index, index + 9) === "-Infinity" || Allow.MINUS_INFINITY & allow && 1 < length - index && length - index < 9 && "-Infinity".startsWith(jsonString.substring(index))) {
      index += 9;
      return -Infinity;
    }
    if (jsonString.substring(index, index + 3) === "NaN" || Allow.NAN & allow && length - index < 3 && "NaN".startsWith(jsonString.substring(index))) {
      index += 3;
      return NaN;
    }
    return parseNum();
  };
  const parseStr = () => {
    const start = index;
    let escape2 = false;
    index++;
    while (index < length && (jsonString[index] !== '"' || escape2 && jsonString[index - 1] === "\\")) {
      escape2 = jsonString[index] === "\\" ? !escape2 : false;
      index++;
    }
    if (jsonString.charAt(index) == '"') {
      try {
        return JSON.parse(jsonString.substring(start, ++index - Number(escape2)));
      } catch (e3) {
        throwMalformedError(String(e3));
      }
    } else if (Allow.STR & allow) {
      try {
        return JSON.parse(jsonString.substring(start, index - Number(escape2)) + '"');
      } catch (e3) {
        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("\\")) + '"');
      }
    }
    markPartialJSON("Unterminated string literal");
  };
  const parseObj = () => {
    index++;
    skipBlank();
    const obj = {};
    try {
      while (jsonString[index] !== "}") {
        skipBlank();
        if (index >= length && Allow.OBJ & allow)
          return obj;
        const key = parseStr();
        skipBlank();
        index++;
        try {
          const value = parseAny();
          Object.defineProperty(obj, key, { value, writable: true, enumerable: true, configurable: true });
        } catch (e3) {
          if (Allow.OBJ & allow)
            return obj;
          else
            throw e3;
        }
        skipBlank();
        if (jsonString[index] === ",")
          index++;
      }
    } catch (e3) {
      if (Allow.OBJ & allow)
        return obj;
      else
        markPartialJSON("Expected '}' at end of object");
    }
    index++;
    return obj;
  };
  const parseArr = () => {
    index++;
    const arr = [];
    try {
      while (jsonString[index] !== "]") {
        arr.push(parseAny());
        skipBlank();
        if (jsonString[index] === ",") {
          index++;
        }
      }
    } catch (e3) {
      if (Allow.ARR & allow) {
        return arr;
      }
      markPartialJSON("Expected ']' at end of array");
    }
    index++;
    return arr;
  };
  const parseNum = () => {
    if (index === 0) {
      if (jsonString === "-" && Allow.NUM & allow)
        markPartialJSON("Not sure what '-' is");
      try {
        return JSON.parse(jsonString);
      } catch (e3) {
        if (Allow.NUM & allow) {
          try {
            if ("." === jsonString[jsonString.length - 1])
              return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf(".")));
            return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf("e")));
          } catch (e5) {
          }
        }
        throwMalformedError(String(e3));
      }
    }
    const start = index;
    if (jsonString[index] === "-")
      index++;
    while (jsonString[index] && !",]}".includes(jsonString[index]))
      index++;
    if (index == length && !(Allow.NUM & allow))
      markPartialJSON("Unterminated number literal");
    try {
      return JSON.parse(jsonString.substring(start, index));
    } catch (e3) {
      if (jsonString.substring(start, index) === "-" && Allow.NUM & allow)
        markPartialJSON("Not sure what '-' is");
      try {
        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("e")));
      } catch (e5) {
        throwMalformedError(String(e5));
      }
    }
  };
  const skipBlank = () => {
    while (index < length && " \n\r	".includes(jsonString[index])) {
      index++;
    }
  };
  return parseAny();
};
var partialParse = (input) => parseJSON(input, Allow.ALL ^ Allow.NUM);

// node_modules/openai/lib/ChatCompletionStream.mjs
var _ChatCompletionStream_instances;
var _ChatCompletionStream_params;
var _ChatCompletionStream_choiceEventStates;
var _ChatCompletionStream_currentChatCompletionSnapshot;
var _ChatCompletionStream_beginRequest;
var _ChatCompletionStream_getChoiceEventState;
var _ChatCompletionStream_addChunk;
var _ChatCompletionStream_emitToolCallDoneEvent;
var _ChatCompletionStream_emitContentDoneEvents;
var _ChatCompletionStream_endRequest;
var _ChatCompletionStream_getAutoParseableResponseFormat;
var _ChatCompletionStream_accumulateChatCompletion;
var ChatCompletionStream = class _ChatCompletionStream extends AbstractChatCompletionRunner {
  constructor(params) {
    super();
    _ChatCompletionStream_instances.add(this);
    _ChatCompletionStream_params.set(this, void 0);
    _ChatCompletionStream_choiceEventStates.set(this, void 0);
    _ChatCompletionStream_currentChatCompletionSnapshot.set(this, void 0);
    __classPrivateFieldSet(this, _ChatCompletionStream_params, params, "f");
    __classPrivateFieldSet(this, _ChatCompletionStream_choiceEventStates, [], "f");
  }
  get currentChatCompletionSnapshot() {
    return __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(stream) {
    const runner = new _ChatCompletionStream(null);
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  static createChatCompletion(client, params, options) {
    const runner = new _ChatCompletionStream(params);
    runner._run(() => runner._runChatCompletion(client, { ...params, stream: true }, { ...options, headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" } }));
    return runner;
  }
  async _createChatCompletion(client, params, options) {
    var _a5;
    super._createChatCompletion;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
    const stream = await client.chat.completions.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const chunk of stream) {
      __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
    }
    if ((_a5 = stream.controller.signal) == null ? void 0 : _a5.aborted) {
      throw new APIUserAbortError();
    }
    return this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
  }
  async _fromReadableStream(readableStream, options) {
    var _a5;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
    this._connected();
    const stream = Stream.fromReadableStream(readableStream, this.controller);
    let chatId;
    for await (const chunk of stream) {
      if (chatId && chatId !== chunk.id) {
        this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
      }
      __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
      chatId = chunk.id;
    }
    if ((_a5 = stream.controller.signal) == null ? void 0 : _a5.aborted) {
      throw new APIUserAbortError();
    }
    return this._addChatCompletion(__classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
  }
  [(_ChatCompletionStream_params = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_choiceEventStates = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_currentChatCompletionSnapshot = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_instances = /* @__PURE__ */ new WeakSet(), _ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest2() {
    if (this.ended)
      return;
    __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
  }, _ChatCompletionStream_getChoiceEventState = function _ChatCompletionStream_getChoiceEventState2(choice) {
    let state = __classPrivateFieldGet(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index];
    if (state) {
      return state;
    }
    state = {
      content_done: false,
      refusal_done: false,
      logprobs_content_done: false,
      logprobs_refusal_done: false,
      done_tool_calls: /* @__PURE__ */ new Set(),
      current_tool_call_index: null
    };
    __classPrivateFieldGet(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index] = state;
    return state;
  }, _ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk2(chunk) {
    var _a5, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q2, _r, _s, _t;
    if (this.ended)
      return;
    const completion = __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_accumulateChatCompletion).call(this, chunk);
    this._emit("chunk", chunk, completion);
    for (const choice of chunk.choices) {
      const choiceSnapshot = completion.choices[choice.index];
      if (choice.delta.content != null && ((_a5 = choiceSnapshot.message) == null ? void 0 : _a5.role) === "assistant" && ((_b = choiceSnapshot.message) == null ? void 0 : _b.content)) {
        this._emit("content", choice.delta.content, choiceSnapshot.message.content);
        this._emit("content.delta", {
          delta: choice.delta.content,
          snapshot: choiceSnapshot.message.content,
          parsed: choiceSnapshot.message.parsed
        });
      }
      if (choice.delta.refusal != null && ((_c = choiceSnapshot.message) == null ? void 0 : _c.role) === "assistant" && ((_d = choiceSnapshot.message) == null ? void 0 : _d.refusal)) {
        this._emit("refusal.delta", {
          delta: choice.delta.refusal,
          snapshot: choiceSnapshot.message.refusal
        });
      }
      if (((_e = choice.logprobs) == null ? void 0 : _e.content) != null && ((_f = choiceSnapshot.message) == null ? void 0 : _f.role) === "assistant") {
        this._emit("logprobs.content.delta", {
          content: (_g = choice.logprobs) == null ? void 0 : _g.content,
          snapshot: (_i = (_h = choiceSnapshot.logprobs) == null ? void 0 : _h.content) != null ? _i : []
        });
      }
      if (((_j = choice.logprobs) == null ? void 0 : _j.refusal) != null && ((_k = choiceSnapshot.message) == null ? void 0 : _k.role) === "assistant") {
        this._emit("logprobs.refusal.delta", {
          refusal: (_l = choice.logprobs) == null ? void 0 : _l.refusal,
          snapshot: (_n = (_m = choiceSnapshot.logprobs) == null ? void 0 : _m.refusal) != null ? _n : []
        });
      }
      const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
      if (choiceSnapshot.finish_reason) {
        __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
        if (state.current_tool_call_index != null) {
          __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
        }
      }
      for (const toolCall of (_o = choice.delta.tool_calls) != null ? _o : []) {
        if (state.current_tool_call_index !== toolCall.index) {
          __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
          if (state.current_tool_call_index != null) {
            __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
          }
        }
        state.current_tool_call_index = toolCall.index;
      }
      for (const toolCallDelta of (_p = choice.delta.tool_calls) != null ? _p : []) {
        const toolCallSnapshot = (_q2 = choiceSnapshot.message.tool_calls) == null ? void 0 : _q2[toolCallDelta.index];
        if (!(toolCallSnapshot == null ? void 0 : toolCallSnapshot.type)) {
          continue;
        }
        if ((toolCallSnapshot == null ? void 0 : toolCallSnapshot.type) === "function") {
          this._emit("tool_calls.function.arguments.delta", {
            name: (_r = toolCallSnapshot.function) == null ? void 0 : _r.name,
            index: toolCallDelta.index,
            arguments: toolCallSnapshot.function.arguments,
            parsed_arguments: toolCallSnapshot.function.parsed_arguments,
            arguments_delta: (_t = (_s = toolCallDelta.function) == null ? void 0 : _s.arguments) != null ? _t : ""
          });
        } else {
          assertNever(toolCallSnapshot == null ? void 0 : toolCallSnapshot.type);
        }
      }
    }
  }, _ChatCompletionStream_emitToolCallDoneEvent = function _ChatCompletionStream_emitToolCallDoneEvent2(choiceSnapshot, toolCallIndex) {
    var _a5, _b, _c;
    const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
    if (state.done_tool_calls.has(toolCallIndex)) {
      return;
    }
    const toolCallSnapshot = (_a5 = choiceSnapshot.message.tool_calls) == null ? void 0 : _a5[toolCallIndex];
    if (!toolCallSnapshot) {
      throw new Error("no tool call snapshot");
    }
    if (!toolCallSnapshot.type) {
      throw new Error("tool call snapshot missing `type`");
    }
    if (toolCallSnapshot.type === "function") {
      const inputTool = (_c = (_b = __classPrivateFieldGet(this, _ChatCompletionStream_params, "f")) == null ? void 0 : _b.tools) == null ? void 0 : _c.find((tool) => isChatCompletionFunctionTool(tool) && tool.function.name === toolCallSnapshot.function.name);
      this._emit("tool_calls.function.arguments.done", {
        name: toolCallSnapshot.function.name,
        index: toolCallIndex,
        arguments: toolCallSnapshot.function.arguments,
        parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCallSnapshot.function.arguments) : (inputTool == null ? void 0 : inputTool.function.strict) ? JSON.parse(toolCallSnapshot.function.arguments) : null
      });
    } else {
      assertNever(toolCallSnapshot.type);
    }
  }, _ChatCompletionStream_emitContentDoneEvents = function _ChatCompletionStream_emitContentDoneEvents2(choiceSnapshot) {
    var _a5, _b;
    const state = __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
    if (choiceSnapshot.message.content && !state.content_done) {
      state.content_done = true;
      const responseFormat = __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this);
      this._emit("content.done", {
        content: choiceSnapshot.message.content,
        parsed: responseFormat ? responseFormat.$parseRaw(choiceSnapshot.message.content) : null
      });
    }
    if (choiceSnapshot.message.refusal && !state.refusal_done) {
      state.refusal_done = true;
      this._emit("refusal.done", { refusal: choiceSnapshot.message.refusal });
    }
    if (((_a5 = choiceSnapshot.logprobs) == null ? void 0 : _a5.content) && !state.logprobs_content_done) {
      state.logprobs_content_done = true;
      this._emit("logprobs.content.done", { content: choiceSnapshot.logprobs.content });
    }
    if (((_b = choiceSnapshot.logprobs) == null ? void 0 : _b.refusal) && !state.logprobs_refusal_done) {
      state.logprobs_refusal_done = true;
      this._emit("logprobs.refusal.done", { refusal: choiceSnapshot.logprobs.refusal });
    }
  }, _ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest2() {
    if (this.ended) {
      throw new OpenAIError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    if (!snapshot) {
      throw new OpenAIError(`request ended without sending any chunks`);
    }
    __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
    __classPrivateFieldSet(this, _ChatCompletionStream_choiceEventStates, [], "f");
    return finalizeChatCompletion(snapshot, __classPrivateFieldGet(this, _ChatCompletionStream_params, "f"));
  }, _ChatCompletionStream_getAutoParseableResponseFormat = function _ChatCompletionStream_getAutoParseableResponseFormat2() {
    var _a5;
    const responseFormat = (_a5 = __classPrivateFieldGet(this, _ChatCompletionStream_params, "f")) == null ? void 0 : _a5.response_format;
    if (isAutoParsableResponseFormat(responseFormat)) {
      return responseFormat;
    }
    return null;
  }, _ChatCompletionStream_accumulateChatCompletion = function _ChatCompletionStream_accumulateChatCompletion2(chunk) {
    var _a6, _b2, _c2, _d2, _e, _f;
    var _a5, _b, _c, _d;
    let snapshot = __classPrivateFieldGet(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    const { choices, ...rest } = chunk;
    if (!snapshot) {
      snapshot = __classPrivateFieldSet(this, _ChatCompletionStream_currentChatCompletionSnapshot, {
        ...rest,
        choices: []
      }, "f");
    } else {
      Object.assign(snapshot, rest);
    }
    for (const { delta, finish_reason, index, logprobs = null, ...other } of chunk.choices) {
      let choice = snapshot.choices[index];
      if (!choice) {
        choice = snapshot.choices[index] = { finish_reason, index, message: {}, logprobs, ...other };
      }
      if (logprobs) {
        if (!choice.logprobs) {
          choice.logprobs = Object.assign({}, logprobs);
        } else {
          const { content: content2, refusal: refusal2, ...rest3 } = logprobs;
          assertIsEmpty(rest3);
          Object.assign(choice.logprobs, rest3);
          if (content2) {
            (_a6 = (_a5 = choice.logprobs).content) != null ? _a6 : _a5.content = [];
            choice.logprobs.content.push(...content2);
          }
          if (refusal2) {
            (_b2 = (_b = choice.logprobs).refusal) != null ? _b2 : _b.refusal = [];
            choice.logprobs.refusal.push(...refusal2);
          }
        }
      }
      if (finish_reason) {
        choice.finish_reason = finish_reason;
        if (__classPrivateFieldGet(this, _ChatCompletionStream_params, "f") && hasAutoParseableInput(__classPrivateFieldGet(this, _ChatCompletionStream_params, "f"))) {
          if (finish_reason === "length") {
            throw new LengthFinishReasonError();
          }
          if (finish_reason === "content_filter") {
            throw new ContentFilterFinishReasonError();
          }
        }
      }
      Object.assign(choice, other);
      if (!delta)
        continue;
      const { content, refusal, function_call, role, tool_calls, ...rest2 } = delta;
      assertIsEmpty(rest2);
      Object.assign(choice.message, rest2);
      if (refusal) {
        choice.message.refusal = (choice.message.refusal || "") + refusal;
      }
      if (role)
        choice.message.role = role;
      if (function_call) {
        if (!choice.message.function_call) {
          choice.message.function_call = function_call;
        } else {
          if (function_call.name)
            choice.message.function_call.name = function_call.name;
          if (function_call.arguments) {
            (_c2 = (_c = choice.message.function_call).arguments) != null ? _c2 : _c.arguments = "";
            choice.message.function_call.arguments += function_call.arguments;
          }
        }
      }
      if (content) {
        choice.message.content = (choice.message.content || "") + content;
        if (!choice.message.refusal && __classPrivateFieldGet(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this)) {
          choice.message.parsed = partialParse(choice.message.content);
        }
      }
      if (tool_calls) {
        if (!choice.message.tool_calls)
          choice.message.tool_calls = [];
        for (const { index: index2, id, type, function: fn, ...rest3 } of tool_calls) {
          const tool_call = (_d2 = (_d = choice.message.tool_calls)[index2]) != null ? _d2 : _d[index2] = {};
          Object.assign(tool_call, rest3);
          if (id)
            tool_call.id = id;
          if (type)
            tool_call.type = type;
          if (fn)
            (_f = tool_call.function) != null ? _f : tool_call.function = { name: (_e = fn.name) != null ? _e : "", arguments: "" };
          if (fn == null ? void 0 : fn.name)
            tool_call.function.name = fn.name;
          if (fn == null ? void 0 : fn.arguments) {
            tool_call.function.arguments += fn.arguments;
            if (shouldParseToolCall(__classPrivateFieldGet(this, _ChatCompletionStream_params, "f"), tool_call)) {
              tool_call.function.parsed_arguments = partialParse(tool_call.function.arguments);
            }
          }
        }
      }
    }
    return snapshot;
  }, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("chunk", (chunk) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(chunk);
      } else {
        pushQueue.push(chunk);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  toReadableStream() {
    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
};
function finalizeChatCompletion(snapshot, params) {
  const { id, choices, created, model, system_fingerprint, ...rest } = snapshot;
  const completion = {
    ...rest,
    id,
    choices: choices.map(({ message, finish_reason, index, logprobs, ...choiceRest }) => {
      var _a5, _b, _c;
      if (!finish_reason) {
        throw new OpenAIError(`missing finish_reason for choice ${index}`);
      }
      const { content = null, function_call, tool_calls, ...messageRest } = message;
      const role = message.role;
      if (!role) {
        throw new OpenAIError(`missing role for choice ${index}`);
      }
      if (function_call) {
        const { arguments: args, name } = function_call;
        if (args == null) {
          throw new OpenAIError(`missing function_call.arguments for choice ${index}`);
        }
        if (!name) {
          throw new OpenAIError(`missing function_call.name for choice ${index}`);
        }
        return {
          ...choiceRest,
          message: {
            content,
            function_call: { arguments: args, name },
            role,
            refusal: (_a5 = message.refusal) != null ? _a5 : null
          },
          finish_reason,
          index,
          logprobs
        };
      }
      if (tool_calls) {
        return {
          ...choiceRest,
          index,
          finish_reason,
          logprobs,
          message: {
            ...messageRest,
            role,
            content,
            refusal: (_b = message.refusal) != null ? _b : null,
            tool_calls: tool_calls.map((tool_call, i3) => {
              const { function: fn, type, id: id2, ...toolRest } = tool_call;
              const { arguments: args, name, ...fnRest } = fn || {};
              if (id2 == null) {
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i3}].id
${str(snapshot)}`);
              }
              if (type == null) {
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i3}].type
${str(snapshot)}`);
              }
              if (name == null) {
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i3}].function.name
${str(snapshot)}`);
              }
              if (args == null) {
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i3}].function.arguments
${str(snapshot)}`);
              }
              return { ...toolRest, id: id2, type, function: { ...fnRest, name, arguments: args } };
            })
          }
        };
      }
      return {
        ...choiceRest,
        message: { ...messageRest, content, role, refusal: (_c = message.refusal) != null ? _c : null },
        finish_reason,
        index,
        logprobs
      };
    }),
    created,
    model,
    object: "chat.completion",
    ...system_fingerprint ? { system_fingerprint } : {}
  };
  return maybeParseChatCompletion(completion, params);
}
function str(x3) {
  return JSON.stringify(x3);
}
function assertIsEmpty(obj) {
  return;
}
function assertNever(_x) {
}

// node_modules/openai/lib/ChatCompletionStreamingRunner.mjs
var ChatCompletionStreamingRunner = class _ChatCompletionStreamingRunner extends ChatCompletionStream {
  static fromReadableStream(stream) {
    const runner = new _ChatCompletionStreamingRunner(null);
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  static runTools(client, params, options) {
    const runner = new _ChatCompletionStreamingRunner(
      // @ts-expect-error TODO these types are incompatible
      params
    );
    const opts = {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    runner._run(() => runner._runTools(client, params, opts));
    return runner;
  }
};

// node_modules/openai/resources/chat/completions/completions.mjs
var Completions = class extends APIResource {
  constructor() {
    super(...arguments);
    this.messages = new Messages(this._client);
  }
  create(body, options) {
    var _a5;
    return this._client.post("/chat/completions", { body, ...options, stream: (_a5 = body.stream) != null ? _a5 : false });
  }
  /**
   * Get a stored chat completion. Only Chat Completions that have been created with
   * the `store` parameter set to `true` will be returned.
   *
   * @example
   * ```ts
   * const chatCompletion =
   *   await client.chat.completions.retrieve('completion_id');
   * ```
   */
  retrieve(completionID, options) {
    return this._client.get(path`/chat/completions/${completionID}`, options);
  }
  /**
   * Modify a stored chat completion. Only Chat Completions that have been created
   * with the `store` parameter set to `true` can be modified. Currently, the only
   * supported modification is to update the `metadata` field.
   *
   * @example
   * ```ts
   * const chatCompletion = await client.chat.completions.update(
   *   'completion_id',
   *   { metadata: { foo: 'string' } },
   * );
   * ```
   */
  update(completionID, body, options) {
    return this._client.post(path`/chat/completions/${completionID}`, { body, ...options });
  }
  /**
   * List stored Chat Completions. Only Chat Completions that have been stored with
   * the `store` parameter set to `true` will be returned.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const chatCompletion of client.chat.completions.list()) {
   *   // ...
   * }
   * ```
   */
  list(query = {}, options) {
    return this._client.getAPIList("/chat/completions", CursorPage, { query, ...options });
  }
  /**
   * Delete a stored chat completion. Only Chat Completions that have been created
   * with the `store` parameter set to `true` can be deleted.
   *
   * @example
   * ```ts
   * const chatCompletionDeleted =
   *   await client.chat.completions.delete('completion_id');
   * ```
   */
  delete(completionID, options) {
    return this._client.delete(path`/chat/completions/${completionID}`, options);
  }
  parse(body, options) {
    validateInputTools(body.tools);
    return this._client.chat.completions.create(body, {
      ...options,
      headers: {
        ...options == null ? void 0 : options.headers,
        "X-Stainless-Helper-Method": "chat.completions.parse"
      }
    })._thenUnwrap((completion) => parseChatCompletion(completion, body));
  }
  runTools(body, options) {
    if (body.stream) {
      return ChatCompletionStreamingRunner.runTools(this._client, body, options);
    }
    return ChatCompletionRunner.runTools(this._client, body, options);
  }
  /**
   * Creates a chat completion stream
   */
  stream(body, options) {
    return ChatCompletionStream.createChatCompletion(this._client, body, options);
  }
};
Completions.Messages = Messages;

// node_modules/openai/resources/chat/chat.mjs
var Chat = class extends APIResource {
  constructor() {
    super(...arguments);
    this.completions = new Completions(this._client);
  }
};
Chat.Completions = Completions;

// node_modules/openai/internal/headers.mjs
var brand_privateNullableHeaders = /* @__PURE__ */ Symbol("brand.privateNullableHeaders");
function* iterateHeaders(headers) {
  if (!headers)
    return;
  if (brand_privateNullableHeaders in headers) {
    const { values, nulls } = headers;
    yield* values.entries();
    for (const name of nulls) {
      yield [name, null];
    }
    return;
  }
  let shouldClear = false;
  let iter;
  if (headers instanceof Headers) {
    iter = headers.entries();
  } else if (isReadonlyArray(headers)) {
    iter = headers;
  } else {
    shouldClear = true;
    iter = Object.entries(headers != null ? headers : {});
  }
  for (let row of iter) {
    const name = row[0];
    if (typeof name !== "string")
      throw new TypeError("expected header name to be a string");
    const values = isReadonlyArray(row[1]) ? row[1] : [row[1]];
    let didClear = false;
    for (const value of values) {
      if (value === void 0)
        continue;
      if (shouldClear && !didClear) {
        didClear = true;
        yield [name, null];
      }
      yield [name, value];
    }
  }
}
var buildHeaders = (newHeaders) => {
  const targetHeaders = new Headers();
  const nullHeaders = /* @__PURE__ */ new Set();
  for (const headers of newHeaders) {
    const seenHeaders = /* @__PURE__ */ new Set();
    for (const [name, value] of iterateHeaders(headers)) {
      const lowerName = name.toLowerCase();
      if (!seenHeaders.has(lowerName)) {
        targetHeaders.delete(name);
        seenHeaders.add(lowerName);
      }
      if (value === null) {
        targetHeaders.delete(name);
        nullHeaders.add(lowerName);
      } else {
        targetHeaders.append(name, value);
        nullHeaders.delete(lowerName);
      }
    }
  }
  return { [brand_privateNullableHeaders]: true, values: targetHeaders, nulls: nullHeaders };
};

// node_modules/openai/resources/audio/speech.mjs
var Speech = class extends APIResource {
  /**
   * Generates audio from the input text.
   *
   * @example
   * ```ts
   * const speech = await client.audio.speech.create({
   *   input: 'input',
   *   model: 'string',
   *   voice: 'ash',
   * });
   *
   * const content = await speech.blob();
   * console.log(content);
   * ```
   */
  create(body, options) {
    return this._client.post("/audio/speech", {
      body,
      ...options,
      headers: buildHeaders([{ Accept: "application/octet-stream" }, options == null ? void 0 : options.headers]),
      __binaryResponse: true
    });
  }
};

// node_modules/openai/resources/audio/transcriptions.mjs
var Transcriptions = class extends APIResource {
  create(body, options) {
    var _a5;
    return this._client.post("/audio/transcriptions", multipartFormRequestOptions({
      body,
      ...options,
      stream: (_a5 = body.stream) != null ? _a5 : false,
      __metadata: { model: body.model }
    }, this._client));
  }
};

// node_modules/openai/resources/audio/translations.mjs
var Translations = class extends APIResource {
  create(body, options) {
    return this._client.post("/audio/translations", multipartFormRequestOptions({ body, ...options, __metadata: { model: body.model } }, this._client));
  }
};

// node_modules/openai/resources/audio/audio.mjs
var Audio = class extends APIResource {
  constructor() {
    super(...arguments);
    this.transcriptions = new Transcriptions(this._client);
    this.translations = new Translations(this._client);
    this.speech = new Speech(this._client);
  }
};
Audio.Transcriptions = Transcriptions;
Audio.Translations = Translations;
Audio.Speech = Speech;

// node_modules/openai/resources/batches.mjs
var Batches = class extends APIResource {
  /**
   * Creates and executes a batch from an uploaded file of requests
   */
  create(body, options) {
    return this._client.post("/batches", { body, ...options });
  }
  /**
   * Retrieves a batch.
   */
  retrieve(batchID, options) {
    return this._client.get(path`/batches/${batchID}`, options);
  }
  /**
   * List your organization's batches.
   */
  list(query = {}, options) {
    return this._client.getAPIList("/batches", CursorPage, { query, ...options });
  }
  /**
   * Cancels an in-progress batch. The batch will be in status `cancelling` for up to
   * 10 minutes, before changing to `cancelled`, where it will have partial results
   * (if any) available in the output file.
   */
  cancel(batchID, options) {
    return this._client.post(path`/batches/${batchID}/cancel`, options);
  }
};

// node_modules/openai/resources/beta/assistants.mjs
var Assistants2 = class extends APIResource {
  /**
   * Create an assistant with a model and instructions.
   *
   * @deprecated
   */
  create(body, options) {
    return this._client.post("/assistants", {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * Retrieves an assistant.
   *
   * @deprecated
   */
  retrieve(assistantID, options) {
    return this._client.get(path`/assistants/${assistantID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * Modifies an assistant.
   *
   * @deprecated
   */
  update(assistantID, body, options) {
    return this._client.post(path`/assistants/${assistantID}`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * Returns a list of assistants.
   *
   * @deprecated
   */
  list(query = {}, options) {
    return this._client.getAPIList("/assistants", CursorPage, {
      query,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * Delete an assistant.
   *
   * @deprecated
   */
  delete(assistantID, options) {
    return this._client.delete(path`/assistants/${assistantID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
    });
  }
};

// node_modules/openai/resources/beta/realtime/sessions.mjs
var Sessions = class extends APIResource {
  /**
   * Create an ephemeral API token for use in client-side applications with the
   * Realtime API. Can be configured with the same session parameters as the
   * `session.update` client event.
   *
   * It responds with a session object, plus a `client_secret` key which contains a
   * usable ephemeral API token that can be used to authenticate browser clients for
   * the Realtime API.
   *
   * @example
   * ```ts
   * const session =
   *   await client.beta.realtime.sessions.create();
   * ```
   */
  create(body, options) {
    return this._client.post("/realtime/sessions", {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
    });
  }
};

// node_modules/openai/resources/beta/realtime/transcription-sessions.mjs
var TranscriptionSessions = class extends APIResource {
  /**
   * Create an ephemeral API token for use in client-side applications with the
   * Realtime API specifically for realtime transcriptions. Can be configured with
   * the same session parameters as the `transcription_session.update` client event.
   *
   * It responds with a session object, plus a `client_secret` key which contains a
   * usable ephemeral API token that can be used to authenticate browser clients for
   * the Realtime API.
   *
   * @example
   * ```ts
   * const transcriptionSession =
   *   await client.beta.realtime.transcriptionSessions.create();
   * ```
   */
  create(body, options) {
    return this._client.post("/realtime/transcription_sessions", {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
    });
  }
};

// node_modules/openai/resources/beta/realtime/realtime.mjs
var Realtime = class extends APIResource {
  constructor() {
    super(...arguments);
    this.sessions = new Sessions(this._client);
    this.transcriptionSessions = new TranscriptionSessions(this._client);
  }
};
Realtime.Sessions = Sessions;
Realtime.TranscriptionSessions = TranscriptionSessions;

// node_modules/openai/resources/beta/chatkit/sessions.mjs
var Sessions2 = class extends APIResource {
  /**
   * Create a ChatKit session
   *
   * @example
   * ```ts
   * const chatSession =
   *   await client.beta.chatkit.sessions.create({
   *     user: 'x',
   *     workflow: { id: 'id' },
   *   });
   * ```
   */
  create(body, options) {
    return this._client.post("/chatkit/sessions", {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * Cancel a ChatKit session
   *
   * @example
   * ```ts
   * const chatSession =
   *   await client.beta.chatkit.sessions.cancel('cksess_123');
   * ```
   */
  cancel(sessionID, options) {
    return this._client.post(path`/chatkit/sessions/${sessionID}/cancel`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options == null ? void 0 : options.headers])
    });
  }
};

// node_modules/openai/resources/beta/chatkit/threads.mjs
var Threads = class extends APIResource {
  /**
   * Retrieve a ChatKit thread
   *
   * @example
   * ```ts
   * const chatkitThread =
   *   await client.beta.chatkit.threads.retrieve('cthr_123');
   * ```
   */
  retrieve(threadID, options) {
    return this._client.get(path`/chatkit/threads/${threadID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * List ChatKit threads
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const chatkitThread of client.beta.chatkit.threads.list()) {
   *   // ...
   * }
   * ```
   */
  list(query = {}, options) {
    return this._client.getAPIList("/chatkit/threads", ConversationCursorPage, {
      query,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * Delete a ChatKit thread
   *
   * @example
   * ```ts
   * const thread = await client.beta.chatkit.threads.delete(
   *   'cthr_123',
   * );
   * ```
   */
  delete(threadID, options) {
    return this._client.delete(path`/chatkit/threads/${threadID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * List ChatKit thread items
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const thread of client.beta.chatkit.threads.listItems(
   *   'cthr_123',
   * )) {
   *   // ...
   * }
   * ```
   */
  listItems(threadID, query = {}, options) {
    return this._client.getAPIList(path`/chatkit/threads/${threadID}/items`, ConversationCursorPage, { query, ...options, headers: buildHeaders([{ "OpenAI-Beta": "chatkit_beta=v1" }, options == null ? void 0 : options.headers]) });
  }
};

// node_modules/openai/resources/beta/chatkit/chatkit.mjs
var ChatKit = class extends APIResource {
  constructor() {
    super(...arguments);
    this.sessions = new Sessions2(this._client);
    this.threads = new Threads(this._client);
  }
};
ChatKit.Sessions = Sessions2;
ChatKit.Threads = Threads;

// node_modules/openai/resources/beta/threads/messages.mjs
var Messages2 = class extends APIResource {
  /**
   * Create a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  create(threadID, body, options) {
    return this._client.post(path`/threads/${threadID}/messages`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * Retrieve a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(messageID, params, options) {
    const { thread_id } = params;
    return this._client.get(path`/threads/${thread_id}/messages/${messageID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * Modifies a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  update(messageID, params, options) {
    const { thread_id, ...body } = params;
    return this._client.post(path`/threads/${thread_id}/messages/${messageID}`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * Returns a list of messages for a given thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  list(threadID, query = {}, options) {
    return this._client.getAPIList(path`/threads/${threadID}/messages`, CursorPage, {
      query,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * Deletes a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  delete(messageID, params, options) {
    const { thread_id } = params;
    return this._client.delete(path`/threads/${thread_id}/messages/${messageID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
    });
  }
};

// node_modules/openai/resources/beta/threads/runs/steps.mjs
var Steps = class extends APIResource {
  /**
   * Retrieves a run step.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(stepID, params, options) {
    const { thread_id, run_id, ...query } = params;
    return this._client.get(path`/threads/${thread_id}/runs/${run_id}/steps/${stepID}`, {
      query,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * Returns a list of run steps belonging to a run.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  list(runID, params, options) {
    const { thread_id, ...query } = params;
    return this._client.getAPIList(path`/threads/${thread_id}/runs/${runID}/steps`, CursorPage, {
      query,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
    });
  }
};

// node_modules/openai/internal/utils/base64.mjs
var toFloat32Array = (base64Str) => {
  if (typeof Buffer !== "undefined") {
    const buf = Buffer.from(base64Str, "base64");
    return Array.from(new Float32Array(buf.buffer, buf.byteOffset, buf.length / Float32Array.BYTES_PER_ELEMENT));
  } else {
    const binaryStr = atob(base64Str);
    const len = binaryStr.length;
    const bytes = new Uint8Array(len);
    for (let i3 = 0; i3 < len; i3++) {
      bytes[i3] = binaryStr.charCodeAt(i3);
    }
    return Array.from(new Float32Array(bytes.buffer));
  }
};

// node_modules/openai/internal/utils/env.mjs
var readEnv = (env) => {
  var _a5, _b, _c, _d, _e, _f;
  if (typeof globalThis.process !== "undefined") {
    return (_c = (_b = (_a5 = globalThis.process.env) == null ? void 0 : _a5[env]) == null ? void 0 : _b.trim()) != null ? _c : void 0;
  }
  if (typeof globalThis.Deno !== "undefined") {
    return (_f = (_e = (_d = globalThis.Deno.env) == null ? void 0 : _d.get) == null ? void 0 : _e.call(_d, env)) == null ? void 0 : _f.trim();
  }
  return void 0;
};

// node_modules/openai/lib/AssistantStream.mjs
var _AssistantStream_instances;
var _a;
var _AssistantStream_events;
var _AssistantStream_runStepSnapshots;
var _AssistantStream_messageSnapshots;
var _AssistantStream_messageSnapshot;
var _AssistantStream_finalRun;
var _AssistantStream_currentContentIndex;
var _AssistantStream_currentContent;
var _AssistantStream_currentToolCallIndex;
var _AssistantStream_currentToolCall;
var _AssistantStream_currentEvent;
var _AssistantStream_currentRunSnapshot;
var _AssistantStream_currentRunStepSnapshot;
var _AssistantStream_addEvent;
var _AssistantStream_endRequest;
var _AssistantStream_handleMessage;
var _AssistantStream_handleRunStep;
var _AssistantStream_handleEvent;
var _AssistantStream_accumulateRunStep;
var _AssistantStream_accumulateMessage;
var _AssistantStream_accumulateContent;
var _AssistantStream_handleRun;
var AssistantStream = class extends EventStream {
  constructor() {
    super(...arguments);
    _AssistantStream_instances.add(this);
    _AssistantStream_events.set(this, []);
    _AssistantStream_runStepSnapshots.set(this, {});
    _AssistantStream_messageSnapshots.set(this, {});
    _AssistantStream_messageSnapshot.set(this, void 0);
    _AssistantStream_finalRun.set(this, void 0);
    _AssistantStream_currentContentIndex.set(this, void 0);
    _AssistantStream_currentContent.set(this, void 0);
    _AssistantStream_currentToolCallIndex.set(this, void 0);
    _AssistantStream_currentToolCall.set(this, void 0);
    _AssistantStream_currentEvent.set(this, void 0);
    _AssistantStream_currentRunSnapshot.set(this, void 0);
    _AssistantStream_currentRunStepSnapshot.set(this, void 0);
  }
  [(_AssistantStream_events = /* @__PURE__ */ new WeakMap(), _AssistantStream_runStepSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_finalRun = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContentIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCallIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCall = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentEvent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunStepSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_instances = /* @__PURE__ */ new WeakSet(), Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("event", (event) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(event);
      } else {
        pushQueue.push(event);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  static fromReadableStream(stream) {
    const runner = new _a();
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  async _fromReadableStream(readableStream, options) {
    var _a5;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    this._connected();
    const stream = Stream.fromReadableStream(readableStream, this.controller);
    for await (const event of stream) {
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if ((_a5 = stream.controller.signal) == null ? void 0 : _a5.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  toReadableStream() {
    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
  static createToolAssistantStream(runId, runs, params, options) {
    const runner = new _a();
    runner._run(() => runner._runToolAssistantStream(runId, runs, params, {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  async _createToolAssistantStream(run, runId, params, options) {
    var _a5;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await run.submitToolOutputs(runId, body, {
      ...options,
      signal: this.controller.signal
    });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if ((_a5 = stream.controller.signal) == null ? void 0 : _a5.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  static createThreadAssistantStream(params, thread, options) {
    const runner = new _a();
    runner._run(() => runner._threadAssistantStream(params, thread, {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  static createAssistantStream(threadId, runs, params, options) {
    const runner = new _a();
    runner._run(() => runner._runAssistantStream(threadId, runs, params, {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  currentEvent() {
    return __classPrivateFieldGet(this, _AssistantStream_currentEvent, "f");
  }
  currentRun() {
    return __classPrivateFieldGet(this, _AssistantStream_currentRunSnapshot, "f");
  }
  currentMessageSnapshot() {
    return __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f");
  }
  currentRunStepSnapshot() {
    return __classPrivateFieldGet(this, _AssistantStream_currentRunStepSnapshot, "f");
  }
  async finalRunSteps() {
    await this.done();
    return Object.values(__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f"));
  }
  async finalMessages() {
    await this.done();
    return Object.values(__classPrivateFieldGet(this, _AssistantStream_messageSnapshots, "f"));
  }
  async finalRun() {
    await this.done();
    if (!__classPrivateFieldGet(this, _AssistantStream_finalRun, "f"))
      throw Error("Final run was not received.");
    return __classPrivateFieldGet(this, _AssistantStream_finalRun, "f");
  }
  async _createThreadAssistantStream(thread, params, options) {
    var _a5;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await thread.createAndRun(body, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if ((_a5 = stream.controller.signal) == null ? void 0 : _a5.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  async _createAssistantStream(run, threadId, params, options) {
    var _a5;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await run.create(threadId, body, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if ((_a5 = stream.controller.signal) == null ? void 0 : _a5.aborted) {
      throw new APIUserAbortError();
    }
    return this._addRun(__classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  static accumulateDelta(acc, delta) {
    for (const [key, deltaValue] of Object.entries(delta)) {
      if (!acc.hasOwnProperty(key)) {
        acc[key] = deltaValue;
        continue;
      }
      let accValue = acc[key];
      if (accValue === null || accValue === void 0) {
        acc[key] = deltaValue;
        continue;
      }
      if (key === "index" || key === "type") {
        acc[key] = deltaValue;
        continue;
      }
      if (typeof accValue === "string" && typeof deltaValue === "string") {
        accValue += deltaValue;
      } else if (typeof accValue === "number" && typeof deltaValue === "number") {
        accValue += deltaValue;
      } else if (isObj(accValue) && isObj(deltaValue)) {
        accValue = this.accumulateDelta(accValue, deltaValue);
      } else if (Array.isArray(accValue) && Array.isArray(deltaValue)) {
        if (accValue.every((x3) => typeof x3 === "string" || typeof x3 === "number")) {
          accValue.push(...deltaValue);
          continue;
        }
        for (const deltaEntry of deltaValue) {
          if (!isObj(deltaEntry)) {
            throw new Error(`Expected array delta entry to be an object but got: ${deltaEntry}`);
          }
          const index = deltaEntry["index"];
          if (index == null) {
            console.error(deltaEntry);
            throw new Error("Expected array delta entry to have an `index` property");
          }
          if (typeof index !== "number") {
            throw new Error(`Expected array delta entry \`index\` property to be a number but got ${index}`);
          }
          const accEntry = accValue[index];
          if (accEntry == null) {
            accValue.push(deltaEntry);
          } else {
            accValue[index] = this.accumulateDelta(accEntry, deltaEntry);
          }
        }
        continue;
      } else {
        throw Error(`Unhandled record type: ${key}, deltaValue: ${deltaValue}, accValue: ${accValue}`);
      }
      acc[key] = accValue;
    }
    return acc;
  }
  _addRun(run) {
    return run;
  }
  async _threadAssistantStream(params, thread, options) {
    return await this._createThreadAssistantStream(thread, params, options);
  }
  async _runAssistantStream(threadId, runs, params, options) {
    return await this._createAssistantStream(runs, threadId, params, options);
  }
  async _runToolAssistantStream(runId, runs, params, options) {
    return await this._createToolAssistantStream(runs, runId, params, options);
  }
};
_a = AssistantStream, _AssistantStream_addEvent = function _AssistantStream_addEvent2(event) {
  if (this.ended)
    return;
  __classPrivateFieldSet(this, _AssistantStream_currentEvent, event, "f");
  __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleEvent).call(this, event);
  switch (event.event) {
    case "thread.created":
      break;
    case "thread.run.created":
    case "thread.run.queued":
    case "thread.run.in_progress":
    case "thread.run.requires_action":
    case "thread.run.completed":
    case "thread.run.incomplete":
    case "thread.run.failed":
    case "thread.run.cancelling":
    case "thread.run.cancelled":
    case "thread.run.expired":
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleRun).call(this, event);
      break;
    case "thread.run.step.created":
    case "thread.run.step.in_progress":
    case "thread.run.step.delta":
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleRunStep).call(this, event);
      break;
    case "thread.message.created":
    case "thread.message.in_progress":
    case "thread.message.delta":
    case "thread.message.completed":
    case "thread.message.incomplete":
      __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_handleMessage).call(this, event);
      break;
    case "error":
      throw new Error("Encountered an error event in event processing - errors should be processed earlier");
    default:
      assertNever2(event);
  }
}, _AssistantStream_endRequest = function _AssistantStream_endRequest2() {
  if (this.ended) {
    throw new OpenAIError(`stream has ended, this shouldn't happen`);
  }
  if (!__classPrivateFieldGet(this, _AssistantStream_finalRun, "f"))
    throw Error("Final run has not been received");
  return __classPrivateFieldGet(this, _AssistantStream_finalRun, "f");
}, _AssistantStream_handleMessage = function _AssistantStream_handleMessage2(event) {
  const [accumulatedMessage, newContent] = __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_accumulateMessage).call(this, event, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
  __classPrivateFieldSet(this, _AssistantStream_messageSnapshot, accumulatedMessage, "f");
  __classPrivateFieldGet(this, _AssistantStream_messageSnapshots, "f")[accumulatedMessage.id] = accumulatedMessage;
  for (const content of newContent) {
    const snapshotContent = accumulatedMessage.content[content.index];
    if ((snapshotContent == null ? void 0 : snapshotContent.type) == "text") {
      this._emit("textCreated", snapshotContent.text);
    }
  }
  switch (event.event) {
    case "thread.message.created":
      this._emit("messageCreated", event.data);
      break;
    case "thread.message.in_progress":
      break;
    case "thread.message.delta":
      this._emit("messageDelta", event.data.delta, accumulatedMessage);
      if (event.data.delta.content) {
        for (const content of event.data.delta.content) {
          if (content.type == "text" && content.text) {
            let textDelta = content.text;
            let snapshot = accumulatedMessage.content[content.index];
            if (snapshot && snapshot.type == "text") {
              this._emit("textDelta", textDelta, snapshot.text);
            } else {
              throw Error("The snapshot associated with this text delta is not text or missing");
            }
          }
          if (content.index != __classPrivateFieldGet(this, _AssistantStream_currentContentIndex, "f")) {
            if (__classPrivateFieldGet(this, _AssistantStream_currentContent, "f")) {
              switch (__classPrivateFieldGet(this, _AssistantStream_currentContent, "f").type) {
                case "text":
                  this._emit("textDone", __classPrivateFieldGet(this, _AssistantStream_currentContent, "f").text, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
                  break;
                case "image_file":
                  this._emit("imageFileDone", __classPrivateFieldGet(this, _AssistantStream_currentContent, "f").image_file, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
                  break;
              }
            }
            __classPrivateFieldSet(this, _AssistantStream_currentContentIndex, content.index, "f");
          }
          __classPrivateFieldSet(this, _AssistantStream_currentContent, accumulatedMessage.content[content.index], "f");
        }
      }
      break;
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (__classPrivateFieldGet(this, _AssistantStream_currentContentIndex, "f") !== void 0) {
        const currentContent = event.data.content[__classPrivateFieldGet(this, _AssistantStream_currentContentIndex, "f")];
        if (currentContent) {
          switch (currentContent.type) {
            case "image_file":
              this._emit("imageFileDone", currentContent.image_file, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
              break;
            case "text":
              this._emit("textDone", currentContent.text, __classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f"));
              break;
          }
        }
      }
      if (__classPrivateFieldGet(this, _AssistantStream_messageSnapshot, "f")) {
        this._emit("messageDone", event.data);
      }
      __classPrivateFieldSet(this, _AssistantStream_messageSnapshot, void 0, "f");
  }
}, _AssistantStream_handleRunStep = function _AssistantStream_handleRunStep2(event) {
  const accumulatedRunStep = __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_accumulateRunStep).call(this, event);
  __classPrivateFieldSet(this, _AssistantStream_currentRunStepSnapshot, accumulatedRunStep, "f");
  switch (event.event) {
    case "thread.run.step.created":
      this._emit("runStepCreated", event.data);
      break;
    case "thread.run.step.delta":
      const delta = event.data.delta;
      if (delta.step_details && delta.step_details.type == "tool_calls" && delta.step_details.tool_calls && accumulatedRunStep.step_details.type == "tool_calls") {
        for (const toolCall of delta.step_details.tool_calls) {
          if (toolCall.index == __classPrivateFieldGet(this, _AssistantStream_currentToolCallIndex, "f")) {
            this._emit("toolCallDelta", toolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index]);
          } else {
            if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f")) {
              this._emit("toolCallDone", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
            }
            __classPrivateFieldSet(this, _AssistantStream_currentToolCallIndex, toolCall.index, "f");
            __classPrivateFieldSet(this, _AssistantStream_currentToolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index], "f");
            if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"))
              this._emit("toolCallCreated", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
          }
        }
      }
      this._emit("runStepDelta", event.data.delta, accumulatedRunStep);
      break;
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      __classPrivateFieldSet(this, _AssistantStream_currentRunStepSnapshot, void 0, "f");
      const details = event.data.step_details;
      if (details.type == "tool_calls") {
        if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f")) {
          this._emit("toolCallDone", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
          __classPrivateFieldSet(this, _AssistantStream_currentToolCall, void 0, "f");
        }
      }
      this._emit("runStepDone", event.data, accumulatedRunStep);
      break;
    case "thread.run.step.in_progress":
      break;
  }
}, _AssistantStream_handleEvent = function _AssistantStream_handleEvent2(event) {
  __classPrivateFieldGet(this, _AssistantStream_events, "f").push(event);
  this._emit("event", event);
}, _AssistantStream_accumulateRunStep = function _AssistantStream_accumulateRunStep2(event) {
  switch (event.event) {
    case "thread.run.step.created":
      __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
      return event.data;
    case "thread.run.step.delta":
      let snapshot = __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
      if (!snapshot) {
        throw Error("Received a RunStepDelta before creation of a snapshot");
      }
      let data = event.data;
      if (data.delta) {
        const accumulated = _a.accumulateDelta(snapshot, data.delta);
        __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = accumulated;
      }
      return __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
    case "thread.run.step.in_progress":
      __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
      break;
  }
  if (__classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id])
    return __classPrivateFieldGet(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
  throw new Error("No snapshot available");
}, _AssistantStream_accumulateMessage = function _AssistantStream_accumulateMessage2(event, snapshot) {
  let newContent = [];
  switch (event.event) {
    case "thread.message.created":
      return [event.data, newContent];
    case "thread.message.delta":
      if (!snapshot) {
        throw Error("Received a delta with no existing snapshot (there should be one from message creation)");
      }
      let data = event.data;
      if (data.delta.content) {
        for (const contentElement of data.delta.content) {
          if (contentElement.index in snapshot.content) {
            let currentContent = snapshot.content[contentElement.index];
            snapshot.content[contentElement.index] = __classPrivateFieldGet(this, _AssistantStream_instances, "m", _AssistantStream_accumulateContent).call(this, contentElement, currentContent);
          } else {
            snapshot.content[contentElement.index] = contentElement;
            newContent.push(contentElement);
          }
        }
      }
      return [snapshot, newContent];
    case "thread.message.in_progress":
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (snapshot) {
        return [snapshot, newContent];
      } else {
        throw Error("Received thread message event with no existing snapshot");
      }
  }
  throw Error("Tried to accumulate a non-message event");
}, _AssistantStream_accumulateContent = function _AssistantStream_accumulateContent2(contentElement, currentContent) {
  return _a.accumulateDelta(currentContent, contentElement);
}, _AssistantStream_handleRun = function _AssistantStream_handleRun2(event) {
  __classPrivateFieldSet(this, _AssistantStream_currentRunSnapshot, event.data, "f");
  switch (event.event) {
    case "thread.run.created":
      break;
    case "thread.run.queued":
      break;
    case "thread.run.in_progress":
      break;
    case "thread.run.requires_action":
    case "thread.run.cancelled":
    case "thread.run.failed":
    case "thread.run.completed":
    case "thread.run.expired":
    case "thread.run.incomplete":
      __classPrivateFieldSet(this, _AssistantStream_finalRun, event.data, "f");
      if (__classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f")) {
        this._emit("toolCallDone", __classPrivateFieldGet(this, _AssistantStream_currentToolCall, "f"));
        __classPrivateFieldSet(this, _AssistantStream_currentToolCall, void 0, "f");
      }
      break;
    case "thread.run.cancelling":
      break;
  }
};
function assertNever2(_x) {
}

// node_modules/openai/resources/beta/threads/runs/runs.mjs
var Runs = class extends APIResource {
  constructor() {
    super(...arguments);
    this.steps = new Steps(this._client);
  }
  create(threadID, params, options) {
    var _a5;
    const { include, ...body } = params;
    return this._client.post(path`/threads/${threadID}/runs`, {
      query: { include },
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers]),
      stream: (_a5 = params.stream) != null ? _a5 : false
    });
  }
  /**
   * Retrieves a run.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(runID, params, options) {
    const { thread_id } = params;
    return this._client.get(path`/threads/${thread_id}/runs/${runID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * Modifies a run.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  update(runID, params, options) {
    const { thread_id, ...body } = params;
    return this._client.post(path`/threads/${thread_id}/runs/${runID}`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * Returns a list of runs belonging to a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  list(threadID, query = {}, options) {
    return this._client.getAPIList(path`/threads/${threadID}/runs`, CursorPage, {
      query,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * Cancels a run that is `in_progress`.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  cancel(runID, params, options) {
    const { thread_id } = params;
    return this._client.post(path`/threads/${thread_id}/runs/${runID}/cancel`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * A helper to create a run an poll for a terminal state. More information on Run
   * lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndPoll(threadId, body, options) {
    const run = await this.create(threadId, body, options);
    return await this.poll(run.id, { thread_id: threadId }, options);
  }
  /**
   * Create a Run stream
   *
   * @deprecated use `stream` instead
   */
  createAndStream(threadId, body, options) {
    return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
  }
  /**
   * A helper to poll a run status until it reaches a terminal state. More
   * information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async poll(runId, params, options) {
    var _a5, _b;
    const headers = buildHeaders([
      options == null ? void 0 : options.headers,
      {
        "X-Stainless-Poll-Helper": "true",
        "X-Stainless-Custom-Poll-Interval": (_b = (_a5 = options == null ? void 0 : options.pollIntervalMs) == null ? void 0 : _a5.toString()) != null ? _b : void 0
      }
    ]);
    while (true) {
      const { data: run, response } = await this.retrieve(runId, params, {
        ...options,
        headers: { ...options == null ? void 0 : options.headers, ...headers }
      }).withResponse();
      switch (run.status) {
        //If we are in any sort of intermediate state we poll
        case "queued":
        case "in_progress":
        case "cancelling":
          let sleepInterval = 5e3;
          if (options == null ? void 0 : options.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep(sleepInterval);
          break;
        //We return the run in any terminal state.
        case "requires_action":
        case "incomplete":
        case "cancelled":
        case "completed":
        case "failed":
        case "expired":
          return run;
      }
    }
  }
  /**
   * Create a Run stream
   */
  stream(threadId, body, options) {
    return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
  }
  submitToolOutputs(runID, params, options) {
    var _a5;
    const { thread_id, ...body } = params;
    return this._client.post(path`/threads/${thread_id}/runs/${runID}/submit_tool_outputs`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers]),
      stream: (_a5 = params.stream) != null ? _a5 : false
    });
  }
  /**
   * A helper to submit a tool output to a run and poll for a terminal run state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async submitToolOutputsAndPoll(runId, params, options) {
    const run = await this.submitToolOutputs(runId, params, options);
    return await this.poll(run.id, params, options);
  }
  /**
   * Submit the tool outputs from a previous run and stream the run to a terminal
   * state. More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  submitToolOutputsStream(runId, params, options) {
    return AssistantStream.createToolAssistantStream(runId, this._client.beta.threads.runs, params, options);
  }
};
Runs.Steps = Steps;

// node_modules/openai/resources/beta/threads/threads.mjs
var Threads2 = class extends APIResource {
  constructor() {
    super(...arguments);
    this.runs = new Runs(this._client);
    this.messages = new Messages2(this._client);
  }
  /**
   * Create a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  create(body = {}, options) {
    return this._client.post("/threads", {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * Retrieves a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(threadID, options) {
    return this._client.get(path`/threads/${threadID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * Modifies a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  update(threadID, body, options) {
    return this._client.post(path`/threads/${threadID}`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * Delete a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  delete(threadID, options) {
    return this._client.delete(path`/threads/${threadID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
    });
  }
  createAndRun(body, options) {
    var _a5;
    return this._client.post("/threads/runs", {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers]),
      stream: (_a5 = body.stream) != null ? _a5 : false
    });
  }
  /**
   * A helper to create a thread, start a run and then poll for a terminal state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndRunPoll(body, options) {
    const run = await this.createAndRun(body, options);
    return await this.runs.poll(run.id, { thread_id: run.thread_id }, options);
  }
  /**
   * Create a thread and stream the run back
   */
  createAndRunStream(body, options) {
    return AssistantStream.createThreadAssistantStream(body, this._client.beta.threads, options);
  }
};
Threads2.Runs = Runs;
Threads2.Messages = Messages2;

// node_modules/openai/resources/beta/beta.mjs
var Beta = class extends APIResource {
  constructor() {
    super(...arguments);
    this.realtime = new Realtime(this._client);
    this.chatkit = new ChatKit(this._client);
    this.assistants = new Assistants2(this._client);
    this.threads = new Threads2(this._client);
  }
};
Beta.Realtime = Realtime;
Beta.ChatKit = ChatKit;
Beta.Assistants = Assistants2;
Beta.Threads = Threads2;

// node_modules/openai/resources/completions.mjs
var Completions2 = class extends APIResource {
  create(body, options) {
    var _a5;
    return this._client.post("/completions", { body, ...options, stream: (_a5 = body.stream) != null ? _a5 : false });
  }
};

// node_modules/openai/resources/containers/files/content.mjs
var Content = class extends APIResource {
  /**
   * Retrieve Container File Content
   */
  retrieve(fileID, params, options) {
    const { container_id } = params;
    return this._client.get(path`/containers/${container_id}/files/${fileID}/content`, {
      ...options,
      headers: buildHeaders([{ Accept: "application/binary" }, options == null ? void 0 : options.headers]),
      __binaryResponse: true
    });
  }
};

// node_modules/openai/resources/containers/files/files.mjs
var Files = class extends APIResource {
  constructor() {
    super(...arguments);
    this.content = new Content(this._client);
  }
  /**
   * Create a Container File
   *
   * You can send either a multipart/form-data request with the raw file content, or
   * a JSON request with a file ID.
   */
  create(containerID, body, options) {
    return this._client.post(path`/containers/${containerID}/files`, multipartFormRequestOptions({ body, ...options }, this._client));
  }
  /**
   * Retrieve Container File
   */
  retrieve(fileID, params, options) {
    const { container_id } = params;
    return this._client.get(path`/containers/${container_id}/files/${fileID}`, options);
  }
  /**
   * List Container files
   */
  list(containerID, query = {}, options) {
    return this._client.getAPIList(path`/containers/${containerID}/files`, CursorPage, {
      query,
      ...options
    });
  }
  /**
   * Delete Container File
   */
  delete(fileID, params, options) {
    const { container_id } = params;
    return this._client.delete(path`/containers/${container_id}/files/${fileID}`, {
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options == null ? void 0 : options.headers])
    });
  }
};
Files.Content = Content;

// node_modules/openai/resources/containers/containers.mjs
var Containers = class extends APIResource {
  constructor() {
    super(...arguments);
    this.files = new Files(this._client);
  }
  /**
   * Create Container
   */
  create(body, options) {
    return this._client.post("/containers", { body, ...options });
  }
  /**
   * Retrieve Container
   */
  retrieve(containerID, options) {
    return this._client.get(path`/containers/${containerID}`, options);
  }
  /**
   * List Containers
   */
  list(query = {}, options) {
    return this._client.getAPIList("/containers", CursorPage, { query, ...options });
  }
  /**
   * Delete Container
   */
  delete(containerID, options) {
    return this._client.delete(path`/containers/${containerID}`, {
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options == null ? void 0 : options.headers])
    });
  }
};
Containers.Files = Files;

// node_modules/openai/resources/conversations/items.mjs
var Items = class extends APIResource {
  /**
   * Create items in a conversation with the given ID.
   */
  create(conversationID, params, options) {
    const { include, ...body } = params;
    return this._client.post(path`/conversations/${conversationID}/items`, {
      query: { include },
      body,
      ...options
    });
  }
  /**
   * Get a single item from a conversation with the given IDs.
   */
  retrieve(itemID, params, options) {
    const { conversation_id, ...query } = params;
    return this._client.get(path`/conversations/${conversation_id}/items/${itemID}`, { query, ...options });
  }
  /**
   * List all items for a conversation with the given ID.
   */
  list(conversationID, query = {}, options) {
    return this._client.getAPIList(path`/conversations/${conversationID}/items`, ConversationCursorPage, { query, ...options });
  }
  /**
   * Delete an item from a conversation with the given IDs.
   */
  delete(itemID, params, options) {
    const { conversation_id } = params;
    return this._client.delete(path`/conversations/${conversation_id}/items/${itemID}`, options);
  }
};

// node_modules/openai/resources/conversations/conversations.mjs
var Conversations = class extends APIResource {
  constructor() {
    super(...arguments);
    this.items = new Items(this._client);
  }
  /**
   * Create a conversation.
   */
  create(body = {}, options) {
    return this._client.post("/conversations", { body, ...options });
  }
  /**
   * Get a conversation
   */
  retrieve(conversationID, options) {
    return this._client.get(path`/conversations/${conversationID}`, options);
  }
  /**
   * Update a conversation
   */
  update(conversationID, body, options) {
    return this._client.post(path`/conversations/${conversationID}`, { body, ...options });
  }
  /**
   * Delete a conversation. Items in the conversation will not be deleted.
   */
  delete(conversationID, options) {
    return this._client.delete(path`/conversations/${conversationID}`, options);
  }
};
Conversations.Items = Items;

// node_modules/openai/resources/embeddings.mjs
var Embeddings = class extends APIResource {
  /**
   * Creates an embedding vector representing the input text.
   *
   * @example
   * ```ts
   * const createEmbeddingResponse =
   *   await client.embeddings.create({
   *     input: 'The quick brown fox jumped over the lazy dog',
   *     model: 'text-embedding-3-small',
   *   });
   * ```
   */
  create(body, options) {
    const hasUserProvidedEncodingFormat = !!body.encoding_format;
    let encoding_format = hasUserProvidedEncodingFormat ? body.encoding_format : "base64";
    if (hasUserProvidedEncodingFormat) {
      loggerFor(this._client).debug("embeddings/user defined encoding_format:", body.encoding_format);
    }
    const response = this._client.post("/embeddings", {
      body: {
        ...body,
        encoding_format
      },
      ...options
    });
    if (hasUserProvidedEncodingFormat) {
      return response;
    }
    loggerFor(this._client).debug("embeddings/decoding base64 embeddings from base64");
    return response._thenUnwrap((response2) => {
      if (response2 && response2.data) {
        response2.data.forEach((embeddingBase64Obj) => {
          const embeddingBase64Str = embeddingBase64Obj.embedding;
          embeddingBase64Obj.embedding = toFloat32Array(embeddingBase64Str);
        });
      }
      return response2;
    });
  }
};

// node_modules/openai/resources/evals/runs/output-items.mjs
var OutputItems = class extends APIResource {
  /**
   * Get an evaluation run output item by ID.
   */
  retrieve(outputItemID, params, options) {
    const { eval_id, run_id } = params;
    return this._client.get(path`/evals/${eval_id}/runs/${run_id}/output_items/${outputItemID}`, options);
  }
  /**
   * Get a list of output items for an evaluation run.
   */
  list(runID, params, options) {
    const { eval_id, ...query } = params;
    return this._client.getAPIList(path`/evals/${eval_id}/runs/${runID}/output_items`, CursorPage, { query, ...options });
  }
};

// node_modules/openai/resources/evals/runs/runs.mjs
var Runs2 = class extends APIResource {
  constructor() {
    super(...arguments);
    this.outputItems = new OutputItems(this._client);
  }
  /**
   * Kicks off a new run for a given evaluation, specifying the data source, and what
   * model configuration to use to test. The datasource will be validated against the
   * schema specified in the config of the evaluation.
   */
  create(evalID, body, options) {
    return this._client.post(path`/evals/${evalID}/runs`, { body, ...options });
  }
  /**
   * Get an evaluation run by ID.
   */
  retrieve(runID, params, options) {
    const { eval_id } = params;
    return this._client.get(path`/evals/${eval_id}/runs/${runID}`, options);
  }
  /**
   * Get a list of runs for an evaluation.
   */
  list(evalID, query = {}, options) {
    return this._client.getAPIList(path`/evals/${evalID}/runs`, CursorPage, {
      query,
      ...options
    });
  }
  /**
   * Delete an eval run.
   */
  delete(runID, params, options) {
    const { eval_id } = params;
    return this._client.delete(path`/evals/${eval_id}/runs/${runID}`, options);
  }
  /**
   * Cancel an ongoing evaluation run.
   */
  cancel(runID, params, options) {
    const { eval_id } = params;
    return this._client.post(path`/evals/${eval_id}/runs/${runID}`, options);
  }
};
Runs2.OutputItems = OutputItems;

// node_modules/openai/resources/evals/evals.mjs
var Evals = class extends APIResource {
  constructor() {
    super(...arguments);
    this.runs = new Runs2(this._client);
  }
  /**
   * Create the structure of an evaluation that can be used to test a model's
   * performance. An evaluation is a set of testing criteria and the config for a
   * data source, which dictates the schema of the data used in the evaluation. After
   * creating an evaluation, you can run it on different models and model parameters.
   * We support several types of graders and datasources. For more information, see
   * the [Evals guide](https://platform.openai.com/docs/guides/evals).
   */
  create(body, options) {
    return this._client.post("/evals", { body, ...options });
  }
  /**
   * Get an evaluation by ID.
   */
  retrieve(evalID, options) {
    return this._client.get(path`/evals/${evalID}`, options);
  }
  /**
   * Update certain properties of an evaluation.
   */
  update(evalID, body, options) {
    return this._client.post(path`/evals/${evalID}`, { body, ...options });
  }
  /**
   * List evaluations for a project.
   */
  list(query = {}, options) {
    return this._client.getAPIList("/evals", CursorPage, { query, ...options });
  }
  /**
   * Delete an evaluation.
   */
  delete(evalID, options) {
    return this._client.delete(path`/evals/${evalID}`, options);
  }
};
Evals.Runs = Runs2;

// node_modules/openai/resources/files.mjs
var Files2 = class extends APIResource {
  /**
   * Upload a file that can be used across various endpoints. Individual files can be
   * up to 512 MB, and each project can store up to 2.5 TB of files in total. There
   * is no organization-wide storage limit.
   *
   * - The Assistants API supports files up to 2 million tokens and of specific file
   *   types. See the
   *   [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools)
   *   for details.
   * - The Fine-tuning API only supports `.jsonl` files. The input also has certain
   *   required formats for fine-tuning
   *   [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input)
   *   or
   *   [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)
   *   models.
   * - The Batch API only supports `.jsonl` files up to 200 MB in size. The input
   *   also has a specific required
   *   [format](https://platform.openai.com/docs/api-reference/batch/request-input).
   *
   * Please [contact us](https://help.openai.com/) if you need to increase these
   * storage limits.
   */
  create(body, options) {
    return this._client.post("/files", multipartFormRequestOptions({ body, ...options }, this._client));
  }
  /**
   * Returns information about a specific file.
   */
  retrieve(fileID, options) {
    return this._client.get(path`/files/${fileID}`, options);
  }
  /**
   * Returns a list of files.
   */
  list(query = {}, options) {
    return this._client.getAPIList("/files", CursorPage, { query, ...options });
  }
  /**
   * Delete a file and remove it from all vector stores.
   */
  delete(fileID, options) {
    return this._client.delete(path`/files/${fileID}`, options);
  }
  /**
   * Returns the contents of the specified file.
   */
  content(fileID, options) {
    return this._client.get(path`/files/${fileID}/content`, {
      ...options,
      headers: buildHeaders([{ Accept: "application/binary" }, options == null ? void 0 : options.headers]),
      __binaryResponse: true
    });
  }
  /**
   * Waits for the given file to be processed, default timeout is 30 mins.
   */
  async waitForProcessing(id, { pollInterval = 5e3, maxWait = 30 * 60 * 1e3 } = {}) {
    const TERMINAL_STATES = /* @__PURE__ */ new Set(["processed", "error", "deleted"]);
    const start = Date.now();
    let file = await this.retrieve(id);
    while (!file.status || !TERMINAL_STATES.has(file.status)) {
      await sleep(pollInterval);
      file = await this.retrieve(id);
      if (Date.now() - start > maxWait) {
        throw new APIConnectionTimeoutError({
          message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`
        });
      }
    }
    return file;
  }
};

// node_modules/openai/resources/fine-tuning/methods.mjs
var Methods = class extends APIResource {
};

// node_modules/openai/resources/fine-tuning/alpha/graders.mjs
var Graders = class extends APIResource {
  /**
   * Run a grader.
   *
   * @example
   * ```ts
   * const response = await client.fineTuning.alpha.graders.run({
   *   grader: {
   *     input: 'input',
   *     name: 'name',
   *     operation: 'eq',
   *     reference: 'reference',
   *     type: 'string_check',
   *   },
   *   model_sample: 'model_sample',
   * });
   * ```
   */
  run(body, options) {
    return this._client.post("/fine_tuning/alpha/graders/run", { body, ...options });
  }
  /**
   * Validate a grader.
   *
   * @example
   * ```ts
   * const response =
   *   await client.fineTuning.alpha.graders.validate({
   *     grader: {
   *       input: 'input',
   *       name: 'name',
   *       operation: 'eq',
   *       reference: 'reference',
   *       type: 'string_check',
   *     },
   *   });
   * ```
   */
  validate(body, options) {
    return this._client.post("/fine_tuning/alpha/graders/validate", { body, ...options });
  }
};

// node_modules/openai/resources/fine-tuning/alpha/alpha.mjs
var Alpha = class extends APIResource {
  constructor() {
    super(...arguments);
    this.graders = new Graders(this._client);
  }
};
Alpha.Graders = Graders;

// node_modules/openai/resources/fine-tuning/checkpoints/permissions.mjs
var Permissions = class extends APIResource {
  /**
   * **NOTE:** Calling this endpoint requires an [admin API key](../admin-api-keys).
   *
   * This enables organization owners to share fine-tuned models with other projects
   * in their organization.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const permissionCreateResponse of client.fineTuning.checkpoints.permissions.create(
   *   'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',
   *   { project_ids: ['string'] },
   * )) {
   *   // ...
   * }
   * ```
   */
  create(fineTunedModelCheckpoint, body, options) {
    return this._client.getAPIList(path`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`, Page, { body, method: "post", ...options });
  }
  /**
   * **NOTE:** This endpoint requires an [admin API key](../admin-api-keys).
   *
   * Organization owners can use this endpoint to view all permissions for a
   * fine-tuned model checkpoint.
   *
   * @example
   * ```ts
   * const permission =
   *   await client.fineTuning.checkpoints.permissions.retrieve(
   *     'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   *   );
   * ```
   */
  retrieve(fineTunedModelCheckpoint, query = {}, options) {
    return this._client.get(path`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`, {
      query,
      ...options
    });
  }
  /**
   * **NOTE:** This endpoint requires an [admin API key](../admin-api-keys).
   *
   * Organization owners can use this endpoint to delete a permission for a
   * fine-tuned model checkpoint.
   *
   * @example
   * ```ts
   * const permission =
   *   await client.fineTuning.checkpoints.permissions.delete(
   *     'cp_zc4Q7MP6XxulcVzj4MZdwsAB',
   *     {
   *       fine_tuned_model_checkpoint:
   *         'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',
   *     },
   *   );
   * ```
   */
  delete(permissionID, params, options) {
    const { fine_tuned_model_checkpoint } = params;
    return this._client.delete(path`/fine_tuning/checkpoints/${fine_tuned_model_checkpoint}/permissions/${permissionID}`, options);
  }
};

// node_modules/openai/resources/fine-tuning/checkpoints/checkpoints.mjs
var Checkpoints = class extends APIResource {
  constructor() {
    super(...arguments);
    this.permissions = new Permissions(this._client);
  }
};
Checkpoints.Permissions = Permissions;

// node_modules/openai/resources/fine-tuning/jobs/checkpoints.mjs
var Checkpoints2 = class extends APIResource {
  /**
   * List checkpoints for a fine-tuning job.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const fineTuningJobCheckpoint of client.fineTuning.jobs.checkpoints.list(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * )) {
   *   // ...
   * }
   * ```
   */
  list(fineTuningJobID, query = {}, options) {
    return this._client.getAPIList(path`/fine_tuning/jobs/${fineTuningJobID}/checkpoints`, CursorPage, { query, ...options });
  }
};

// node_modules/openai/resources/fine-tuning/jobs/jobs.mjs
var Jobs = class extends APIResource {
  constructor() {
    super(...arguments);
    this.checkpoints = new Checkpoints2(this._client);
  }
  /**
   * Creates a fine-tuning job which begins the process of creating a new model from
   * a given dataset.
   *
   * Response includes details of the enqueued job including job status and the name
   * of the fine-tuned models once complete.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/model-optimization)
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.create({
   *   model: 'gpt-4o-mini',
   *   training_file: 'file-abc123',
   * });
   * ```
   */
  create(body, options) {
    return this._client.post("/fine_tuning/jobs", { body, ...options });
  }
  /**
   * Get info about a fine-tuning job.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/model-optimization)
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.retrieve(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  retrieve(fineTuningJobID, options) {
    return this._client.get(path`/fine_tuning/jobs/${fineTuningJobID}`, options);
  }
  /**
   * List your organization's fine-tuning jobs
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const fineTuningJob of client.fineTuning.jobs.list()) {
   *   // ...
   * }
   * ```
   */
  list(query = {}, options) {
    return this._client.getAPIList("/fine_tuning/jobs", CursorPage, { query, ...options });
  }
  /**
   * Immediately cancel a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.cancel(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  cancel(fineTuningJobID, options) {
    return this._client.post(path`/fine_tuning/jobs/${fineTuningJobID}/cancel`, options);
  }
  /**
   * Get status updates for a fine-tuning job.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const fineTuningJobEvent of client.fineTuning.jobs.listEvents(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * )) {
   *   // ...
   * }
   * ```
   */
  listEvents(fineTuningJobID, query = {}, options) {
    return this._client.getAPIList(path`/fine_tuning/jobs/${fineTuningJobID}/events`, CursorPage, { query, ...options });
  }
  /**
   * Pause a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.pause(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  pause(fineTuningJobID, options) {
    return this._client.post(path`/fine_tuning/jobs/${fineTuningJobID}/pause`, options);
  }
  /**
   * Resume a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.resume(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  resume(fineTuningJobID, options) {
    return this._client.post(path`/fine_tuning/jobs/${fineTuningJobID}/resume`, options);
  }
};
Jobs.Checkpoints = Checkpoints2;

// node_modules/openai/resources/fine-tuning/fine-tuning.mjs
var FineTuning = class extends APIResource {
  constructor() {
    super(...arguments);
    this.methods = new Methods(this._client);
    this.jobs = new Jobs(this._client);
    this.checkpoints = new Checkpoints(this._client);
    this.alpha = new Alpha(this._client);
  }
};
FineTuning.Methods = Methods;
FineTuning.Jobs = Jobs;
FineTuning.Checkpoints = Checkpoints;
FineTuning.Alpha = Alpha;

// node_modules/openai/resources/graders/grader-models.mjs
var GraderModels = class extends APIResource {
};

// node_modules/openai/resources/graders/graders.mjs
var Graders2 = class extends APIResource {
  constructor() {
    super(...arguments);
    this.graderModels = new GraderModels(this._client);
  }
};
Graders2.GraderModels = GraderModels;

// node_modules/openai/resources/images.mjs
var Images = class extends APIResource {
  /**
   * Creates a variation of a given image. This endpoint only supports `dall-e-2`.
   *
   * @example
   * ```ts
   * const imagesResponse = await client.images.createVariation({
   *   image: fs.createReadStream('otter.png'),
   * });
   * ```
   */
  createVariation(body, options) {
    return this._client.post("/images/variations", multipartFormRequestOptions({ body, ...options }, this._client));
  }
  edit(body, options) {
    var _a5;
    return this._client.post("/images/edits", multipartFormRequestOptions({ body, ...options, stream: (_a5 = body.stream) != null ? _a5 : false }, this._client));
  }
  generate(body, options) {
    var _a5;
    return this._client.post("/images/generations", { body, ...options, stream: (_a5 = body.stream) != null ? _a5 : false });
  }
};

// node_modules/openai/resources/models.mjs
var Models = class extends APIResource {
  /**
   * Retrieves a model instance, providing basic information about the model such as
   * the owner and permissioning.
   */
  retrieve(model, options) {
    return this._client.get(path`/models/${model}`, options);
  }
  /**
   * Lists the currently available models, and provides basic information about each
   * one such as the owner and availability.
   */
  list(options) {
    return this._client.getAPIList("/models", Page, options);
  }
  /**
   * Delete a fine-tuned model. You must have the Owner role in your organization to
   * delete a model.
   */
  delete(model, options) {
    return this._client.delete(path`/models/${model}`, options);
  }
};

// node_modules/openai/resources/moderations.mjs
var Moderations = class extends APIResource {
  /**
   * Classifies if text and/or image inputs are potentially harmful. Learn more in
   * the [moderation guide](https://platform.openai.com/docs/guides/moderation).
   */
  create(body, options) {
    return this._client.post("/moderations", { body, ...options });
  }
};

// node_modules/openai/resources/realtime/calls.mjs
var Calls = class extends APIResource {
  /**
   * Accept an incoming SIP call and configure the realtime session that will handle
   * it.
   *
   * @example
   * ```ts
   * await client.realtime.calls.accept('call_id', {
   *   type: 'realtime',
   * });
   * ```
   */
  accept(callID, body, options) {
    return this._client.post(path`/realtime/calls/${callID}/accept`, {
      body,
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * End an active Realtime API call, whether it was initiated over SIP or WebRTC.
   *
   * @example
   * ```ts
   * await client.realtime.calls.hangup('call_id');
   * ```
   */
  hangup(callID, options) {
    return this._client.post(path`/realtime/calls/${callID}/hangup`, {
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * Transfer an active SIP call to a new destination using the SIP REFER verb.
   *
   * @example
   * ```ts
   * await client.realtime.calls.refer('call_id', {
   *   target_uri: 'tel:+14155550123',
   * });
   * ```
   */
  refer(callID, body, options) {
    return this._client.post(path`/realtime/calls/${callID}/refer`, {
      body,
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * Decline an incoming SIP call by returning a SIP status code to the caller.
   *
   * @example
   * ```ts
   * await client.realtime.calls.reject('call_id');
   * ```
   */
  reject(callID, body = {}, options) {
    return this._client.post(path`/realtime/calls/${callID}/reject`, {
      body,
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options == null ? void 0 : options.headers])
    });
  }
};

// node_modules/openai/resources/realtime/client-secrets.mjs
var ClientSecrets = class extends APIResource {
  /**
   * Create a Realtime client secret with an associated session configuration.
   *
   * @example
   * ```ts
   * const clientSecret =
   *   await client.realtime.clientSecrets.create();
   * ```
   */
  create(body, options) {
    return this._client.post("/realtime/client_secrets", { body, ...options });
  }
};

// node_modules/openai/resources/realtime/realtime.mjs
var Realtime2 = class extends APIResource {
  constructor() {
    super(...arguments);
    this.clientSecrets = new ClientSecrets(this._client);
    this.calls = new Calls(this._client);
  }
};
Realtime2.ClientSecrets = ClientSecrets;
Realtime2.Calls = Calls;

// node_modules/openai/lib/ResponsesParser.mjs
function maybeParseResponse(response, params) {
  if (!params || !hasAutoParseableInput2(params)) {
    return {
      ...response,
      output_parsed: null,
      output: response.output.map((item) => {
        if (item.type === "function_call") {
          return {
            ...item,
            parsed_arguments: null
          };
        }
        if (item.type === "message") {
          return {
            ...item,
            content: item.content.map((content) => ({
              ...content,
              parsed: null
            }))
          };
        } else {
          return item;
        }
      })
    };
  }
  return parseResponse(response, params);
}
function parseResponse(response, params) {
  const output = response.output.map((item) => {
    if (item.type === "function_call") {
      return {
        ...item,
        parsed_arguments: parseToolCall2(params, item)
      };
    }
    if (item.type === "message") {
      const content = item.content.map((content2) => {
        if (content2.type === "output_text") {
          return {
            ...content2,
            parsed: parseTextFormat(params, content2.text)
          };
        }
        return content2;
      });
      return {
        ...item,
        content
      };
    }
    return item;
  });
  const parsed = Object.assign({}, response, { output });
  if (!Object.getOwnPropertyDescriptor(response, "output_text")) {
    addOutputText(parsed);
  }
  Object.defineProperty(parsed, "output_parsed", {
    enumerable: true,
    get() {
      for (const output2 of parsed.output) {
        if (output2.type !== "message") {
          continue;
        }
        for (const content of output2.content) {
          if (content.type === "output_text" && content.parsed !== null) {
            return content.parsed;
          }
        }
      }
      return null;
    }
  });
  return parsed;
}
function parseTextFormat(params, content) {
  var _a5, _b, _c, _d;
  if (((_b = (_a5 = params.text) == null ? void 0 : _a5.format) == null ? void 0 : _b.type) !== "json_schema") {
    return null;
  }
  if ("$parseRaw" in ((_c = params.text) == null ? void 0 : _c.format)) {
    const text_format = (_d = params.text) == null ? void 0 : _d.format;
    return text_format.$parseRaw(content);
  }
  return JSON.parse(content);
}
function hasAutoParseableInput2(params) {
  var _a5;
  if (isAutoParsableResponseFormat((_a5 = params.text) == null ? void 0 : _a5.format)) {
    return true;
  }
  return false;
}
function isAutoParsableTool2(tool) {
  return (tool == null ? void 0 : tool["$brand"]) === "auto-parseable-tool";
}
function getInputToolByName(input_tools, name) {
  return input_tools.find((tool) => tool.type === "function" && tool.name === name);
}
function parseToolCall2(params, toolCall) {
  var _a5;
  const inputTool = getInputToolByName((_a5 = params.tools) != null ? _a5 : [], toolCall.name);
  return {
    ...toolCall,
    ...toolCall,
    parsed_arguments: isAutoParsableTool2(inputTool) ? inputTool.$parseRaw(toolCall.arguments) : (inputTool == null ? void 0 : inputTool.strict) ? JSON.parse(toolCall.arguments) : null
  };
}
function addOutputText(rsp) {
  const texts = [];
  for (const output of rsp.output) {
    if (output.type !== "message") {
      continue;
    }
    for (const content of output.content) {
      if (content.type === "output_text") {
        texts.push(content.text);
      }
    }
  }
  rsp.output_text = texts.join("");
}

// node_modules/openai/lib/responses/ResponseStream.mjs
var _ResponseStream_instances;
var _ResponseStream_params;
var _ResponseStream_currentResponseSnapshot;
var _ResponseStream_finalResponse;
var _ResponseStream_beginRequest;
var _ResponseStream_addEvent;
var _ResponseStream_endRequest;
var _ResponseStream_accumulateResponse;
var ResponseStream = class _ResponseStream extends EventStream {
  constructor(params) {
    super();
    _ResponseStream_instances.add(this);
    _ResponseStream_params.set(this, void 0);
    _ResponseStream_currentResponseSnapshot.set(this, void 0);
    _ResponseStream_finalResponse.set(this, void 0);
    __classPrivateFieldSet(this, _ResponseStream_params, params, "f");
  }
  static createResponse(client, params, options) {
    const runner = new _ResponseStream(params);
    runner._run(() => runner._createOrRetrieveResponse(client, params, {
      ...options,
      headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  async _createOrRetrieveResponse(client, params, options) {
    var _a5, _b;
    const signal = options == null ? void 0 : options.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_beginRequest).call(this);
    let stream;
    let starting_after = null;
    if ("response_id" in params) {
      stream = await client.responses.retrieve(params.response_id, { stream: true }, { ...options, signal: this.controller.signal, stream: true });
      starting_after = (_a5 = params.starting_after) != null ? _a5 : null;
    } else {
      stream = await client.responses.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });
    }
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_addEvent).call(this, event, starting_after);
    }
    if ((_b = stream.controller.signal) == null ? void 0 : _b.aborted) {
      throw new APIUserAbortError();
    }
    return __classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_endRequest).call(this);
  }
  [(_ResponseStream_params = /* @__PURE__ */ new WeakMap(), _ResponseStream_currentResponseSnapshot = /* @__PURE__ */ new WeakMap(), _ResponseStream_finalResponse = /* @__PURE__ */ new WeakMap(), _ResponseStream_instances = /* @__PURE__ */ new WeakSet(), _ResponseStream_beginRequest = function _ResponseStream_beginRequest2() {
    if (this.ended)
      return;
    __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, void 0, "f");
  }, _ResponseStream_addEvent = function _ResponseStream_addEvent2(event, starting_after) {
    if (this.ended)
      return;
    const maybeEmit = (name, event2) => {
      if (starting_after == null || event2.sequence_number > starting_after) {
        this._emit(name, event2);
      }
    };
    const response = __classPrivateFieldGet(this, _ResponseStream_instances, "m", _ResponseStream_accumulateResponse).call(this, event);
    maybeEmit("event", event);
    switch (event.type) {
      case "response.output_text.delta": {
        const output = response.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "message") {
          const content = output.content[event.content_index];
          if (!content) {
            throw new OpenAIError(`missing content at index ${event.content_index}`);
          }
          if (content.type !== "output_text") {
            throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);
          }
          maybeEmit("response.output_text.delta", {
            ...event,
            snapshot: content.text
          });
        }
        break;
      }
      case "response.function_call_arguments.delta": {
        const output = response.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "function_call") {
          maybeEmit("response.function_call_arguments.delta", {
            ...event,
            snapshot: output.arguments
          });
        }
        break;
      }
      default:
        maybeEmit(event.type, event);
        break;
    }
  }, _ResponseStream_endRequest = function _ResponseStream_endRequest2() {
    if (this.ended) {
      throw new OpenAIError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet(this, _ResponseStream_currentResponseSnapshot, "f");
    if (!snapshot) {
      throw new OpenAIError(`request ended without sending any events`);
    }
    __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, void 0, "f");
    const parsedResponse = finalizeResponse(snapshot, __classPrivateFieldGet(this, _ResponseStream_params, "f"));
    __classPrivateFieldSet(this, _ResponseStream_finalResponse, parsedResponse, "f");
    return parsedResponse;
  }, _ResponseStream_accumulateResponse = function _ResponseStream_accumulateResponse2(event) {
    var _a5;
    let snapshot = __classPrivateFieldGet(this, _ResponseStream_currentResponseSnapshot, "f");
    if (!snapshot) {
      if (event.type !== "response.created") {
        throw new OpenAIError(`When snapshot hasn't been set yet, expected 'response.created' event, got ${event.type}`);
      }
      snapshot = __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, event.response, "f");
      return snapshot;
    }
    switch (event.type) {
      case "response.output_item.added": {
        snapshot.output.push(event.item);
        break;
      }
      case "response.content_part.added": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        const type = output.type;
        const part = event.part;
        if (type === "message" && part.type !== "reasoning_text") {
          output.content.push(part);
        } else if (type === "reasoning" && part.type === "reasoning_text") {
          if (!output.content) {
            output.content = [];
          }
          output.content.push(part);
        }
        break;
      }
      case "response.output_text.delta": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "message") {
          const content = output.content[event.content_index];
          if (!content) {
            throw new OpenAIError(`missing content at index ${event.content_index}`);
          }
          if (content.type !== "output_text") {
            throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);
          }
          content.text += event.delta;
        }
        break;
      }
      case "response.function_call_arguments.delta": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "function_call") {
          output.arguments += event.delta;
        }
        break;
      }
      case "response.reasoning_text.delta": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "reasoning") {
          const content = (_a5 = output.content) == null ? void 0 : _a5[event.content_index];
          if (!content) {
            throw new OpenAIError(`missing content at index ${event.content_index}`);
          }
          if (content.type !== "reasoning_text") {
            throw new OpenAIError(`expected content to be 'reasoning_text', got ${content.type}`);
          }
          content.text += event.delta;
        }
        break;
      }
      case "response.completed": {
        __classPrivateFieldSet(this, _ResponseStream_currentResponseSnapshot, event.response, "f");
        break;
      }
    }
    return snapshot;
  }, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("event", (event) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(event);
      } else {
        pushQueue.push(event);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((event2) => event2 ? { value: event2, done: false } : { value: void 0, done: true });
        }
        const event = pushQueue.shift();
        return { value: event, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  /**
   * @returns a promise that resolves with the final Response, or rejects
   * if an error occurred or the stream ended prematurely without producing a REsponse.
   */
  async finalResponse() {
    await this.done();
    const response = __classPrivateFieldGet(this, _ResponseStream_finalResponse, "f");
    if (!response)
      throw new OpenAIError("stream ended without producing a ChatCompletion");
    return response;
  }
};
function finalizeResponse(snapshot, params) {
  return maybeParseResponse(snapshot, params);
}

// node_modules/openai/resources/responses/input-items.mjs
var InputItems = class extends APIResource {
  /**
   * Returns a list of input items for a given response.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const responseItem of client.responses.inputItems.list(
   *   'response_id',
   * )) {
   *   // ...
   * }
   * ```
   */
  list(responseID, query = {}, options) {
    return this._client.getAPIList(path`/responses/${responseID}/input_items`, CursorPage, { query, ...options });
  }
};

// node_modules/openai/resources/responses/input-tokens.mjs
var InputTokens = class extends APIResource {
  /**
   * Get input token counts
   *
   * @example
   * ```ts
   * const response = await client.responses.inputTokens.count();
   * ```
   */
  count(body = {}, options) {
    return this._client.post("/responses/input_tokens", { body, ...options });
  }
};

// node_modules/openai/resources/responses/responses.mjs
var Responses = class extends APIResource {
  constructor() {
    super(...arguments);
    this.inputItems = new InputItems(this._client);
    this.inputTokens = new InputTokens(this._client);
  }
  create(body, options) {
    var _a5;
    return this._client.post("/responses", { body, ...options, stream: (_a5 = body.stream) != null ? _a5 : false })._thenUnwrap((rsp) => {
      if ("object" in rsp && rsp.object === "response") {
        addOutputText(rsp);
      }
      return rsp;
    });
  }
  retrieve(responseID, query = {}, options) {
    var _a5;
    return this._client.get(path`/responses/${responseID}`, {
      query,
      ...options,
      stream: (_a5 = query == null ? void 0 : query.stream) != null ? _a5 : false
    })._thenUnwrap((rsp) => {
      if ("object" in rsp && rsp.object === "response") {
        addOutputText(rsp);
      }
      return rsp;
    });
  }
  /**
   * Deletes a model response with the given ID.
   *
   * @example
   * ```ts
   * await client.responses.delete(
   *   'resp_677efb5139a88190b512bc3fef8e535d',
   * );
   * ```
   */
  delete(responseID, options) {
    return this._client.delete(path`/responses/${responseID}`, {
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options == null ? void 0 : options.headers])
    });
  }
  parse(body, options) {
    return this._client.responses.create(body, options)._thenUnwrap((response) => parseResponse(response, body));
  }
  /**
   * Creates a model response stream
   */
  stream(body, options) {
    return ResponseStream.createResponse(this._client, body, options);
  }
  /**
   * Cancels a model response with the given ID. Only responses created with the
   * `background` parameter set to `true` can be cancelled.
   * [Learn more](https://platform.openai.com/docs/guides/background).
   *
   * @example
   * ```ts
   * const response = await client.responses.cancel(
   *   'resp_677efb5139a88190b512bc3fef8e535d',
   * );
   * ```
   */
  cancel(responseID, options) {
    return this._client.post(path`/responses/${responseID}/cancel`, options);
  }
  /**
   * Compact conversation
   *
   * @example
   * ```ts
   * const compactedResponse = await client.responses.compact({
   *   model: 'gpt-5.2',
   * });
   * ```
   */
  compact(body, options) {
    return this._client.post("/responses/compact", { body, ...options });
  }
};
Responses.InputItems = InputItems;
Responses.InputTokens = InputTokens;

// node_modules/openai/resources/uploads/parts.mjs
var Parts = class extends APIResource {
  /**
   * Adds a
   * [Part](https://platform.openai.com/docs/api-reference/uploads/part-object) to an
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object.
   * A Part represents a chunk of bytes from the file you are trying to upload.
   *
   * Each Part can be at most 64 MB, and you can add Parts until you hit the Upload
   * maximum of 8 GB.
   *
   * It is possible to add multiple Parts in parallel. You can decide the intended
   * order of the Parts when you
   * [complete the Upload](https://platform.openai.com/docs/api-reference/uploads/complete).
   */
  create(uploadID, body, options) {
    return this._client.post(path`/uploads/${uploadID}/parts`, multipartFormRequestOptions({ body, ...options }, this._client));
  }
};

// node_modules/openai/resources/uploads/uploads.mjs
var Uploads = class extends APIResource {
  constructor() {
    super(...arguments);
    this.parts = new Parts(this._client);
  }
  /**
   * Creates an intermediate
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object
   * that you can add
   * [Parts](https://platform.openai.com/docs/api-reference/uploads/part-object) to.
   * Currently, an Upload can accept at most 8 GB in total and expires after an hour
   * after you create it.
   *
   * Once you complete the Upload, we will create a
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * contains all the parts you uploaded. This File is usable in the rest of our
   * platform as a regular File object.
   *
   * For certain `purpose` values, the correct `mime_type` must be specified. Please
   * refer to documentation for the
   * [supported MIME types for your use case](https://platform.openai.com/docs/assistants/tools/file-search#supported-files).
   *
   * For guidance on the proper filename extensions for each purpose, please follow
   * the documentation on
   * [creating a File](https://platform.openai.com/docs/api-reference/files/create).
   */
  create(body, options) {
    return this._client.post("/uploads", { body, ...options });
  }
  /**
   * Cancels the Upload. No Parts may be added after an Upload is cancelled.
   */
  cancel(uploadID, options) {
    return this._client.post(path`/uploads/${uploadID}/cancel`, options);
  }
  /**
   * Completes the
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object).
   *
   * Within the returned Upload object, there is a nested
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * is ready to use in the rest of the platform.
   *
   * You can specify the order of the Parts by passing in an ordered list of the Part
   * IDs.
   *
   * The number of bytes uploaded upon completion must match the number of bytes
   * initially specified when creating the Upload object. No Parts may be added after
   * an Upload is completed.
   */
  complete(uploadID, body, options) {
    return this._client.post(path`/uploads/${uploadID}/complete`, { body, ...options });
  }
};
Uploads.Parts = Parts;

// node_modules/openai/lib/Util.mjs
var allSettledWithThrow = async (promises) => {
  const results = await Promise.allSettled(promises);
  const rejected = results.filter((result) => result.status === "rejected");
  if (rejected.length) {
    for (const result of rejected) {
      console.error(result.reason);
    }
    throw new Error(`${rejected.length} promise(s) failed - see the above errors`);
  }
  const values = [];
  for (const result of results) {
    if (result.status === "fulfilled") {
      values.push(result.value);
    }
  }
  return values;
};

// node_modules/openai/resources/vector-stores/file-batches.mjs
var FileBatches = class extends APIResource {
  /**
   * Create a vector store file batch.
   */
  create(vectorStoreID, body, options) {
    return this._client.post(path`/vector_stores/${vectorStoreID}/file_batches`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * Retrieves a vector store file batch.
   */
  retrieve(batchID, params, options) {
    const { vector_store_id } = params;
    return this._client.get(path`/vector_stores/${vector_store_id}/file_batches/${batchID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * Cancel a vector store file batch. This attempts to cancel the processing of
   * files in this batch as soon as possible.
   */
  cancel(batchID, params, options) {
    const { vector_store_id } = params;
    return this._client.post(path`/vector_stores/${vector_store_id}/file_batches/${batchID}/cancel`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * Create a vector store batch and poll until all files have been processed.
   */
  async createAndPoll(vectorStoreId, body, options) {
    const batch = await this.create(vectorStoreId, body);
    return await this.poll(vectorStoreId, batch.id, options);
  }
  /**
   * Returns a list of vector store files in a batch.
   */
  listFiles(batchID, params, options) {
    const { vector_store_id, ...query } = params;
    return this._client.getAPIList(path`/vector_stores/${vector_store_id}/file_batches/${batchID}/files`, CursorPage, { query, ...options, headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers]) });
  }
  /**
   * Wait for the given file batch to be processed.
   *
   * Note: this will return even if one of the files failed to process, you need to
   * check batch.file_counts.failed_count to handle this case.
   */
  async poll(vectorStoreID, batchID, options) {
    var _a5, _b;
    const headers = buildHeaders([
      options == null ? void 0 : options.headers,
      {
        "X-Stainless-Poll-Helper": "true",
        "X-Stainless-Custom-Poll-Interval": (_b = (_a5 = options == null ? void 0 : options.pollIntervalMs) == null ? void 0 : _a5.toString()) != null ? _b : void 0
      }
    ]);
    while (true) {
      const { data: batch, response } = await this.retrieve(batchID, { vector_store_id: vectorStoreID }, {
        ...options,
        headers
      }).withResponse();
      switch (batch.status) {
        case "in_progress":
          let sleepInterval = 5e3;
          if (options == null ? void 0 : options.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep(sleepInterval);
          break;
        case "failed":
        case "cancelled":
        case "completed":
          return batch;
      }
    }
  }
  /**
   * Uploads the given files concurrently and then creates a vector store file batch.
   *
   * The concurrency limit is configurable using the `maxConcurrency` parameter.
   */
  async uploadAndPoll(vectorStoreId, { files, fileIds = [] }, options) {
    var _a5;
    if (files == null || files.length == 0) {
      throw new Error(`No \`files\` provided to process. If you've already uploaded files you should use \`.createAndPoll()\` instead`);
    }
    const configuredConcurrency = (_a5 = options == null ? void 0 : options.maxConcurrency) != null ? _a5 : 5;
    const concurrencyLimit = Math.min(configuredConcurrency, files.length);
    const client = this._client;
    const fileIterator = files.values();
    const allFileIds = [...fileIds];
    async function processFiles(iterator) {
      for (let item of iterator) {
        const fileObj = await client.files.create({ file: item, purpose: "assistants" }, options);
        allFileIds.push(fileObj.id);
      }
    }
    const workers = Array(concurrencyLimit).fill(fileIterator).map(processFiles);
    await allSettledWithThrow(workers);
    return await this.createAndPoll(vectorStoreId, {
      file_ids: allFileIds
    });
  }
};

// node_modules/openai/resources/vector-stores/files.mjs
var Files3 = class extends APIResource {
  /**
   * Create a vector store file by attaching a
   * [File](https://platform.openai.com/docs/api-reference/files) to a
   * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).
   */
  create(vectorStoreID, body, options) {
    return this._client.post(path`/vector_stores/${vectorStoreID}/files`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * Retrieves a vector store file.
   */
  retrieve(fileID, params, options) {
    const { vector_store_id } = params;
    return this._client.get(path`/vector_stores/${vector_store_id}/files/${fileID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * Update attributes on a vector store file.
   */
  update(fileID, params, options) {
    const { vector_store_id, ...body } = params;
    return this._client.post(path`/vector_stores/${vector_store_id}/files/${fileID}`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * Returns a list of vector store files.
   */
  list(vectorStoreID, query = {}, options) {
    return this._client.getAPIList(path`/vector_stores/${vectorStoreID}/files`, CursorPage, {
      query,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * Delete a vector store file. This will remove the file from the vector store but
   * the file itself will not be deleted. To delete the file, use the
   * [delete file](https://platform.openai.com/docs/api-reference/files/delete)
   * endpoint.
   */
  delete(fileID, params, options) {
    const { vector_store_id } = params;
    return this._client.delete(path`/vector_stores/${vector_store_id}/files/${fileID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * Attach a file to the given vector store and wait for it to be processed.
   */
  async createAndPoll(vectorStoreId, body, options) {
    const file = await this.create(vectorStoreId, body, options);
    return await this.poll(vectorStoreId, file.id, options);
  }
  /**
   * Wait for the vector store file to finish processing.
   *
   * Note: this will return even if the file failed to process, you need to check
   * file.last_error and file.status to handle these cases
   */
  async poll(vectorStoreID, fileID, options) {
    var _a5, _b;
    const headers = buildHeaders([
      options == null ? void 0 : options.headers,
      {
        "X-Stainless-Poll-Helper": "true",
        "X-Stainless-Custom-Poll-Interval": (_b = (_a5 = options == null ? void 0 : options.pollIntervalMs) == null ? void 0 : _a5.toString()) != null ? _b : void 0
      }
    ]);
    while (true) {
      const fileResponse = await this.retrieve(fileID, {
        vector_store_id: vectorStoreID
      }, { ...options, headers }).withResponse();
      const file = fileResponse.data;
      switch (file.status) {
        case "in_progress":
          let sleepInterval = 5e3;
          if (options == null ? void 0 : options.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = fileResponse.response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep(sleepInterval);
          break;
        case "failed":
        case "completed":
          return file;
      }
    }
  }
  /**
   * Upload a file to the `files` API and then attach it to the given vector store.
   *
   * Note the file will be asynchronously processed (you can use the alternative
   * polling helper method to wait for processing to complete).
   */
  async upload(vectorStoreId, file, options) {
    const fileInfo = await this._client.files.create({ file, purpose: "assistants" }, options);
    return this.create(vectorStoreId, { file_id: fileInfo.id }, options);
  }
  /**
   * Add a file to a vector store and poll until processing is complete.
   */
  async uploadAndPoll(vectorStoreId, file, options) {
    const fileInfo = await this.upload(vectorStoreId, file, options);
    return await this.poll(vectorStoreId, fileInfo.id, options);
  }
  /**
   * Retrieve the parsed contents of a vector store file.
   */
  content(fileID, params, options) {
    const { vector_store_id } = params;
    return this._client.getAPIList(path`/vector_stores/${vector_store_id}/files/${fileID}/content`, Page, { ...options, headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers]) });
  }
};

// node_modules/openai/resources/vector-stores/vector-stores.mjs
var VectorStores = class extends APIResource {
  constructor() {
    super(...arguments);
    this.files = new Files3(this._client);
    this.fileBatches = new FileBatches(this._client);
  }
  /**
   * Create a vector store.
   */
  create(body, options) {
    return this._client.post("/vector_stores", {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * Retrieves a vector store.
   */
  retrieve(vectorStoreID, options) {
    return this._client.get(path`/vector_stores/${vectorStoreID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * Modifies a vector store.
   */
  update(vectorStoreID, body, options) {
    return this._client.post(path`/vector_stores/${vectorStoreID}`, {
      body,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * Returns a list of vector stores.
   */
  list(query = {}, options) {
    return this._client.getAPIList("/vector_stores", CursorPage, {
      query,
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * Delete a vector store.
   */
  delete(vectorStoreID, options) {
    return this._client.delete(path`/vector_stores/${vectorStoreID}`, {
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * Search a vector store for relevant chunks based on a query and file attributes
   * filter.
   */
  search(vectorStoreID, body, options) {
    return this._client.getAPIList(path`/vector_stores/${vectorStoreID}/search`, Page, {
      body,
      method: "post",
      ...options,
      headers: buildHeaders([{ "OpenAI-Beta": "assistants=v2" }, options == null ? void 0 : options.headers])
    });
  }
};
VectorStores.Files = Files3;
VectorStores.FileBatches = FileBatches;

// node_modules/openai/resources/videos.mjs
var Videos = class extends APIResource {
  /**
   * Create a video
   */
  create(body, options) {
    return this._client.post("/videos", maybeMultipartFormRequestOptions({ body, ...options }, this._client));
  }
  /**
   * Retrieve a video
   */
  retrieve(videoID, options) {
    return this._client.get(path`/videos/${videoID}`, options);
  }
  /**
   * List videos
   */
  list(query = {}, options) {
    return this._client.getAPIList("/videos", ConversationCursorPage, { query, ...options });
  }
  /**
   * Delete a video
   */
  delete(videoID, options) {
    return this._client.delete(path`/videos/${videoID}`, options);
  }
  /**
   * Download video content
   */
  downloadContent(videoID, query = {}, options) {
    return this._client.get(path`/videos/${videoID}/content`, {
      query,
      ...options,
      headers: buildHeaders([{ Accept: "application/binary" }, options == null ? void 0 : options.headers]),
      __binaryResponse: true
    });
  }
  /**
   * Create a video remix
   */
  remix(videoID, body, options) {
    return this._client.post(path`/videos/${videoID}/remix`, maybeMultipartFormRequestOptions({ body, ...options }, this._client));
  }
};

// node_modules/openai/resources/webhooks.mjs
var _Webhooks_instances;
var _Webhooks_validateSecret;
var _Webhooks_getRequiredHeader;
var Webhooks = class extends APIResource {
  constructor() {
    super(...arguments);
    _Webhooks_instances.add(this);
  }
  /**
   * Validates that the given payload was sent by OpenAI and parses the payload.
   */
  async unwrap(payload, headers, secret = this._client.webhookSecret, tolerance = 300) {
    await this.verifySignature(payload, headers, secret, tolerance);
    return JSON.parse(payload);
  }
  /**
   * Validates whether or not the webhook payload was sent by OpenAI.
   *
   * An error will be raised if the webhook payload was not sent by OpenAI.
   *
   * @param payload - The webhook payload
   * @param headers - The webhook headers
   * @param secret - The webhook secret (optional, will use client secret if not provided)
   * @param tolerance - Maximum age of the webhook in seconds (default: 300 = 5 minutes)
   */
  async verifySignature(payload, headers, secret = this._client.webhookSecret, tolerance = 300) {
    if (typeof crypto === "undefined" || typeof crypto.subtle.importKey !== "function" || typeof crypto.subtle.verify !== "function") {
      throw new Error("Webhook signature verification is only supported when the `crypto` global is defined");
    }
    __classPrivateFieldGet(this, _Webhooks_instances, "m", _Webhooks_validateSecret).call(this, secret);
    const headersObj = buildHeaders([headers]).values;
    const signatureHeader = __classPrivateFieldGet(this, _Webhooks_instances, "m", _Webhooks_getRequiredHeader).call(this, headersObj, "webhook-signature");
    const timestamp = __classPrivateFieldGet(this, _Webhooks_instances, "m", _Webhooks_getRequiredHeader).call(this, headersObj, "webhook-timestamp");
    const webhookId = __classPrivateFieldGet(this, _Webhooks_instances, "m", _Webhooks_getRequiredHeader).call(this, headersObj, "webhook-id");
    const timestampSeconds = parseInt(timestamp, 10);
    if (isNaN(timestampSeconds)) {
      throw new InvalidWebhookSignatureError("Invalid webhook timestamp format");
    }
    const nowSeconds = Math.floor(Date.now() / 1e3);
    if (nowSeconds - timestampSeconds > tolerance) {
      throw new InvalidWebhookSignatureError("Webhook timestamp is too old");
    }
    if (timestampSeconds > nowSeconds + tolerance) {
      throw new InvalidWebhookSignatureError("Webhook timestamp is too new");
    }
    const signatures = signatureHeader.split(" ").map((part) => part.startsWith("v1,") ? part.substring(3) : part);
    const decodedSecret = secret.startsWith("whsec_") ? Buffer.from(secret.replace("whsec_", ""), "base64") : Buffer.from(secret, "utf-8");
    const signedPayload = webhookId ? `${webhookId}.${timestamp}.${payload}` : `${timestamp}.${payload}`;
    const key = await crypto.subtle.importKey("raw", decodedSecret, { name: "HMAC", hash: "SHA-256" }, false, ["verify"]);
    for (const signature of signatures) {
      try {
        const signatureBytes = Buffer.from(signature, "base64");
        const isValid = await crypto.subtle.verify("HMAC", key, signatureBytes, new TextEncoder().encode(signedPayload));
        if (isValid) {
          return;
        }
      } catch (e3) {
        continue;
      }
    }
    throw new InvalidWebhookSignatureError("The given webhook signature does not match the expected signature");
  }
};
_Webhooks_instances = /* @__PURE__ */ new WeakSet(), _Webhooks_validateSecret = function _Webhooks_validateSecret2(secret) {
  if (typeof secret !== "string" || secret.length === 0) {
    throw new Error(`The webhook secret must either be set using the env var, OPENAI_WEBHOOK_SECRET, on the client class, OpenAI({ webhookSecret: '123' }), or passed to this function`);
  }
}, _Webhooks_getRequiredHeader = function _Webhooks_getRequiredHeader2(headers, name) {
  if (!headers) {
    throw new Error(`Headers are required`);
  }
  const value = headers.get(name);
  if (value === null || value === void 0) {
    throw new Error(`Missing required header: ${name}`);
  }
  return value;
};

// node_modules/openai/client.mjs
var _OpenAI_instances;
var _a2;
var _OpenAI_encoder;
var _OpenAI_baseURLOverridden;
var OpenAI = class {
  /**
   * API Client for interfacing with the OpenAI API.
   *
   * @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]
   * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]
   * @param {string | null | undefined} [opts.project=process.env['OPENAI_PROJECT_ID'] ?? null]
   * @param {string | null | undefined} [opts.webhookSecret=process.env['OPENAI_WEBHOOK_SECRET'] ?? null]
   * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.
   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {MergedRequestInit} [opts.fetchOptions] - Additional `RequestInit` options to be passed to `fetch` calls.
   * @param {Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {HeadersLike} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Record<string, string | undefined>} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   */
  constructor({ baseURL = readEnv("OPENAI_BASE_URL"), apiKey = readEnv("OPENAI_API_KEY"), organization = ((_a5) => (_a5 = readEnv("OPENAI_ORG_ID")) != null ? _a5 : null)(), project = ((_b) => (_b = readEnv("OPENAI_PROJECT_ID")) != null ? _b : null)(), webhookSecret = ((_c) => (_c = readEnv("OPENAI_WEBHOOK_SECRET")) != null ? _c : null)(), ...opts } = {}) {
    var _a6, _b2, _c2, _d, _e, _f;
    _OpenAI_instances.add(this);
    _OpenAI_encoder.set(this, void 0);
    this.completions = new Completions2(this);
    this.chat = new Chat(this);
    this.embeddings = new Embeddings(this);
    this.files = new Files2(this);
    this.images = new Images(this);
    this.audio = new Audio(this);
    this.moderations = new Moderations(this);
    this.models = new Models(this);
    this.fineTuning = new FineTuning(this);
    this.graders = new Graders2(this);
    this.vectorStores = new VectorStores(this);
    this.webhooks = new Webhooks(this);
    this.beta = new Beta(this);
    this.batches = new Batches(this);
    this.uploads = new Uploads(this);
    this.responses = new Responses(this);
    this.realtime = new Realtime2(this);
    this.conversations = new Conversations(this);
    this.evals = new Evals(this);
    this.containers = new Containers(this);
    this.videos = new Videos(this);
    if (apiKey === void 0) {
      throw new OpenAIError("Missing credentials. Please pass an `apiKey`, or set the `OPENAI_API_KEY` environment variable.");
    }
    const options = {
      apiKey,
      organization,
      project,
      webhookSecret,
      ...opts,
      baseURL: baseURL || `https://api.openai.com/v1`
    };
    if (!options.dangerouslyAllowBrowser && isRunningInBrowser()) {
      throw new OpenAIError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n");
    }
    this.baseURL = options.baseURL;
    this.timeout = (_a6 = options.timeout) != null ? _a6 : _a2.DEFAULT_TIMEOUT;
    this.logger = (_b2 = options.logger) != null ? _b2 : console;
    const defaultLogLevel = "warn";
    this.logLevel = defaultLogLevel;
    this.logLevel = (_d = (_c2 = parseLogLevel(options.logLevel, "ClientOptions.logLevel", this)) != null ? _c2 : parseLogLevel(readEnv("OPENAI_LOG"), "process.env['OPENAI_LOG']", this)) != null ? _d : defaultLogLevel;
    this.fetchOptions = options.fetchOptions;
    this.maxRetries = (_e = options.maxRetries) != null ? _e : 2;
    this.fetch = (_f = options.fetch) != null ? _f : getDefaultFetch();
    __classPrivateFieldSet(this, _OpenAI_encoder, FallbackEncoder, "f");
    this._options = options;
    this.apiKey = typeof apiKey === "string" ? apiKey : "Missing Key";
    this.organization = organization;
    this.project = project;
    this.webhookSecret = webhookSecret;
  }
  /**
   * Create a new client instance re-using the same options given to the current client with optional overriding.
   */
  withOptions(options) {
    const client = new this.constructor({
      ...this._options,
      baseURL: this.baseURL,
      maxRetries: this.maxRetries,
      timeout: this.timeout,
      logger: this.logger,
      logLevel: this.logLevel,
      fetch: this.fetch,
      fetchOptions: this.fetchOptions,
      apiKey: this.apiKey,
      organization: this.organization,
      project: this.project,
      webhookSecret: this.webhookSecret,
      ...options
    });
    return client;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  validateHeaders({ values, nulls }) {
    return;
  }
  async authHeaders(opts) {
    return buildHeaders([{ Authorization: `Bearer ${this.apiKey}` }]);
  }
  stringifyQuery(query) {
    return stringify(query, { arrayFormat: "brackets" });
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION}`;
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid4()}`;
  }
  makeStatusError(status, error, message, headers) {
    return APIError.generate(status, error, message, headers);
  }
  async _callApiKey() {
    const apiKey = this._options.apiKey;
    if (typeof apiKey !== "function")
      return false;
    let token;
    try {
      token = await apiKey();
    } catch (err) {
      if (err instanceof OpenAIError)
        throw err;
      throw new OpenAIError(
        `Failed to get token from 'apiKey' function: ${err.message}`,
        // @ts-ignore
        { cause: err }
      );
    }
    if (typeof token !== "string" || !token) {
      throw new OpenAIError(`Expected 'apiKey' function argument to return a string but it returned ${token}`);
    }
    this.apiKey = token;
    return true;
  }
  buildURL(path4, query, defaultBaseURL) {
    const baseURL = !__classPrivateFieldGet(this, _OpenAI_instances, "m", _OpenAI_baseURLOverridden).call(this) && defaultBaseURL || this.baseURL;
    const url = isAbsoluteURL(path4) ? new URL(path4) : new URL(baseURL + (baseURL.endsWith("/") && path4.startsWith("/") ? path4.slice(1) : path4));
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (typeof query === "object" && query && !Array.isArray(query)) {
      url.search = this.stringifyQuery(query);
    }
    return url.toString();
  }
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  async prepareOptions(options) {
    await this._callApiKey();
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(request, { url, options }) {
  }
  get(path4, opts) {
    return this.methodRequest("get", path4, opts);
  }
  post(path4, opts) {
    return this.methodRequest("post", path4, opts);
  }
  patch(path4, opts) {
    return this.methodRequest("patch", path4, opts);
  }
  put(path4, opts) {
    return this.methodRequest("put", path4, opts);
  }
  delete(path4, opts) {
    return this.methodRequest("delete", path4, opts);
  }
  methodRequest(method, path4, opts) {
    return this.request(Promise.resolve(opts).then((opts2) => {
      return { method, path: path4, ...opts2 };
    }));
  }
  request(options, remainingRetries = null) {
    return new APIPromise(this, this.makeRequest(options, remainingRetries, void 0));
  }
  async makeRequest(optionsInput, retriesRemaining, retryOfRequestLogID) {
    var _a5, _b, _c;
    const options = await optionsInput;
    const maxRetries = (_a5 = options.maxRetries) != null ? _a5 : this.maxRetries;
    if (retriesRemaining == null) {
      retriesRemaining = maxRetries;
    }
    await this.prepareOptions(options);
    const { req, url, timeout } = await this.buildRequest(options, {
      retryCount: maxRetries - retriesRemaining
    });
    await this.prepareRequest(req, { url, options });
    const requestLogID = "log_" + (Math.random() * (1 << 24) | 0).toString(16).padStart(6, "0");
    const retryLogStr = retryOfRequestLogID === void 0 ? "" : `, retryOf: ${retryOfRequestLogID}`;
    const startTime = Date.now();
    loggerFor(this).debug(`[${requestLogID}] sending request`, formatRequestDetails({
      retryOfRequestLogID,
      method: options.method,
      url,
      options,
      headers: req.headers
    }));
    if ((_b = options.signal) == null ? void 0 : _b.aborted) {
      throw new APIUserAbortError();
    }
    const controller = new AbortController();
    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);
    const headersTime = Date.now();
    if (response instanceof globalThis.Error) {
      const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;
      if ((_c = options.signal) == null ? void 0 : _c.aborted) {
        throw new APIUserAbortError();
      }
      const isTimeout = isAbortError(response) || /timed? ?out/i.test(String(response) + ("cause" in response ? String(response.cause) : ""));
      if (retriesRemaining) {
        loggerFor(this).info(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} - ${retryMessage}`);
        loggerFor(this).debug(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} (${retryMessage})`, formatRequestDetails({
          retryOfRequestLogID,
          url,
          durationMs: headersTime - startTime,
          message: response.message
        }));
        return this.retryRequest(options, retriesRemaining, retryOfRequestLogID != null ? retryOfRequestLogID : requestLogID);
      }
      loggerFor(this).info(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} - error; no more retries left`);
      loggerFor(this).debug(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} (error; no more retries left)`, formatRequestDetails({
        retryOfRequestLogID,
        url,
        durationMs: headersTime - startTime,
        message: response.message
      }));
      if (isTimeout) {
        throw new APIConnectionTimeoutError();
      }
      throw new APIConnectionError({ cause: response });
    }
    const specialHeaders = [...response.headers.entries()].filter(([name]) => name === "x-request-id").map(([name, value]) => ", " + name + ": " + JSON.stringify(value)).join("");
    const responseInfo = `[${requestLogID}${retryLogStr}${specialHeaders}] ${req.method} ${url} ${response.ok ? "succeeded" : "failed"} with status ${response.status} in ${headersTime - startTime}ms`;
    if (!response.ok) {
      const shouldRetry = await this.shouldRetry(response);
      if (retriesRemaining && shouldRetry) {
        const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
        await CancelReadableStream(response.body);
        loggerFor(this).info(`${responseInfo} - ${retryMessage2}`);
        loggerFor(this).debug(`[${requestLogID}] response error (${retryMessage2})`, formatRequestDetails({
          retryOfRequestLogID,
          url: response.url,
          status: response.status,
          headers: response.headers,
          durationMs: headersTime - startTime
        }));
        return this.retryRequest(options, retriesRemaining, retryOfRequestLogID != null ? retryOfRequestLogID : requestLogID, response.headers);
      }
      const retryMessage = shouldRetry ? `error; no more retries left` : `error; not retryable`;
      loggerFor(this).info(`${responseInfo} - ${retryMessage}`);
      const errText = await response.text().catch((err2) => castToError(err2).message);
      const errJSON = safeJSON(errText);
      const errMessage = errJSON ? void 0 : errText;
      loggerFor(this).debug(`[${requestLogID}] response error (${retryMessage})`, formatRequestDetails({
        retryOfRequestLogID,
        url: response.url,
        status: response.status,
        headers: response.headers,
        message: errMessage,
        durationMs: Date.now() - startTime
      }));
      const err = this.makeStatusError(response.status, errJSON, errMessage, response.headers);
      throw err;
    }
    loggerFor(this).info(responseInfo);
    loggerFor(this).debug(`[${requestLogID}] response start`, formatRequestDetails({
      retryOfRequestLogID,
      url: response.url,
      status: response.status,
      headers: response.headers,
      durationMs: headersTime - startTime
    }));
    return { response, options, controller, requestLogID, retryOfRequestLogID, startTime };
  }
  getAPIList(path4, Page3, opts) {
    return this.requestAPIList(Page3, opts && "then" in opts ? opts.then((opts2) => ({ method: "get", path: path4, ...opts2 })) : { method: "get", path: path4, ...opts });
  }
  requestAPIList(Page3, options) {
    const request = this.makeRequest(options, null, void 0);
    return new PagePromise(this, request, Page3);
  }
  async fetchWithTimeout(url, init, ms, controller) {
    const { signal, method, ...options } = init || {};
    const abort = this._makeAbort(controller);
    if (signal)
      signal.addEventListener("abort", abort, { once: true });
    const timeout = setTimeout(abort, ms);
    const isReadableBody = globalThis.ReadableStream && options.body instanceof globalThis.ReadableStream || typeof options.body === "object" && options.body !== null && Symbol.asyncIterator in options.body;
    const fetchOptions = {
      signal: controller.signal,
      ...isReadableBody ? { duplex: "half" } : {},
      method: "GET",
      ...options
    };
    if (method) {
      fetchOptions.method = method.toUpperCase();
    }
    try {
      return await this.fetch.call(void 0, url, fetchOptions);
    } finally {
      clearTimeout(timeout);
    }
  }
  async shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true")
      return true;
    if (shouldRetryHeader === "false")
      return false;
    if (response.status === 408)
      return true;
    if (response.status === 409)
      return true;
    if (response.status === 429)
      return true;
    if (response.status >= 500)
      return true;
    return false;
  }
  async retryRequest(options, retriesRemaining, requestLogID, responseHeaders) {
    var _a5;
    let timeoutMillis;
    const retryAfterMillisHeader = responseHeaders == null ? void 0 : responseHeaders.get("retry-after-ms");
    if (retryAfterMillisHeader) {
      const timeoutMs = parseFloat(retryAfterMillisHeader);
      if (!Number.isNaN(timeoutMs)) {
        timeoutMillis = timeoutMs;
      }
    }
    const retryAfterHeader = responseHeaders == null ? void 0 : responseHeaders.get("retry-after");
    if (retryAfterHeader && !timeoutMillis) {
      const timeoutSeconds = parseFloat(retryAfterHeader);
      if (!Number.isNaN(timeoutSeconds)) {
        timeoutMillis = timeoutSeconds * 1e3;
      } else {
        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
      }
    }
    if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
      const maxRetries = (_a5 = options.maxRetries) != null ? _a5 : this.maxRetries;
      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
    }
    await sleep(timeoutMillis);
    return this.makeRequest(options, retriesRemaining - 1, requestLogID);
  }
  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 8;
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
    const jitter = 1 - Math.random() * 0.25;
    return sleepSeconds * jitter * 1e3;
  }
  async buildRequest(inputOptions, { retryCount = 0 } = {}) {
    var _a5, _b, _c;
    const options = { ...inputOptions };
    const { method, path: path4, query, defaultBaseURL } = options;
    const url = this.buildURL(path4, query, defaultBaseURL);
    if ("timeout" in options)
      validatePositiveInteger("timeout", options.timeout);
    options.timeout = (_a5 = options.timeout) != null ? _a5 : this.timeout;
    const { bodyHeaders, body } = this.buildBody({ options });
    const reqHeaders = await this.buildHeaders({ options: inputOptions, method, bodyHeaders, retryCount });
    const req = {
      method,
      headers: reqHeaders,
      ...options.signal && { signal: options.signal },
      ...globalThis.ReadableStream && body instanceof globalThis.ReadableStream && { duplex: "half" },
      ...body && { body },
      ...(_b = this.fetchOptions) != null ? _b : {},
      ...(_c = options.fetchOptions) != null ? _c : {}
    };
    return { req, url, timeout: options.timeout };
  }
  async buildHeaders({ options, method, bodyHeaders, retryCount }) {
    let idempotencyHeaders = {};
    if (this.idempotencyHeader && method !== "get") {
      if (!options.idempotencyKey)
        options.idempotencyKey = this.defaultIdempotencyKey();
      idempotencyHeaders[this.idempotencyHeader] = options.idempotencyKey;
    }
    const headers = buildHeaders([
      idempotencyHeaders,
      {
        Accept: "application/json",
        "User-Agent": this.getUserAgent(),
        "X-Stainless-Retry-Count": String(retryCount),
        ...options.timeout ? { "X-Stainless-Timeout": String(Math.trunc(options.timeout / 1e3)) } : {},
        ...getPlatformHeaders(),
        "OpenAI-Organization": this.organization,
        "OpenAI-Project": this.project
      },
      await this.authHeaders(options),
      this._options.defaultHeaders,
      bodyHeaders,
      options.headers
    ]);
    this.validateHeaders(headers);
    return headers.values;
  }
  _makeAbort(controller) {
    return () => controller.abort();
  }
  buildBody({ options: { body, headers: rawHeaders } }) {
    if (!body) {
      return { bodyHeaders: void 0, body: void 0 };
    }
    const headers = buildHeaders([rawHeaders]);
    if (
      // Pass raw type verbatim
      ArrayBuffer.isView(body) || body instanceof ArrayBuffer || body instanceof DataView || typeof body === "string" && // Preserve legacy string encoding behavior for now
      headers.values.has("content-type") || // `Blob` is superset of `File`
      globalThis.Blob && body instanceof globalThis.Blob || // `FormData` -> `multipart/form-data`
      body instanceof FormData || // `URLSearchParams` -> `application/x-www-form-urlencoded`
      body instanceof URLSearchParams || // Send chunked stream (each chunk has own `length`)
      globalThis.ReadableStream && body instanceof globalThis.ReadableStream
    ) {
      return { bodyHeaders: void 0, body };
    } else if (typeof body === "object" && (Symbol.asyncIterator in body || Symbol.iterator in body && "next" in body && typeof body.next === "function")) {
      return { bodyHeaders: void 0, body: ReadableStreamFrom(body) };
    } else {
      return __classPrivateFieldGet(this, _OpenAI_encoder, "f").call(this, { body, headers });
    }
  }
};
_a2 = OpenAI, _OpenAI_encoder = /* @__PURE__ */ new WeakMap(), _OpenAI_instances = /* @__PURE__ */ new WeakSet(), _OpenAI_baseURLOverridden = function _OpenAI_baseURLOverridden2() {
  return this.baseURL !== "https://api.openai.com/v1";
};
OpenAI.OpenAI = _a2;
OpenAI.DEFAULT_TIMEOUT = 6e5;
OpenAI.OpenAIError = OpenAIError;
OpenAI.APIError = APIError;
OpenAI.APIConnectionError = APIConnectionError;
OpenAI.APIConnectionTimeoutError = APIConnectionTimeoutError;
OpenAI.APIUserAbortError = APIUserAbortError;
OpenAI.NotFoundError = NotFoundError;
OpenAI.ConflictError = ConflictError;
OpenAI.RateLimitError = RateLimitError;
OpenAI.BadRequestError = BadRequestError;
OpenAI.AuthenticationError = AuthenticationError;
OpenAI.InternalServerError = InternalServerError;
OpenAI.PermissionDeniedError = PermissionDeniedError;
OpenAI.UnprocessableEntityError = UnprocessableEntityError;
OpenAI.InvalidWebhookSignatureError = InvalidWebhookSignatureError;
OpenAI.toFile = toFile;
OpenAI.Completions = Completions2;
OpenAI.Chat = Chat;
OpenAI.Embeddings = Embeddings;
OpenAI.Files = Files2;
OpenAI.Images = Images;
OpenAI.Audio = Audio;
OpenAI.Moderations = Moderations;
OpenAI.Models = Models;
OpenAI.FineTuning = FineTuning;
OpenAI.Graders = Graders2;
OpenAI.VectorStores = VectorStores;
OpenAI.Webhooks = Webhooks;
OpenAI.Beta = Beta;
OpenAI.Batches = Batches;
OpenAI.Uploads = Uploads;
OpenAI.Responses = Responses;
OpenAI.Realtime = Realtime2;
OpenAI.Conversations = Conversations;
OpenAI.Evals = Evals;
OpenAI.Containers = Containers;
OpenAI.Videos = Videos;

// node_modules/@anthropic-ai/sdk/internal/tslib.mjs
function __classPrivateFieldSet2(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldGet2(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

// node_modules/@anthropic-ai/sdk/internal/utils/uuid.mjs
var uuid42 = function() {
  const { crypto: crypto2 } = globalThis;
  if (crypto2 == null ? void 0 : crypto2.randomUUID) {
    uuid42 = crypto2.randomUUID.bind(crypto2);
    return crypto2.randomUUID();
  }
  const u8 = new Uint8Array(1);
  const randomByte = crypto2 ? () => crypto2.getRandomValues(u8)[0] : () => Math.random() * 255 & 255;
  return "10000000-1000-4000-8000-100000000000".replace(/[018]/g, (c) => (+c ^ randomByte() & 15 >> +c / 4).toString(16));
};

// node_modules/@anthropic-ai/sdk/internal/errors.mjs
function isAbortError2(err) {
  return typeof err === "object" && err !== null && // Spec-compliant fetch implementations
  ("name" in err && err.name === "AbortError" || // Expo fetch
  "message" in err && String(err.message).includes("FetchRequestCanceledException"));
}
var castToError2 = (err) => {
  if (err instanceof Error)
    return err;
  if (typeof err === "object" && err !== null) {
    try {
      if (Object.prototype.toString.call(err) === "[object Error]") {
        const error = new Error(err.message, err.cause ? { cause: err.cause } : {});
        if (err.stack)
          error.stack = err.stack;
        if (err.cause && !error.cause)
          error.cause = err.cause;
        if (err.name)
          error.name = err.name;
        return error;
      }
    } catch (e3) {
    }
    try {
      return new Error(JSON.stringify(err));
    } catch (e3) {
    }
  }
  return new Error(err);
};

// node_modules/@anthropic-ai/sdk/core/error.mjs
var AnthropicError = class extends Error {
};
var APIError2 = class _APIError extends AnthropicError {
  constructor(status, error, message, headers) {
    super(`${_APIError.makeMessage(status, error, message)}`);
    this.status = status;
    this.headers = headers;
    this.requestID = headers == null ? void 0 : headers.get("request-id");
    this.error = error;
  }
  static makeMessage(status, error, message) {
    const msg = (error == null ? void 0 : error.message) ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
    if (status && msg) {
      return `${status} ${msg}`;
    }
    if (status) {
      return `${status} status code (no body)`;
    }
    if (msg) {
      return msg;
    }
    return "(no status code or body)";
  }
  static generate(status, errorResponse, message, headers) {
    if (!status || !headers) {
      return new APIConnectionError2({ message, cause: castToError2(errorResponse) });
    }
    const error = errorResponse;
    if (status === 400) {
      return new BadRequestError2(status, error, message, headers);
    }
    if (status === 401) {
      return new AuthenticationError2(status, error, message, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError2(status, error, message, headers);
    }
    if (status === 404) {
      return new NotFoundError2(status, error, message, headers);
    }
    if (status === 409) {
      return new ConflictError2(status, error, message, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError2(status, error, message, headers);
    }
    if (status === 429) {
      return new RateLimitError2(status, error, message, headers);
    }
    if (status >= 500) {
      return new InternalServerError2(status, error, message, headers);
    }
    return new _APIError(status, error, message, headers);
  }
};
var APIUserAbortError2 = class extends APIError2 {
  constructor({ message } = {}) {
    super(void 0, void 0, message || "Request was aborted.", void 0);
  }
};
var APIConnectionError2 = class extends APIError2 {
  constructor({ message, cause }) {
    super(void 0, void 0, message || "Connection error.", void 0);
    if (cause)
      this.cause = cause;
  }
};
var APIConnectionTimeoutError2 = class extends APIConnectionError2 {
  constructor({ message } = {}) {
    super({ message: message != null ? message : "Request timed out." });
  }
};
var BadRequestError2 = class extends APIError2 {
};
var AuthenticationError2 = class extends APIError2 {
};
var PermissionDeniedError2 = class extends APIError2 {
};
var NotFoundError2 = class extends APIError2 {
};
var ConflictError2 = class extends APIError2 {
};
var UnprocessableEntityError2 = class extends APIError2 {
};
var RateLimitError2 = class extends APIError2 {
};
var InternalServerError2 = class extends APIError2 {
};

// node_modules/@anthropic-ai/sdk/internal/utils/values.mjs
var startsWithSchemeRegexp2 = /^[a-z][a-z0-9+.-]*:/i;
var isAbsoluteURL2 = (url) => {
  return startsWithSchemeRegexp2.test(url);
};
var isArray2 = (val) => (isArray2 = Array.isArray, isArray2(val));
var isReadonlyArray2 = isArray2;
function maybeObj2(x3) {
  if (typeof x3 !== "object") {
    return {};
  }
  return x3 != null ? x3 : {};
}
function isEmptyObj2(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn2(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
var validatePositiveInteger2 = (name, n3) => {
  if (typeof n3 !== "number" || !Number.isInteger(n3)) {
    throw new AnthropicError(`${name} must be an integer`);
  }
  if (n3 < 0) {
    throw new AnthropicError(`${name} must be a positive integer`);
  }
  return n3;
};
var safeJSON2 = (text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return void 0;
  }
};

// node_modules/@anthropic-ai/sdk/internal/utils/sleep.mjs
var sleep2 = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

// node_modules/@anthropic-ai/sdk/version.mjs
var VERSION2 = "0.74.0";

// node_modules/@anthropic-ai/sdk/internal/detect-platform.mjs
var isRunningInBrowser2 = () => {
  return (
    // @ts-ignore
    typeof window !== "undefined" && // @ts-ignore
    typeof window.document !== "undefined" && // @ts-ignore
    typeof navigator !== "undefined"
  );
};
function getDetectedPlatform2() {
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return "deno";
  }
  if (typeof EdgeRuntime !== "undefined") {
    return "edge";
  }
  if (Object.prototype.toString.call(typeof globalThis.process !== "undefined" ? globalThis.process : 0) === "[object process]") {
    return "node";
  }
  return "unknown";
}
var getPlatformProperties2 = () => {
  var _a5, _b, _c, _d, _e;
  const detectedPlatform = getDetectedPlatform2();
  if (detectedPlatform === "deno") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION2,
      "X-Stainless-OS": normalizePlatform2(Deno.build.os),
      "X-Stainless-Arch": normalizeArch2(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : (_b = (_a5 = Deno.version) == null ? void 0 : _a5.deno) != null ? _b : "unknown"
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION2,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": globalThis.process.version
    };
  }
  if (detectedPlatform === "node") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION2,
      "X-Stainless-OS": normalizePlatform2((_c = globalThis.process.platform) != null ? _c : "unknown"),
      "X-Stainless-Arch": normalizeArch2((_d = globalThis.process.arch) != null ? _d : "unknown"),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": (_e = globalThis.process.version) != null ? _e : "unknown"
    };
  }
  const browserInfo = getBrowserInfo2();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION2,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION2,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function getBrowserInfo2() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
var normalizeArch2 = (arch) => {
  if (arch === "x32")
    return "x32";
  if (arch === "x86_64" || arch === "x64")
    return "x64";
  if (arch === "arm")
    return "arm";
  if (arch === "aarch64" || arch === "arm64")
    return "arm64";
  if (arch)
    return `other:${arch}`;
  return "unknown";
};
var normalizePlatform2 = (platform) => {
  platform = platform.toLowerCase();
  if (platform.includes("ios"))
    return "iOS";
  if (platform === "android")
    return "Android";
  if (platform === "darwin")
    return "MacOS";
  if (platform === "win32")
    return "Windows";
  if (platform === "freebsd")
    return "FreeBSD";
  if (platform === "openbsd")
    return "OpenBSD";
  if (platform === "linux")
    return "Linux";
  if (platform)
    return `Other:${platform}`;
  return "Unknown";
};
var _platformHeaders2;
var getPlatformHeaders2 = () => {
  return _platformHeaders2 != null ? _platformHeaders2 : _platformHeaders2 = getPlatformProperties2();
};

// node_modules/@anthropic-ai/sdk/internal/shims.mjs
function getDefaultFetch2() {
  if (typeof fetch !== "undefined") {
    return fetch;
  }
  throw new Error("`fetch` is not defined as a global; Either pass `fetch` to the client, `new Anthropic({ fetch })` or polyfill the global, `globalThis.fetch = fetch`");
}
function makeReadableStream2(...args) {
  const ReadableStream2 = globalThis.ReadableStream;
  if (typeof ReadableStream2 === "undefined") {
    throw new Error("`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`");
  }
  return new ReadableStream2(...args);
}
function ReadableStreamFrom2(iterable) {
  let iter = Symbol.asyncIterator in iterable ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();
  return makeReadableStream2({
    start() {
    },
    async pull(controller) {
      const { done, value } = await iter.next();
      if (done) {
        controller.close();
      } else {
        controller.enqueue(value);
      }
    },
    async cancel() {
      var _a5;
      await ((_a5 = iter.return) == null ? void 0 : _a5.call(iter));
    }
  });
}
function ReadableStreamToAsyncIterable2(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result == null ? void 0 : result.done)
          reader.releaseLock();
        return result;
      } catch (e3) {
        reader.releaseLock();
        throw e3;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
async function CancelReadableStream2(stream) {
  var _a5, _b;
  if (stream === null || typeof stream !== "object")
    return;
  if (stream[Symbol.asyncIterator]) {
    await ((_b = (_a5 = stream[Symbol.asyncIterator]()).return) == null ? void 0 : _b.call(_a5));
    return;
  }
  const reader = stream.getReader();
  const cancelPromise = reader.cancel();
  reader.releaseLock();
  await cancelPromise;
}

// node_modules/@anthropic-ai/sdk/internal/request-options.mjs
var FallbackEncoder2 = ({ headers, body }) => {
  return {
    bodyHeaders: {
      "content-type": "application/json"
    },
    body: JSON.stringify(body)
  };
};

// node_modules/@anthropic-ai/sdk/internal/utils/bytes.mjs
function concatBytes2(buffers) {
  let length = 0;
  for (const buffer of buffers) {
    length += buffer.length;
  }
  const output = new Uint8Array(length);
  let index = 0;
  for (const buffer of buffers) {
    output.set(buffer, index);
    index += buffer.length;
  }
  return output;
}
var encodeUTF8_2;
function encodeUTF82(str2) {
  let encoder;
  return (encodeUTF8_2 != null ? encodeUTF8_2 : (encoder = new globalThis.TextEncoder(), encodeUTF8_2 = encoder.encode.bind(encoder)))(str2);
}
var decodeUTF8_2;
function decodeUTF82(bytes) {
  let decoder;
  return (decodeUTF8_2 != null ? decodeUTF8_2 : (decoder = new globalThis.TextDecoder(), decodeUTF8_2 = decoder.decode.bind(decoder)))(bytes);
}

// node_modules/@anthropic-ai/sdk/internal/decoders/line.mjs
var _LineDecoder_buffer2;
var _LineDecoder_carriageReturnIndex2;
var LineDecoder2 = class {
  constructor() {
    _LineDecoder_buffer2.set(this, void 0);
    _LineDecoder_carriageReturnIndex2.set(this, void 0);
    __classPrivateFieldSet2(this, _LineDecoder_buffer2, new Uint8Array(), "f");
    __classPrivateFieldSet2(this, _LineDecoder_carriageReturnIndex2, null, "f");
  }
  decode(chunk) {
    if (chunk == null) {
      return [];
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? encodeUTF82(chunk) : chunk;
    __classPrivateFieldSet2(this, _LineDecoder_buffer2, concatBytes2([__classPrivateFieldGet2(this, _LineDecoder_buffer2, "f"), binaryChunk]), "f");
    const lines = [];
    let patternIndex;
    while ((patternIndex = findNewlineIndex2(__classPrivateFieldGet2(this, _LineDecoder_buffer2, "f"), __classPrivateFieldGet2(this, _LineDecoder_carriageReturnIndex2, "f"))) != null) {
      if (patternIndex.carriage && __classPrivateFieldGet2(this, _LineDecoder_carriageReturnIndex2, "f") == null) {
        __classPrivateFieldSet2(this, _LineDecoder_carriageReturnIndex2, patternIndex.index, "f");
        continue;
      }
      if (__classPrivateFieldGet2(this, _LineDecoder_carriageReturnIndex2, "f") != null && (patternIndex.index !== __classPrivateFieldGet2(this, _LineDecoder_carriageReturnIndex2, "f") + 1 || patternIndex.carriage)) {
        lines.push(decodeUTF82(__classPrivateFieldGet2(this, _LineDecoder_buffer2, "f").subarray(0, __classPrivateFieldGet2(this, _LineDecoder_carriageReturnIndex2, "f") - 1)));
        __classPrivateFieldSet2(this, _LineDecoder_buffer2, __classPrivateFieldGet2(this, _LineDecoder_buffer2, "f").subarray(__classPrivateFieldGet2(this, _LineDecoder_carriageReturnIndex2, "f")), "f");
        __classPrivateFieldSet2(this, _LineDecoder_carriageReturnIndex2, null, "f");
        continue;
      }
      const endIndex = __classPrivateFieldGet2(this, _LineDecoder_carriageReturnIndex2, "f") !== null ? patternIndex.preceding - 1 : patternIndex.preceding;
      const line = decodeUTF82(__classPrivateFieldGet2(this, _LineDecoder_buffer2, "f").subarray(0, endIndex));
      lines.push(line);
      __classPrivateFieldSet2(this, _LineDecoder_buffer2, __classPrivateFieldGet2(this, _LineDecoder_buffer2, "f").subarray(patternIndex.index), "f");
      __classPrivateFieldSet2(this, _LineDecoder_carriageReturnIndex2, null, "f");
    }
    return lines;
  }
  flush() {
    if (!__classPrivateFieldGet2(this, _LineDecoder_buffer2, "f").length) {
      return [];
    }
    return this.decode("\n");
  }
};
_LineDecoder_buffer2 = /* @__PURE__ */ new WeakMap(), _LineDecoder_carriageReturnIndex2 = /* @__PURE__ */ new WeakMap();
LineDecoder2.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r"]);
LineDecoder2.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
function findNewlineIndex2(buffer, startIndex) {
  const newline = 10;
  const carriage = 13;
  for (let i3 = startIndex != null ? startIndex : 0; i3 < buffer.length; i3++) {
    if (buffer[i3] === newline) {
      return { preceding: i3, index: i3 + 1, carriage: false };
    }
    if (buffer[i3] === carriage) {
      return { preceding: i3, index: i3 + 1, carriage: true };
    }
  }
  return null;
}
function findDoubleNewlineIndex2(buffer) {
  const newline = 10;
  const carriage = 13;
  for (let i3 = 0; i3 < buffer.length - 1; i3++) {
    if (buffer[i3] === newline && buffer[i3 + 1] === newline) {
      return i3 + 2;
    }
    if (buffer[i3] === carriage && buffer[i3 + 1] === carriage) {
      return i3 + 2;
    }
    if (buffer[i3] === carriage && buffer[i3 + 1] === newline && i3 + 3 < buffer.length && buffer[i3 + 2] === carriage && buffer[i3 + 3] === newline) {
      return i3 + 4;
    }
  }
  return -1;
}

// node_modules/@anthropic-ai/sdk/internal/utils/log.mjs
var levelNumbers2 = {
  off: 0,
  error: 200,
  warn: 300,
  info: 400,
  debug: 500
};
var parseLogLevel2 = (maybeLevel, sourceName, client) => {
  if (!maybeLevel) {
    return void 0;
  }
  if (hasOwn2(levelNumbers2, maybeLevel)) {
    return maybeLevel;
  }
  loggerFor2(client).warn(`${sourceName} was set to ${JSON.stringify(maybeLevel)}, expected one of ${JSON.stringify(Object.keys(levelNumbers2))}`);
  return void 0;
};
function noop2() {
}
function makeLogFn2(fnLevel, logger, logLevel) {
  if (!logger || levelNumbers2[fnLevel] > levelNumbers2[logLevel]) {
    return noop2;
  } else {
    return logger[fnLevel].bind(logger);
  }
}
var noopLogger2 = {
  error: noop2,
  warn: noop2,
  info: noop2,
  debug: noop2
};
var cachedLoggers2 = /* @__PURE__ */ new WeakMap();
function loggerFor2(client) {
  var _a5;
  const logger = client.logger;
  const logLevel = (_a5 = client.logLevel) != null ? _a5 : "off";
  if (!logger) {
    return noopLogger2;
  }
  const cachedLogger = cachedLoggers2.get(logger);
  if (cachedLogger && cachedLogger[0] === logLevel) {
    return cachedLogger[1];
  }
  const levelLogger = {
    error: makeLogFn2("error", logger, logLevel),
    warn: makeLogFn2("warn", logger, logLevel),
    info: makeLogFn2("info", logger, logLevel),
    debug: makeLogFn2("debug", logger, logLevel)
  };
  cachedLoggers2.set(logger, [logLevel, levelLogger]);
  return levelLogger;
}
var formatRequestDetails2 = (details) => {
  if (details.options) {
    details.options = { ...details.options };
    delete details.options["headers"];
  }
  if (details.headers) {
    details.headers = Object.fromEntries((details.headers instanceof Headers ? [...details.headers] : Object.entries(details.headers)).map(([name, value]) => [
      name,
      name.toLowerCase() === "x-api-key" || name.toLowerCase() === "authorization" || name.toLowerCase() === "cookie" || name.toLowerCase() === "set-cookie" ? "***" : value
    ]));
  }
  if ("retryOfRequestLogID" in details) {
    if (details.retryOfRequestLogID) {
      details.retryOf = details.retryOfRequestLogID;
    }
    delete details.retryOfRequestLogID;
  }
  return details;
};

// node_modules/@anthropic-ai/sdk/core/streaming.mjs
var _Stream_client2;
var Stream2 = class _Stream {
  constructor(iterator, controller, client) {
    this.iterator = iterator;
    _Stream_client2.set(this, void 0);
    this.controller = controller;
    __classPrivateFieldSet2(this, _Stream_client2, client, "f");
  }
  static fromSSEResponse(response, controller, client) {
    let consumed = false;
    const logger = client ? loggerFor2(client) : console;
    async function* iterator() {
      var _a5;
      if (consumed) {
        throw new AnthropicError("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const sse of _iterSSEMessages2(response, controller)) {
          if (sse.event === "completion") {
            try {
              yield JSON.parse(sse.data);
            } catch (e3) {
              logger.error(`Could not parse message into JSON:`, sse.data);
              logger.error(`From chunk:`, sse.raw);
              throw e3;
            }
          }
          if (sse.event === "message_start" || sse.event === "message_delta" || sse.event === "message_stop" || sse.event === "content_block_start" || sse.event === "content_block_delta" || sse.event === "content_block_stop") {
            try {
              yield JSON.parse(sse.data);
            } catch (e3) {
              logger.error(`Could not parse message into JSON:`, sse.data);
              logger.error(`From chunk:`, sse.raw);
              throw e3;
            }
          }
          if (sse.event === "ping") {
            continue;
          }
          if (sse.event === "error") {
            throw new APIError2(void 0, (_a5 = safeJSON2(sse.data)) != null ? _a5 : sse.data, void 0, response.headers);
          }
        }
        done = true;
      } catch (e3) {
        if (isAbortError2(e3))
          return;
        throw e3;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new _Stream(iterator, controller, client);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(readableStream, controller, client) {
    let consumed = false;
    async function* iterLines() {
      const lineDecoder = new LineDecoder2();
      const iter = ReadableStreamToAsyncIterable2(readableStream);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          yield line;
        }
      }
      for (const line of lineDecoder.flush()) {
        yield line;
      }
    }
    async function* iterator() {
      if (consumed) {
        throw new AnthropicError("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const line of iterLines()) {
          if (done)
            continue;
          if (line)
            yield JSON.parse(line);
        }
        done = true;
      } catch (e3) {
        if (isAbortError2(e3))
          return;
        throw e3;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new _Stream(iterator, controller, client);
  }
  [(_Stream_client2 = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const left = [];
    const right = [];
    const iterator = this.iterator();
    const teeIterator = (queue) => {
      return {
        next: () => {
          if (queue.length === 0) {
            const result = iterator.next();
            left.push(result);
            right.push(result);
          }
          return queue.shift();
        }
      };
    };
    return [
      new _Stream(() => teeIterator(left), this.controller, __classPrivateFieldGet2(this, _Stream_client2, "f")),
      new _Stream(() => teeIterator(right), this.controller, __classPrivateFieldGet2(this, _Stream_client2, "f"))
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const self2 = this;
    let iter;
    return makeReadableStream2({
      async start() {
        iter = self2[Symbol.asyncIterator]();
      },
      async pull(ctrl) {
        try {
          const { value, done } = await iter.next();
          if (done)
            return ctrl.close();
          const bytes = encodeUTF82(JSON.stringify(value) + "\n");
          ctrl.enqueue(bytes);
        } catch (err) {
          ctrl.error(err);
        }
      },
      async cancel() {
        var _a5;
        await ((_a5 = iter.return) == null ? void 0 : _a5.call(iter));
      }
    });
  }
};
async function* _iterSSEMessages2(response, controller) {
  if (!response.body) {
    controller.abort();
    if (typeof globalThis.navigator !== "undefined" && globalThis.navigator.product === "ReactNative") {
      throw new AnthropicError(`The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api`);
    }
    throw new AnthropicError(`Attempted to iterate over a response with no body`);
  }
  const sseDecoder = new SSEDecoder2();
  const lineDecoder = new LineDecoder2();
  const iter = ReadableStreamToAsyncIterable2(response.body);
  for await (const sseChunk of iterSSEChunks2(iter)) {
    for (const line of lineDecoder.decode(sseChunk)) {
      const sse = sseDecoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  for (const line of lineDecoder.flush()) {
    const sse = sseDecoder.decode(line);
    if (sse)
      yield sse;
  }
}
async function* iterSSEChunks2(iterator) {
  let data = new Uint8Array();
  for await (const chunk of iterator) {
    if (chunk == null) {
      continue;
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? encodeUTF82(chunk) : chunk;
    let newData = new Uint8Array(data.length + binaryChunk.length);
    newData.set(data);
    newData.set(binaryChunk, data.length);
    data = newData;
    let patternIndex;
    while ((patternIndex = findDoubleNewlineIndex2(data)) !== -1) {
      yield data.slice(0, patternIndex);
      data = data.slice(patternIndex);
    }
  }
  if (data.length > 0) {
    yield data;
  }
}
var SSEDecoder2 = class {
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length)
        return null;
      const sse = {
        event: this.event,
        data: this.data.join("\n"),
        raw: this.chunks
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _, value] = partition2(line, ":");
    if (value.startsWith(" ")) {
      value = value.substring(1);
    }
    if (fieldname === "event") {
      this.event = value;
    } else if (fieldname === "data") {
      this.data.push(value);
    }
    return null;
  }
};
function partition2(str2, delimiter) {
  const index = str2.indexOf(delimiter);
  if (index !== -1) {
    return [str2.substring(0, index), delimiter, str2.substring(index + delimiter.length)];
  }
  return [str2, "", ""];
}

// node_modules/@anthropic-ai/sdk/internal/parse.mjs
async function defaultParseResponse2(client, props) {
  const { response, requestLogID, retryOfRequestLogID, startTime } = props;
  const body = await (async () => {
    var _a5;
    if (props.options.stream) {
      loggerFor2(client).debug("response", response.status, response.url, response.headers, response.body);
      if (props.options.__streamClass) {
        return props.options.__streamClass.fromSSEResponse(response, props.controller);
      }
      return Stream2.fromSSEResponse(response, props.controller);
    }
    if (response.status === 204) {
      return null;
    }
    if (props.options.__binaryResponse) {
      return response;
    }
    const contentType = response.headers.get("content-type");
    const mediaType = (_a5 = contentType == null ? void 0 : contentType.split(";")[0]) == null ? void 0 : _a5.trim();
    const isJSON = (mediaType == null ? void 0 : mediaType.includes("application/json")) || (mediaType == null ? void 0 : mediaType.endsWith("+json"));
    if (isJSON) {
      const contentLength = response.headers.get("content-length");
      if (contentLength === "0") {
        return void 0;
      }
      const json = await response.json();
      return addRequestID2(json, response);
    }
    const text = await response.text();
    return text;
  })();
  loggerFor2(client).debug(`[${requestLogID}] response parsed`, formatRequestDetails2({
    retryOfRequestLogID,
    url: response.url,
    status: response.status,
    body,
    durationMs: Date.now() - startTime
  }));
  return body;
}
function addRequestID2(value, response) {
  if (!value || typeof value !== "object" || Array.isArray(value)) {
    return value;
  }
  return Object.defineProperty(value, "_request_id", {
    value: response.headers.get("request-id"),
    enumerable: false
  });
}

// node_modules/@anthropic-ai/sdk/core/api-promise.mjs
var _APIPromise_client2;
var APIPromise2 = class _APIPromise extends Promise {
  constructor(client, responsePromise, parseResponse2 = defaultParseResponse2) {
    super((resolve) => {
      resolve(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse2;
    _APIPromise_client2.set(this, void 0);
    __classPrivateFieldSet2(this, _APIPromise_client2, client, "f");
  }
  _thenUnwrap(transform) {
    return new _APIPromise(__classPrivateFieldGet2(this, _APIPromise_client2, "f"), this.responsePromise, async (client, props) => addRequestID2(transform(await this.parseResponse(client, props), props), props.response));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
   * to your `tsconfig.json`.
   */
  asResponse() {
    return this.responsePromise.then((p3) => p3.response);
  }
  /**
   * Gets the parsed response data, the raw `Response` instance and the ID of the request,
   * returned via the `request-id` header which is useful for debugging requests and resporting
   * issues to Anthropic.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
   * to your `tsconfig.json`.
   */
  async withResponse() {
    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
    return { data, response, request_id: response.headers.get("request-id") };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then((data) => this.parseResponse(__classPrivateFieldGet2(this, _APIPromise_client2, "f"), data));
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
};
_APIPromise_client2 = /* @__PURE__ */ new WeakMap();

// node_modules/@anthropic-ai/sdk/core/pagination.mjs
var _AbstractPage_client2;
var AbstractPage2 = class {
  constructor(client, response, body, options) {
    _AbstractPage_client2.set(this, void 0);
    __classPrivateFieldSet2(this, _AbstractPage_client2, client, "f");
    this.options = options;
    this.response = response;
    this.body = body;
  }
  hasNextPage() {
    const items = this.getPaginatedItems();
    if (!items.length)
      return false;
    return this.nextPageRequestOptions() != null;
  }
  async getNextPage() {
    const nextOptions = this.nextPageRequestOptions();
    if (!nextOptions) {
      throw new AnthropicError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    }
    return await __classPrivateFieldGet2(this, _AbstractPage_client2, "f").requestAPIList(this.constructor, nextOptions);
  }
  async *iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async *[(_AbstractPage_client2 = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
};
var PagePromise2 = class extends APIPromise2 {
  constructor(client, request, Page3) {
    super(client, request, async (client2, props) => new Page3(client2, props.response, await defaultParseResponse2(client2, props), props.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
};
var Page2 = class extends AbstractPage2 {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
    this.has_more = body.has_more || false;
    this.first_id = body.first_id || null;
    this.last_id = body.last_id || null;
  }
  getPaginatedItems() {
    var _a5;
    return (_a5 = this.data) != null ? _a5 : [];
  }
  hasNextPage() {
    if (this.has_more === false) {
      return false;
    }
    return super.hasNextPage();
  }
  nextPageRequestOptions() {
    var _a5;
    if ((_a5 = this.options.query) == null ? void 0 : _a5["before_id"]) {
      const first_id = this.first_id;
      if (!first_id) {
        return null;
      }
      return {
        ...this.options,
        query: {
          ...maybeObj2(this.options.query),
          before_id: first_id
        }
      };
    }
    const cursor = this.last_id;
    if (!cursor) {
      return null;
    }
    return {
      ...this.options,
      query: {
        ...maybeObj2(this.options.query),
        after_id: cursor
      }
    };
  }
};
var PageCursor = class extends AbstractPage2 {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
    this.has_more = body.has_more || false;
    this.next_page = body.next_page || null;
  }
  getPaginatedItems() {
    var _a5;
    return (_a5 = this.data) != null ? _a5 : [];
  }
  hasNextPage() {
    if (this.has_more === false) {
      return false;
    }
    return super.hasNextPage();
  }
  nextPageRequestOptions() {
    const cursor = this.next_page;
    if (!cursor) {
      return null;
    }
    return {
      ...this.options,
      query: {
        ...maybeObj2(this.options.query),
        page: cursor
      }
    };
  }
};

// node_modules/@anthropic-ai/sdk/internal/uploads.mjs
var checkFileSupport2 = () => {
  var _a5;
  if (typeof File === "undefined") {
    const { process: process2 } = globalThis;
    const isOldNode = typeof ((_a5 = process2 == null ? void 0 : process2.versions) == null ? void 0 : _a5.node) === "string" && parseInt(process2.versions.node.split(".")) < 20;
    throw new Error("`File` is not defined as a global, which is required for file uploads." + (isOldNode ? " Update to Node 20 LTS or newer, or set `globalThis.File` to `import('node:buffer').File`." : ""));
  }
};
function makeFile2(fileBits, fileName, options) {
  checkFileSupport2();
  return new File(fileBits, fileName != null ? fileName : "unknown_file", options);
}
function getName2(value, stripPath) {
  const val = typeof value === "object" && value !== null && ("name" in value && value.name && String(value.name) || "url" in value && value.url && String(value.url) || "filename" in value && value.filename && String(value.filename) || "path" in value && value.path && String(value.path)) || "";
  return stripPath ? val.split(/[\\/]/).pop() || void 0 : val;
}
var isAsyncIterable2 = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
var multipartFormRequestOptions2 = async (opts, fetch2, stripFilenames = true) => {
  return { ...opts, body: await createForm2(opts.body, fetch2, stripFilenames) };
};
var supportsFormDataMap2 = /* @__PURE__ */ new WeakMap();
function supportsFormData2(fetchObject) {
  const fetch2 = typeof fetchObject === "function" ? fetchObject : fetchObject.fetch;
  const cached = supportsFormDataMap2.get(fetch2);
  if (cached)
    return cached;
  const promise = (async () => {
    try {
      const FetchResponse = "Response" in fetch2 ? fetch2.Response : (await fetch2("data:,")).constructor;
      const data = new FormData();
      if (data.toString() === await new FetchResponse(data).text()) {
        return false;
      }
      return true;
    } catch (e3) {
      return true;
    }
  })();
  supportsFormDataMap2.set(fetch2, promise);
  return promise;
}
var createForm2 = async (body, fetch2, stripFilenames = true) => {
  if (!await supportsFormData2(fetch2)) {
    throw new TypeError("The provided fetch function does not support file uploads with the current global FormData class.");
  }
  const form = new FormData();
  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue2(form, key, value, stripFilenames)));
  return form;
};
var isNamedBlob2 = (value) => value instanceof Blob && "name" in value;
var addFormValue2 = async (form, key, value, stripFilenames) => {
  if (value === void 0)
    return;
  if (value == null) {
    throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);
  }
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    form.append(key, String(value));
  } else if (value instanceof Response) {
    let options = {};
    const contentType = value.headers.get("Content-Type");
    if (contentType) {
      options = { type: contentType };
    }
    form.append(key, makeFile2([await value.blob()], getName2(value, stripFilenames), options));
  } else if (isAsyncIterable2(value)) {
    form.append(key, makeFile2([await new Response(ReadableStreamFrom2(value)).blob()], getName2(value, stripFilenames)));
  } else if (isNamedBlob2(value)) {
    form.append(key, makeFile2([value], getName2(value, stripFilenames), { type: value.type }));
  } else if (Array.isArray(value)) {
    await Promise.all(value.map((entry) => addFormValue2(form, key + "[]", entry, stripFilenames)));
  } else if (typeof value === "object") {
    await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue2(form, `${key}[${name}]`, prop, stripFilenames)));
  } else {
    throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
  }
};

// node_modules/@anthropic-ai/sdk/internal/to-file.mjs
var isBlobLike2 = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
var isFileLike2 = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike2(value);
var isResponseLike2 = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
async function toFile2(value, name, options) {
  checkFileSupport2();
  value = await value;
  name || (name = getName2(value, true));
  if (isFileLike2(value)) {
    if (value instanceof File && name == null && options == null) {
      return value;
    }
    return makeFile2([await value.arrayBuffer()], name != null ? name : value.name, {
      type: value.type,
      lastModified: value.lastModified,
      ...options
    });
  }
  if (isResponseLike2(value)) {
    const blob = await value.blob();
    name || (name = new URL(value.url).pathname.split(/[\\/]/).pop());
    return makeFile2(await getBytes2(blob), name, options);
  }
  const parts = await getBytes2(value);
  if (!(options == null ? void 0 : options.type)) {
    const type = parts.find((part) => typeof part === "object" && "type" in part && part.type);
    if (typeof type === "string") {
      options = { ...options, type };
    }
  }
  return makeFile2(parts, name, options);
}
async function getBytes2(value) {
  var _a5;
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
  value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike2(value)) {
    parts.push(value instanceof Blob ? value : await value.arrayBuffer());
  } else if (isAsyncIterable2(value)) {
    for await (const chunk of value) {
      parts.push(...await getBytes2(chunk));
    }
  } else {
    const constructor = (_a5 = value == null ? void 0 : value.constructor) == null ? void 0 : _a5.name;
    throw new Error(`Unexpected data type: ${typeof value}${constructor ? `; constructor: ${constructor}` : ""}${propsForError2(value)}`);
  }
  return parts;
}
function propsForError2(value) {
  if (typeof value !== "object" || value === null)
    return "";
  const props = Object.getOwnPropertyNames(value);
  return `; props: [${props.map((p3) => `"${p3}"`).join(", ")}]`;
}

// node_modules/@anthropic-ai/sdk/core/resource.mjs
var APIResource2 = class {
  constructor(client) {
    this._client = client;
  }
};

// node_modules/@anthropic-ai/sdk/internal/headers.mjs
var brand_privateNullableHeaders2 = /* @__PURE__ */ Symbol.for("brand.privateNullableHeaders");
function* iterateHeaders2(headers) {
  if (!headers)
    return;
  if (brand_privateNullableHeaders2 in headers) {
    const { values, nulls } = headers;
    yield* values.entries();
    for (const name of nulls) {
      yield [name, null];
    }
    return;
  }
  let shouldClear = false;
  let iter;
  if (headers instanceof Headers) {
    iter = headers.entries();
  } else if (isReadonlyArray2(headers)) {
    iter = headers;
  } else {
    shouldClear = true;
    iter = Object.entries(headers != null ? headers : {});
  }
  for (let row of iter) {
    const name = row[0];
    if (typeof name !== "string")
      throw new TypeError("expected header name to be a string");
    const values = isReadonlyArray2(row[1]) ? row[1] : [row[1]];
    let didClear = false;
    for (const value of values) {
      if (value === void 0)
        continue;
      if (shouldClear && !didClear) {
        didClear = true;
        yield [name, null];
      }
      yield [name, value];
    }
  }
}
var buildHeaders2 = (newHeaders) => {
  const targetHeaders = new Headers();
  const nullHeaders = /* @__PURE__ */ new Set();
  for (const headers of newHeaders) {
    const seenHeaders = /* @__PURE__ */ new Set();
    for (const [name, value] of iterateHeaders2(headers)) {
      const lowerName = name.toLowerCase();
      if (!seenHeaders.has(lowerName)) {
        targetHeaders.delete(name);
        seenHeaders.add(lowerName);
      }
      if (value === null) {
        targetHeaders.delete(name);
        nullHeaders.add(lowerName);
      } else {
        targetHeaders.append(name, value);
        nullHeaders.delete(lowerName);
      }
    }
  }
  return { [brand_privateNullableHeaders2]: true, values: targetHeaders, nulls: nullHeaders };
};

// node_modules/@anthropic-ai/sdk/lib/stainless-helper-header.mjs
var SDK_HELPER_SYMBOL = /* @__PURE__ */ Symbol("anthropic.sdk.stainlessHelper");
function wasCreatedByStainlessHelper(value) {
  return typeof value === "object" && value !== null && SDK_HELPER_SYMBOL in value;
}
function collectStainlessHelpers(tools, messages2) {
  const helpers = /* @__PURE__ */ new Set();
  if (tools) {
    for (const tool of tools) {
      if (wasCreatedByStainlessHelper(tool)) {
        helpers.add(tool[SDK_HELPER_SYMBOL]);
      }
    }
  }
  if (messages2) {
    for (const message of messages2) {
      if (wasCreatedByStainlessHelper(message)) {
        helpers.add(message[SDK_HELPER_SYMBOL]);
      }
      if (Array.isArray(message.content)) {
        for (const block of message.content) {
          if (wasCreatedByStainlessHelper(block)) {
            helpers.add(block[SDK_HELPER_SYMBOL]);
          }
        }
      }
    }
  }
  return Array.from(helpers);
}
function stainlessHelperHeader(tools, messages2) {
  const helpers = collectStainlessHelpers(tools, messages2);
  if (helpers.length === 0)
    return {};
  return { "x-stainless-helper": helpers.join(", ") };
}
function stainlessHelperHeaderFromFile(file) {
  if (wasCreatedByStainlessHelper(file)) {
    return { "x-stainless-helper": file[SDK_HELPER_SYMBOL] };
  }
  return {};
}

// node_modules/@anthropic-ai/sdk/internal/utils/path.mjs
function encodeURIPath2(str2) {
  return str2.replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]+/g, encodeURIComponent);
}
var EMPTY2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.create(null));
var createPathTagFunction2 = (pathEncoder = encodeURIPath2) => function path4(statics, ...params) {
  if (statics.length === 1)
    return statics[0];
  let postPath = false;
  const invalidSegments = [];
  const path5 = statics.reduce((previousValue, currentValue, index) => {
    var _a5, _b, _c;
    if (/[?#]/.test(currentValue)) {
      postPath = true;
    }
    const value = params[index];
    let encoded = (postPath ? encodeURIComponent : pathEncoder)("" + value);
    if (index !== params.length && (value == null || typeof value === "object" && // handle values from other realms
    value.toString === ((_c = Object.getPrototypeOf((_b = Object.getPrototypeOf((_a5 = value.hasOwnProperty) != null ? _a5 : EMPTY2)) != null ? _b : EMPTY2)) == null ? void 0 : _c.toString))) {
      encoded = value + "";
      invalidSegments.push({
        start: previousValue.length + currentValue.length,
        length: encoded.length,
        error: `Value of type ${Object.prototype.toString.call(value).slice(8, -1)} is not a valid path parameter`
      });
    }
    return previousValue + currentValue + (index === params.length ? "" : encoded);
  }, "");
  const pathOnly = path5.split(/[?#]/, 1)[0];
  const invalidSegmentPattern = /(?<=^|\/)(?:\.|%2e){1,2}(?=\/|$)/gi;
  let match;
  while ((match = invalidSegmentPattern.exec(pathOnly)) !== null) {
    invalidSegments.push({
      start: match.index,
      length: match[0].length,
      error: `Value "${match[0]}" can't be safely passed as a path parameter`
    });
  }
  invalidSegments.sort((a, b3) => a.start - b3.start);
  if (invalidSegments.length > 0) {
    let lastEnd = 0;
    const underline = invalidSegments.reduce((acc, segment) => {
      const spaces = " ".repeat(segment.start - lastEnd);
      const arrows = "^".repeat(segment.length);
      lastEnd = segment.start + segment.length;
      return acc + spaces + arrows;
    }, "");
    throw new AnthropicError(`Path parameters result in path with invalid segments:
${invalidSegments.map((e3) => e3.error).join("\n")}
${path5}
${underline}`);
  }
  return path5;
};
var path2 = /* @__PURE__ */ createPathTagFunction2(encodeURIPath2);

// node_modules/@anthropic-ai/sdk/resources/beta/files.mjs
var Files4 = class extends APIResource2 {
  /**
   * List Files
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const fileMetadata of client.beta.files.list()) {
   *   // ...
   * }
   * ```
   */
  list(params = {}, options) {
    const { betas, ...query } = params != null ? params : {};
    return this._client.getAPIList("/v1/files", Page2, {
      query,
      ...options,
      headers: buildHeaders2([
        { "anthropic-beta": [...betas != null ? betas : [], "files-api-2025-04-14"].toString() },
        options == null ? void 0 : options.headers
      ])
    });
  }
  /**
   * Delete File
   *
   * @example
   * ```ts
   * const deletedFile = await client.beta.files.delete(
   *   'file_id',
   * );
   * ```
   */
  delete(fileID, params = {}, options) {
    const { betas } = params != null ? params : {};
    return this._client.delete(path2`/v1/files/${fileID}`, {
      ...options,
      headers: buildHeaders2([
        { "anthropic-beta": [...betas != null ? betas : [], "files-api-2025-04-14"].toString() },
        options == null ? void 0 : options.headers
      ])
    });
  }
  /**
   * Download File
   *
   * @example
   * ```ts
   * const response = await client.beta.files.download(
   *   'file_id',
   * );
   *
   * const content = await response.blob();
   * console.log(content);
   * ```
   */
  download(fileID, params = {}, options) {
    const { betas } = params != null ? params : {};
    return this._client.get(path2`/v1/files/${fileID}/content`, {
      ...options,
      headers: buildHeaders2([
        {
          "anthropic-beta": [...betas != null ? betas : [], "files-api-2025-04-14"].toString(),
          Accept: "application/binary"
        },
        options == null ? void 0 : options.headers
      ]),
      __binaryResponse: true
    });
  }
  /**
   * Get File Metadata
   *
   * @example
   * ```ts
   * const fileMetadata =
   *   await client.beta.files.retrieveMetadata('file_id');
   * ```
   */
  retrieveMetadata(fileID, params = {}, options) {
    const { betas } = params != null ? params : {};
    return this._client.get(path2`/v1/files/${fileID}`, {
      ...options,
      headers: buildHeaders2([
        { "anthropic-beta": [...betas != null ? betas : [], "files-api-2025-04-14"].toString() },
        options == null ? void 0 : options.headers
      ])
    });
  }
  /**
   * Upload File
   *
   * @example
   * ```ts
   * const fileMetadata = await client.beta.files.upload({
   *   file: fs.createReadStream('path/to/file'),
   * });
   * ```
   */
  upload(params, options) {
    const { betas, ...body } = params;
    return this._client.post("/v1/files", multipartFormRequestOptions2({
      body,
      ...options,
      headers: buildHeaders2([
        { "anthropic-beta": [...betas != null ? betas : [], "files-api-2025-04-14"].toString() },
        stainlessHelperHeaderFromFile(body.file),
        options == null ? void 0 : options.headers
      ])
    }, this._client));
  }
};

// node_modules/@anthropic-ai/sdk/resources/beta/models.mjs
var Models2 = class extends APIResource2 {
  /**
   * Get a specific model.
   *
   * The Models API response can be used to determine information about a specific
   * model or resolve a model alias to a model ID.
   *
   * @example
   * ```ts
   * const betaModelInfo = await client.beta.models.retrieve(
   *   'model_id',
   * );
   * ```
   */
  retrieve(modelID, params = {}, options) {
    const { betas } = params != null ? params : {};
    return this._client.get(path2`/v1/models/${modelID}?beta=true`, {
      ...options,
      headers: buildHeaders2([
        { ...(betas == null ? void 0 : betas.toString()) != null ? { "anthropic-beta": betas == null ? void 0 : betas.toString() } : void 0 },
        options == null ? void 0 : options.headers
      ])
    });
  }
  /**
   * List available models.
   *
   * The Models API response can be used to determine which models are available for
   * use in the API. More recently released models are listed first.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const betaModelInfo of client.beta.models.list()) {
   *   // ...
   * }
   * ```
   */
  list(params = {}, options) {
    const { betas, ...query } = params != null ? params : {};
    return this._client.getAPIList("/v1/models?beta=true", Page2, {
      query,
      ...options,
      headers: buildHeaders2([
        { ...(betas == null ? void 0 : betas.toString()) != null ? { "anthropic-beta": betas == null ? void 0 : betas.toString() } : void 0 },
        options == null ? void 0 : options.headers
      ])
    });
  }
};

// node_modules/@anthropic-ai/sdk/internal/constants.mjs
var MODEL_NONSTREAMING_TOKENS = {
  "claude-opus-4-20250514": 8192,
  "claude-opus-4-0": 8192,
  "claude-4-opus-20250514": 8192,
  "anthropic.claude-opus-4-20250514-v1:0": 8192,
  "claude-opus-4@20250514": 8192,
  "claude-opus-4-1-20250805": 8192,
  "anthropic.claude-opus-4-1-20250805-v1:0": 8192,
  "claude-opus-4-1@20250805": 8192
};

// node_modules/@anthropic-ai/sdk/lib/beta-parser.mjs
function getOutputFormat(params) {
  var _a5, _b;
  return (_b = params == null ? void 0 : params.output_format) != null ? _b : (_a5 = params == null ? void 0 : params.output_config) == null ? void 0 : _a5.format;
}
function maybeParseBetaMessage(message, params, opts) {
  const outputFormat = getOutputFormat(params);
  if (!params || !("parse" in (outputFormat != null ? outputFormat : {}))) {
    return {
      ...message,
      content: message.content.map((block) => {
        if (block.type === "text") {
          const parsedBlock = Object.defineProperty({ ...block }, "parsed_output", {
            value: null,
            enumerable: false
          });
          return Object.defineProperty(parsedBlock, "parsed", {
            get() {
              opts.logger.warn("The `parsed` property on `text` blocks is deprecated, please use `parsed_output` instead.");
              return null;
            },
            enumerable: false
          });
        }
        return block;
      }),
      parsed_output: null
    };
  }
  return parseBetaMessage(message, params, opts);
}
function parseBetaMessage(message, params, opts) {
  let firstParsedOutput = null;
  const content = message.content.map((block) => {
    if (block.type === "text") {
      const parsedOutput = parseBetaOutputFormat(params, block.text);
      if (firstParsedOutput === null) {
        firstParsedOutput = parsedOutput;
      }
      const parsedBlock = Object.defineProperty({ ...block }, "parsed_output", {
        value: parsedOutput,
        enumerable: false
      });
      return Object.defineProperty(parsedBlock, "parsed", {
        get() {
          opts.logger.warn("The `parsed` property on `text` blocks is deprecated, please use `parsed_output` instead.");
          return parsedOutput;
        },
        enumerable: false
      });
    }
    return block;
  });
  return {
    ...message,
    content,
    parsed_output: firstParsedOutput
  };
}
function parseBetaOutputFormat(params, content) {
  const outputFormat = getOutputFormat(params);
  if ((outputFormat == null ? void 0 : outputFormat.type) !== "json_schema") {
    return null;
  }
  try {
    if ("parse" in outputFormat) {
      return outputFormat.parse(content);
    }
    return JSON.parse(content);
  } catch (error) {
    throw new AnthropicError(`Failed to parse structured output: ${error}`);
  }
}

// node_modules/@anthropic-ai/sdk/_vendor/partial-json-parser/parser.mjs
var tokenize = (input) => {
  let current = 0;
  let tokens = [];
  while (current < input.length) {
    let char = input[current];
    if (char === "\\") {
      current++;
      continue;
    }
    if (char === "{") {
      tokens.push({
        type: "brace",
        value: "{"
      });
      current++;
      continue;
    }
    if (char === "}") {
      tokens.push({
        type: "brace",
        value: "}"
      });
      current++;
      continue;
    }
    if (char === "[") {
      tokens.push({
        type: "paren",
        value: "["
      });
      current++;
      continue;
    }
    if (char === "]") {
      tokens.push({
        type: "paren",
        value: "]"
      });
      current++;
      continue;
    }
    if (char === ":") {
      tokens.push({
        type: "separator",
        value: ":"
      });
      current++;
      continue;
    }
    if (char === ",") {
      tokens.push({
        type: "delimiter",
        value: ","
      });
      current++;
      continue;
    }
    if (char === '"') {
      let value = "";
      let danglingQuote = false;
      char = input[++current];
      while (char !== '"') {
        if (current === input.length) {
          danglingQuote = true;
          break;
        }
        if (char === "\\") {
          current++;
          if (current === input.length) {
            danglingQuote = true;
            break;
          }
          value += char + input[current];
          char = input[++current];
        } else {
          value += char;
          char = input[++current];
        }
      }
      char = input[++current];
      if (!danglingQuote) {
        tokens.push({
          type: "string",
          value
        });
      }
      continue;
    }
    let WHITESPACE = /\s/;
    if (char && WHITESPACE.test(char)) {
      current++;
      continue;
    }
    let NUMBERS = /[0-9]/;
    if (char && NUMBERS.test(char) || char === "-" || char === ".") {
      let value = "";
      if (char === "-") {
        value += char;
        char = input[++current];
      }
      while (char && NUMBERS.test(char) || char === ".") {
        value += char;
        char = input[++current];
      }
      tokens.push({
        type: "number",
        value
      });
      continue;
    }
    let LETTERS = /[a-z]/i;
    if (char && LETTERS.test(char)) {
      let value = "";
      while (char && LETTERS.test(char)) {
        if (current === input.length) {
          break;
        }
        value += char;
        char = input[++current];
      }
      if (value == "true" || value == "false" || value === "null") {
        tokens.push({
          type: "name",
          value
        });
      } else {
        current++;
        continue;
      }
      continue;
    }
    current++;
  }
  return tokens;
};
var strip = (tokens) => {
  if (tokens.length === 0) {
    return tokens;
  }
  let lastToken = tokens[tokens.length - 1];
  switch (lastToken.type) {
    case "separator":
      tokens = tokens.slice(0, tokens.length - 1);
      return strip(tokens);
      break;
    case "number":
      let lastCharacterOfLastToken = lastToken.value[lastToken.value.length - 1];
      if (lastCharacterOfLastToken === "." || lastCharacterOfLastToken === "-") {
        tokens = tokens.slice(0, tokens.length - 1);
        return strip(tokens);
      }
    case "string":
      let tokenBeforeTheLastToken = tokens[tokens.length - 2];
      if ((tokenBeforeTheLastToken == null ? void 0 : tokenBeforeTheLastToken.type) === "delimiter") {
        tokens = tokens.slice(0, tokens.length - 1);
        return strip(tokens);
      } else if ((tokenBeforeTheLastToken == null ? void 0 : tokenBeforeTheLastToken.type) === "brace" && tokenBeforeTheLastToken.value === "{") {
        tokens = tokens.slice(0, tokens.length - 1);
        return strip(tokens);
      }
      break;
    case "delimiter":
      tokens = tokens.slice(0, tokens.length - 1);
      return strip(tokens);
      break;
  }
  return tokens;
};
var unstrip = (tokens) => {
  let tail = [];
  tokens.map((token) => {
    if (token.type === "brace") {
      if (token.value === "{") {
        tail.push("}");
      } else {
        tail.splice(tail.lastIndexOf("}"), 1);
      }
    }
    if (token.type === "paren") {
      if (token.value === "[") {
        tail.push("]");
      } else {
        tail.splice(tail.lastIndexOf("]"), 1);
      }
    }
  });
  if (tail.length > 0) {
    tail.reverse().map((item) => {
      if (item === "}") {
        tokens.push({
          type: "brace",
          value: "}"
        });
      } else if (item === "]") {
        tokens.push({
          type: "paren",
          value: "]"
        });
      }
    });
  }
  return tokens;
};
var generate = (tokens) => {
  let output = "";
  tokens.map((token) => {
    switch (token.type) {
      case "string":
        output += '"' + token.value + '"';
        break;
      default:
        output += token.value;
        break;
    }
  });
  return output;
};
var partialParse2 = (input) => JSON.parse(generate(unstrip(strip(tokenize(input)))));

// node_modules/@anthropic-ai/sdk/lib/BetaMessageStream.mjs
var _BetaMessageStream_instances;
var _BetaMessageStream_currentMessageSnapshot;
var _BetaMessageStream_params;
var _BetaMessageStream_connectedPromise;
var _BetaMessageStream_resolveConnectedPromise;
var _BetaMessageStream_rejectConnectedPromise;
var _BetaMessageStream_endPromise;
var _BetaMessageStream_resolveEndPromise;
var _BetaMessageStream_rejectEndPromise;
var _BetaMessageStream_listeners;
var _BetaMessageStream_ended;
var _BetaMessageStream_errored;
var _BetaMessageStream_aborted;
var _BetaMessageStream_catchingPromiseCreated;
var _BetaMessageStream_response;
var _BetaMessageStream_request_id;
var _BetaMessageStream_logger;
var _BetaMessageStream_getFinalMessage;
var _BetaMessageStream_getFinalText;
var _BetaMessageStream_handleError;
var _BetaMessageStream_beginRequest;
var _BetaMessageStream_addStreamEvent;
var _BetaMessageStream_endRequest;
var _BetaMessageStream_accumulateMessage;
var JSON_BUF_PROPERTY = "__json_buf";
function tracksToolInput(content) {
  return content.type === "tool_use" || content.type === "server_tool_use" || content.type === "mcp_tool_use";
}
var BetaMessageStream = class _BetaMessageStream {
  constructor(params, opts) {
    var _a5;
    _BetaMessageStream_instances.add(this);
    this.messages = [];
    this.receivedMessages = [];
    _BetaMessageStream_currentMessageSnapshot.set(this, void 0);
    _BetaMessageStream_params.set(this, null);
    this.controller = new AbortController();
    _BetaMessageStream_connectedPromise.set(this, void 0);
    _BetaMessageStream_resolveConnectedPromise.set(this, () => {
    });
    _BetaMessageStream_rejectConnectedPromise.set(this, () => {
    });
    _BetaMessageStream_endPromise.set(this, void 0);
    _BetaMessageStream_resolveEndPromise.set(this, () => {
    });
    _BetaMessageStream_rejectEndPromise.set(this, () => {
    });
    _BetaMessageStream_listeners.set(this, {});
    _BetaMessageStream_ended.set(this, false);
    _BetaMessageStream_errored.set(this, false);
    _BetaMessageStream_aborted.set(this, false);
    _BetaMessageStream_catchingPromiseCreated.set(this, false);
    _BetaMessageStream_response.set(this, void 0);
    _BetaMessageStream_request_id.set(this, void 0);
    _BetaMessageStream_logger.set(this, void 0);
    _BetaMessageStream_handleError.set(this, (error) => {
      __classPrivateFieldSet2(this, _BetaMessageStream_errored, true, "f");
      if (isAbortError2(error)) {
        error = new APIUserAbortError2();
      }
      if (error instanceof APIUserAbortError2) {
        __classPrivateFieldSet2(this, _BetaMessageStream_aborted, true, "f");
        return this._emit("abort", error);
      }
      if (error instanceof AnthropicError) {
        return this._emit("error", error);
      }
      if (error instanceof Error) {
        const anthropicError = new AnthropicError(error.message);
        anthropicError.cause = error;
        return this._emit("error", anthropicError);
      }
      return this._emit("error", new AnthropicError(String(error)));
    });
    __classPrivateFieldSet2(this, _BetaMessageStream_connectedPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet2(this, _BetaMessageStream_resolveConnectedPromise, resolve, "f");
      __classPrivateFieldSet2(this, _BetaMessageStream_rejectConnectedPromise, reject, "f");
    }), "f");
    __classPrivateFieldSet2(this, _BetaMessageStream_endPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet2(this, _BetaMessageStream_resolveEndPromise, resolve, "f");
      __classPrivateFieldSet2(this, _BetaMessageStream_rejectEndPromise, reject, "f");
    }), "f");
    __classPrivateFieldGet2(this, _BetaMessageStream_connectedPromise, "f").catch(() => {
    });
    __classPrivateFieldGet2(this, _BetaMessageStream_endPromise, "f").catch(() => {
    });
    __classPrivateFieldSet2(this, _BetaMessageStream_params, params, "f");
    __classPrivateFieldSet2(this, _BetaMessageStream_logger, (_a5 = opts == null ? void 0 : opts.logger) != null ? _a5 : console, "f");
  }
  get response() {
    return __classPrivateFieldGet2(this, _BetaMessageStream_response, "f");
  }
  get request_id() {
    return __classPrivateFieldGet2(this, _BetaMessageStream_request_id, "f");
  }
  /**
   * Returns the `MessageStream` data, the raw `Response` instance and the ID of the request,
   * returned vie the `request-id` header which is useful for debugging requests and resporting
   * issues to Anthropic.
   *
   * This is the same as the `APIPromise.withResponse()` method.
   *
   * This method will raise an error if you created the stream using `MessageStream.fromReadableStream`
   * as no `Response` is available.
   */
  async withResponse() {
    __classPrivateFieldSet2(this, _BetaMessageStream_catchingPromiseCreated, true, "f");
    const response = await __classPrivateFieldGet2(this, _BetaMessageStream_connectedPromise, "f");
    if (!response) {
      throw new Error("Could not resolve a `Response` object");
    }
    return {
      data: this,
      response,
      request_id: response.headers.get("request-id")
    };
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(stream) {
    const runner = new _BetaMessageStream(null);
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  static createMessage(messages2, params, options, { logger } = {}) {
    const runner = new _BetaMessageStream(params, { logger });
    for (const message of params.messages) {
      runner._addMessageParam(message);
    }
    __classPrivateFieldSet2(runner, _BetaMessageStream_params, { ...params, stream: true }, "f");
    runner._run(() => runner._createMessage(messages2, { ...params, stream: true }, { ...options, headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" } }));
    return runner;
  }
  _run(executor) {
    executor().then(() => {
      this._emitFinal();
      this._emit("end");
    }, __classPrivateFieldGet2(this, _BetaMessageStream_handleError, "f"));
  }
  _addMessageParam(message) {
    this.messages.push(message);
  }
  _addMessage(message, emit = true) {
    this.receivedMessages.push(message);
    if (emit) {
      this._emit("message", message);
    }
  }
  async _createMessage(messages2, params, options) {
    var _a5;
    const signal = options == null ? void 0 : options.signal;
    let abortHandler;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      abortHandler = this.controller.abort.bind(this.controller);
      signal.addEventListener("abort", abortHandler);
    }
    try {
      __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_beginRequest).call(this);
      const { response, data: stream } = await messages2.create({ ...params, stream: true }, { ...options, signal: this.controller.signal }).withResponse();
      this._connected(response);
      for await (const event of stream) {
        __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_addStreamEvent).call(this, event);
      }
      if ((_a5 = stream.controller.signal) == null ? void 0 : _a5.aborted) {
        throw new APIUserAbortError2();
      }
      __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_endRequest).call(this);
    } finally {
      if (signal && abortHandler) {
        signal.removeEventListener("abort", abortHandler);
      }
    }
  }
  _connected(response) {
    if (this.ended)
      return;
    __classPrivateFieldSet2(this, _BetaMessageStream_response, response, "f");
    __classPrivateFieldSet2(this, _BetaMessageStream_request_id, response == null ? void 0 : response.headers.get("request-id"), "f");
    __classPrivateFieldGet2(this, _BetaMessageStream_resolveConnectedPromise, "f").call(this, response);
    this._emit("connect");
  }
  get ended() {
    return __classPrivateFieldGet2(this, _BetaMessageStream_ended, "f");
  }
  get errored() {
    return __classPrivateFieldGet2(this, _BetaMessageStream_errored, "f");
  }
  get aborted() {
    return __classPrivateFieldGet2(this, _BetaMessageStream_aborted, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this MessageStream, so that calls can be chained
   */
  on(event, listener) {
    const listeners = __classPrivateFieldGet2(this, _BetaMessageStream_listeners, "f")[event] || (__classPrivateFieldGet2(this, _BetaMessageStream_listeners, "f")[event] = []);
    listeners.push({ listener });
    return this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this MessageStream, so that calls can be chained
   */
  off(event, listener) {
    const listeners = __classPrivateFieldGet2(this, _BetaMessageStream_listeners, "f")[event];
    if (!listeners)
      return this;
    const index = listeners.findIndex((l3) => l3.listener === listener);
    if (index >= 0)
      listeners.splice(index, 1);
    return this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this MessageStream, so that calls can be chained
   */
  once(event, listener) {
    const listeners = __classPrivateFieldGet2(this, _BetaMessageStream_listeners, "f")[event] || (__classPrivateFieldGet2(this, _BetaMessageStream_listeners, "f")[event] = []);
    listeners.push({ listener, once: true });
    return this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(event) {
    return new Promise((resolve, reject) => {
      __classPrivateFieldSet2(this, _BetaMessageStream_catchingPromiseCreated, true, "f");
      if (event !== "error")
        this.once("error", reject);
      this.once(event, resolve);
    });
  }
  async done() {
    __classPrivateFieldSet2(this, _BetaMessageStream_catchingPromiseCreated, true, "f");
    await __classPrivateFieldGet2(this, _BetaMessageStream_endPromise, "f");
  }
  get currentMessage() {
    return __classPrivateFieldGet2(this, _BetaMessageStream_currentMessageSnapshot, "f");
  }
  /**
   * @returns a promise that resolves with the the final assistant Message response,
   * or rejects if an error occurred or the stream ended prematurely without producing a Message.
   * If structured outputs were used, this will be a ParsedMessage with a `parsed` field.
   */
  async finalMessage() {
    await this.done();
    return __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_getFinalMessage).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant Message's text response, concatenated
   * together if there are more than one text blocks.
   * Rejects if an error occurred or the stream ended prematurely without producing a Message.
   */
  async finalText() {
    await this.done();
    return __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_getFinalText).call(this);
  }
  _emit(event, ...args) {
    if (__classPrivateFieldGet2(this, _BetaMessageStream_ended, "f"))
      return;
    if (event === "end") {
      __classPrivateFieldSet2(this, _BetaMessageStream_ended, true, "f");
      __classPrivateFieldGet2(this, _BetaMessageStream_resolveEndPromise, "f").call(this);
    }
    const listeners = __classPrivateFieldGet2(this, _BetaMessageStream_listeners, "f")[event];
    if (listeners) {
      __classPrivateFieldGet2(this, _BetaMessageStream_listeners, "f")[event] = listeners.filter((l3) => !l3.once);
      listeners.forEach(({ listener }) => listener(...args));
    }
    if (event === "abort") {
      const error = args[0];
      if (!__classPrivateFieldGet2(this, _BetaMessageStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
        Promise.reject(error);
      }
      __classPrivateFieldGet2(this, _BetaMessageStream_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet2(this, _BetaMessageStream_rejectEndPromise, "f").call(this, error);
      this._emit("end");
      return;
    }
    if (event === "error") {
      const error = args[0];
      if (!__classPrivateFieldGet2(this, _BetaMessageStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
        Promise.reject(error);
      }
      __classPrivateFieldGet2(this, _BetaMessageStream_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet2(this, _BetaMessageStream_rejectEndPromise, "f").call(this, error);
      this._emit("end");
    }
  }
  _emitFinal() {
    const finalMessage = this.receivedMessages.at(-1);
    if (finalMessage) {
      this._emit("finalMessage", __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_getFinalMessage).call(this));
    }
  }
  async _fromReadableStream(readableStream, options) {
    var _a5;
    const signal = options == null ? void 0 : options.signal;
    let abortHandler;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      abortHandler = this.controller.abort.bind(this.controller);
      signal.addEventListener("abort", abortHandler);
    }
    try {
      __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_beginRequest).call(this);
      this._connected(null);
      const stream = Stream2.fromReadableStream(readableStream, this.controller);
      for await (const event of stream) {
        __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_addStreamEvent).call(this, event);
      }
      if ((_a5 = stream.controller.signal) == null ? void 0 : _a5.aborted) {
        throw new APIUserAbortError2();
      }
      __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_endRequest).call(this);
    } finally {
      if (signal && abortHandler) {
        signal.removeEventListener("abort", abortHandler);
      }
    }
  }
  [(_BetaMessageStream_currentMessageSnapshot = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_params = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_endPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_listeners = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_ended = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_errored = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_aborted = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_response = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_request_id = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_logger = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_handleError = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_instances = /* @__PURE__ */ new WeakSet(), _BetaMessageStream_getFinalMessage = function _BetaMessageStream_getFinalMessage2() {
    if (this.receivedMessages.length === 0) {
      throw new AnthropicError("stream ended without producing a Message with role=assistant");
    }
    return this.receivedMessages.at(-1);
  }, _BetaMessageStream_getFinalText = function _BetaMessageStream_getFinalText2() {
    if (this.receivedMessages.length === 0) {
      throw new AnthropicError("stream ended without producing a Message with role=assistant");
    }
    const textBlocks = this.receivedMessages.at(-1).content.filter((block) => block.type === "text").map((block) => block.text);
    if (textBlocks.length === 0) {
      throw new AnthropicError("stream ended without producing a content block with type=text");
    }
    return textBlocks.join(" ");
  }, _BetaMessageStream_beginRequest = function _BetaMessageStream_beginRequest2() {
    if (this.ended)
      return;
    __classPrivateFieldSet2(this, _BetaMessageStream_currentMessageSnapshot, void 0, "f");
  }, _BetaMessageStream_addStreamEvent = function _BetaMessageStream_addStreamEvent2(event) {
    var _a5;
    if (this.ended)
      return;
    const messageSnapshot = __classPrivateFieldGet2(this, _BetaMessageStream_instances, "m", _BetaMessageStream_accumulateMessage).call(this, event);
    this._emit("streamEvent", event, messageSnapshot);
    switch (event.type) {
      case "content_block_delta": {
        const content = messageSnapshot.content.at(-1);
        switch (event.delta.type) {
          case "text_delta": {
            if (content.type === "text") {
              this._emit("text", event.delta.text, content.text || "");
            }
            break;
          }
          case "citations_delta": {
            if (content.type === "text") {
              this._emit("citation", event.delta.citation, (_a5 = content.citations) != null ? _a5 : []);
            }
            break;
          }
          case "input_json_delta": {
            if (tracksToolInput(content) && content.input) {
              this._emit("inputJson", event.delta.partial_json, content.input);
            }
            break;
          }
          case "thinking_delta": {
            if (content.type === "thinking") {
              this._emit("thinking", event.delta.thinking, content.thinking);
            }
            break;
          }
          case "signature_delta": {
            if (content.type === "thinking") {
              this._emit("signature", content.signature);
            }
            break;
          }
          case "compaction_delta": {
            if (content.type === "compaction" && content.content) {
              this._emit("compaction", content.content);
            }
            break;
          }
          default:
            checkNever(event.delta);
        }
        break;
      }
      case "message_stop": {
        this._addMessageParam(messageSnapshot);
        this._addMessage(maybeParseBetaMessage(messageSnapshot, __classPrivateFieldGet2(this, _BetaMessageStream_params, "f"), { logger: __classPrivateFieldGet2(this, _BetaMessageStream_logger, "f") }), true);
        break;
      }
      case "content_block_stop": {
        this._emit("contentBlock", messageSnapshot.content.at(-1));
        break;
      }
      case "message_start": {
        __classPrivateFieldSet2(this, _BetaMessageStream_currentMessageSnapshot, messageSnapshot, "f");
        break;
      }
      case "content_block_start":
      case "message_delta":
        break;
    }
  }, _BetaMessageStream_endRequest = function _BetaMessageStream_endRequest2() {
    if (this.ended) {
      throw new AnthropicError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet2(this, _BetaMessageStream_currentMessageSnapshot, "f");
    if (!snapshot) {
      throw new AnthropicError(`request ended without sending any chunks`);
    }
    __classPrivateFieldSet2(this, _BetaMessageStream_currentMessageSnapshot, void 0, "f");
    return maybeParseBetaMessage(snapshot, __classPrivateFieldGet2(this, _BetaMessageStream_params, "f"), { logger: __classPrivateFieldGet2(this, _BetaMessageStream_logger, "f") });
  }, _BetaMessageStream_accumulateMessage = function _BetaMessageStream_accumulateMessage2(event) {
    var _a5;
    let snapshot = __classPrivateFieldGet2(this, _BetaMessageStream_currentMessageSnapshot, "f");
    if (event.type === "message_start") {
      if (snapshot) {
        throw new AnthropicError(`Unexpected event order, got ${event.type} before receiving "message_stop"`);
      }
      return event.message;
    }
    if (!snapshot) {
      throw new AnthropicError(`Unexpected event order, got ${event.type} before "message_start"`);
    }
    switch (event.type) {
      case "message_stop":
        return snapshot;
      case "message_delta":
        snapshot.container = event.delta.container;
        snapshot.stop_reason = event.delta.stop_reason;
        snapshot.stop_sequence = event.delta.stop_sequence;
        snapshot.usage.output_tokens = event.usage.output_tokens;
        snapshot.context_management = event.context_management;
        if (event.usage.input_tokens != null) {
          snapshot.usage.input_tokens = event.usage.input_tokens;
        }
        if (event.usage.cache_creation_input_tokens != null) {
          snapshot.usage.cache_creation_input_tokens = event.usage.cache_creation_input_tokens;
        }
        if (event.usage.cache_read_input_tokens != null) {
          snapshot.usage.cache_read_input_tokens = event.usage.cache_read_input_tokens;
        }
        if (event.usage.server_tool_use != null) {
          snapshot.usage.server_tool_use = event.usage.server_tool_use;
        }
        if (event.usage.iterations != null) {
          snapshot.usage.iterations = event.usage.iterations;
        }
        return snapshot;
      case "content_block_start":
        snapshot.content.push(event.content_block);
        return snapshot;
      case "content_block_delta": {
        const snapshotContent = snapshot.content.at(event.index);
        switch (event.delta.type) {
          case "text_delta": {
            if ((snapshotContent == null ? void 0 : snapshotContent.type) === "text") {
              snapshot.content[event.index] = {
                ...snapshotContent,
                text: (snapshotContent.text || "") + event.delta.text
              };
            }
            break;
          }
          case "citations_delta": {
            if ((snapshotContent == null ? void 0 : snapshotContent.type) === "text") {
              snapshot.content[event.index] = {
                ...snapshotContent,
                citations: [...(_a5 = snapshotContent.citations) != null ? _a5 : [], event.delta.citation]
              };
            }
            break;
          }
          case "input_json_delta": {
            if (snapshotContent && tracksToolInput(snapshotContent)) {
              let jsonBuf = snapshotContent[JSON_BUF_PROPERTY] || "";
              jsonBuf += event.delta.partial_json;
              const newContent = { ...snapshotContent };
              Object.defineProperty(newContent, JSON_BUF_PROPERTY, {
                value: jsonBuf,
                enumerable: false,
                writable: true
              });
              if (jsonBuf) {
                try {
                  newContent.input = partialParse2(jsonBuf);
                } catch (err) {
                  const error = new AnthropicError(`Unable to parse tool parameter JSON from model. Please retry your request or adjust your prompt. Error: ${err}. JSON: ${jsonBuf}`);
                  __classPrivateFieldGet2(this, _BetaMessageStream_handleError, "f").call(this, error);
                }
              }
              snapshot.content[event.index] = newContent;
            }
            break;
          }
          case "thinking_delta": {
            if ((snapshotContent == null ? void 0 : snapshotContent.type) === "thinking") {
              snapshot.content[event.index] = {
                ...snapshotContent,
                thinking: snapshotContent.thinking + event.delta.thinking
              };
            }
            break;
          }
          case "signature_delta": {
            if ((snapshotContent == null ? void 0 : snapshotContent.type) === "thinking") {
              snapshot.content[event.index] = {
                ...snapshotContent,
                signature: event.delta.signature
              };
            }
            break;
          }
          case "compaction_delta": {
            if ((snapshotContent == null ? void 0 : snapshotContent.type) === "compaction") {
              snapshot.content[event.index] = {
                ...snapshotContent,
                content: (snapshotContent.content || "") + event.delta.content
              };
            }
            break;
          }
          default:
            checkNever(event.delta);
        }
        return snapshot;
      }
      case "content_block_stop":
        return snapshot;
    }
  }, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("streamEvent", (event) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(event);
      } else {
        pushQueue.push(event);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  toReadableStream() {
    const stream = new Stream2(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
};
function checkNever(x3) {
}

// node_modules/@anthropic-ai/sdk/lib/tools/ToolError.mjs
var ToolError = class extends Error {
  constructor(content) {
    const message = typeof content === "string" ? content : content.map((block) => {
      if (block.type === "text")
        return block.text;
      return `[${block.type}]`;
    }).join(" ");
    super(message);
    this.name = "ToolError";
    this.content = content;
  }
};

// node_modules/@anthropic-ai/sdk/lib/tools/CompactionControl.mjs
var DEFAULT_TOKEN_THRESHOLD = 1e5;
var DEFAULT_SUMMARY_PROMPT = `You have been working on the task described above but have not yet completed it. Write a continuation summary that will allow you (or another instance of yourself) to resume work efficiently in a future context window where the conversation history will be replaced with this summary. Your summary should be structured, concise, and actionable. Include:
1. Task Overview
The user's core request and success criteria
Any clarifications or constraints they specified
2. Current State
What has been completed so far
Files created, modified, or analyzed (with paths if relevant)
Key outputs or artifacts produced
3. Important Discoveries
Technical constraints or requirements uncovered
Decisions made and their rationale
Errors encountered and how they were resolved
What approaches were tried that didn't work (and why)
4. Next Steps
Specific actions needed to complete the task
Any blockers or open questions to resolve
Priority order if multiple steps remain
5. Context to Preserve
User preferences or style requirements
Domain-specific details that aren't obvious
Any promises made to the user
Be concise but complete\u2014err on the side of including information that would prevent duplicate work or repeated mistakes. Write in a way that enables immediate resumption of the task.
Wrap your summary in <summary></summary> tags.`;

// node_modules/@anthropic-ai/sdk/lib/tools/BetaToolRunner.mjs
var _BetaToolRunner_instances;
var _BetaToolRunner_consumed;
var _BetaToolRunner_mutated;
var _BetaToolRunner_state;
var _BetaToolRunner_options;
var _BetaToolRunner_message;
var _BetaToolRunner_toolResponse;
var _BetaToolRunner_completion;
var _BetaToolRunner_iterationCount;
var _BetaToolRunner_checkAndCompact;
var _BetaToolRunner_generateToolResponse;
function promiseWithResolvers() {
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { promise, resolve, reject };
}
var BetaToolRunner = class {
  constructor(client, params, options) {
    _BetaToolRunner_instances.add(this);
    this.client = client;
    _BetaToolRunner_consumed.set(this, false);
    _BetaToolRunner_mutated.set(this, false);
    _BetaToolRunner_state.set(this, void 0);
    _BetaToolRunner_options.set(this, void 0);
    _BetaToolRunner_message.set(this, void 0);
    _BetaToolRunner_toolResponse.set(this, void 0);
    _BetaToolRunner_completion.set(this, void 0);
    _BetaToolRunner_iterationCount.set(this, 0);
    __classPrivateFieldSet2(this, _BetaToolRunner_state, {
      params: {
        // You can't clone the entire params since there are functions as handlers.
        // You also don't really need to clone params.messages, but it probably will prevent a foot gun
        // somewhere.
        ...params,
        messages: structuredClone(params.messages)
      }
    }, "f");
    const helpers = collectStainlessHelpers(params.tools, params.messages);
    const helperValue = ["BetaToolRunner", ...helpers].join(", ");
    __classPrivateFieldSet2(this, _BetaToolRunner_options, {
      ...options,
      headers: buildHeaders2([{ "x-stainless-helper": helperValue }, options == null ? void 0 : options.headers])
    }, "f");
    __classPrivateFieldSet2(this, _BetaToolRunner_completion, promiseWithResolvers(), "f");
  }
  async *[(_BetaToolRunner_consumed = /* @__PURE__ */ new WeakMap(), _BetaToolRunner_mutated = /* @__PURE__ */ new WeakMap(), _BetaToolRunner_state = /* @__PURE__ */ new WeakMap(), _BetaToolRunner_options = /* @__PURE__ */ new WeakMap(), _BetaToolRunner_message = /* @__PURE__ */ new WeakMap(), _BetaToolRunner_toolResponse = /* @__PURE__ */ new WeakMap(), _BetaToolRunner_completion = /* @__PURE__ */ new WeakMap(), _BetaToolRunner_iterationCount = /* @__PURE__ */ new WeakMap(), _BetaToolRunner_instances = /* @__PURE__ */ new WeakSet(), _BetaToolRunner_checkAndCompact = async function _BetaToolRunner_checkAndCompact2() {
    var _a5, _b, _c, _d, _e, _f;
    const compactionControl = __classPrivateFieldGet2(this, _BetaToolRunner_state, "f").params.compactionControl;
    if (!compactionControl || !compactionControl.enabled) {
      return false;
    }
    let tokensUsed = 0;
    if (__classPrivateFieldGet2(this, _BetaToolRunner_message, "f") !== void 0) {
      try {
        const message = await __classPrivateFieldGet2(this, _BetaToolRunner_message, "f");
        const totalInputTokens = message.usage.input_tokens + ((_a5 = message.usage.cache_creation_input_tokens) != null ? _a5 : 0) + ((_b = message.usage.cache_read_input_tokens) != null ? _b : 0);
        tokensUsed = totalInputTokens + message.usage.output_tokens;
      } catch (e3) {
        return false;
      }
    }
    const threshold = (_c = compactionControl.contextTokenThreshold) != null ? _c : DEFAULT_TOKEN_THRESHOLD;
    if (tokensUsed < threshold) {
      return false;
    }
    const model = (_d = compactionControl.model) != null ? _d : __classPrivateFieldGet2(this, _BetaToolRunner_state, "f").params.model;
    const summaryPrompt = (_e = compactionControl.summaryPrompt) != null ? _e : DEFAULT_SUMMARY_PROMPT;
    const messages2 = __classPrivateFieldGet2(this, _BetaToolRunner_state, "f").params.messages;
    if (messages2[messages2.length - 1].role === "assistant") {
      const lastMessage = messages2[messages2.length - 1];
      if (Array.isArray(lastMessage.content)) {
        const nonToolBlocks = lastMessage.content.filter((block) => block.type !== "tool_use");
        if (nonToolBlocks.length === 0) {
          messages2.pop();
        } else {
          lastMessage.content = nonToolBlocks;
        }
      }
    }
    const response = await this.client.beta.messages.create({
      model,
      messages: [
        ...messages2,
        {
          role: "user",
          content: [
            {
              type: "text",
              text: summaryPrompt
            }
          ]
        }
      ],
      max_tokens: __classPrivateFieldGet2(this, _BetaToolRunner_state, "f").params.max_tokens
    }, {
      headers: { "x-stainless-helper": "compaction" }
    });
    if (((_f = response.content[0]) == null ? void 0 : _f.type) !== "text") {
      throw new AnthropicError("Expected text response for compaction");
    }
    __classPrivateFieldGet2(this, _BetaToolRunner_state, "f").params.messages = [
      {
        role: "user",
        content: response.content
      }
    ];
    return true;
  }, Symbol.asyncIterator)]() {
    var _a5;
    if (__classPrivateFieldGet2(this, _BetaToolRunner_consumed, "f")) {
      throw new AnthropicError("Cannot iterate over a consumed stream");
    }
    __classPrivateFieldSet2(this, _BetaToolRunner_consumed, true, "f");
    __classPrivateFieldSet2(this, _BetaToolRunner_mutated, true, "f");
    __classPrivateFieldSet2(this, _BetaToolRunner_toolResponse, void 0, "f");
    try {
      while (true) {
        let stream;
        try {
          if (__classPrivateFieldGet2(this, _BetaToolRunner_state, "f").params.max_iterations && __classPrivateFieldGet2(this, _BetaToolRunner_iterationCount, "f") >= __classPrivateFieldGet2(this, _BetaToolRunner_state, "f").params.max_iterations) {
            break;
          }
          __classPrivateFieldSet2(this, _BetaToolRunner_mutated, false, "f");
          __classPrivateFieldSet2(this, _BetaToolRunner_toolResponse, void 0, "f");
          __classPrivateFieldSet2(this, _BetaToolRunner_iterationCount, (_a5 = __classPrivateFieldGet2(this, _BetaToolRunner_iterationCount, "f"), _a5++, _a5), "f");
          __classPrivateFieldSet2(this, _BetaToolRunner_message, void 0, "f");
          const { max_iterations, compactionControl, ...params } = __classPrivateFieldGet2(this, _BetaToolRunner_state, "f").params;
          if (params.stream) {
            stream = this.client.beta.messages.stream({ ...params }, __classPrivateFieldGet2(this, _BetaToolRunner_options, "f"));
            __classPrivateFieldSet2(this, _BetaToolRunner_message, stream.finalMessage(), "f");
            __classPrivateFieldGet2(this, _BetaToolRunner_message, "f").catch(() => {
            });
            yield stream;
          } else {
            __classPrivateFieldSet2(this, _BetaToolRunner_message, this.client.beta.messages.create({ ...params, stream: false }, __classPrivateFieldGet2(this, _BetaToolRunner_options, "f")), "f");
            yield __classPrivateFieldGet2(this, _BetaToolRunner_message, "f");
          }
          const isCompacted = await __classPrivateFieldGet2(this, _BetaToolRunner_instances, "m", _BetaToolRunner_checkAndCompact).call(this);
          if (!isCompacted) {
            if (!__classPrivateFieldGet2(this, _BetaToolRunner_mutated, "f")) {
              const { role, content } = await __classPrivateFieldGet2(this, _BetaToolRunner_message, "f");
              __classPrivateFieldGet2(this, _BetaToolRunner_state, "f").params.messages.push({ role, content });
            }
            const toolMessage = await __classPrivateFieldGet2(this, _BetaToolRunner_instances, "m", _BetaToolRunner_generateToolResponse).call(this, __classPrivateFieldGet2(this, _BetaToolRunner_state, "f").params.messages.at(-1));
            if (toolMessage) {
              __classPrivateFieldGet2(this, _BetaToolRunner_state, "f").params.messages.push(toolMessage);
            } else if (!__classPrivateFieldGet2(this, _BetaToolRunner_mutated, "f")) {
              break;
            }
          }
        } finally {
          if (stream) {
            stream.abort();
          }
        }
      }
      if (!__classPrivateFieldGet2(this, _BetaToolRunner_message, "f")) {
        throw new AnthropicError("ToolRunner concluded without a message from the server");
      }
      __classPrivateFieldGet2(this, _BetaToolRunner_completion, "f").resolve(await __classPrivateFieldGet2(this, _BetaToolRunner_message, "f"));
    } catch (error) {
      __classPrivateFieldSet2(this, _BetaToolRunner_consumed, false, "f");
      __classPrivateFieldGet2(this, _BetaToolRunner_completion, "f").promise.catch(() => {
      });
      __classPrivateFieldGet2(this, _BetaToolRunner_completion, "f").reject(error);
      __classPrivateFieldSet2(this, _BetaToolRunner_completion, promiseWithResolvers(), "f");
      throw error;
    }
  }
  setMessagesParams(paramsOrMutator) {
    if (typeof paramsOrMutator === "function") {
      __classPrivateFieldGet2(this, _BetaToolRunner_state, "f").params = paramsOrMutator(__classPrivateFieldGet2(this, _BetaToolRunner_state, "f").params);
    } else {
      __classPrivateFieldGet2(this, _BetaToolRunner_state, "f").params = paramsOrMutator;
    }
    __classPrivateFieldSet2(this, _BetaToolRunner_mutated, true, "f");
    __classPrivateFieldSet2(this, _BetaToolRunner_toolResponse, void 0, "f");
  }
  /**
   * Get the tool response for the last message from the assistant.
   * Avoids redundant tool executions by caching results.
   *
   * @returns A promise that resolves to a BetaMessageParam containing tool results, or null if no tools need to be executed
   *
   * @example
   * const toolResponse = await runner.generateToolResponse();
   * if (toolResponse) {
   *   console.log('Tool results:', toolResponse.content);
   * }
   */
  async generateToolResponse() {
    var _a5;
    const message = (_a5 = await __classPrivateFieldGet2(this, _BetaToolRunner_message, "f")) != null ? _a5 : this.params.messages.at(-1);
    if (!message) {
      return null;
    }
    return __classPrivateFieldGet2(this, _BetaToolRunner_instances, "m", _BetaToolRunner_generateToolResponse).call(this, message);
  }
  /**
   * Wait for the async iterator to complete. This works even if the async iterator hasn't yet started, and
   * will wait for an instance to start and go to completion.
   *
   * @returns A promise that resolves to the final BetaMessage when the iterator completes
   *
   * @example
   * // Start consuming the iterator
   * for await (const message of runner) {
   *   console.log('Message:', message.content);
   * }
   *
   * // Meanwhile, wait for completion from another part of the code
   * const finalMessage = await runner.done();
   * console.log('Final response:', finalMessage.content);
   */
  done() {
    return __classPrivateFieldGet2(this, _BetaToolRunner_completion, "f").promise;
  }
  /**
   * Returns a promise indicating that the stream is done. Unlike .done(), this will eagerly read the stream:
   * * If the iterator has not been consumed, consume the entire iterator and return the final message from the
   * assistant.
   * * If the iterator has been consumed, waits for it to complete and returns the final message.
   *
   * @returns A promise that resolves to the final BetaMessage from the conversation
   * @throws {AnthropicError} If no messages were processed during the conversation
   *
   * @example
   * const finalMessage = await runner.runUntilDone();
   * console.log('Final response:', finalMessage.content);
   */
  async runUntilDone() {
    if (!__classPrivateFieldGet2(this, _BetaToolRunner_consumed, "f")) {
      for await (const _ of this) {
      }
    }
    return this.done();
  }
  /**
   * Get the current parameters being used by the ToolRunner.
   *
   * @returns A readonly view of the current ToolRunnerParams
   *
   * @example
   * const currentParams = runner.params;
   * console.log('Current model:', currentParams.model);
   * console.log('Message count:', currentParams.messages.length);
   */
  get params() {
    return __classPrivateFieldGet2(this, _BetaToolRunner_state, "f").params;
  }
  /**
   * Add one or more messages to the conversation history.
   *
   * @param messages - One or more BetaMessageParam objects to add to the conversation
   *
   * @example
   * runner.pushMessages(
   *   { role: 'user', content: 'Also, what about the weather in NYC?' }
   * );
   *
   * @example
   * // Adding multiple messages
   * runner.pushMessages(
   *   { role: 'user', content: 'What about NYC?' },
   *   { role: 'user', content: 'And Boston?' }
   * );
   */
  pushMessages(...messages2) {
    this.setMessagesParams((params) => ({
      ...params,
      messages: [...params.messages, ...messages2]
    }));
  }
  /**
   * Makes the ToolRunner directly awaitable, equivalent to calling .runUntilDone()
   * This allows using `await runner` instead of `await runner.runUntilDone()`
   */
  then(onfulfilled, onrejected) {
    return this.runUntilDone().then(onfulfilled, onrejected);
  }
};
_BetaToolRunner_generateToolResponse = async function _BetaToolRunner_generateToolResponse2(lastMessage) {
  if (__classPrivateFieldGet2(this, _BetaToolRunner_toolResponse, "f") !== void 0) {
    return __classPrivateFieldGet2(this, _BetaToolRunner_toolResponse, "f");
  }
  __classPrivateFieldSet2(this, _BetaToolRunner_toolResponse, generateToolResponse(__classPrivateFieldGet2(this, _BetaToolRunner_state, "f").params, lastMessage), "f");
  return __classPrivateFieldGet2(this, _BetaToolRunner_toolResponse, "f");
};
async function generateToolResponse(params, lastMessage = params.messages.at(-1)) {
  if (!lastMessage || lastMessage.role !== "assistant" || !lastMessage.content || typeof lastMessage.content === "string") {
    return null;
  }
  const toolUseBlocks = lastMessage.content.filter((content) => content.type === "tool_use");
  if (toolUseBlocks.length === 0) {
    return null;
  }
  const toolResults = await Promise.all(toolUseBlocks.map(async (toolUse) => {
    const tool = params.tools.find((t) => ("name" in t ? t.name : t.mcp_server_name) === toolUse.name);
    if (!tool || !("run" in tool)) {
      return {
        type: "tool_result",
        tool_use_id: toolUse.id,
        content: `Error: Tool '${toolUse.name}' not found`,
        is_error: true
      };
    }
    try {
      let input = toolUse.input;
      if ("parse" in tool && tool.parse) {
        input = tool.parse(input);
      }
      const result = await tool.run(input);
      return {
        type: "tool_result",
        tool_use_id: toolUse.id,
        content: result
      };
    } catch (error) {
      return {
        type: "tool_result",
        tool_use_id: toolUse.id,
        content: error instanceof ToolError ? error.content : `Error: ${error instanceof Error ? error.message : String(error)}`,
        is_error: true
      };
    }
  }));
  return {
    role: "user",
    content: toolResults
  };
}

// node_modules/@anthropic-ai/sdk/internal/decoders/jsonl.mjs
var JSONLDecoder = class _JSONLDecoder {
  constructor(iterator, controller) {
    this.iterator = iterator;
    this.controller = controller;
  }
  async *decoder() {
    const lineDecoder = new LineDecoder2();
    for await (const chunk of this.iterator) {
      for (const line of lineDecoder.decode(chunk)) {
        yield JSON.parse(line);
      }
    }
    for (const line of lineDecoder.flush()) {
      yield JSON.parse(line);
    }
  }
  [Symbol.asyncIterator]() {
    return this.decoder();
  }
  static fromResponse(response, controller) {
    if (!response.body) {
      controller.abort();
      if (typeof globalThis.navigator !== "undefined" && globalThis.navigator.product === "ReactNative") {
        throw new AnthropicError(`The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api`);
      }
      throw new AnthropicError(`Attempted to iterate over a response with no body`);
    }
    return new _JSONLDecoder(ReadableStreamToAsyncIterable2(response.body), controller);
  }
};

// node_modules/@anthropic-ai/sdk/resources/beta/messages/batches.mjs
var Batches2 = class extends APIResource2 {
  /**
   * Send a batch of Message creation requests.
   *
   * The Message Batches API can be used to process multiple Messages API requests at
   * once. Once a Message Batch is created, it begins processing immediately. Batches
   * can take up to 24 hours to complete.
   *
   * Learn more about the Message Batches API in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const betaMessageBatch =
   *   await client.beta.messages.batches.create({
   *     requests: [
   *       {
   *         custom_id: 'my-custom-id-1',
   *         params: {
   *           max_tokens: 1024,
   *           messages: [
   *             { content: 'Hello, world', role: 'user' },
   *           ],
   *           model: 'claude-opus-4-6',
   *         },
   *       },
   *     ],
   *   });
   * ```
   */
  create(params, options) {
    const { betas, ...body } = params;
    return this._client.post("/v1/messages/batches?beta=true", {
      body,
      ...options,
      headers: buildHeaders2([
        { "anthropic-beta": [...betas != null ? betas : [], "message-batches-2024-09-24"].toString() },
        options == null ? void 0 : options.headers
      ])
    });
  }
  /**
   * This endpoint is idempotent and can be used to poll for Message Batch
   * completion. To access the results of a Message Batch, make a request to the
   * `results_url` field in the response.
   *
   * Learn more about the Message Batches API in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const betaMessageBatch =
   *   await client.beta.messages.batches.retrieve(
   *     'message_batch_id',
   *   );
   * ```
   */
  retrieve(messageBatchID, params = {}, options) {
    const { betas } = params != null ? params : {};
    return this._client.get(path2`/v1/messages/batches/${messageBatchID}?beta=true`, {
      ...options,
      headers: buildHeaders2([
        { "anthropic-beta": [...betas != null ? betas : [], "message-batches-2024-09-24"].toString() },
        options == null ? void 0 : options.headers
      ])
    });
  }
  /**
   * List all Message Batches within a Workspace. Most recently created batches are
   * returned first.
   *
   * Learn more about the Message Batches API in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const betaMessageBatch of client.beta.messages.batches.list()) {
   *   // ...
   * }
   * ```
   */
  list(params = {}, options) {
    const { betas, ...query } = params != null ? params : {};
    return this._client.getAPIList("/v1/messages/batches?beta=true", Page2, {
      query,
      ...options,
      headers: buildHeaders2([
        { "anthropic-beta": [...betas != null ? betas : [], "message-batches-2024-09-24"].toString() },
        options == null ? void 0 : options.headers
      ])
    });
  }
  /**
   * Delete a Message Batch.
   *
   * Message Batches can only be deleted once they've finished processing. If you'd
   * like to delete an in-progress batch, you must first cancel it.
   *
   * Learn more about the Message Batches API in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const betaDeletedMessageBatch =
   *   await client.beta.messages.batches.delete(
   *     'message_batch_id',
   *   );
   * ```
   */
  delete(messageBatchID, params = {}, options) {
    const { betas } = params != null ? params : {};
    return this._client.delete(path2`/v1/messages/batches/${messageBatchID}?beta=true`, {
      ...options,
      headers: buildHeaders2([
        { "anthropic-beta": [...betas != null ? betas : [], "message-batches-2024-09-24"].toString() },
        options == null ? void 0 : options.headers
      ])
    });
  }
  /**
   * Batches may be canceled any time before processing ends. Once cancellation is
   * initiated, the batch enters a `canceling` state, at which time the system may
   * complete any in-progress, non-interruptible requests before finalizing
   * cancellation.
   *
   * The number of canceled requests is specified in `request_counts`. To determine
   * which requests were canceled, check the individual results within the batch.
   * Note that cancellation may not result in any canceled requests if they were
   * non-interruptible.
   *
   * Learn more about the Message Batches API in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const betaMessageBatch =
   *   await client.beta.messages.batches.cancel(
   *     'message_batch_id',
   *   );
   * ```
   */
  cancel(messageBatchID, params = {}, options) {
    const { betas } = params != null ? params : {};
    return this._client.post(path2`/v1/messages/batches/${messageBatchID}/cancel?beta=true`, {
      ...options,
      headers: buildHeaders2([
        { "anthropic-beta": [...betas != null ? betas : [], "message-batches-2024-09-24"].toString() },
        options == null ? void 0 : options.headers
      ])
    });
  }
  /**
   * Streams the results of a Message Batch as a `.jsonl` file.
   *
   * Each line in the file is a JSON object containing the result of a single request
   * in the Message Batch. Results are not guaranteed to be in the same order as
   * requests. Use the `custom_id` field to match results to requests.
   *
   * Learn more about the Message Batches API in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const betaMessageBatchIndividualResponse =
   *   await client.beta.messages.batches.results(
   *     'message_batch_id',
   *   );
   * ```
   */
  async results(messageBatchID, params = {}, options) {
    const batch = await this.retrieve(messageBatchID);
    if (!batch.results_url) {
      throw new AnthropicError(`No batch \`results_url\`; Has it finished processing? ${batch.processing_status} - ${batch.id}`);
    }
    const { betas } = params != null ? params : {};
    return this._client.get(batch.results_url, {
      ...options,
      headers: buildHeaders2([
        {
          "anthropic-beta": [...betas != null ? betas : [], "message-batches-2024-09-24"].toString(),
          Accept: "application/binary"
        },
        options == null ? void 0 : options.headers
      ]),
      stream: true,
      __binaryResponse: true
    })._thenUnwrap((_, props) => JSONLDecoder.fromResponse(props.response, props.controller));
  }
};

// node_modules/@anthropic-ai/sdk/resources/beta/messages/messages.mjs
var DEPRECATED_MODELS = {
  "claude-1.3": "November 6th, 2024",
  "claude-1.3-100k": "November 6th, 2024",
  "claude-instant-1.1": "November 6th, 2024",
  "claude-instant-1.1-100k": "November 6th, 2024",
  "claude-instant-1.2": "November 6th, 2024",
  "claude-3-sonnet-20240229": "July 21st, 2025",
  "claude-3-opus-20240229": "January 5th, 2026",
  "claude-2.1": "July 21st, 2025",
  "claude-2.0": "July 21st, 2025",
  "claude-3-7-sonnet-latest": "February 19th, 2026",
  "claude-3-7-sonnet-20250219": "February 19th, 2026"
};
var MODELS_TO_WARN_WITH_THINKING_ENABLED = ["claude-opus-4-6"];
var Messages3 = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.batches = new Batches2(this._client);
  }
  create(params, options) {
    var _a5, _b;
    const modifiedParams = transformOutputFormat(params);
    const { betas, ...body } = modifiedParams;
    if (body.model in DEPRECATED_MODELS) {
      console.warn(`The model '${body.model}' is deprecated and will reach end-of-life on ${DEPRECATED_MODELS[body.model]}
Please migrate to a newer model. Visit https://docs.anthropic.com/en/docs/resources/model-deprecations for more information.`);
    }
    if (body.model in MODELS_TO_WARN_WITH_THINKING_ENABLED && body.thinking && body.thinking.type === "enabled") {
      console.warn(`Using Claude with ${body.model} and 'thinking.type=enabled' is deprecated. Use 'thinking.type=adaptive' instead which results in better model performance in our testing: https://platform.claude.com/docs/en/build-with-claude/adaptive-thinking`);
    }
    let timeout = this._client._options.timeout;
    if (!body.stream && timeout == null) {
      const maxNonstreamingTokens = (_a5 = MODEL_NONSTREAMING_TOKENS[body.model]) != null ? _a5 : void 0;
      timeout = this._client.calculateNonstreamingTimeout(body.max_tokens, maxNonstreamingTokens);
    }
    const helperHeader = stainlessHelperHeader(body.tools, body.messages);
    return this._client.post("/v1/messages?beta=true", {
      body,
      timeout: timeout != null ? timeout : 6e5,
      ...options,
      headers: buildHeaders2([
        { ...(betas == null ? void 0 : betas.toString()) != null ? { "anthropic-beta": betas == null ? void 0 : betas.toString() } : void 0 },
        helperHeader,
        options == null ? void 0 : options.headers
      ]),
      stream: (_b = modifiedParams.stream) != null ? _b : false
    });
  }
  /**
   * Send a structured list of input messages with text and/or image content, along with an expected `output_format` and
   * the response will be automatically parsed and available in the `parsed_output` property of the message.
   *
   * @example
   * ```ts
   * const message = await client.beta.messages.parse({
   *   model: 'claude-3-5-sonnet-20241022',
   *   max_tokens: 1024,
   *   messages: [{ role: 'user', content: 'What is 2+2?' }],
   *   output_format: zodOutputFormat(z.object({ answer: z.number() }), 'math'),
   * });
   *
   * console.log(message.parsed_output?.answer); // 4
   * ```
   */
  parse(params, options) {
    var _a5;
    options = {
      ...options,
      headers: buildHeaders2([
        { "anthropic-beta": [...(_a5 = params.betas) != null ? _a5 : [], "structured-outputs-2025-12-15"].toString() },
        options == null ? void 0 : options.headers
      ])
    };
    return this.create(params, options).then((message) => {
      var _a6;
      return parseBetaMessage(message, params, { logger: (_a6 = this._client.logger) != null ? _a6 : console });
    });
  }
  /**
   * Create a Message stream
   */
  stream(body, options) {
    return BetaMessageStream.createMessage(this, body, options);
  }
  /**
   * Count the number of tokens in a Message.
   *
   * The Token Count API can be used to count the number of tokens in a Message,
   * including tools, images, and documents, without creating it.
   *
   * Learn more about token counting in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/token-counting)
   *
   * @example
   * ```ts
   * const betaMessageTokensCount =
   *   await client.beta.messages.countTokens({
   *     messages: [{ content: 'string', role: 'user' }],
   *     model: 'claude-opus-4-6',
   *   });
   * ```
   */
  countTokens(params, options) {
    const modifiedParams = transformOutputFormat(params);
    const { betas, ...body } = modifiedParams;
    return this._client.post("/v1/messages/count_tokens?beta=true", {
      body,
      ...options,
      headers: buildHeaders2([
        { "anthropic-beta": [...betas != null ? betas : [], "token-counting-2024-11-01"].toString() },
        options == null ? void 0 : options.headers
      ])
    });
  }
  toolRunner(body, options) {
    return new BetaToolRunner(this._client, body, options);
  }
};
function transformOutputFormat(params) {
  var _a5;
  if (!params.output_format) {
    return params;
  }
  if ((_a5 = params.output_config) == null ? void 0 : _a5.format) {
    throw new AnthropicError("Both output_format and output_config.format were provided. Please use only output_config.format (output_format is deprecated).");
  }
  const { output_format, ...rest } = params;
  return {
    ...rest,
    output_config: {
      ...params.output_config,
      format: output_format
    }
  };
}
Messages3.Batches = Batches2;
Messages3.BetaToolRunner = BetaToolRunner;
Messages3.ToolError = ToolError;

// node_modules/@anthropic-ai/sdk/resources/beta/skills/versions.mjs
var Versions = class extends APIResource2 {
  /**
   * Create Skill Version
   *
   * @example
   * ```ts
   * const version = await client.beta.skills.versions.create(
   *   'skill_id',
   * );
   * ```
   */
  create(skillID, params = {}, options) {
    const { betas, ...body } = params != null ? params : {};
    return this._client.post(path2`/v1/skills/${skillID}/versions?beta=true`, multipartFormRequestOptions2({
      body,
      ...options,
      headers: buildHeaders2([
        { "anthropic-beta": [...betas != null ? betas : [], "skills-2025-10-02"].toString() },
        options == null ? void 0 : options.headers
      ])
    }, this._client));
  }
  /**
   * Get Skill Version
   *
   * @example
   * ```ts
   * const version = await client.beta.skills.versions.retrieve(
   *   'version',
   *   { skill_id: 'skill_id' },
   * );
   * ```
   */
  retrieve(version, params, options) {
    const { skill_id, betas } = params;
    return this._client.get(path2`/v1/skills/${skill_id}/versions/${version}?beta=true`, {
      ...options,
      headers: buildHeaders2([
        { "anthropic-beta": [...betas != null ? betas : [], "skills-2025-10-02"].toString() },
        options == null ? void 0 : options.headers
      ])
    });
  }
  /**
   * List Skill Versions
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const versionListResponse of client.beta.skills.versions.list(
   *   'skill_id',
   * )) {
   *   // ...
   * }
   * ```
   */
  list(skillID, params = {}, options) {
    const { betas, ...query } = params != null ? params : {};
    return this._client.getAPIList(path2`/v1/skills/${skillID}/versions?beta=true`, PageCursor, {
      query,
      ...options,
      headers: buildHeaders2([
        { "anthropic-beta": [...betas != null ? betas : [], "skills-2025-10-02"].toString() },
        options == null ? void 0 : options.headers
      ])
    });
  }
  /**
   * Delete Skill Version
   *
   * @example
   * ```ts
   * const version = await client.beta.skills.versions.delete(
   *   'version',
   *   { skill_id: 'skill_id' },
   * );
   * ```
   */
  delete(version, params, options) {
    const { skill_id, betas } = params;
    return this._client.delete(path2`/v1/skills/${skill_id}/versions/${version}?beta=true`, {
      ...options,
      headers: buildHeaders2([
        { "anthropic-beta": [...betas != null ? betas : [], "skills-2025-10-02"].toString() },
        options == null ? void 0 : options.headers
      ])
    });
  }
};

// node_modules/@anthropic-ai/sdk/resources/beta/skills/skills.mjs
var Skills = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.versions = new Versions(this._client);
  }
  /**
   * Create Skill
   *
   * @example
   * ```ts
   * const skill = await client.beta.skills.create();
   * ```
   */
  create(params = {}, options) {
    const { betas, ...body } = params != null ? params : {};
    return this._client.post("/v1/skills?beta=true", multipartFormRequestOptions2({
      body,
      ...options,
      headers: buildHeaders2([
        { "anthropic-beta": [...betas != null ? betas : [], "skills-2025-10-02"].toString() },
        options == null ? void 0 : options.headers
      ])
    }, this._client, false));
  }
  /**
   * Get Skill
   *
   * @example
   * ```ts
   * const skill = await client.beta.skills.retrieve('skill_id');
   * ```
   */
  retrieve(skillID, params = {}, options) {
    const { betas } = params != null ? params : {};
    return this._client.get(path2`/v1/skills/${skillID}?beta=true`, {
      ...options,
      headers: buildHeaders2([
        { "anthropic-beta": [...betas != null ? betas : [], "skills-2025-10-02"].toString() },
        options == null ? void 0 : options.headers
      ])
    });
  }
  /**
   * List Skills
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const skillListResponse of client.beta.skills.list()) {
   *   // ...
   * }
   * ```
   */
  list(params = {}, options) {
    const { betas, ...query } = params != null ? params : {};
    return this._client.getAPIList("/v1/skills?beta=true", PageCursor, {
      query,
      ...options,
      headers: buildHeaders2([
        { "anthropic-beta": [...betas != null ? betas : [], "skills-2025-10-02"].toString() },
        options == null ? void 0 : options.headers
      ])
    });
  }
  /**
   * Delete Skill
   *
   * @example
   * ```ts
   * const skill = await client.beta.skills.delete('skill_id');
   * ```
   */
  delete(skillID, params = {}, options) {
    const { betas } = params != null ? params : {};
    return this._client.delete(path2`/v1/skills/${skillID}?beta=true`, {
      ...options,
      headers: buildHeaders2([
        { "anthropic-beta": [...betas != null ? betas : [], "skills-2025-10-02"].toString() },
        options == null ? void 0 : options.headers
      ])
    });
  }
};
Skills.Versions = Versions;

// node_modules/@anthropic-ai/sdk/resources/beta/beta.mjs
var Beta2 = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.models = new Models2(this._client);
    this.messages = new Messages3(this._client);
    this.files = new Files4(this._client);
    this.skills = new Skills(this._client);
  }
};
Beta2.Models = Models2;
Beta2.Messages = Messages3;
Beta2.Files = Files4;
Beta2.Skills = Skills;

// node_modules/@anthropic-ai/sdk/resources/completions.mjs
var Completions3 = class extends APIResource2 {
  create(params, options) {
    var _a5, _b;
    const { betas, ...body } = params;
    return this._client.post("/v1/complete", {
      body,
      timeout: (_a5 = this._client._options.timeout) != null ? _a5 : 6e5,
      ...options,
      headers: buildHeaders2([
        { ...(betas == null ? void 0 : betas.toString()) != null ? { "anthropic-beta": betas == null ? void 0 : betas.toString() } : void 0 },
        options == null ? void 0 : options.headers
      ]),
      stream: (_b = params.stream) != null ? _b : false
    });
  }
};

// node_modules/@anthropic-ai/sdk/lib/parser.mjs
function getOutputFormat2(params) {
  var _a5;
  return (_a5 = params == null ? void 0 : params.output_config) == null ? void 0 : _a5.format;
}
function maybeParseMessage(message, params, opts) {
  const outputFormat = getOutputFormat2(params);
  if (!params || !("parse" in (outputFormat != null ? outputFormat : {}))) {
    return {
      ...message,
      content: message.content.map((block) => {
        if (block.type === "text") {
          const parsedBlock = Object.defineProperty({ ...block }, "parsed_output", {
            value: null,
            enumerable: false
          });
          return parsedBlock;
        }
        return block;
      }),
      parsed_output: null
    };
  }
  return parseMessage(message, params, opts);
}
function parseMessage(message, params, opts) {
  let firstParsedOutput = null;
  const content = message.content.map((block) => {
    if (block.type === "text") {
      const parsedOutput = parseOutputFormat(params, block.text);
      if (firstParsedOutput === null) {
        firstParsedOutput = parsedOutput;
      }
      const parsedBlock = Object.defineProperty({ ...block }, "parsed_output", {
        value: parsedOutput,
        enumerable: false
      });
      return parsedBlock;
    }
    return block;
  });
  return {
    ...message,
    content,
    parsed_output: firstParsedOutput
  };
}
function parseOutputFormat(params, content) {
  const outputFormat = getOutputFormat2(params);
  if ((outputFormat == null ? void 0 : outputFormat.type) !== "json_schema") {
    return null;
  }
  try {
    if ("parse" in outputFormat) {
      return outputFormat.parse(content);
    }
    return JSON.parse(content);
  } catch (error) {
    throw new AnthropicError(`Failed to parse structured output: ${error}`);
  }
}

// node_modules/@anthropic-ai/sdk/lib/MessageStream.mjs
var _MessageStream_instances;
var _MessageStream_currentMessageSnapshot;
var _MessageStream_params;
var _MessageStream_connectedPromise;
var _MessageStream_resolveConnectedPromise;
var _MessageStream_rejectConnectedPromise;
var _MessageStream_endPromise;
var _MessageStream_resolveEndPromise;
var _MessageStream_rejectEndPromise;
var _MessageStream_listeners;
var _MessageStream_ended;
var _MessageStream_errored;
var _MessageStream_aborted;
var _MessageStream_catchingPromiseCreated;
var _MessageStream_response;
var _MessageStream_request_id;
var _MessageStream_logger;
var _MessageStream_getFinalMessage;
var _MessageStream_getFinalText;
var _MessageStream_handleError;
var _MessageStream_beginRequest;
var _MessageStream_addStreamEvent;
var _MessageStream_endRequest;
var _MessageStream_accumulateMessage;
var JSON_BUF_PROPERTY2 = "__json_buf";
function tracksToolInput2(content) {
  return content.type === "tool_use" || content.type === "server_tool_use";
}
var MessageStream = class _MessageStream {
  constructor(params, opts) {
    var _a5;
    _MessageStream_instances.add(this);
    this.messages = [];
    this.receivedMessages = [];
    _MessageStream_currentMessageSnapshot.set(this, void 0);
    _MessageStream_params.set(this, null);
    this.controller = new AbortController();
    _MessageStream_connectedPromise.set(this, void 0);
    _MessageStream_resolveConnectedPromise.set(this, () => {
    });
    _MessageStream_rejectConnectedPromise.set(this, () => {
    });
    _MessageStream_endPromise.set(this, void 0);
    _MessageStream_resolveEndPromise.set(this, () => {
    });
    _MessageStream_rejectEndPromise.set(this, () => {
    });
    _MessageStream_listeners.set(this, {});
    _MessageStream_ended.set(this, false);
    _MessageStream_errored.set(this, false);
    _MessageStream_aborted.set(this, false);
    _MessageStream_catchingPromiseCreated.set(this, false);
    _MessageStream_response.set(this, void 0);
    _MessageStream_request_id.set(this, void 0);
    _MessageStream_logger.set(this, void 0);
    _MessageStream_handleError.set(this, (error) => {
      __classPrivateFieldSet2(this, _MessageStream_errored, true, "f");
      if (isAbortError2(error)) {
        error = new APIUserAbortError2();
      }
      if (error instanceof APIUserAbortError2) {
        __classPrivateFieldSet2(this, _MessageStream_aborted, true, "f");
        return this._emit("abort", error);
      }
      if (error instanceof AnthropicError) {
        return this._emit("error", error);
      }
      if (error instanceof Error) {
        const anthropicError = new AnthropicError(error.message);
        anthropicError.cause = error;
        return this._emit("error", anthropicError);
      }
      return this._emit("error", new AnthropicError(String(error)));
    });
    __classPrivateFieldSet2(this, _MessageStream_connectedPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet2(this, _MessageStream_resolveConnectedPromise, resolve, "f");
      __classPrivateFieldSet2(this, _MessageStream_rejectConnectedPromise, reject, "f");
    }), "f");
    __classPrivateFieldSet2(this, _MessageStream_endPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet2(this, _MessageStream_resolveEndPromise, resolve, "f");
      __classPrivateFieldSet2(this, _MessageStream_rejectEndPromise, reject, "f");
    }), "f");
    __classPrivateFieldGet2(this, _MessageStream_connectedPromise, "f").catch(() => {
    });
    __classPrivateFieldGet2(this, _MessageStream_endPromise, "f").catch(() => {
    });
    __classPrivateFieldSet2(this, _MessageStream_params, params, "f");
    __classPrivateFieldSet2(this, _MessageStream_logger, (_a5 = opts == null ? void 0 : opts.logger) != null ? _a5 : console, "f");
  }
  get response() {
    return __classPrivateFieldGet2(this, _MessageStream_response, "f");
  }
  get request_id() {
    return __classPrivateFieldGet2(this, _MessageStream_request_id, "f");
  }
  /**
   * Returns the `MessageStream` data, the raw `Response` instance and the ID of the request,
   * returned vie the `request-id` header which is useful for debugging requests and resporting
   * issues to Anthropic.
   *
   * This is the same as the `APIPromise.withResponse()` method.
   *
   * This method will raise an error if you created the stream using `MessageStream.fromReadableStream`
   * as no `Response` is available.
   */
  async withResponse() {
    __classPrivateFieldSet2(this, _MessageStream_catchingPromiseCreated, true, "f");
    const response = await __classPrivateFieldGet2(this, _MessageStream_connectedPromise, "f");
    if (!response) {
      throw new Error("Could not resolve a `Response` object");
    }
    return {
      data: this,
      response,
      request_id: response.headers.get("request-id")
    };
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(stream) {
    const runner = new _MessageStream(null);
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  static createMessage(messages2, params, options, { logger } = {}) {
    const runner = new _MessageStream(params, { logger });
    for (const message of params.messages) {
      runner._addMessageParam(message);
    }
    __classPrivateFieldSet2(runner, _MessageStream_params, { ...params, stream: true }, "f");
    runner._run(() => runner._createMessage(messages2, { ...params, stream: true }, { ...options, headers: { ...options == null ? void 0 : options.headers, "X-Stainless-Helper-Method": "stream" } }));
    return runner;
  }
  _run(executor) {
    executor().then(() => {
      this._emitFinal();
      this._emit("end");
    }, __classPrivateFieldGet2(this, _MessageStream_handleError, "f"));
  }
  _addMessageParam(message) {
    this.messages.push(message);
  }
  _addMessage(message, emit = true) {
    this.receivedMessages.push(message);
    if (emit) {
      this._emit("message", message);
    }
  }
  async _createMessage(messages2, params, options) {
    var _a5;
    const signal = options == null ? void 0 : options.signal;
    let abortHandler;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      abortHandler = this.controller.abort.bind(this.controller);
      signal.addEventListener("abort", abortHandler);
    }
    try {
      __classPrivateFieldGet2(this, _MessageStream_instances, "m", _MessageStream_beginRequest).call(this);
      const { response, data: stream } = await messages2.create({ ...params, stream: true }, { ...options, signal: this.controller.signal }).withResponse();
      this._connected(response);
      for await (const event of stream) {
        __classPrivateFieldGet2(this, _MessageStream_instances, "m", _MessageStream_addStreamEvent).call(this, event);
      }
      if ((_a5 = stream.controller.signal) == null ? void 0 : _a5.aborted) {
        throw new APIUserAbortError2();
      }
      __classPrivateFieldGet2(this, _MessageStream_instances, "m", _MessageStream_endRequest).call(this);
    } finally {
      if (signal && abortHandler) {
        signal.removeEventListener("abort", abortHandler);
      }
    }
  }
  _connected(response) {
    if (this.ended)
      return;
    __classPrivateFieldSet2(this, _MessageStream_response, response, "f");
    __classPrivateFieldSet2(this, _MessageStream_request_id, response == null ? void 0 : response.headers.get("request-id"), "f");
    __classPrivateFieldGet2(this, _MessageStream_resolveConnectedPromise, "f").call(this, response);
    this._emit("connect");
  }
  get ended() {
    return __classPrivateFieldGet2(this, _MessageStream_ended, "f");
  }
  get errored() {
    return __classPrivateFieldGet2(this, _MessageStream_errored, "f");
  }
  get aborted() {
    return __classPrivateFieldGet2(this, _MessageStream_aborted, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this MessageStream, so that calls can be chained
   */
  on(event, listener) {
    const listeners = __classPrivateFieldGet2(this, _MessageStream_listeners, "f")[event] || (__classPrivateFieldGet2(this, _MessageStream_listeners, "f")[event] = []);
    listeners.push({ listener });
    return this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this MessageStream, so that calls can be chained
   */
  off(event, listener) {
    const listeners = __classPrivateFieldGet2(this, _MessageStream_listeners, "f")[event];
    if (!listeners)
      return this;
    const index = listeners.findIndex((l3) => l3.listener === listener);
    if (index >= 0)
      listeners.splice(index, 1);
    return this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this MessageStream, so that calls can be chained
   */
  once(event, listener) {
    const listeners = __classPrivateFieldGet2(this, _MessageStream_listeners, "f")[event] || (__classPrivateFieldGet2(this, _MessageStream_listeners, "f")[event] = []);
    listeners.push({ listener, once: true });
    return this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(event) {
    return new Promise((resolve, reject) => {
      __classPrivateFieldSet2(this, _MessageStream_catchingPromiseCreated, true, "f");
      if (event !== "error")
        this.once("error", reject);
      this.once(event, resolve);
    });
  }
  async done() {
    __classPrivateFieldSet2(this, _MessageStream_catchingPromiseCreated, true, "f");
    await __classPrivateFieldGet2(this, _MessageStream_endPromise, "f");
  }
  get currentMessage() {
    return __classPrivateFieldGet2(this, _MessageStream_currentMessageSnapshot, "f");
  }
  /**
   * @returns a promise that resolves with the the final assistant Message response,
   * or rejects if an error occurred or the stream ended prematurely without producing a Message.
   * If structured outputs were used, this will be a ParsedMessage with a `parsed_output` field.
   */
  async finalMessage() {
    await this.done();
    return __classPrivateFieldGet2(this, _MessageStream_instances, "m", _MessageStream_getFinalMessage).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant Message's text response, concatenated
   * together if there are more than one text blocks.
   * Rejects if an error occurred or the stream ended prematurely without producing a Message.
   */
  async finalText() {
    await this.done();
    return __classPrivateFieldGet2(this, _MessageStream_instances, "m", _MessageStream_getFinalText).call(this);
  }
  _emit(event, ...args) {
    if (__classPrivateFieldGet2(this, _MessageStream_ended, "f"))
      return;
    if (event === "end") {
      __classPrivateFieldSet2(this, _MessageStream_ended, true, "f");
      __classPrivateFieldGet2(this, _MessageStream_resolveEndPromise, "f").call(this);
    }
    const listeners = __classPrivateFieldGet2(this, _MessageStream_listeners, "f")[event];
    if (listeners) {
      __classPrivateFieldGet2(this, _MessageStream_listeners, "f")[event] = listeners.filter((l3) => !l3.once);
      listeners.forEach(({ listener }) => listener(...args));
    }
    if (event === "abort") {
      const error = args[0];
      if (!__classPrivateFieldGet2(this, _MessageStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
        Promise.reject(error);
      }
      __classPrivateFieldGet2(this, _MessageStream_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet2(this, _MessageStream_rejectEndPromise, "f").call(this, error);
      this._emit("end");
      return;
    }
    if (event === "error") {
      const error = args[0];
      if (!__classPrivateFieldGet2(this, _MessageStream_catchingPromiseCreated, "f") && !(listeners == null ? void 0 : listeners.length)) {
        Promise.reject(error);
      }
      __classPrivateFieldGet2(this, _MessageStream_rejectConnectedPromise, "f").call(this, error);
      __classPrivateFieldGet2(this, _MessageStream_rejectEndPromise, "f").call(this, error);
      this._emit("end");
    }
  }
  _emitFinal() {
    const finalMessage = this.receivedMessages.at(-1);
    if (finalMessage) {
      this._emit("finalMessage", __classPrivateFieldGet2(this, _MessageStream_instances, "m", _MessageStream_getFinalMessage).call(this));
    }
  }
  async _fromReadableStream(readableStream, options) {
    var _a5;
    const signal = options == null ? void 0 : options.signal;
    let abortHandler;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      abortHandler = this.controller.abort.bind(this.controller);
      signal.addEventListener("abort", abortHandler);
    }
    try {
      __classPrivateFieldGet2(this, _MessageStream_instances, "m", _MessageStream_beginRequest).call(this);
      this._connected(null);
      const stream = Stream2.fromReadableStream(readableStream, this.controller);
      for await (const event of stream) {
        __classPrivateFieldGet2(this, _MessageStream_instances, "m", _MessageStream_addStreamEvent).call(this, event);
      }
      if ((_a5 = stream.controller.signal) == null ? void 0 : _a5.aborted) {
        throw new APIUserAbortError2();
      }
      __classPrivateFieldGet2(this, _MessageStream_instances, "m", _MessageStream_endRequest).call(this);
    } finally {
      if (signal && abortHandler) {
        signal.removeEventListener("abort", abortHandler);
      }
    }
  }
  [(_MessageStream_currentMessageSnapshot = /* @__PURE__ */ new WeakMap(), _MessageStream_params = /* @__PURE__ */ new WeakMap(), _MessageStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_endPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_listeners = /* @__PURE__ */ new WeakMap(), _MessageStream_ended = /* @__PURE__ */ new WeakMap(), _MessageStream_errored = /* @__PURE__ */ new WeakMap(), _MessageStream_aborted = /* @__PURE__ */ new WeakMap(), _MessageStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _MessageStream_response = /* @__PURE__ */ new WeakMap(), _MessageStream_request_id = /* @__PURE__ */ new WeakMap(), _MessageStream_logger = /* @__PURE__ */ new WeakMap(), _MessageStream_handleError = /* @__PURE__ */ new WeakMap(), _MessageStream_instances = /* @__PURE__ */ new WeakSet(), _MessageStream_getFinalMessage = function _MessageStream_getFinalMessage2() {
    if (this.receivedMessages.length === 0) {
      throw new AnthropicError("stream ended without producing a Message with role=assistant");
    }
    return this.receivedMessages.at(-1);
  }, _MessageStream_getFinalText = function _MessageStream_getFinalText2() {
    if (this.receivedMessages.length === 0) {
      throw new AnthropicError("stream ended without producing a Message with role=assistant");
    }
    const textBlocks = this.receivedMessages.at(-1).content.filter((block) => block.type === "text").map((block) => block.text);
    if (textBlocks.length === 0) {
      throw new AnthropicError("stream ended without producing a content block with type=text");
    }
    return textBlocks.join(" ");
  }, _MessageStream_beginRequest = function _MessageStream_beginRequest2() {
    if (this.ended)
      return;
    __classPrivateFieldSet2(this, _MessageStream_currentMessageSnapshot, void 0, "f");
  }, _MessageStream_addStreamEvent = function _MessageStream_addStreamEvent2(event) {
    var _a5;
    if (this.ended)
      return;
    const messageSnapshot = __classPrivateFieldGet2(this, _MessageStream_instances, "m", _MessageStream_accumulateMessage).call(this, event);
    this._emit("streamEvent", event, messageSnapshot);
    switch (event.type) {
      case "content_block_delta": {
        const content = messageSnapshot.content.at(-1);
        switch (event.delta.type) {
          case "text_delta": {
            if (content.type === "text") {
              this._emit("text", event.delta.text, content.text || "");
            }
            break;
          }
          case "citations_delta": {
            if (content.type === "text") {
              this._emit("citation", event.delta.citation, (_a5 = content.citations) != null ? _a5 : []);
            }
            break;
          }
          case "input_json_delta": {
            if (tracksToolInput2(content) && content.input) {
              this._emit("inputJson", event.delta.partial_json, content.input);
            }
            break;
          }
          case "thinking_delta": {
            if (content.type === "thinking") {
              this._emit("thinking", event.delta.thinking, content.thinking);
            }
            break;
          }
          case "signature_delta": {
            if (content.type === "thinking") {
              this._emit("signature", content.signature);
            }
            break;
          }
          default:
            checkNever2(event.delta);
        }
        break;
      }
      case "message_stop": {
        this._addMessageParam(messageSnapshot);
        this._addMessage(maybeParseMessage(messageSnapshot, __classPrivateFieldGet2(this, _MessageStream_params, "f"), { logger: __classPrivateFieldGet2(this, _MessageStream_logger, "f") }), true);
        break;
      }
      case "content_block_stop": {
        this._emit("contentBlock", messageSnapshot.content.at(-1));
        break;
      }
      case "message_start": {
        __classPrivateFieldSet2(this, _MessageStream_currentMessageSnapshot, messageSnapshot, "f");
        break;
      }
      case "content_block_start":
      case "message_delta":
        break;
    }
  }, _MessageStream_endRequest = function _MessageStream_endRequest2() {
    if (this.ended) {
      throw new AnthropicError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet2(this, _MessageStream_currentMessageSnapshot, "f");
    if (!snapshot) {
      throw new AnthropicError(`request ended without sending any chunks`);
    }
    __classPrivateFieldSet2(this, _MessageStream_currentMessageSnapshot, void 0, "f");
    return maybeParseMessage(snapshot, __classPrivateFieldGet2(this, _MessageStream_params, "f"), { logger: __classPrivateFieldGet2(this, _MessageStream_logger, "f") });
  }, _MessageStream_accumulateMessage = function _MessageStream_accumulateMessage2(event) {
    var _a5;
    let snapshot = __classPrivateFieldGet2(this, _MessageStream_currentMessageSnapshot, "f");
    if (event.type === "message_start") {
      if (snapshot) {
        throw new AnthropicError(`Unexpected event order, got ${event.type} before receiving "message_stop"`);
      }
      return event.message;
    }
    if (!snapshot) {
      throw new AnthropicError(`Unexpected event order, got ${event.type} before "message_start"`);
    }
    switch (event.type) {
      case "message_stop":
        return snapshot;
      case "message_delta":
        snapshot.stop_reason = event.delta.stop_reason;
        snapshot.stop_sequence = event.delta.stop_sequence;
        snapshot.usage.output_tokens = event.usage.output_tokens;
        if (event.usage.input_tokens != null) {
          snapshot.usage.input_tokens = event.usage.input_tokens;
        }
        if (event.usage.cache_creation_input_tokens != null) {
          snapshot.usage.cache_creation_input_tokens = event.usage.cache_creation_input_tokens;
        }
        if (event.usage.cache_read_input_tokens != null) {
          snapshot.usage.cache_read_input_tokens = event.usage.cache_read_input_tokens;
        }
        if (event.usage.server_tool_use != null) {
          snapshot.usage.server_tool_use = event.usage.server_tool_use;
        }
        return snapshot;
      case "content_block_start":
        snapshot.content.push({ ...event.content_block });
        return snapshot;
      case "content_block_delta": {
        const snapshotContent = snapshot.content.at(event.index);
        switch (event.delta.type) {
          case "text_delta": {
            if ((snapshotContent == null ? void 0 : snapshotContent.type) === "text") {
              snapshot.content[event.index] = {
                ...snapshotContent,
                text: (snapshotContent.text || "") + event.delta.text
              };
            }
            break;
          }
          case "citations_delta": {
            if ((snapshotContent == null ? void 0 : snapshotContent.type) === "text") {
              snapshot.content[event.index] = {
                ...snapshotContent,
                citations: [...(_a5 = snapshotContent.citations) != null ? _a5 : [], event.delta.citation]
              };
            }
            break;
          }
          case "input_json_delta": {
            if (snapshotContent && tracksToolInput2(snapshotContent)) {
              let jsonBuf = snapshotContent[JSON_BUF_PROPERTY2] || "";
              jsonBuf += event.delta.partial_json;
              const newContent = { ...snapshotContent };
              Object.defineProperty(newContent, JSON_BUF_PROPERTY2, {
                value: jsonBuf,
                enumerable: false,
                writable: true
              });
              if (jsonBuf) {
                newContent.input = partialParse2(jsonBuf);
              }
              snapshot.content[event.index] = newContent;
            }
            break;
          }
          case "thinking_delta": {
            if ((snapshotContent == null ? void 0 : snapshotContent.type) === "thinking") {
              snapshot.content[event.index] = {
                ...snapshotContent,
                thinking: snapshotContent.thinking + event.delta.thinking
              };
            }
            break;
          }
          case "signature_delta": {
            if ((snapshotContent == null ? void 0 : snapshotContent.type) === "thinking") {
              snapshot.content[event.index] = {
                ...snapshotContent,
                signature: event.delta.signature
              };
            }
            break;
          }
          default:
            checkNever2(event.delta);
        }
        return snapshot;
      }
      case "content_block_stop":
        return snapshot;
    }
  }, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("streamEvent", (event) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(event);
      } else {
        pushQueue.push(event);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  toReadableStream() {
    const stream = new Stream2(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
};
function checkNever2(x3) {
}

// node_modules/@anthropic-ai/sdk/resources/messages/batches.mjs
var Batches3 = class extends APIResource2 {
  /**
   * Send a batch of Message creation requests.
   *
   * The Message Batches API can be used to process multiple Messages API requests at
   * once. Once a Message Batch is created, it begins processing immediately. Batches
   * can take up to 24 hours to complete.
   *
   * Learn more about the Message Batches API in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const messageBatch = await client.messages.batches.create({
   *   requests: [
   *     {
   *       custom_id: 'my-custom-id-1',
   *       params: {
   *         max_tokens: 1024,
   *         messages: [
   *           { content: 'Hello, world', role: 'user' },
   *         ],
   *         model: 'claude-opus-4-6',
   *       },
   *     },
   *   ],
   * });
   * ```
   */
  create(body, options) {
    return this._client.post("/v1/messages/batches", { body, ...options });
  }
  /**
   * This endpoint is idempotent and can be used to poll for Message Batch
   * completion. To access the results of a Message Batch, make a request to the
   * `results_url` field in the response.
   *
   * Learn more about the Message Batches API in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const messageBatch = await client.messages.batches.retrieve(
   *   'message_batch_id',
   * );
   * ```
   */
  retrieve(messageBatchID, options) {
    return this._client.get(path2`/v1/messages/batches/${messageBatchID}`, options);
  }
  /**
   * List all Message Batches within a Workspace. Most recently created batches are
   * returned first.
   *
   * Learn more about the Message Batches API in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const messageBatch of client.messages.batches.list()) {
   *   // ...
   * }
   * ```
   */
  list(query = {}, options) {
    return this._client.getAPIList("/v1/messages/batches", Page2, { query, ...options });
  }
  /**
   * Delete a Message Batch.
   *
   * Message Batches can only be deleted once they've finished processing. If you'd
   * like to delete an in-progress batch, you must first cancel it.
   *
   * Learn more about the Message Batches API in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const deletedMessageBatch =
   *   await client.messages.batches.delete('message_batch_id');
   * ```
   */
  delete(messageBatchID, options) {
    return this._client.delete(path2`/v1/messages/batches/${messageBatchID}`, options);
  }
  /**
   * Batches may be canceled any time before processing ends. Once cancellation is
   * initiated, the batch enters a `canceling` state, at which time the system may
   * complete any in-progress, non-interruptible requests before finalizing
   * cancellation.
   *
   * The number of canceled requests is specified in `request_counts`. To determine
   * which requests were canceled, check the individual results within the batch.
   * Note that cancellation may not result in any canceled requests if they were
   * non-interruptible.
   *
   * Learn more about the Message Batches API in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const messageBatch = await client.messages.batches.cancel(
   *   'message_batch_id',
   * );
   * ```
   */
  cancel(messageBatchID, options) {
    return this._client.post(path2`/v1/messages/batches/${messageBatchID}/cancel`, options);
  }
  /**
   * Streams the results of a Message Batch as a `.jsonl` file.
   *
   * Each line in the file is a JSON object containing the result of a single request
   * in the Message Batch. Results are not guaranteed to be in the same order as
   * requests. Use the `custom_id` field to match results to requests.
   *
   * Learn more about the Message Batches API in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const messageBatchIndividualResponse =
   *   await client.messages.batches.results('message_batch_id');
   * ```
   */
  async results(messageBatchID, options) {
    const batch = await this.retrieve(messageBatchID);
    if (!batch.results_url) {
      throw new AnthropicError(`No batch \`results_url\`; Has it finished processing? ${batch.processing_status} - ${batch.id}`);
    }
    return this._client.get(batch.results_url, {
      ...options,
      headers: buildHeaders2([{ Accept: "application/binary" }, options == null ? void 0 : options.headers]),
      stream: true,
      __binaryResponse: true
    })._thenUnwrap((_, props) => JSONLDecoder.fromResponse(props.response, props.controller));
  }
};

// node_modules/@anthropic-ai/sdk/resources/messages/messages.mjs
var Messages4 = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.batches = new Batches3(this._client);
  }
  create(body, options) {
    var _a5, _b;
    if (body.model in DEPRECATED_MODELS2) {
      console.warn(`The model '${body.model}' is deprecated and will reach end-of-life on ${DEPRECATED_MODELS2[body.model]}
Please migrate to a newer model. Visit https://docs.anthropic.com/en/docs/resources/model-deprecations for more information.`);
    }
    if (body.model in MODELS_TO_WARN_WITH_THINKING_ENABLED2 && body.thinking && body.thinking.type === "enabled") {
      console.warn(`Using Claude with ${body.model} and 'thinking.type=enabled' is deprecated. Use 'thinking.type=adaptive' instead which results in better model performance in our testing: https://platform.claude.com/docs/en/build-with-claude/adaptive-thinking`);
    }
    let timeout = this._client._options.timeout;
    if (!body.stream && timeout == null) {
      const maxNonstreamingTokens = (_a5 = MODEL_NONSTREAMING_TOKENS[body.model]) != null ? _a5 : void 0;
      timeout = this._client.calculateNonstreamingTimeout(body.max_tokens, maxNonstreamingTokens);
    }
    const helperHeader = stainlessHelperHeader(body.tools, body.messages);
    return this._client.post("/v1/messages", {
      body,
      timeout: timeout != null ? timeout : 6e5,
      ...options,
      headers: buildHeaders2([helperHeader, options == null ? void 0 : options.headers]),
      stream: (_b = body.stream) != null ? _b : false
    });
  }
  /**
   * Send a structured list of input messages with text and/or image content, along with an expected `output_config.format` and
   * the response will be automatically parsed and available in the `parsed_output` property of the message.
   *
   * @example
   * ```ts
   * const message = await client.messages.parse({
   *   model: 'claude-sonnet-4-5-20250929',
   *   max_tokens: 1024,
   *   messages: [{ role: 'user', content: 'What is 2+2?' }],
   *   output_config: {
   *     format: zodOutputFormat(z.object({ answer: z.number() })),
   *   },
   * });
   *
   * console.log(message.parsed_output?.answer); // 4
   * ```
   */
  parse(params, options) {
    return this.create(params, options).then((message) => {
      var _a5;
      return parseMessage(message, params, { logger: (_a5 = this._client.logger) != null ? _a5 : console });
    });
  }
  /**
   * Create a Message stream.
   *
   * If `output_config.format` is provided with a parseable format (like `zodOutputFormat()`),
   * the final message will include a `parsed_output` property with the parsed content.
   *
   * @example
   * ```ts
   * const stream = client.messages.stream({
   *   model: 'claude-sonnet-4-5-20250929',
   *   max_tokens: 1024,
   *   messages: [{ role: 'user', content: 'What is 2+2?' }],
   *   output_config: {
   *     format: zodOutputFormat(z.object({ answer: z.number() })),
   *   },
   * });
   *
   * const message = await stream.finalMessage();
   * console.log(message.parsed_output?.answer); // 4
   * ```
   */
  stream(body, options) {
    var _a5;
    return MessageStream.createMessage(this, body, options, { logger: (_a5 = this._client.logger) != null ? _a5 : console });
  }
  /**
   * Count the number of tokens in a Message.
   *
   * The Token Count API can be used to count the number of tokens in a Message,
   * including tools, images, and documents, without creating it.
   *
   * Learn more about token counting in our
   * [user guide](https://docs.claude.com/en/docs/build-with-claude/token-counting)
   *
   * @example
   * ```ts
   * const messageTokensCount =
   *   await client.messages.countTokens({
   *     messages: [{ content: 'string', role: 'user' }],
   *     model: 'claude-opus-4-6',
   *   });
   * ```
   */
  countTokens(body, options) {
    return this._client.post("/v1/messages/count_tokens", { body, ...options });
  }
};
var DEPRECATED_MODELS2 = {
  "claude-1.3": "November 6th, 2024",
  "claude-1.3-100k": "November 6th, 2024",
  "claude-instant-1.1": "November 6th, 2024",
  "claude-instant-1.1-100k": "November 6th, 2024",
  "claude-instant-1.2": "November 6th, 2024",
  "claude-3-sonnet-20240229": "July 21st, 2025",
  "claude-3-opus-20240229": "January 5th, 2026",
  "claude-2.1": "July 21st, 2025",
  "claude-2.0": "July 21st, 2025",
  "claude-3-7-sonnet-latest": "February 19th, 2026",
  "claude-3-7-sonnet-20250219": "February 19th, 2026",
  "claude-3-5-haiku-latest": "February 19th, 2026",
  "claude-3-5-haiku-20241022": "February 19th, 2026"
};
var MODELS_TO_WARN_WITH_THINKING_ENABLED2 = ["claude-opus-4-6"];
Messages4.Batches = Batches3;

// node_modules/@anthropic-ai/sdk/resources/models.mjs
var Models3 = class extends APIResource2 {
  /**
   * Get a specific model.
   *
   * The Models API response can be used to determine information about a specific
   * model or resolve a model alias to a model ID.
   */
  retrieve(modelID, params = {}, options) {
    const { betas } = params != null ? params : {};
    return this._client.get(path2`/v1/models/${modelID}`, {
      ...options,
      headers: buildHeaders2([
        { ...(betas == null ? void 0 : betas.toString()) != null ? { "anthropic-beta": betas == null ? void 0 : betas.toString() } : void 0 },
        options == null ? void 0 : options.headers
      ])
    });
  }
  /**
   * List available models.
   *
   * The Models API response can be used to determine which models are available for
   * use in the API. More recently released models are listed first.
   */
  list(params = {}, options) {
    const { betas, ...query } = params != null ? params : {};
    return this._client.getAPIList("/v1/models", Page2, {
      query,
      ...options,
      headers: buildHeaders2([
        { ...(betas == null ? void 0 : betas.toString()) != null ? { "anthropic-beta": betas == null ? void 0 : betas.toString() } : void 0 },
        options == null ? void 0 : options.headers
      ])
    });
  }
};

// node_modules/@anthropic-ai/sdk/internal/utils/env.mjs
var readEnv2 = (env) => {
  var _a5, _b, _c, _d, _e, _f;
  if (typeof globalThis.process !== "undefined") {
    return (_c = (_b = (_a5 = globalThis.process.env) == null ? void 0 : _a5[env]) == null ? void 0 : _b.trim()) != null ? _c : void 0;
  }
  if (typeof globalThis.Deno !== "undefined") {
    return (_f = (_e = (_d = globalThis.Deno.env) == null ? void 0 : _d.get) == null ? void 0 : _e.call(_d, env)) == null ? void 0 : _f.trim();
  }
  return void 0;
};

// node_modules/@anthropic-ai/sdk/client.mjs
var _BaseAnthropic_instances;
var _a3;
var _BaseAnthropic_encoder;
var _BaseAnthropic_baseURLOverridden;
var HUMAN_PROMPT = "\\n\\nHuman:";
var AI_PROMPT = "\\n\\nAssistant:";
var BaseAnthropic = class {
  /**
   * API Client for interfacing with the Anthropic API.
   *
   * @param {string | null | undefined} [opts.apiKey=process.env['ANTHROPIC_API_KEY'] ?? null]
   * @param {string | null | undefined} [opts.authToken=process.env['ANTHROPIC_AUTH_TOKEN'] ?? null]
   * @param {string} [opts.baseURL=process.env['ANTHROPIC_BASE_URL'] ?? https://api.anthropic.com] - Override the default base URL for the API.
   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {MergedRequestInit} [opts.fetchOptions] - Additional `RequestInit` options to be passed to `fetch` calls.
   * @param {Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {HeadersLike} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Record<string, string | undefined>} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   */
  constructor({ baseURL = readEnv2("ANTHROPIC_BASE_URL"), apiKey = ((_a5) => (_a5 = readEnv2("ANTHROPIC_API_KEY")) != null ? _a5 : null)(), authToken = ((_b) => (_b = readEnv2("ANTHROPIC_AUTH_TOKEN")) != null ? _b : null)(), ...opts } = {}) {
    var _a6, _b2, _c, _d, _e, _f;
    _BaseAnthropic_instances.add(this);
    _BaseAnthropic_encoder.set(this, void 0);
    const options = {
      apiKey,
      authToken,
      ...opts,
      baseURL: baseURL || `https://api.anthropic.com`
    };
    if (!options.dangerouslyAllowBrowser && isRunningInBrowser2()) {
      throw new AnthropicError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew Anthropic({ apiKey, dangerouslyAllowBrowser: true });\n");
    }
    this.baseURL = options.baseURL;
    this.timeout = (_a6 = options.timeout) != null ? _a6 : _a3.DEFAULT_TIMEOUT;
    this.logger = (_b2 = options.logger) != null ? _b2 : console;
    const defaultLogLevel = "warn";
    this.logLevel = defaultLogLevel;
    this.logLevel = (_d = (_c = parseLogLevel2(options.logLevel, "ClientOptions.logLevel", this)) != null ? _c : parseLogLevel2(readEnv2("ANTHROPIC_LOG"), "process.env['ANTHROPIC_LOG']", this)) != null ? _d : defaultLogLevel;
    this.fetchOptions = options.fetchOptions;
    this.maxRetries = (_e = options.maxRetries) != null ? _e : 2;
    this.fetch = (_f = options.fetch) != null ? _f : getDefaultFetch2();
    __classPrivateFieldSet2(this, _BaseAnthropic_encoder, FallbackEncoder2, "f");
    this._options = options;
    this.apiKey = typeof apiKey === "string" ? apiKey : null;
    this.authToken = authToken;
  }
  /**
   * Create a new client instance re-using the same options given to the current client with optional overriding.
   */
  withOptions(options) {
    const client = new this.constructor({
      ...this._options,
      baseURL: this.baseURL,
      maxRetries: this.maxRetries,
      timeout: this.timeout,
      logger: this.logger,
      logLevel: this.logLevel,
      fetch: this.fetch,
      fetchOptions: this.fetchOptions,
      apiKey: this.apiKey,
      authToken: this.authToken,
      ...options
    });
    return client;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  validateHeaders({ values, nulls }) {
    if (values.get("x-api-key") || values.get("authorization")) {
      return;
    }
    if (this.apiKey && values.get("x-api-key")) {
      return;
    }
    if (nulls.has("x-api-key")) {
      return;
    }
    if (this.authToken && values.get("authorization")) {
      return;
    }
    if (nulls.has("authorization")) {
      return;
    }
    throw new Error('Could not resolve authentication method. Expected either apiKey or authToken to be set. Or for one of the "X-Api-Key" or "Authorization" headers to be explicitly omitted');
  }
  async authHeaders(opts) {
    return buildHeaders2([await this.apiKeyAuth(opts), await this.bearerAuth(opts)]);
  }
  async apiKeyAuth(opts) {
    if (this.apiKey == null) {
      return void 0;
    }
    return buildHeaders2([{ "X-Api-Key": this.apiKey }]);
  }
  async bearerAuth(opts) {
    if (this.authToken == null) {
      return void 0;
    }
    return buildHeaders2([{ Authorization: `Bearer ${this.authToken}` }]);
  }
  /**
   * Basic re-implementation of `qs.stringify` for primitive types.
   */
  stringifyQuery(query) {
    return Object.entries(query).filter(([_, value]) => typeof value !== "undefined").map(([key, value]) => {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
      }
      if (value === null) {
        return `${encodeURIComponent(key)}=`;
      }
      throw new AnthropicError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
    }).join("&");
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION2}`;
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid42()}`;
  }
  makeStatusError(status, error, message, headers) {
    return APIError2.generate(status, error, message, headers);
  }
  buildURL(path4, query, defaultBaseURL) {
    const baseURL = !__classPrivateFieldGet2(this, _BaseAnthropic_instances, "m", _BaseAnthropic_baseURLOverridden).call(this) && defaultBaseURL || this.baseURL;
    const url = isAbsoluteURL2(path4) ? new URL(path4) : new URL(baseURL + (baseURL.endsWith("/") && path4.startsWith("/") ? path4.slice(1) : path4));
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj2(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (typeof query === "object" && query && !Array.isArray(query)) {
      url.search = this.stringifyQuery(query);
    }
    return url.toString();
  }
  _calculateNonstreamingTimeout(maxTokens) {
    const defaultTimeout = 10 * 60;
    const expectedTimeout = 60 * 60 * maxTokens / 128e3;
    if (expectedTimeout > defaultTimeout) {
      throw new AnthropicError("Streaming is required for operations that may take longer than 10 minutes. See https://github.com/anthropics/anthropic-sdk-typescript#streaming-responses for more details");
    }
    return defaultTimeout * 1e3;
  }
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  async prepareOptions(options) {
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(request, { url, options }) {
  }
  get(path4, opts) {
    return this.methodRequest("get", path4, opts);
  }
  post(path4, opts) {
    return this.methodRequest("post", path4, opts);
  }
  patch(path4, opts) {
    return this.methodRequest("patch", path4, opts);
  }
  put(path4, opts) {
    return this.methodRequest("put", path4, opts);
  }
  delete(path4, opts) {
    return this.methodRequest("delete", path4, opts);
  }
  methodRequest(method, path4, opts) {
    return this.request(Promise.resolve(opts).then((opts2) => {
      return { method, path: path4, ...opts2 };
    }));
  }
  request(options, remainingRetries = null) {
    return new APIPromise2(this, this.makeRequest(options, remainingRetries, void 0));
  }
  async makeRequest(optionsInput, retriesRemaining, retryOfRequestLogID) {
    var _a5, _b, _c;
    const options = await optionsInput;
    const maxRetries = (_a5 = options.maxRetries) != null ? _a5 : this.maxRetries;
    if (retriesRemaining == null) {
      retriesRemaining = maxRetries;
    }
    await this.prepareOptions(options);
    const { req, url, timeout } = await this.buildRequest(options, {
      retryCount: maxRetries - retriesRemaining
    });
    await this.prepareRequest(req, { url, options });
    const requestLogID = "log_" + (Math.random() * (1 << 24) | 0).toString(16).padStart(6, "0");
    const retryLogStr = retryOfRequestLogID === void 0 ? "" : `, retryOf: ${retryOfRequestLogID}`;
    const startTime = Date.now();
    loggerFor2(this).debug(`[${requestLogID}] sending request`, formatRequestDetails2({
      retryOfRequestLogID,
      method: options.method,
      url,
      options,
      headers: req.headers
    }));
    if ((_b = options.signal) == null ? void 0 : _b.aborted) {
      throw new APIUserAbortError2();
    }
    const controller = new AbortController();
    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError2);
    const headersTime = Date.now();
    if (response instanceof globalThis.Error) {
      const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;
      if ((_c = options.signal) == null ? void 0 : _c.aborted) {
        throw new APIUserAbortError2();
      }
      const isTimeout = isAbortError2(response) || /timed? ?out/i.test(String(response) + ("cause" in response ? String(response.cause) : ""));
      if (retriesRemaining) {
        loggerFor2(this).info(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} - ${retryMessage}`);
        loggerFor2(this).debug(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} (${retryMessage})`, formatRequestDetails2({
          retryOfRequestLogID,
          url,
          durationMs: headersTime - startTime,
          message: response.message
        }));
        return this.retryRequest(options, retriesRemaining, retryOfRequestLogID != null ? retryOfRequestLogID : requestLogID);
      }
      loggerFor2(this).info(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} - error; no more retries left`);
      loggerFor2(this).debug(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} (error; no more retries left)`, formatRequestDetails2({
        retryOfRequestLogID,
        url,
        durationMs: headersTime - startTime,
        message: response.message
      }));
      if (isTimeout) {
        throw new APIConnectionTimeoutError2();
      }
      throw new APIConnectionError2({ cause: response });
    }
    const specialHeaders = [...response.headers.entries()].filter(([name]) => name === "request-id").map(([name, value]) => ", " + name + ": " + JSON.stringify(value)).join("");
    const responseInfo = `[${requestLogID}${retryLogStr}${specialHeaders}] ${req.method} ${url} ${response.ok ? "succeeded" : "failed"} with status ${response.status} in ${headersTime - startTime}ms`;
    if (!response.ok) {
      const shouldRetry = await this.shouldRetry(response);
      if (retriesRemaining && shouldRetry) {
        const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
        await CancelReadableStream2(response.body);
        loggerFor2(this).info(`${responseInfo} - ${retryMessage2}`);
        loggerFor2(this).debug(`[${requestLogID}] response error (${retryMessage2})`, formatRequestDetails2({
          retryOfRequestLogID,
          url: response.url,
          status: response.status,
          headers: response.headers,
          durationMs: headersTime - startTime
        }));
        return this.retryRequest(options, retriesRemaining, retryOfRequestLogID != null ? retryOfRequestLogID : requestLogID, response.headers);
      }
      const retryMessage = shouldRetry ? `error; no more retries left` : `error; not retryable`;
      loggerFor2(this).info(`${responseInfo} - ${retryMessage}`);
      const errText = await response.text().catch((err2) => castToError2(err2).message);
      const errJSON = safeJSON2(errText);
      const errMessage = errJSON ? void 0 : errText;
      loggerFor2(this).debug(`[${requestLogID}] response error (${retryMessage})`, formatRequestDetails2({
        retryOfRequestLogID,
        url: response.url,
        status: response.status,
        headers: response.headers,
        message: errMessage,
        durationMs: Date.now() - startTime
      }));
      const err = this.makeStatusError(response.status, errJSON, errMessage, response.headers);
      throw err;
    }
    loggerFor2(this).info(responseInfo);
    loggerFor2(this).debug(`[${requestLogID}] response start`, formatRequestDetails2({
      retryOfRequestLogID,
      url: response.url,
      status: response.status,
      headers: response.headers,
      durationMs: headersTime - startTime
    }));
    return { response, options, controller, requestLogID, retryOfRequestLogID, startTime };
  }
  getAPIList(path4, Page3, opts) {
    return this.requestAPIList(Page3, opts && "then" in opts ? opts.then((opts2) => ({ method: "get", path: path4, ...opts2 })) : { method: "get", path: path4, ...opts });
  }
  requestAPIList(Page3, options) {
    const request = this.makeRequest(options, null, void 0);
    return new PagePromise2(this, request, Page3);
  }
  async fetchWithTimeout(url, init, ms, controller) {
    const { signal, method, ...options } = init || {};
    const abort = this._makeAbort(controller);
    if (signal)
      signal.addEventListener("abort", abort, { once: true });
    const timeout = setTimeout(abort, ms);
    const isReadableBody = globalThis.ReadableStream && options.body instanceof globalThis.ReadableStream || typeof options.body === "object" && options.body !== null && Symbol.asyncIterator in options.body;
    const fetchOptions = {
      signal: controller.signal,
      ...isReadableBody ? { duplex: "half" } : {},
      method: "GET",
      ...options
    };
    if (method) {
      fetchOptions.method = method.toUpperCase();
    }
    try {
      return await this.fetch.call(void 0, url, fetchOptions);
    } finally {
      clearTimeout(timeout);
    }
  }
  async shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true")
      return true;
    if (shouldRetryHeader === "false")
      return false;
    if (response.status === 408)
      return true;
    if (response.status === 409)
      return true;
    if (response.status === 429)
      return true;
    if (response.status >= 500)
      return true;
    return false;
  }
  async retryRequest(options, retriesRemaining, requestLogID, responseHeaders) {
    var _a5;
    let timeoutMillis;
    const retryAfterMillisHeader = responseHeaders == null ? void 0 : responseHeaders.get("retry-after-ms");
    if (retryAfterMillisHeader) {
      const timeoutMs = parseFloat(retryAfterMillisHeader);
      if (!Number.isNaN(timeoutMs)) {
        timeoutMillis = timeoutMs;
      }
    }
    const retryAfterHeader = responseHeaders == null ? void 0 : responseHeaders.get("retry-after");
    if (retryAfterHeader && !timeoutMillis) {
      const timeoutSeconds = parseFloat(retryAfterHeader);
      if (!Number.isNaN(timeoutSeconds)) {
        timeoutMillis = timeoutSeconds * 1e3;
      } else {
        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
      }
    }
    if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
      const maxRetries = (_a5 = options.maxRetries) != null ? _a5 : this.maxRetries;
      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
    }
    await sleep2(timeoutMillis);
    return this.makeRequest(options, retriesRemaining - 1, requestLogID);
  }
  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 8;
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
    const jitter = 1 - Math.random() * 0.25;
    return sleepSeconds * jitter * 1e3;
  }
  calculateNonstreamingTimeout(maxTokens, maxNonstreamingTokens) {
    const maxTime = 60 * 60 * 1e3;
    const defaultTime = 60 * 10 * 1e3;
    const expectedTime = maxTime * maxTokens / 128e3;
    if (expectedTime > defaultTime || maxNonstreamingTokens != null && maxTokens > maxNonstreamingTokens) {
      throw new AnthropicError("Streaming is required for operations that may take longer than 10 minutes. See https://github.com/anthropics/anthropic-sdk-typescript#long-requests for more details");
    }
    return defaultTime;
  }
  async buildRequest(inputOptions, { retryCount = 0 } = {}) {
    var _a5, _b, _c;
    const options = { ...inputOptions };
    const { method, path: path4, query, defaultBaseURL } = options;
    const url = this.buildURL(path4, query, defaultBaseURL);
    if ("timeout" in options)
      validatePositiveInteger2("timeout", options.timeout);
    options.timeout = (_a5 = options.timeout) != null ? _a5 : this.timeout;
    const { bodyHeaders, body } = this.buildBody({ options });
    const reqHeaders = await this.buildHeaders({ options: inputOptions, method, bodyHeaders, retryCount });
    const req = {
      method,
      headers: reqHeaders,
      ...options.signal && { signal: options.signal },
      ...globalThis.ReadableStream && body instanceof globalThis.ReadableStream && { duplex: "half" },
      ...body && { body },
      ...(_b = this.fetchOptions) != null ? _b : {},
      ...(_c = options.fetchOptions) != null ? _c : {}
    };
    return { req, url, timeout: options.timeout };
  }
  async buildHeaders({ options, method, bodyHeaders, retryCount }) {
    let idempotencyHeaders = {};
    if (this.idempotencyHeader && method !== "get") {
      if (!options.idempotencyKey)
        options.idempotencyKey = this.defaultIdempotencyKey();
      idempotencyHeaders[this.idempotencyHeader] = options.idempotencyKey;
    }
    const headers = buildHeaders2([
      idempotencyHeaders,
      {
        Accept: "application/json",
        "User-Agent": this.getUserAgent(),
        "X-Stainless-Retry-Count": String(retryCount),
        ...options.timeout ? { "X-Stainless-Timeout": String(Math.trunc(options.timeout / 1e3)) } : {},
        ...getPlatformHeaders2(),
        ...this._options.dangerouslyAllowBrowser ? { "anthropic-dangerous-direct-browser-access": "true" } : void 0,
        "anthropic-version": "2023-06-01"
      },
      await this.authHeaders(options),
      this._options.defaultHeaders,
      bodyHeaders,
      options.headers
    ]);
    this.validateHeaders(headers);
    return headers.values;
  }
  _makeAbort(controller) {
    return () => controller.abort();
  }
  buildBody({ options: { body, headers: rawHeaders } }) {
    if (!body) {
      return { bodyHeaders: void 0, body: void 0 };
    }
    const headers = buildHeaders2([rawHeaders]);
    if (
      // Pass raw type verbatim
      ArrayBuffer.isView(body) || body instanceof ArrayBuffer || body instanceof DataView || typeof body === "string" && // Preserve legacy string encoding behavior for now
      headers.values.has("content-type") || // `Blob` is superset of `File`
      globalThis.Blob && body instanceof globalThis.Blob || // `FormData` -> `multipart/form-data`
      body instanceof FormData || // `URLSearchParams` -> `application/x-www-form-urlencoded`
      body instanceof URLSearchParams || // Send chunked stream (each chunk has own `length`)
      globalThis.ReadableStream && body instanceof globalThis.ReadableStream
    ) {
      return { bodyHeaders: void 0, body };
    } else if (typeof body === "object" && (Symbol.asyncIterator in body || Symbol.iterator in body && "next" in body && typeof body.next === "function")) {
      return { bodyHeaders: void 0, body: ReadableStreamFrom2(body) };
    } else {
      return __classPrivateFieldGet2(this, _BaseAnthropic_encoder, "f").call(this, { body, headers });
    }
  }
};
_a3 = BaseAnthropic, _BaseAnthropic_encoder = /* @__PURE__ */ new WeakMap(), _BaseAnthropic_instances = /* @__PURE__ */ new WeakSet(), _BaseAnthropic_baseURLOverridden = function _BaseAnthropic_baseURLOverridden2() {
  return this.baseURL !== "https://api.anthropic.com";
};
BaseAnthropic.Anthropic = _a3;
BaseAnthropic.HUMAN_PROMPT = HUMAN_PROMPT;
BaseAnthropic.AI_PROMPT = AI_PROMPT;
BaseAnthropic.DEFAULT_TIMEOUT = 6e5;
BaseAnthropic.AnthropicError = AnthropicError;
BaseAnthropic.APIError = APIError2;
BaseAnthropic.APIConnectionError = APIConnectionError2;
BaseAnthropic.APIConnectionTimeoutError = APIConnectionTimeoutError2;
BaseAnthropic.APIUserAbortError = APIUserAbortError2;
BaseAnthropic.NotFoundError = NotFoundError2;
BaseAnthropic.ConflictError = ConflictError2;
BaseAnthropic.RateLimitError = RateLimitError2;
BaseAnthropic.BadRequestError = BadRequestError2;
BaseAnthropic.AuthenticationError = AuthenticationError2;
BaseAnthropic.InternalServerError = InternalServerError2;
BaseAnthropic.PermissionDeniedError = PermissionDeniedError2;
BaseAnthropic.UnprocessableEntityError = UnprocessableEntityError2;
BaseAnthropic.toFile = toFile2;
var Anthropic = class extends BaseAnthropic {
  constructor() {
    super(...arguments);
    this.completions = new Completions3(this);
    this.messages = new Messages4(this);
    this.models = new Models3(this);
    this.beta = new Beta2(this);
  }
};
Anthropic.Completions = Completions3;
Anthropic.Messages = Messages4;
Anthropic.Models = Models3;
Anthropic.Beta = Beta2;

// node_modules/@anthropic-ai/claude-agent-sdk/sdk.mjs
var import_path40 = require("path");
var import_url = require("url");
var import_events = require("events");
var import_child_process = require("child_process");
var import_readline = require("readline");
var h = __toESM(require("fs"), 1);
var import_promises = require("fs/promises");
var import_path41 = require("path");
var import_os = require("os");
var import_path42 = require("path");
var import_process = require("process");
var import_fs = require("fs");
var import_crypto = require("crypto");
var import_crypto2 = require("crypto");
var import_fs2 = require("fs");
var import_path43 = require("path");
var import_crypto3 = require("crypto");
var import_path44 = require("path");
var import_url2 = require("url");
var import_meta = {};
var JK = Object.create;
var { getPrototypeOf: GK, defineProperty: Y9, getOwnPropertyNames: HK } = Object;
var BK = Object.prototype.hasOwnProperty;
var K7 = (X, Q, $) => {
  $ = X != null ? JK(GK(X)) : {};
  let Y = Q || !X || !X.__esModule ? Y9($, "default", { value: X, enumerable: true }) : $;
  for (let W of HK(X)) if (!BK.call(Y, W)) Y9(Y, W, { get: () => X[W], enumerable: true });
  return Y;
};
var P = (X, Q) => () => (Q || X((Q = { exports: {} }).exports, Q), Q.exports);
var U7 = (X, Q) => {
  for (var $ in Q) Y9(X, $, { get: Q[$], enumerable: true, configurable: true, set: (Y) => Q[$] = () => Y });
};
var hX = P((JG) => {
  Object.defineProperty(JG, "__esModule", { value: true });
  JG.regexpCode = JG.getEsmExportName = JG.getProperty = JG.safeStringify = JG.stringify = JG.strConcat = JG.addCodeArg = JG.str = JG._ = JG.nil = JG._Code = JG.Name = JG.IDENTIFIER = JG._CodeOrName = void 0;
  class D8 {
  }
  JG._CodeOrName = D8;
  JG.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  class g6 extends D8 {
    constructor(X) {
      super();
      if (!JG.IDENTIFIER.test(X)) throw Error("CodeGen: name must be a valid identifier");
      this.str = X;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      return false;
    }
    get names() {
      return { [this.str]: 1 };
    }
  }
  JG.Name = g6;
  class s0 extends D8 {
    constructor(X) {
      super();
      this._items = typeof X === "string" ? [X] : X;
    }
    toString() {
      return this.str;
    }
    emptyStr() {
      if (this._items.length > 1) return false;
      let X = this._items[0];
      return X === "" || X === '""';
    }
    get str() {
      var X;
      return (X = this._str) !== null && X !== void 0 ? X : this._str = this._items.reduce((Q, $) => `${Q}${$}`, "");
    }
    get names() {
      var X;
      return (X = this._names) !== null && X !== void 0 ? X : this._names = this._items.reduce((Q, $) => {
        if ($ instanceof g6) Q[$.str] = (Q[$.str] || 0) + 1;
        return Q;
      }, {});
    }
  }
  JG._Code = s0;
  JG.nil = new s0("");
  function YG(X, ...Q) {
    let $ = [X[0]], Y = 0;
    while (Y < Q.length) s$($, Q[Y]), $.push(X[++Y]);
    return new s0($);
  }
  JG._ = YG;
  var a$ = new s0("+");
  function WG(X, ...Q) {
    let $ = [fX(X[0])], Y = 0;
    while (Y < Q.length) $.push(a$), s$($, Q[Y]), $.push(a$, fX(X[++Y]));
    return ON($), new s0($);
  }
  JG.str = WG;
  function s$(X, Q) {
    if (Q instanceof s0) X.push(...Q._items);
    else if (Q instanceof g6) X.push(Q);
    else X.push(AN(Q));
  }
  JG.addCodeArg = s$;
  function ON(X) {
    let Q = 1;
    while (Q < X.length - 1) {
      if (X[Q] === a$) {
        let $ = DN(X[Q - 1], X[Q + 1]);
        if ($ !== void 0) {
          X.splice(Q - 1, 3, $);
          continue;
        }
        X[Q++] = "+";
      }
      Q++;
    }
  }
  function DN(X, Q) {
    if (Q === '""') return X;
    if (X === '""') return Q;
    if (typeof X == "string") {
      if (Q instanceof g6 || X[X.length - 1] !== '"') return;
      if (typeof Q != "string") return `${X.slice(0, -1)}${Q}"`;
      if (Q[0] === '"') return X.slice(0, -1) + Q.slice(1);
      return;
    }
    if (typeof Q == "string" && Q[0] === '"' && !(X instanceof g6)) return `"${X}${Q.slice(1)}`;
    return;
  }
  function wN(X, Q) {
    return Q.emptyStr() ? X : X.emptyStr() ? Q : WG`${X}${Q}`;
  }
  JG.strConcat = wN;
  function AN(X) {
    return typeof X == "number" || typeof X == "boolean" || X === null ? X : fX(Array.isArray(X) ? X.join(",") : X);
  }
  function MN(X) {
    return new s0(fX(X));
  }
  JG.stringify = MN;
  function fX(X) {
    return JSON.stringify(X).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  }
  JG.safeStringify = fX;
  function jN(X) {
    return typeof X == "string" && JG.IDENTIFIER.test(X) ? new s0(`.${X}`) : YG`[${X}]`;
  }
  JG.getProperty = jN;
  function RN(X) {
    if (typeof X == "string" && JG.IDENTIFIER.test(X)) return new s0(`${X}`);
    throw Error(`CodeGen: invalid export name: ${X}, use explicit $id name mapping`);
  }
  JG.getEsmExportName = RN;
  function IN(X) {
    return new s0(X.toString());
  }
  JG.regexpCode = IN;
});
var $Y = P((zG) => {
  Object.defineProperty(zG, "__esModule", { value: true });
  zG.ValueScope = zG.ValueScopeName = zG.Scope = zG.varKinds = zG.UsedValueState = void 0;
  var x0 = hX();
  class HG extends Error {
    constructor(X) {
      super(`CodeGen: "code" for ${X} not defined`);
      this.value = X.value;
    }
  }
  var A8;
  (function(X) {
    X[X.Started = 0] = "Started", X[X.Completed = 1] = "Completed";
  })(A8 || (zG.UsedValueState = A8 = {}));
  zG.varKinds = { const: new x0.Name("const"), let: new x0.Name("let"), var: new x0.Name("var") };
  class XY {
    constructor({ prefixes: X, parent: Q } = {}) {
      this._names = {}, this._prefixes = X, this._parent = Q;
    }
    toName(X) {
      return X instanceof x0.Name ? X : this.name(X);
    }
    name(X) {
      return new x0.Name(this._newName(X));
    }
    _newName(X) {
      let Q = this._names[X] || this._nameGroup(X);
      return `${X}${Q.index++}`;
    }
    _nameGroup(X) {
      var Q, $;
      if ((($ = (Q = this._parent) === null || Q === void 0 ? void 0 : Q._prefixes) === null || $ === void 0 ? void 0 : $.has(X)) || this._prefixes && !this._prefixes.has(X)) throw Error(`CodeGen: prefix "${X}" is not allowed in this scope`);
      return this._names[X] = { prefix: X, index: 0 };
    }
  }
  zG.Scope = XY;
  class QY extends x0.Name {
    constructor(X, Q) {
      super(Q);
      this.prefix = X;
    }
    setValue(X, { property: Q, itemIndex: $ }) {
      this.value = X, this.scopePath = x0._`.${new x0.Name(Q)}[${$}]`;
    }
  }
  zG.ValueScopeName = QY;
  var gN = x0._`\n`;
  class BG extends XY {
    constructor(X) {
      super(X);
      this._values = {}, this._scope = X.scope, this.opts = { ...X, _n: X.lines ? gN : x0.nil };
    }
    get() {
      return this._scope;
    }
    name(X) {
      return new QY(X, this._newName(X));
    }
    value(X, Q) {
      var $;
      if (Q.ref === void 0) throw Error("CodeGen: ref must be passed in value");
      let Y = this.toName(X), { prefix: W } = Y, J = ($ = Q.key) !== null && $ !== void 0 ? $ : Q.ref, G = this._values[W];
      if (G) {
        let z = G.get(J);
        if (z) return z;
      } else G = this._values[W] = /* @__PURE__ */ new Map();
      G.set(J, Y);
      let H = this._scope[W] || (this._scope[W] = []), B = H.length;
      return H[B] = Q.ref, Y.setValue(Q, { property: W, itemIndex: B }), Y;
    }
    getValue(X, Q) {
      let $ = this._values[X];
      if (!$) return;
      return $.get(Q);
    }
    scopeRefs(X, Q = this._values) {
      return this._reduceValues(Q, ($) => {
        if ($.scopePath === void 0) throw Error(`CodeGen: name "${$}" has no value`);
        return x0._`${X}${$.scopePath}`;
      });
    }
    scopeCode(X = this._values, Q, $) {
      return this._reduceValues(X, (Y) => {
        if (Y.value === void 0) throw Error(`CodeGen: name "${Y}" has no value`);
        return Y.value.code;
      }, Q, $);
    }
    _reduceValues(X, Q, $ = {}, Y) {
      let W = x0.nil;
      for (let J in X) {
        let G = X[J];
        if (!G) continue;
        let H = $[J] = $[J] || /* @__PURE__ */ new Map();
        G.forEach((B) => {
          if (H.has(B)) return;
          H.set(B, A8.Started);
          let z = Q(B);
          if (z) {
            let K = this.opts.es5 ? zG.varKinds.var : zG.varKinds.const;
            W = x0._`${W}${K} ${B} = ${z};${this.opts._n}`;
          } else if (z = Y === null || Y === void 0 ? void 0 : Y(B)) W = x0._`${W}${z}${this.opts._n}`;
          else throw new HG(B);
          H.set(B, A8.Completed);
        });
      }
      return W;
    }
  }
  zG.ValueScope = BG;
});
var p = P((y0) => {
  Object.defineProperty(y0, "__esModule", { value: true });
  y0.or = y0.and = y0.not = y0.CodeGen = y0.operators = y0.varKinds = y0.ValueScopeName = y0.ValueScope = y0.Scope = y0.Name = y0.regexpCode = y0.stringify = y0.getProperty = y0.nil = y0.strConcat = y0.str = y0._ = void 0;
  var t = hX(), e0 = $Y(), l1 = hX();
  Object.defineProperty(y0, "_", { enumerable: true, get: function() {
    return l1._;
  } });
  Object.defineProperty(y0, "str", { enumerable: true, get: function() {
    return l1.str;
  } });
  Object.defineProperty(y0, "strConcat", { enumerable: true, get: function() {
    return l1.strConcat;
  } });
  Object.defineProperty(y0, "nil", { enumerable: true, get: function() {
    return l1.nil;
  } });
  Object.defineProperty(y0, "getProperty", { enumerable: true, get: function() {
    return l1.getProperty;
  } });
  Object.defineProperty(y0, "stringify", { enumerable: true, get: function() {
    return l1.stringify;
  } });
  Object.defineProperty(y0, "regexpCode", { enumerable: true, get: function() {
    return l1.regexpCode;
  } });
  Object.defineProperty(y0, "Name", { enumerable: true, get: function() {
    return l1.Name;
  } });
  var b8 = $Y();
  Object.defineProperty(y0, "Scope", { enumerable: true, get: function() {
    return b8.Scope;
  } });
  Object.defineProperty(y0, "ValueScope", { enumerable: true, get: function() {
    return b8.ValueScope;
  } });
  Object.defineProperty(y0, "ValueScopeName", { enumerable: true, get: function() {
    return b8.ValueScopeName;
  } });
  Object.defineProperty(y0, "varKinds", { enumerable: true, get: function() {
    return b8.varKinds;
  } });
  y0.operators = { GT: new t._Code(">"), GTE: new t._Code(">="), LT: new t._Code("<"), LTE: new t._Code("<="), EQ: new t._Code("==="), NEQ: new t._Code("!=="), NOT: new t._Code("!"), OR: new t._Code("||"), AND: new t._Code("&&"), ADD: new t._Code("+") };
  class m1 {
    optimizeNodes() {
      return this;
    }
    optimizeNames(X, Q) {
      return this;
    }
  }
  class UG extends m1 {
    constructor(X, Q, $) {
      super();
      this.varKind = X, this.name = Q, this.rhs = $;
    }
    render({ es5: X, _n: Q }) {
      let $ = X ? e0.varKinds.var : this.varKind, Y = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
      return `${$} ${this.name}${Y};` + Q;
    }
    optimizeNames(X, Q) {
      if (!X[this.name.str]) return;
      if (this.rhs) this.rhs = h6(this.rhs, X, Q);
      return this;
    }
    get names() {
      return this.rhs instanceof t._CodeOrName ? this.rhs.names : {};
    }
  }
  class JY extends m1 {
    constructor(X, Q, $) {
      super();
      this.lhs = X, this.rhs = Q, this.sideEffects = $;
    }
    render({ _n: X }) {
      return `${this.lhs} = ${this.rhs};` + X;
    }
    optimizeNames(X, Q) {
      if (this.lhs instanceof t.Name && !X[this.lhs.str] && !this.sideEffects) return;
      return this.rhs = h6(this.rhs, X, Q), this;
    }
    get names() {
      let X = this.lhs instanceof t.Name ? {} : { ...this.lhs.names };
      return E8(X, this.rhs);
    }
  }
  class VG extends JY {
    constructor(X, Q, $, Y) {
      super(X, $, Y);
      this.op = Q;
    }
    render({ _n: X }) {
      return `${this.lhs} ${this.op}= ${this.rhs};` + X;
    }
  }
  class LG extends m1 {
    constructor(X) {
      super();
      this.label = X, this.names = {};
    }
    render({ _n: X }) {
      return `${this.label}:` + X;
    }
  }
  class qG extends m1 {
    constructor(X) {
      super();
      this.label = X, this.names = {};
    }
    render({ _n: X }) {
      return `break${this.label ? ` ${this.label}` : ""};` + X;
    }
  }
  class FG extends m1 {
    constructor(X) {
      super();
      this.error = X;
    }
    render({ _n: X }) {
      return `throw ${this.error};` + X;
    }
    get names() {
      return this.error.names;
    }
  }
  class NG extends m1 {
    constructor(X) {
      super();
      this.code = X;
    }
    render({ _n: X }) {
      return `${this.code};` + X;
    }
    optimizeNodes() {
      return `${this.code}` ? this : void 0;
    }
    optimizeNames(X, Q) {
      return this.code = h6(this.code, X, Q), this;
    }
    get names() {
      return this.code instanceof t._CodeOrName ? this.code.names : {};
    }
  }
  class P8 extends m1 {
    constructor(X = []) {
      super();
      this.nodes = X;
    }
    render(X) {
      return this.nodes.reduce((Q, $) => Q + $.render(X), "");
    }
    optimizeNodes() {
      let { nodes: X } = this, Q = X.length;
      while (Q--) {
        let $ = X[Q].optimizeNodes();
        if (Array.isArray($)) X.splice(Q, 1, ...$);
        else if ($) X[Q] = $;
        else X.splice(Q, 1);
      }
      return X.length > 0 ? this : void 0;
    }
    optimizeNames(X, Q) {
      let { nodes: $ } = this, Y = $.length;
      while (Y--) {
        let W = $[Y];
        if (W.optimizeNames(X, Q)) continue;
        lN(X, W.names), $.splice(Y, 1);
      }
      return $.length > 0 ? this : void 0;
    }
    get names() {
      return this.nodes.reduce((X, Q) => G6(X, Q.names), {});
    }
  }
  class c1 extends P8 {
    render(X) {
      return "{" + X._n + super.render(X) + "}" + X._n;
    }
  }
  class OG extends P8 {
  }
  class uX extends c1 {
  }
  uX.kind = "else";
  class j1 extends c1 {
    constructor(X, Q) {
      super(Q);
      this.condition = X;
    }
    render(X) {
      let Q = `if(${this.condition})` + super.render(X);
      if (this.else) Q += "else " + this.else.render(X);
      return Q;
    }
    optimizeNodes() {
      super.optimizeNodes();
      let X = this.condition;
      if (X === true) return this.nodes;
      let Q = this.else;
      if (Q) {
        let $ = Q.optimizeNodes();
        Q = this.else = Array.isArray($) ? new uX($) : $;
      }
      if (Q) {
        if (X === false) return Q instanceof j1 ? Q : Q.nodes;
        if (this.nodes.length) return this;
        return new j1(jG(X), Q instanceof j1 ? [Q] : Q.nodes);
      }
      if (X === false || !this.nodes.length) return;
      return this;
    }
    optimizeNames(X, Q) {
      var $;
      if (this.else = ($ = this.else) === null || $ === void 0 ? void 0 : $.optimizeNames(X, Q), !(super.optimizeNames(X, Q) || this.else)) return;
      return this.condition = h6(this.condition, X, Q), this;
    }
    get names() {
      let X = super.names;
      if (E8(X, this.condition), this.else) G6(X, this.else.names);
      return X;
    }
  }
  j1.kind = "if";
  class f6 extends c1 {
  }
  f6.kind = "for";
  class DG extends f6 {
    constructor(X) {
      super();
      this.iteration = X;
    }
    render(X) {
      return `for(${this.iteration})` + super.render(X);
    }
    optimizeNames(X, Q) {
      if (!super.optimizeNames(X, Q)) return;
      return this.iteration = h6(this.iteration, X, Q), this;
    }
    get names() {
      return G6(super.names, this.iteration.names);
    }
  }
  class wG extends f6 {
    constructor(X, Q, $, Y) {
      super();
      this.varKind = X, this.name = Q, this.from = $, this.to = Y;
    }
    render(X) {
      let Q = X.es5 ? e0.varKinds.var : this.varKind, { name: $, from: Y, to: W } = this;
      return `for(${Q} ${$}=${Y}; ${$}<${W}; ${$}++)` + super.render(X);
    }
    get names() {
      let X = E8(super.names, this.from);
      return E8(X, this.to);
    }
  }
  class YY extends f6 {
    constructor(X, Q, $, Y) {
      super();
      this.loop = X, this.varKind = Q, this.name = $, this.iterable = Y;
    }
    render(X) {
      return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(X);
    }
    optimizeNames(X, Q) {
      if (!super.optimizeNames(X, Q)) return;
      return this.iterable = h6(this.iterable, X, Q), this;
    }
    get names() {
      return G6(super.names, this.iterable.names);
    }
  }
  class M8 extends c1 {
    constructor(X, Q, $) {
      super();
      this.name = X, this.args = Q, this.async = $;
    }
    render(X) {
      return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(X);
    }
  }
  M8.kind = "func";
  class j8 extends P8 {
    render(X) {
      return "return " + super.render(X);
    }
  }
  j8.kind = "return";
  class AG extends c1 {
    render(X) {
      let Q = "try" + super.render(X);
      if (this.catch) Q += this.catch.render(X);
      if (this.finally) Q += this.finally.render(X);
      return Q;
    }
    optimizeNodes() {
      var X, Q;
      return super.optimizeNodes(), (X = this.catch) === null || X === void 0 || X.optimizeNodes(), (Q = this.finally) === null || Q === void 0 || Q.optimizeNodes(), this;
    }
    optimizeNames(X, Q) {
      var $, Y;
      return super.optimizeNames(X, Q), ($ = this.catch) === null || $ === void 0 || $.optimizeNames(X, Q), (Y = this.finally) === null || Y === void 0 || Y.optimizeNames(X, Q), this;
    }
    get names() {
      let X = super.names;
      if (this.catch) G6(X, this.catch.names);
      if (this.finally) G6(X, this.finally.names);
      return X;
    }
  }
  class R8 extends c1 {
    constructor(X) {
      super();
      this.error = X;
    }
    render(X) {
      return `catch(${this.error})` + super.render(X);
    }
  }
  R8.kind = "catch";
  class I8 extends c1 {
    render(X) {
      return "finally" + super.render(X);
    }
  }
  I8.kind = "finally";
  class MG {
    constructor(X, Q = {}) {
      this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...Q, _n: Q.lines ? `
` : "" }, this._extScope = X, this._scope = new e0.Scope({ parent: X }), this._nodes = [new OG()];
    }
    toString() {
      return this._root.render(this.opts);
    }
    name(X) {
      return this._scope.name(X);
    }
    scopeName(X) {
      return this._extScope.name(X);
    }
    scopeValue(X, Q) {
      let $ = this._extScope.value(X, Q);
      return (this._values[$.prefix] || (this._values[$.prefix] = /* @__PURE__ */ new Set())).add($), $;
    }
    getScopeValue(X, Q) {
      return this._extScope.getValue(X, Q);
    }
    scopeRefs(X) {
      return this._extScope.scopeRefs(X, this._values);
    }
    scopeCode() {
      return this._extScope.scopeCode(this._values);
    }
    _def(X, Q, $, Y) {
      let W = this._scope.toName(Q);
      if ($ !== void 0 && Y) this._constants[W.str] = $;
      return this._leafNode(new UG(X, W, $)), W;
    }
    const(X, Q, $) {
      return this._def(e0.varKinds.const, X, Q, $);
    }
    let(X, Q, $) {
      return this._def(e0.varKinds.let, X, Q, $);
    }
    var(X, Q, $) {
      return this._def(e0.varKinds.var, X, Q, $);
    }
    assign(X, Q, $) {
      return this._leafNode(new JY(X, Q, $));
    }
    add(X, Q) {
      return this._leafNode(new VG(X, y0.operators.ADD, Q));
    }
    code(X) {
      if (typeof X == "function") X();
      else if (X !== t.nil) this._leafNode(new NG(X));
      return this;
    }
    object(...X) {
      let Q = ["{"];
      for (let [$, Y] of X) {
        if (Q.length > 1) Q.push(",");
        if (Q.push($), $ !== Y || this.opts.es5) Q.push(":"), (0, t.addCodeArg)(Q, Y);
      }
      return Q.push("}"), new t._Code(Q);
    }
    if(X, Q, $) {
      if (this._blockNode(new j1(X)), Q && $) this.code(Q).else().code($).endIf();
      else if (Q) this.code(Q).endIf();
      else if ($) throw Error('CodeGen: "else" body without "then" body');
      return this;
    }
    elseIf(X) {
      return this._elseNode(new j1(X));
    }
    else() {
      return this._elseNode(new uX());
    }
    endIf() {
      return this._endBlockNode(j1, uX);
    }
    _for(X, Q) {
      if (this._blockNode(X), Q) this.code(Q).endFor();
      return this;
    }
    for(X, Q) {
      return this._for(new DG(X), Q);
    }
    forRange(X, Q, $, Y, W = this.opts.es5 ? e0.varKinds.var : e0.varKinds.let) {
      let J = this._scope.toName(X);
      return this._for(new wG(W, J, Q, $), () => Y(J));
    }
    forOf(X, Q, $, Y = e0.varKinds.const) {
      let W = this._scope.toName(X);
      if (this.opts.es5) {
        let J = Q instanceof t.Name ? Q : this.var("_arr", Q);
        return this.forRange("_i", 0, t._`${J}.length`, (G) => {
          this.var(W, t._`${J}[${G}]`), $(W);
        });
      }
      return this._for(new YY("of", Y, W, Q), () => $(W));
    }
    forIn(X, Q, $, Y = this.opts.es5 ? e0.varKinds.var : e0.varKinds.const) {
      if (this.opts.ownProperties) return this.forOf(X, t._`Object.keys(${Q})`, $);
      let W = this._scope.toName(X);
      return this._for(new YY("in", Y, W, Q), () => $(W));
    }
    endFor() {
      return this._endBlockNode(f6);
    }
    label(X) {
      return this._leafNode(new LG(X));
    }
    break(X) {
      return this._leafNode(new qG(X));
    }
    return(X) {
      let Q = new j8();
      if (this._blockNode(Q), this.code(X), Q.nodes.length !== 1) throw Error('CodeGen: "return" should have one node');
      return this._endBlockNode(j8);
    }
    try(X, Q, $) {
      if (!Q && !$) throw Error('CodeGen: "try" without "catch" and "finally"');
      let Y = new AG();
      if (this._blockNode(Y), this.code(X), Q) {
        let W = this.name("e");
        this._currNode = Y.catch = new R8(W), Q(W);
      }
      if ($) this._currNode = Y.finally = new I8(), this.code($);
      return this._endBlockNode(R8, I8);
    }
    throw(X) {
      return this._leafNode(new FG(X));
    }
    block(X, Q) {
      if (this._blockStarts.push(this._nodes.length), X) this.code(X).endBlock(Q);
      return this;
    }
    endBlock(X) {
      let Q = this._blockStarts.pop();
      if (Q === void 0) throw Error("CodeGen: not in self-balancing block");
      let $ = this._nodes.length - Q;
      if ($ < 0 || X !== void 0 && $ !== X) throw Error(`CodeGen: wrong number of nodes: ${$} vs ${X} expected`);
      return this._nodes.length = Q, this;
    }
    func(X, Q = t.nil, $, Y) {
      if (this._blockNode(new M8(X, Q, $)), Y) this.code(Y).endFunc();
      return this;
    }
    endFunc() {
      return this._endBlockNode(M8);
    }
    optimize(X = 1) {
      while (X-- > 0) this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
    }
    _leafNode(X) {
      return this._currNode.nodes.push(X), this;
    }
    _blockNode(X) {
      this._currNode.nodes.push(X), this._nodes.push(X);
    }
    _endBlockNode(X, Q) {
      let $ = this._currNode;
      if ($ instanceof X || Q && $ instanceof Q) return this._nodes.pop(), this;
      throw Error(`CodeGen: not in block "${Q ? `${X.kind}/${Q.kind}` : X.kind}"`);
    }
    _elseNode(X) {
      let Q = this._currNode;
      if (!(Q instanceof j1)) throw Error('CodeGen: "else" without "if"');
      return this._currNode = Q.else = X, this;
    }
    get _root() {
      return this._nodes[0];
    }
    get _currNode() {
      let X = this._nodes;
      return X[X.length - 1];
    }
    set _currNode(X) {
      let Q = this._nodes;
      Q[Q.length - 1] = X;
    }
  }
  y0.CodeGen = MG;
  function G6(X, Q) {
    for (let $ in Q) X[$] = (X[$] || 0) + (Q[$] || 0);
    return X;
  }
  function E8(X, Q) {
    return Q instanceof t._CodeOrName ? G6(X, Q.names) : X;
  }
  function h6(X, Q, $) {
    if (X instanceof t.Name) return Y(X);
    if (!W(X)) return X;
    return new t._Code(X._items.reduce((J, G) => {
      if (G instanceof t.Name) G = Y(G);
      if (G instanceof t._Code) J.push(...G._items);
      else J.push(G);
      return J;
    }, []));
    function Y(J) {
      let G = $[J.str];
      if (G === void 0 || Q[J.str] !== 1) return J;
      return delete Q[J.str], G;
    }
    function W(J) {
      return J instanceof t._Code && J._items.some((G) => G instanceof t.Name && Q[G.str] === 1 && $[G.str] !== void 0);
    }
  }
  function lN(X, Q) {
    for (let $ in Q) X[$] = (X[$] || 0) - (Q[$] || 0);
  }
  function jG(X) {
    return typeof X == "boolean" || typeof X == "number" || X === null ? !X : t._`!${WY(X)}`;
  }
  y0.not = jG;
  var mN = RG(y0.operators.AND);
  function cN(...X) {
    return X.reduce(mN);
  }
  y0.and = cN;
  var pN = RG(y0.operators.OR);
  function dN(...X) {
    return X.reduce(pN);
  }
  y0.or = dN;
  function RG(X) {
    return (Q, $) => Q === t.nil ? $ : $ === t.nil ? Q : t._`${WY(Q)} ${X} ${WY($)}`;
  }
  function WY(X) {
    return X instanceof t.Name ? X : t._`(${X})`;
  }
});
var e = P((vG) => {
  Object.defineProperty(vG, "__esModule", { value: true });
  vG.checkStrictMode = vG.getErrorPath = vG.Type = vG.useFunc = vG.setEvaluated = vG.evaluatedPropsToName = vG.mergeEvaluated = vG.eachItem = vG.unescapeJsonPointer = vG.escapeJsonPointer = vG.escapeFragment = vG.unescapeFragment = vG.schemaRefOrVal = vG.schemaHasRulesButRef = vG.schemaHasRules = vG.checkUnknownRules = vG.alwaysValidSchema = vG.toHash = void 0;
  var $0 = p(), oN = hX();
  function tN(X) {
    let Q = {};
    for (let $ of X) Q[$] = true;
    return Q;
  }
  vG.toHash = tN;
  function aN(X, Q) {
    if (typeof Q == "boolean") return Q;
    if (Object.keys(Q).length === 0) return true;
    return PG(X, Q), !SG(Q, X.self.RULES.all);
  }
  vG.alwaysValidSchema = aN;
  function PG(X, Q = X.schema) {
    let { opts: $, self: Y } = X;
    if (!$.strictSchema) return;
    if (typeof Q === "boolean") return;
    let W = Y.RULES.keywords;
    for (let J in Q) if (!W[J]) kG(X, `unknown keyword: "${J}"`);
  }
  vG.checkUnknownRules = PG;
  function SG(X, Q) {
    if (typeof X == "boolean") return !X;
    for (let $ in X) if (Q[$]) return true;
    return false;
  }
  vG.schemaHasRules = SG;
  function sN(X, Q) {
    if (typeof X == "boolean") return !X;
    for (let $ in X) if ($ !== "$ref" && Q.all[$]) return true;
    return false;
  }
  vG.schemaHasRulesButRef = sN;
  function eN({ topSchemaRef: X, schemaPath: Q }, $, Y, W) {
    if (!W) {
      if (typeof $ == "number" || typeof $ == "boolean") return $;
      if (typeof $ == "string") return $0._`${$}`;
    }
    return $0._`${X}${Q}${(0, $0.getProperty)(Y)}`;
  }
  vG.schemaRefOrVal = eN;
  function XO(X) {
    return ZG(decodeURIComponent(X));
  }
  vG.unescapeFragment = XO;
  function QO(X) {
    return encodeURIComponent(HY(X));
  }
  vG.escapeFragment = QO;
  function HY(X) {
    if (typeof X == "number") return `${X}`;
    return X.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  vG.escapeJsonPointer = HY;
  function ZG(X) {
    return X.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  vG.unescapeJsonPointer = ZG;
  function $O(X, Q) {
    if (Array.isArray(X)) for (let $ of X) Q($);
    else Q(X);
  }
  vG.eachItem = $O;
  function EG({ mergeNames: X, mergeToName: Q, mergeValues: $, resultToName: Y }) {
    return (W, J, G, H) => {
      let B = G === void 0 ? J : G instanceof $0.Name ? (J instanceof $0.Name ? X(W, J, G) : Q(W, J, G), G) : J instanceof $0.Name ? (Q(W, G, J), J) : $(J, G);
      return H === $0.Name && !(B instanceof $0.Name) ? Y(W, B) : B;
    };
  }
  vG.mergeEvaluated = { props: EG({ mergeNames: (X, Q, $) => X.if($0._`${$} !== true && ${Q} !== undefined`, () => {
    X.if($0._`${Q} === true`, () => X.assign($, true), () => X.assign($, $0._`${$} || {}`).code($0._`Object.assign(${$}, ${Q})`));
  }), mergeToName: (X, Q, $) => X.if($0._`${$} !== true`, () => {
    if (Q === true) X.assign($, true);
    else X.assign($, $0._`${$} || {}`), BY(X, $, Q);
  }), mergeValues: (X, Q) => X === true ? true : { ...X, ...Q }, resultToName: CG }), items: EG({ mergeNames: (X, Q, $) => X.if($0._`${$} !== true && ${Q} !== undefined`, () => X.assign($, $0._`${Q} === true ? true : ${$} > ${Q} ? ${$} : ${Q}`)), mergeToName: (X, Q, $) => X.if($0._`${$} !== true`, () => X.assign($, Q === true ? true : $0._`${$} > ${Q} ? ${$} : ${Q}`)), mergeValues: (X, Q) => X === true ? true : Math.max(X, Q), resultToName: (X, Q) => X.var("items", Q) }) };
  function CG(X, Q) {
    if (Q === true) return X.var("props", true);
    let $ = X.var("props", $0._`{}`);
    if (Q !== void 0) BY(X, $, Q);
    return $;
  }
  vG.evaluatedPropsToName = CG;
  function BY(X, Q, $) {
    Object.keys($).forEach((Y) => X.assign($0._`${Q}${(0, $0.getProperty)(Y)}`, true));
  }
  vG.setEvaluated = BY;
  var bG = {};
  function YO(X, Q) {
    return X.scopeValue("func", { ref: Q, code: bG[Q.code] || (bG[Q.code] = new oN._Code(Q.code)) });
  }
  vG.useFunc = YO;
  var GY;
  (function(X) {
    X[X.Num = 0] = "Num", X[X.Str = 1] = "Str";
  })(GY || (vG.Type = GY = {}));
  function WO(X, Q, $) {
    if (X instanceof $0.Name) {
      let Y = Q === GY.Num;
      return $ ? Y ? $0._`"[" + ${X} + "]"` : $0._`"['" + ${X} + "']"` : Y ? $0._`"/" + ${X}` : $0._`"/" + ${X}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
    }
    return $ ? (0, $0.getProperty)(X).toString() : "/" + HY(X);
  }
  vG.getErrorPath = WO;
  function kG(X, Q, $ = X.opts.strictSchema) {
    if (!$) return;
    if (Q = `strict mode: ${Q}`, $ === true) throw Error(Q);
    X.self.logger.warn(Q);
  }
  vG.checkStrictMode = kG;
});
var R1 = P((_G) => {
  Object.defineProperty(_G, "__esModule", { value: true });
  var S0 = p(), jO = { data: new S0.Name("data"), valCxt: new S0.Name("valCxt"), instancePath: new S0.Name("instancePath"), parentData: new S0.Name("parentData"), parentDataProperty: new S0.Name("parentDataProperty"), rootData: new S0.Name("rootData"), dynamicAnchors: new S0.Name("dynamicAnchors"), vErrors: new S0.Name("vErrors"), errors: new S0.Name("errors"), this: new S0.Name("this"), self: new S0.Name("self"), scope: new S0.Name("scope"), json: new S0.Name("json"), jsonPos: new S0.Name("jsonPos"), jsonLen: new S0.Name("jsonLen"), jsonPart: new S0.Name("jsonPart") };
  _G.default = jO;
});
var lX = P((fG) => {
  Object.defineProperty(fG, "__esModule", { value: true });
  fG.extendErrors = fG.resetErrorsCount = fG.reportExtraError = fG.reportError = fG.keyword$DataError = fG.keywordError = void 0;
  var a = p(), Z8 = e(), v0 = R1();
  fG.keywordError = { message: ({ keyword: X }) => a.str`must pass "${X}" keyword validation` };
  fG.keyword$DataError = { message: ({ keyword: X, schemaType: Q }) => Q ? a.str`"${X}" keyword must be ${Q} ($data)` : a.str`"${X}" keyword is invalid ($data)` };
  function IO(X, Q = fG.keywordError, $, Y) {
    let { it: W } = X, { gen: J, compositeRule: G, allErrors: H } = W, B = gG(X, Q, $);
    if (Y !== null && Y !== void 0 ? Y : G || H) xG(J, B);
    else yG(W, a._`[${B}]`);
  }
  fG.reportError = IO;
  function EO(X, Q = fG.keywordError, $) {
    let { it: Y } = X, { gen: W, compositeRule: J, allErrors: G } = Y, H = gG(X, Q, $);
    if (xG(W, H), !(J || G)) yG(Y, v0.default.vErrors);
  }
  fG.reportExtraError = EO;
  function bO(X, Q) {
    X.assign(v0.default.errors, Q), X.if(a._`${v0.default.vErrors} !== null`, () => X.if(Q, () => X.assign(a._`${v0.default.vErrors}.length`, Q), () => X.assign(v0.default.vErrors, null)));
  }
  fG.resetErrorsCount = bO;
  function PO({ gen: X, keyword: Q, schemaValue: $, data: Y, errsCount: W, it: J }) {
    if (W === void 0) throw Error("ajv implementation error");
    let G = X.name("err");
    X.forRange("i", W, v0.default.errors, (H) => {
      if (X.const(G, a._`${v0.default.vErrors}[${H}]`), X.if(a._`${G}.instancePath === undefined`, () => X.assign(a._`${G}.instancePath`, (0, a.strConcat)(v0.default.instancePath, J.errorPath))), X.assign(a._`${G}.schemaPath`, a.str`${J.errSchemaPath}/${Q}`), J.opts.verbose) X.assign(a._`${G}.schema`, $), X.assign(a._`${G}.data`, Y);
    });
  }
  fG.extendErrors = PO;
  function xG(X, Q) {
    let $ = X.const("err", Q);
    X.if(a._`${v0.default.vErrors} === null`, () => X.assign(v0.default.vErrors, a._`[${$}]`), a._`${v0.default.vErrors}.push(${$})`), X.code(a._`${v0.default.errors}++`);
  }
  function yG(X, Q) {
    let { gen: $, validateName: Y, schemaEnv: W } = X;
    if (W.$async) $.throw(a._`new ${X.ValidationError}(${Q})`);
    else $.assign(a._`${Y}.errors`, Q), $.return(false);
  }
  var H6 = { keyword: new a.Name("keyword"), schemaPath: new a.Name("schemaPath"), params: new a.Name("params"), propertyName: new a.Name("propertyName"), message: new a.Name("message"), schema: new a.Name("schema"), parentSchema: new a.Name("parentSchema") };
  function gG(X, Q, $) {
    let { createErrors: Y } = X.it;
    if (Y === false) return a._`{}`;
    return SO(X, Q, $);
  }
  function SO(X, Q, $ = {}) {
    let { gen: Y, it: W } = X, J = [ZO(W, $), CO(X, $)];
    return kO(X, Q, J), Y.object(...J);
  }
  function ZO({ errorPath: X }, { instancePath: Q }) {
    let $ = Q ? a.str`${X}${(0, Z8.getErrorPath)(Q, Z8.Type.Str)}` : X;
    return [v0.default.instancePath, (0, a.strConcat)(v0.default.instancePath, $)];
  }
  function CO({ keyword: X, it: { errSchemaPath: Q } }, { schemaPath: $, parentSchema: Y }) {
    let W = Y ? Q : a.str`${Q}/${X}`;
    if ($) W = a.str`${W}${(0, Z8.getErrorPath)($, Z8.Type.Str)}`;
    return [H6.schemaPath, W];
  }
  function kO(X, { params: Q, message: $ }, Y) {
    let { keyword: W, data: J, schemaValue: G, it: H } = X, { opts: B, propertyName: z, topSchemaRef: K, schemaPath: V } = H;
    if (Y.push([H6.keyword, W], [H6.params, typeof Q == "function" ? Q(X) : Q || a._`{}`]), B.messages) Y.push([H6.message, typeof $ == "function" ? $(X) : $]);
    if (B.verbose) Y.push([H6.schema, G], [H6.parentSchema, a._`${K}${V}`], [v0.default.data, J]);
    if (z) Y.push([H6.propertyName, z]);
  }
});
var cG = P((lG) => {
  Object.defineProperty(lG, "__esModule", { value: true });
  lG.boolOrEmptySchema = lG.topBoolOrEmptySchema = void 0;
  var yO = lX(), gO = p(), fO = R1(), hO = { message: "boolean schema is false" };
  function uO(X) {
    let { gen: Q, schema: $, validateName: Y } = X;
    if ($ === false) uG(X, false);
    else if (typeof $ == "object" && $.$async === true) Q.return(fO.default.data);
    else Q.assign(gO._`${Y}.errors`, null), Q.return(true);
  }
  lG.topBoolOrEmptySchema = uO;
  function lO(X, Q) {
    let { gen: $, schema: Y } = X;
    if (Y === false) $.var(Q, false), uG(X);
    else $.var(Q, true);
  }
  lG.boolOrEmptySchema = lO;
  function uG(X, Q) {
    let { gen: $, data: Y } = X, W = { gen: $, keyword: "false schema", data: Y, schema: false, schemaCode: false, schemaValue: false, params: {}, it: X };
    (0, yO.reportError)(W, hO, void 0, Q);
  }
});
var KY = P((pG) => {
  Object.defineProperty(pG, "__esModule", { value: true });
  pG.getRules = pG.isJSONType = void 0;
  var cO = ["string", "number", "integer", "boolean", "null", "object", "array"], pO = new Set(cO);
  function dO(X) {
    return typeof X == "string" && pO.has(X);
  }
  pG.isJSONType = dO;
  function iO() {
    let X = { number: { type: "number", rules: [] }, string: { type: "string", rules: [] }, array: { type: "array", rules: [] }, object: { type: "object", rules: [] } };
    return { types: { ...X, integer: true, boolean: true, null: true }, rules: [{ rules: [] }, X.number, X.string, X.array, X.object], post: { rules: [] }, all: {}, keywords: {} };
  }
  pG.getRules = iO;
});
var UY = P((rG) => {
  Object.defineProperty(rG, "__esModule", { value: true });
  rG.shouldUseRule = rG.shouldUseGroup = rG.schemaHasRulesForType = void 0;
  function rO({ schema: X, self: Q }, $) {
    let Y = Q.RULES.types[$];
    return Y && Y !== true && iG(X, Y);
  }
  rG.schemaHasRulesForType = rO;
  function iG(X, Q) {
    return Q.rules.some(($) => nG(X, $));
  }
  rG.shouldUseGroup = iG;
  function nG(X, Q) {
    var $;
    return X[Q.keyword] !== void 0 || (($ = Q.definition.implements) === null || $ === void 0 ? void 0 : $.some((Y) => X[Y] !== void 0));
  }
  rG.shouldUseRule = nG;
});
var mX = P((eG) => {
  Object.defineProperty(eG, "__esModule", { value: true });
  eG.reportTypeError = eG.checkDataTypes = eG.checkDataType = eG.coerceAndCheckDataType = eG.getJSONTypes = eG.getSchemaTypes = eG.DataType = void 0;
  var aO = KY(), sO = UY(), eO = lX(), m = p(), tG = e(), u6;
  (function(X) {
    X[X.Correct = 0] = "Correct", X[X.Wrong = 1] = "Wrong";
  })(u6 || (eG.DataType = u6 = {}));
  function XD(X) {
    let Q = aG(X.type);
    if (Q.includes("null")) {
      if (X.nullable === false) throw Error("type: null contradicts nullable: false");
    } else {
      if (!Q.length && X.nullable !== void 0) throw Error('"nullable" cannot be used without "type"');
      if (X.nullable === true) Q.push("null");
    }
    return Q;
  }
  eG.getSchemaTypes = XD;
  function aG(X) {
    let Q = Array.isArray(X) ? X : X ? [X] : [];
    if (Q.every(aO.isJSONType)) return Q;
    throw Error("type must be JSONType or JSONType[]: " + Q.join(","));
  }
  eG.getJSONTypes = aG;
  function QD(X, Q) {
    let { gen: $, data: Y, opts: W } = X, J = $D(Q, W.coerceTypes), G = Q.length > 0 && !(J.length === 0 && Q.length === 1 && (0, sO.schemaHasRulesForType)(X, Q[0]));
    if (G) {
      let H = LY(Q, Y, W.strictNumbers, u6.Wrong);
      $.if(H, () => {
        if (J.length) YD(X, Q, J);
        else qY(X);
      });
    }
    return G;
  }
  eG.coerceAndCheckDataType = QD;
  var sG = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
  function $D(X, Q) {
    return Q ? X.filter(($) => sG.has($) || Q === "array" && $ === "array") : [];
  }
  function YD(X, Q, $) {
    let { gen: Y, data: W, opts: J } = X, G = Y.let("dataType", m._`typeof ${W}`), H = Y.let("coerced", m._`undefined`);
    if (J.coerceTypes === "array") Y.if(m._`${G} == 'object' && Array.isArray(${W}) && ${W}.length == 1`, () => Y.assign(W, m._`${W}[0]`).assign(G, m._`typeof ${W}`).if(LY(Q, W, J.strictNumbers), () => Y.assign(H, W)));
    Y.if(m._`${H} !== undefined`);
    for (let z of $) if (sG.has(z) || z === "array" && J.coerceTypes === "array") B(z);
    Y.else(), qY(X), Y.endIf(), Y.if(m._`${H} !== undefined`, () => {
      Y.assign(W, H), WD(X, H);
    });
    function B(z) {
      switch (z) {
        case "string":
          Y.elseIf(m._`${G} == "number" || ${G} == "boolean"`).assign(H, m._`"" + ${W}`).elseIf(m._`${W} === null`).assign(H, m._`""`);
          return;
        case "number":
          Y.elseIf(m._`${G} == "boolean" || ${W} === null
              || (${G} == "string" && ${W} && ${W} == +${W})`).assign(H, m._`+${W}`);
          return;
        case "integer":
          Y.elseIf(m._`${G} === "boolean" || ${W} === null
              || (${G} === "string" && ${W} && ${W} == +${W} && !(${W} % 1))`).assign(H, m._`+${W}`);
          return;
        case "boolean":
          Y.elseIf(m._`${W} === "false" || ${W} === 0 || ${W} === null`).assign(H, false).elseIf(m._`${W} === "true" || ${W} === 1`).assign(H, true);
          return;
        case "null":
          Y.elseIf(m._`${W} === "" || ${W} === 0 || ${W} === false`), Y.assign(H, null);
          return;
        case "array":
          Y.elseIf(m._`${G} === "string" || ${G} === "number"
              || ${G} === "boolean" || ${W} === null`).assign(H, m._`[${W}]`);
      }
    }
  }
  function WD({ gen: X, parentData: Q, parentDataProperty: $ }, Y) {
    X.if(m._`${Q} !== undefined`, () => X.assign(m._`${Q}[${$}]`, Y));
  }
  function VY(X, Q, $, Y = u6.Correct) {
    let W = Y === u6.Correct ? m.operators.EQ : m.operators.NEQ, J;
    switch (X) {
      case "null":
        return m._`${Q} ${W} null`;
      case "array":
        J = m._`Array.isArray(${Q})`;
        break;
      case "object":
        J = m._`${Q} && typeof ${Q} == "object" && !Array.isArray(${Q})`;
        break;
      case "integer":
        J = G(m._`!(${Q} % 1) && !isNaN(${Q})`);
        break;
      case "number":
        J = G();
        break;
      default:
        return m._`typeof ${Q} ${W} ${X}`;
    }
    return Y === u6.Correct ? J : (0, m.not)(J);
    function G(H = m.nil) {
      return (0, m.and)(m._`typeof ${Q} == "number"`, H, $ ? m._`isFinite(${Q})` : m.nil);
    }
  }
  eG.checkDataType = VY;
  function LY(X, Q, $, Y) {
    if (X.length === 1) return VY(X[0], Q, $, Y);
    let W, J = (0, tG.toHash)(X);
    if (J.array && J.object) {
      let G = m._`typeof ${Q} != "object"`;
      W = J.null ? G : m._`!${Q} || ${G}`, delete J.null, delete J.array, delete J.object;
    } else W = m.nil;
    if (J.number) delete J.integer;
    for (let G in J) W = (0, m.and)(W, VY(G, Q, $, Y));
    return W;
  }
  eG.checkDataTypes = LY;
  var JD = { message: ({ schema: X }) => `must be ${X}`, params: ({ schema: X, schemaValue: Q }) => typeof X == "string" ? m._`{type: ${X}}` : m._`{type: ${Q}}` };
  function qY(X) {
    let Q = GD(X);
    (0, eO.reportError)(Q, JD);
  }
  eG.reportTypeError = qY;
  function GD(X) {
    let { gen: Q, data: $, schema: Y } = X, W = (0, tG.schemaRefOrVal)(X, Y, "type");
    return { gen: Q, keyword: "type", data: $, schema: Y.type, schemaCode: W, schemaValue: W, parentSchema: Y, params: {}, it: X };
  }
});
var W3 = P(($3) => {
  Object.defineProperty($3, "__esModule", { value: true });
  $3.assignDefaults = void 0;
  var l6 = p(), LD = e();
  function qD(X, Q) {
    let { properties: $, items: Y } = X.schema;
    if (Q === "object" && $) for (let W in $) Q3(X, W, $[W].default);
    else if (Q === "array" && Array.isArray(Y)) Y.forEach((W, J) => Q3(X, J, W.default));
  }
  $3.assignDefaults = qD;
  function Q3(X, Q, $) {
    let { gen: Y, compositeRule: W, data: J, opts: G } = X;
    if ($ === void 0) return;
    let H = l6._`${J}${(0, l6.getProperty)(Q)}`;
    if (W) {
      (0, LD.checkStrictMode)(X, `default is ignored for: ${H}`);
      return;
    }
    let B = l6._`${H} === undefined`;
    if (G.useDefaults === "empty") B = l6._`${B} || ${H} === null || ${H} === ""`;
    Y.if(B, l6._`${H} = ${(0, l6.stringify)($)}`);
  }
});
var d0 = P((H3) => {
  Object.defineProperty(H3, "__esModule", { value: true });
  H3.validateUnion = H3.validateArray = H3.usePattern = H3.callValidateCode = H3.schemaProperties = H3.allSchemaProperties = H3.noPropertyInData = H3.propertyInData = H3.isOwnProperty = H3.hasPropFunc = H3.reportMissingProp = H3.checkMissingProp = H3.checkReportMissingProp = void 0;
  var G0 = p(), FY = e(), p1 = R1(), FD = e();
  function ND(X, Q) {
    let { gen: $, data: Y, it: W } = X;
    $.if(OY($, Y, Q, W.opts.ownProperties), () => {
      X.setParams({ missingProperty: G0._`${Q}` }, true), X.error();
    });
  }
  H3.checkReportMissingProp = ND;
  function OD({ gen: X, data: Q, it: { opts: $ } }, Y, W) {
    return (0, G0.or)(...Y.map((J) => (0, G0.and)(OY(X, Q, J, $.ownProperties), G0._`${W} = ${J}`)));
  }
  H3.checkMissingProp = OD;
  function DD(X, Q) {
    X.setParams({ missingProperty: Q }, true), X.error();
  }
  H3.reportMissingProp = DD;
  function J3(X) {
    return X.scopeValue("func", { ref: Object.prototype.hasOwnProperty, code: G0._`Object.prototype.hasOwnProperty` });
  }
  H3.hasPropFunc = J3;
  function NY(X, Q, $) {
    return G0._`${J3(X)}.call(${Q}, ${$})`;
  }
  H3.isOwnProperty = NY;
  function wD(X, Q, $, Y) {
    let W = G0._`${Q}${(0, G0.getProperty)($)} !== undefined`;
    return Y ? G0._`${W} && ${NY(X, Q, $)}` : W;
  }
  H3.propertyInData = wD;
  function OY(X, Q, $, Y) {
    let W = G0._`${Q}${(0, G0.getProperty)($)} === undefined`;
    return Y ? (0, G0.or)(W, (0, G0.not)(NY(X, Q, $))) : W;
  }
  H3.noPropertyInData = OY;
  function G3(X) {
    return X ? Object.keys(X).filter((Q) => Q !== "__proto__") : [];
  }
  H3.allSchemaProperties = G3;
  function AD(X, Q) {
    return G3(Q).filter(($) => !(0, FY.alwaysValidSchema)(X, Q[$]));
  }
  H3.schemaProperties = AD;
  function MD({ schemaCode: X, data: Q, it: { gen: $, topSchemaRef: Y, schemaPath: W, errorPath: J }, it: G }, H, B, z) {
    let K = z ? G0._`${X}, ${Q}, ${Y}${W}` : Q, V = [[p1.default.instancePath, (0, G0.strConcat)(p1.default.instancePath, J)], [p1.default.parentData, G.parentData], [p1.default.parentDataProperty, G.parentDataProperty], [p1.default.rootData, p1.default.rootData]];
    if (G.opts.dynamicRef) V.push([p1.default.dynamicAnchors, p1.default.dynamicAnchors]);
    let L = G0._`${K}, ${$.object(...V)}`;
    return B !== G0.nil ? G0._`${H}.call(${B}, ${L})` : G0._`${H}(${L})`;
  }
  H3.callValidateCode = MD;
  var jD = G0._`new RegExp`;
  function RD({ gen: X, it: { opts: Q } }, $) {
    let Y = Q.unicodeRegExp ? "u" : "", { regExp: W } = Q.code, J = W($, Y);
    return X.scopeValue("pattern", { key: J.toString(), ref: J, code: G0._`${W.code === "new RegExp" ? jD : (0, FD.useFunc)(X, W)}(${$}, ${Y})` });
  }
  H3.usePattern = RD;
  function ID(X) {
    let { gen: Q, data: $, keyword: Y, it: W } = X, J = Q.name("valid");
    if (W.allErrors) {
      let H = Q.let("valid", true);
      return G(() => Q.assign(H, false)), H;
    }
    return Q.var(J, true), G(() => Q.break()), J;
    function G(H) {
      let B = Q.const("len", G0._`${$}.length`);
      Q.forRange("i", 0, B, (z) => {
        X.subschema({ keyword: Y, dataProp: z, dataPropType: FY.Type.Num }, J), Q.if((0, G0.not)(J), H);
      });
    }
  }
  H3.validateArray = ID;
  function ED(X) {
    let { gen: Q, schema: $, keyword: Y, it: W } = X;
    if (!Array.isArray($)) throw Error("ajv implementation error");
    if ($.some((B) => (0, FY.alwaysValidSchema)(W, B)) && !W.opts.unevaluated) return;
    let G = Q.let("valid", false), H = Q.name("_valid");
    Q.block(() => $.forEach((B, z) => {
      let K = X.subschema({ keyword: Y, schemaProp: z, compositeRule: true }, H);
      if (Q.assign(G, G0._`${G} || ${H}`), !X.mergeValidEvaluated(K, H)) Q.if((0, G0.not)(G));
    })), X.result(G, () => X.reset(), () => X.error(true));
  }
  H3.validateUnion = ED;
});
var L3 = P((U3) => {
  Object.defineProperty(U3, "__esModule", { value: true });
  U3.validateKeywordUsage = U3.validSchemaType = U3.funcKeywordCode = U3.macroKeywordCode = void 0;
  var T0 = p(), B6 = R1(), fD = d0(), hD = lX();
  function uD(X, Q) {
    let { gen: $, keyword: Y, schema: W, parentSchema: J, it: G } = X, H = Q.macro.call(G.self, W, J, G), B = K3($, Y, H);
    if (G.opts.validateSchema !== false) G.self.validateSchema(H, true);
    let z = $.name("valid");
    X.subschema({ schema: H, schemaPath: T0.nil, errSchemaPath: `${G.errSchemaPath}/${Y}`, topSchemaRef: B, compositeRule: true }, z), X.pass(z, () => X.error(true));
  }
  U3.macroKeywordCode = uD;
  function lD(X, Q) {
    var $;
    let { gen: Y, keyword: W, schema: J, parentSchema: G, $data: H, it: B } = X;
    cD(B, Q);
    let z = !H && Q.compile ? Q.compile.call(B.self, J, G, B) : Q.validate, K = K3(Y, W, z), V = Y.let("valid");
    X.block$data(V, L), X.ok(($ = Q.valid) !== null && $ !== void 0 ? $ : V);
    function L() {
      if (Q.errors === false) {
        if (q(), Q.modifying) z3(X);
        N(() => X.error());
      } else {
        let w = Q.async ? U() : F();
        if (Q.modifying) z3(X);
        N(() => mD(X, w));
      }
    }
    function U() {
      let w = Y.let("ruleErrs", null);
      return Y.try(() => q(T0._`await `), (M) => Y.assign(V, false).if(T0._`${M} instanceof ${B.ValidationError}`, () => Y.assign(w, T0._`${M}.errors`), () => Y.throw(M))), w;
    }
    function F() {
      let w = T0._`${K}.errors`;
      return Y.assign(w, null), q(T0.nil), w;
    }
    function q(w = Q.async ? T0._`await ` : T0.nil) {
      let M = B.opts.passContext ? B6.default.this : B6.default.self, R = !("compile" in Q && !H || Q.schema === false);
      Y.assign(V, T0._`${w}${(0, fD.callValidateCode)(X, K, M, R)}`, Q.modifying);
    }
    function N(w) {
      var M;
      Y.if((0, T0.not)((M = Q.valid) !== null && M !== void 0 ? M : V), w);
    }
  }
  U3.funcKeywordCode = lD;
  function z3(X) {
    let { gen: Q, data: $, it: Y } = X;
    Q.if(Y.parentData, () => Q.assign($, T0._`${Y.parentData}[${Y.parentDataProperty}]`));
  }
  function mD(X, Q) {
    let { gen: $ } = X;
    $.if(T0._`Array.isArray(${Q})`, () => {
      $.assign(B6.default.vErrors, T0._`${B6.default.vErrors} === null ? ${Q} : ${B6.default.vErrors}.concat(${Q})`).assign(B6.default.errors, T0._`${B6.default.vErrors}.length`), (0, hD.extendErrors)(X);
    }, () => X.error());
  }
  function cD({ schemaEnv: X }, Q) {
    if (Q.async && !X.$async) throw Error("async keyword in sync schema");
  }
  function K3(X, Q, $) {
    if ($ === void 0) throw Error(`keyword "${Q}" failed to compile`);
    return X.scopeValue("keyword", typeof $ == "function" ? { ref: $ } : { ref: $, code: (0, T0.stringify)($) });
  }
  function pD(X, Q, $ = false) {
    return !Q.length || Q.some((Y) => Y === "array" ? Array.isArray(X) : Y === "object" ? X && typeof X == "object" && !Array.isArray(X) : typeof X == Y || $ && typeof X > "u");
  }
  U3.validSchemaType = pD;
  function dD({ schema: X, opts: Q, self: $, errSchemaPath: Y }, W, J) {
    if (Array.isArray(W.keyword) ? !W.keyword.includes(J) : W.keyword !== J) throw Error("ajv implementation error");
    let G = W.dependencies;
    if (G === null || G === void 0 ? void 0 : G.some((H) => !Object.prototype.hasOwnProperty.call(X, H))) throw Error(`parent schema must have dependencies of ${J}: ${G.join(",")}`);
    if (W.validateSchema) {
      if (!W.validateSchema(X[J])) {
        let B = `keyword "${J}" value is invalid at path "${Y}": ` + $.errorsText(W.validateSchema.errors);
        if (Q.validateSchema === "log") $.logger.error(B);
        else throw Error(B);
      }
    }
  }
  U3.validateKeywordUsage = dD;
});
var O3 = P((F3) => {
  Object.defineProperty(F3, "__esModule", { value: true });
  F3.extendSubschemaMode = F3.extendSubschemaData = F3.getSubschema = void 0;
  var K1 = p(), q3 = e();
  function oD(X, { keyword: Q, schemaProp: $, schema: Y, schemaPath: W, errSchemaPath: J, topSchemaRef: G }) {
    if (Q !== void 0 && Y !== void 0) throw Error('both "keyword" and "schema" passed, only one allowed');
    if (Q !== void 0) {
      let H = X.schema[Q];
      return $ === void 0 ? { schema: H, schemaPath: K1._`${X.schemaPath}${(0, K1.getProperty)(Q)}`, errSchemaPath: `${X.errSchemaPath}/${Q}` } : { schema: H[$], schemaPath: K1._`${X.schemaPath}${(0, K1.getProperty)(Q)}${(0, K1.getProperty)($)}`, errSchemaPath: `${X.errSchemaPath}/${Q}/${(0, q3.escapeFragment)($)}` };
    }
    if (Y !== void 0) {
      if (W === void 0 || J === void 0 || G === void 0) throw Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
      return { schema: Y, schemaPath: W, topSchemaRef: G, errSchemaPath: J };
    }
    throw Error('either "keyword" or "schema" must be passed');
  }
  F3.getSubschema = oD;
  function tD(X, Q, { dataProp: $, dataPropType: Y, data: W, dataTypes: J, propertyName: G }) {
    if (W !== void 0 && $ !== void 0) throw Error('both "data" and "dataProp" passed, only one allowed');
    let { gen: H } = Q;
    if ($ !== void 0) {
      let { errorPath: z, dataPathArr: K, opts: V } = Q, L = H.let("data", K1._`${Q.data}${(0, K1.getProperty)($)}`, true);
      B(L), X.errorPath = K1.str`${z}${(0, q3.getErrorPath)($, Y, V.jsPropertySyntax)}`, X.parentDataProperty = K1._`${$}`, X.dataPathArr = [...K, X.parentDataProperty];
    }
    if (W !== void 0) {
      let z = W instanceof K1.Name ? W : H.let("data", W, true);
      if (B(z), G !== void 0) X.propertyName = G;
    }
    if (J) X.dataTypes = J;
    function B(z) {
      X.data = z, X.dataLevel = Q.dataLevel + 1, X.dataTypes = [], Q.definedProperties = /* @__PURE__ */ new Set(), X.parentData = Q.data, X.dataNames = [...Q.dataNames, z];
    }
  }
  F3.extendSubschemaData = tD;
  function aD(X, { jtdDiscriminator: Q, jtdMetadata: $, compositeRule: Y, createErrors: W, allErrors: J }) {
    if (Y !== void 0) X.compositeRule = Y;
    if (W !== void 0) X.createErrors = W;
    if (J !== void 0) X.allErrors = J;
    X.jtdDiscriminator = Q, X.jtdMetadata = $;
  }
  F3.extendSubschemaMode = aD;
});
var DY = P(($T, D3) => {
  D3.exports = function X(Q, $) {
    if (Q === $) return true;
    if (Q && $ && typeof Q == "object" && typeof $ == "object") {
      if (Q.constructor !== $.constructor) return false;
      var Y, W, J;
      if (Array.isArray(Q)) {
        if (Y = Q.length, Y != $.length) return false;
        for (W = Y; W-- !== 0; ) if (!X(Q[W], $[W])) return false;
        return true;
      }
      if (Q.constructor === RegExp) return Q.source === $.source && Q.flags === $.flags;
      if (Q.valueOf !== Object.prototype.valueOf) return Q.valueOf() === $.valueOf();
      if (Q.toString !== Object.prototype.toString) return Q.toString() === $.toString();
      if (J = Object.keys(Q), Y = J.length, Y !== Object.keys($).length) return false;
      for (W = Y; W-- !== 0; ) if (!Object.prototype.hasOwnProperty.call($, J[W])) return false;
      for (W = Y; W-- !== 0; ) {
        var G = J[W];
        if (!X(Q[G], $[G])) return false;
      }
      return true;
    }
    return Q !== Q && $ !== $;
  };
});
var A3 = P((YT, w3) => {
  var d1 = w3.exports = function(X, Q, $) {
    if (typeof Q == "function") $ = Q, Q = {};
    $ = Q.cb || $;
    var Y = typeof $ == "function" ? $ : $.pre || function() {
    }, W = $.post || function() {
    };
    C8(Q, Y, W, X, "", X);
  };
  d1.keywords = { additionalItems: true, items: true, contains: true, additionalProperties: true, propertyNames: true, not: true, if: true, then: true, else: true };
  d1.arrayKeywords = { items: true, allOf: true, anyOf: true, oneOf: true };
  d1.propsKeywords = { $defs: true, definitions: true, properties: true, patternProperties: true, dependencies: true };
  d1.skipKeywords = { default: true, enum: true, const: true, required: true, maximum: true, minimum: true, exclusiveMaximum: true, exclusiveMinimum: true, multipleOf: true, maxLength: true, minLength: true, pattern: true, format: true, maxItems: true, minItems: true, uniqueItems: true, maxProperties: true, minProperties: true };
  function C8(X, Q, $, Y, W, J, G, H, B, z) {
    if (Y && typeof Y == "object" && !Array.isArray(Y)) {
      Q(Y, W, J, G, H, B, z);
      for (var K in Y) {
        var V = Y[K];
        if (Array.isArray(V)) {
          if (K in d1.arrayKeywords) for (var L = 0; L < V.length; L++) C8(X, Q, $, V[L], W + "/" + K + "/" + L, J, W, K, Y, L);
        } else if (K in d1.propsKeywords) {
          if (V && typeof V == "object") for (var U in V) C8(X, Q, $, V[U], W + "/" + K + "/" + Xw(U), J, W, K, Y, U);
        } else if (K in d1.keywords || X.allKeys && !(K in d1.skipKeywords)) C8(X, Q, $, V, W + "/" + K, J, W, K, Y);
      }
      $(Y, W, J, G, H, B, z);
    }
  }
  function Xw(X) {
    return X.replace(/~/g, "~0").replace(/\//g, "~1");
  }
});
var cX = P((I3) => {
  Object.defineProperty(I3, "__esModule", { value: true });
  I3.getSchemaRefs = I3.resolveUrl = I3.normalizeId = I3._getFullPath = I3.getFullPath = I3.inlineRef = void 0;
  var Qw = e(), $w = DY(), Yw = A3(), Ww = /* @__PURE__ */ new Set(["type", "format", "pattern", "maxLength", "minLength", "maxProperties", "minProperties", "maxItems", "minItems", "maximum", "minimum", "uniqueItems", "multipleOf", "required", "enum", "const"]);
  function Jw(X, Q = true) {
    if (typeof X == "boolean") return true;
    if (Q === true) return !wY(X);
    if (!Q) return false;
    return M3(X) <= Q;
  }
  I3.inlineRef = Jw;
  var Gw = /* @__PURE__ */ new Set(["$ref", "$recursiveRef", "$recursiveAnchor", "$dynamicRef", "$dynamicAnchor"]);
  function wY(X) {
    for (let Q in X) {
      if (Gw.has(Q)) return true;
      let $ = X[Q];
      if (Array.isArray($) && $.some(wY)) return true;
      if (typeof $ == "object" && wY($)) return true;
    }
    return false;
  }
  function M3(X) {
    let Q = 0;
    for (let $ in X) {
      if ($ === "$ref") return 1 / 0;
      if (Q++, Ww.has($)) continue;
      if (typeof X[$] == "object") (0, Qw.eachItem)(X[$], (Y) => Q += M3(Y));
      if (Q === 1 / 0) return 1 / 0;
    }
    return Q;
  }
  function j3(X, Q = "", $) {
    if ($ !== false) Q = m6(Q);
    let Y = X.parse(Q);
    return R3(X, Y);
  }
  I3.getFullPath = j3;
  function R3(X, Q) {
    return X.serialize(Q).split("#")[0] + "#";
  }
  I3._getFullPath = R3;
  var Hw = /#\/?$/;
  function m6(X) {
    return X ? X.replace(Hw, "") : "";
  }
  I3.normalizeId = m6;
  function Bw(X, Q, $) {
    return $ = m6($), X.resolve(Q, $);
  }
  I3.resolveUrl = Bw;
  var zw = /^[a-z_][-a-z0-9._]*$/i;
  function Kw(X, Q) {
    if (typeof X == "boolean") return {};
    let { schemaId: $, uriResolver: Y } = this.opts, W = m6(X[$] || Q), J = { "": W }, G = j3(Y, W, false), H = {}, B = /* @__PURE__ */ new Set();
    return Yw(X, { allKeys: true }, (V, L, U, F) => {
      if (F === void 0) return;
      let q = G + L, N = J[F];
      if (typeof V[$] == "string") N = w.call(this, V[$]);
      M.call(this, V.$anchor), M.call(this, V.$dynamicAnchor), J[L] = N;
      function w(R) {
        let S = this.opts.uriResolver.resolve;
        if (R = m6(N ? S(N, R) : R), B.has(R)) throw K(R);
        B.add(R);
        let C = this.refs[R];
        if (typeof C == "string") C = this.refs[C];
        if (typeof C == "object") z(V, C.schema, R);
        else if (R !== m6(q)) if (R[0] === "#") z(V, H[R], R), H[R] = V;
        else this.refs[R] = q;
        return R;
      }
      function M(R) {
        if (typeof R == "string") {
          if (!zw.test(R)) throw Error(`invalid anchor "${R}"`);
          w.call(this, `#${R}`);
        }
      }
    }), H;
    function z(V, L, U) {
      if (L !== void 0 && !$w(V, L)) throw K(U);
    }
    function K(V) {
      return Error(`reference "${V}" resolves to more than one schema`);
    }
  }
  I3.getSchemaRefs = Kw;
});
var iX = P((u3) => {
  Object.defineProperty(u3, "__esModule", { value: true });
  u3.getData = u3.KeywordCxt = u3.validateFunctionCode = void 0;
  var C3 = cG(), b3 = mX(), MY = UY(), k8 = mX(), Nw = W3(), dX = L3(), AY = O3(), _ = p(), u = R1(), Ow = cX(), I1 = e(), pX = lX();
  function Dw(X) {
    if (T3(X)) {
      if (_3(X), v3(X)) {
        Mw(X);
        return;
      }
    }
    k3(X, () => (0, C3.topBoolOrEmptySchema)(X));
  }
  u3.validateFunctionCode = Dw;
  function k3({ gen: X, validateName: Q, schema: $, schemaEnv: Y, opts: W }, J) {
    if (W.code.es5) X.func(Q, _._`${u.default.data}, ${u.default.valCxt}`, Y.$async, () => {
      X.code(_._`"use strict"; ${P3($, W)}`), Aw(X, W), X.code(J);
    });
    else X.func(Q, _._`${u.default.data}, ${ww(W)}`, Y.$async, () => X.code(P3($, W)).code(J));
  }
  function ww(X) {
    return _._`{${u.default.instancePath}="", ${u.default.parentData}, ${u.default.parentDataProperty}, ${u.default.rootData}=${u.default.data}${X.dynamicRef ? _._`, ${u.default.dynamicAnchors}={}` : _.nil}}={}`;
  }
  function Aw(X, Q) {
    X.if(u.default.valCxt, () => {
      if (X.var(u.default.instancePath, _._`${u.default.valCxt}.${u.default.instancePath}`), X.var(u.default.parentData, _._`${u.default.valCxt}.${u.default.parentData}`), X.var(u.default.parentDataProperty, _._`${u.default.valCxt}.${u.default.parentDataProperty}`), X.var(u.default.rootData, _._`${u.default.valCxt}.${u.default.rootData}`), Q.dynamicRef) X.var(u.default.dynamicAnchors, _._`${u.default.valCxt}.${u.default.dynamicAnchors}`);
    }, () => {
      if (X.var(u.default.instancePath, _._`""`), X.var(u.default.parentData, _._`undefined`), X.var(u.default.parentDataProperty, _._`undefined`), X.var(u.default.rootData, u.default.data), Q.dynamicRef) X.var(u.default.dynamicAnchors, _._`{}`);
    });
  }
  function Mw(X) {
    let { schema: Q, opts: $, gen: Y } = X;
    k3(X, () => {
      if ($.$comment && Q.$comment) y3(X);
      if (bw(X), Y.let(u.default.vErrors, null), Y.let(u.default.errors, 0), $.unevaluated) jw(X);
      x3(X), Zw(X);
    });
    return;
  }
  function jw(X) {
    let { gen: Q, validateName: $ } = X;
    X.evaluated = Q.const("evaluated", _._`${$}.evaluated`), Q.if(_._`${X.evaluated}.dynamicProps`, () => Q.assign(_._`${X.evaluated}.props`, _._`undefined`)), Q.if(_._`${X.evaluated}.dynamicItems`, () => Q.assign(_._`${X.evaluated}.items`, _._`undefined`));
  }
  function P3(X, Q) {
    let $ = typeof X == "object" && X[Q.schemaId];
    return $ && (Q.code.source || Q.code.process) ? _._`/*# sourceURL=${$} */` : _.nil;
  }
  function Rw(X, Q) {
    if (T3(X)) {
      if (_3(X), v3(X)) {
        Iw(X, Q);
        return;
      }
    }
    (0, C3.boolOrEmptySchema)(X, Q);
  }
  function v3({ schema: X, self: Q }) {
    if (typeof X == "boolean") return !X;
    for (let $ in X) if (Q.RULES.all[$]) return true;
    return false;
  }
  function T3(X) {
    return typeof X.schema != "boolean";
  }
  function Iw(X, Q) {
    let { schema: $, gen: Y, opts: W } = X;
    if (W.$comment && $.$comment) y3(X);
    Pw(X), Sw(X);
    let J = Y.const("_errs", u.default.errors);
    x3(X, J), Y.var(Q, _._`${J} === ${u.default.errors}`);
  }
  function _3(X) {
    (0, I1.checkUnknownRules)(X), Ew(X);
  }
  function x3(X, Q) {
    if (X.opts.jtd) return S3(X, [], false, Q);
    let $ = (0, b3.getSchemaTypes)(X.schema), Y = (0, b3.coerceAndCheckDataType)(X, $);
    S3(X, $, !Y, Q);
  }
  function Ew(X) {
    let { schema: Q, errSchemaPath: $, opts: Y, self: W } = X;
    if (Q.$ref && Y.ignoreKeywordsWithRef && (0, I1.schemaHasRulesButRef)(Q, W.RULES)) W.logger.warn(`$ref: keywords ignored in schema at path "${$}"`);
  }
  function bw(X) {
    let { schema: Q, opts: $ } = X;
    if (Q.default !== void 0 && $.useDefaults && $.strictSchema) (0, I1.checkStrictMode)(X, "default is ignored in the schema root");
  }
  function Pw(X) {
    let Q = X.schema[X.opts.schemaId];
    if (Q) X.baseId = (0, Ow.resolveUrl)(X.opts.uriResolver, X.baseId, Q);
  }
  function Sw(X) {
    if (X.schema.$async && !X.schemaEnv.$async) throw Error("async schema in sync schema");
  }
  function y3({ gen: X, schemaEnv: Q, schema: $, errSchemaPath: Y, opts: W }) {
    let J = $.$comment;
    if (W.$comment === true) X.code(_._`${u.default.self}.logger.log(${J})`);
    else if (typeof W.$comment == "function") {
      let G = _.str`${Y}/$comment`, H = X.scopeValue("root", { ref: Q.root });
      X.code(_._`${u.default.self}.opts.$comment(${J}, ${G}, ${H}.schema)`);
    }
  }
  function Zw(X) {
    let { gen: Q, schemaEnv: $, validateName: Y, ValidationError: W, opts: J } = X;
    if ($.$async) Q.if(_._`${u.default.errors} === 0`, () => Q.return(u.default.data), () => Q.throw(_._`new ${W}(${u.default.vErrors})`));
    else {
      if (Q.assign(_._`${Y}.errors`, u.default.vErrors), J.unevaluated) Cw(X);
      Q.return(_._`${u.default.errors} === 0`);
    }
  }
  function Cw({ gen: X, evaluated: Q, props: $, items: Y }) {
    if ($ instanceof _.Name) X.assign(_._`${Q}.props`, $);
    if (Y instanceof _.Name) X.assign(_._`${Q}.items`, Y);
  }
  function S3(X, Q, $, Y) {
    let { gen: W, schema: J, data: G, allErrors: H, opts: B, self: z } = X, { RULES: K } = z;
    if (J.$ref && (B.ignoreKeywordsWithRef || !(0, I1.schemaHasRulesButRef)(J, K))) {
      W.block(() => f3(X, "$ref", K.all.$ref.definition));
      return;
    }
    if (!B.jtd) kw(X, Q);
    W.block(() => {
      for (let L of K.rules) V(L);
      V(K.post);
    });
    function V(L) {
      if (!(0, MY.shouldUseGroup)(J, L)) return;
      if (L.type) {
        if (W.if((0, k8.checkDataType)(L.type, G, B.strictNumbers)), Z3(X, L), Q.length === 1 && Q[0] === L.type && $) W.else(), (0, k8.reportTypeError)(X);
        W.endIf();
      } else Z3(X, L);
      if (!H) W.if(_._`${u.default.errors} === ${Y || 0}`);
    }
  }
  function Z3(X, Q) {
    let { gen: $, schema: Y, opts: { useDefaults: W } } = X;
    if (W) (0, Nw.assignDefaults)(X, Q.type);
    $.block(() => {
      for (let J of Q.rules) if ((0, MY.shouldUseRule)(Y, J)) f3(X, J.keyword, J.definition, Q.type);
    });
  }
  function kw(X, Q) {
    if (X.schemaEnv.meta || !X.opts.strictTypes) return;
    if (vw(X, Q), !X.opts.allowUnionTypes) Tw(X, Q);
    _w(X, X.dataTypes);
  }
  function vw(X, Q) {
    if (!Q.length) return;
    if (!X.dataTypes.length) {
      X.dataTypes = Q;
      return;
    }
    Q.forEach(($) => {
      if (!g3(X.dataTypes, $)) jY(X, `type "${$}" not allowed by context "${X.dataTypes.join(",")}"`);
    }), yw(X, Q);
  }
  function Tw(X, Q) {
    if (Q.length > 1 && !(Q.length === 2 && Q.includes("null"))) jY(X, "use allowUnionTypes to allow union type keyword");
  }
  function _w(X, Q) {
    let $ = X.self.RULES.all;
    for (let Y in $) {
      let W = $[Y];
      if (typeof W == "object" && (0, MY.shouldUseRule)(X.schema, W)) {
        let { type: J } = W.definition;
        if (J.length && !J.some((G) => xw(Q, G))) jY(X, `missing type "${J.join(",")}" for keyword "${Y}"`);
      }
    }
  }
  function xw(X, Q) {
    return X.includes(Q) || Q === "number" && X.includes("integer");
  }
  function g3(X, Q) {
    return X.includes(Q) || Q === "integer" && X.includes("number");
  }
  function yw(X, Q) {
    let $ = [];
    for (let Y of X.dataTypes) if (g3(Q, Y)) $.push(Y);
    else if (Q.includes("integer") && Y === "number") $.push("integer");
    X.dataTypes = $;
  }
  function jY(X, Q) {
    let $ = X.schemaEnv.baseId + X.errSchemaPath;
    Q += ` at "${$}" (strictTypes)`, (0, I1.checkStrictMode)(X, Q, X.opts.strictTypes);
  }
  class RY {
    constructor(X, Q, $) {
      if ((0, dX.validateKeywordUsage)(X, Q, $), this.gen = X.gen, this.allErrors = X.allErrors, this.keyword = $, this.data = X.data, this.schema = X.schema[$], this.$data = Q.$data && X.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, I1.schemaRefOrVal)(X, this.schema, $, this.$data), this.schemaType = Q.schemaType, this.parentSchema = X.schema, this.params = {}, this.it = X, this.def = Q, this.$data) this.schemaCode = X.gen.const("vSchema", h3(this.$data, X));
      else if (this.schemaCode = this.schemaValue, !(0, dX.validSchemaType)(this.schema, Q.schemaType, Q.allowUndefined)) throw Error(`${$} value must be ${JSON.stringify(Q.schemaType)}`);
      if ("code" in Q ? Q.trackErrors : Q.errors !== false) this.errsCount = X.gen.const("_errs", u.default.errors);
    }
    result(X, Q, $) {
      this.failResult((0, _.not)(X), Q, $);
    }
    failResult(X, Q, $) {
      if (this.gen.if(X), $) $();
      else this.error();
      if (Q) {
        if (this.gen.else(), Q(), this.allErrors) this.gen.endIf();
      } else if (this.allErrors) this.gen.endIf();
      else this.gen.else();
    }
    pass(X, Q) {
      this.failResult((0, _.not)(X), void 0, Q);
    }
    fail(X) {
      if (X === void 0) {
        if (this.error(), !this.allErrors) this.gen.if(false);
        return;
      }
      if (this.gen.if(X), this.error(), this.allErrors) this.gen.endIf();
      else this.gen.else();
    }
    fail$data(X) {
      if (!this.$data) return this.fail(X);
      let { schemaCode: Q } = this;
      this.fail(_._`${Q} !== undefined && (${(0, _.or)(this.invalid$data(), X)})`);
    }
    error(X, Q, $) {
      if (Q) {
        this.setParams(Q), this._error(X, $), this.setParams({});
        return;
      }
      this._error(X, $);
    }
    _error(X, Q) {
      (X ? pX.reportExtraError : pX.reportError)(this, this.def.error, Q);
    }
    $dataError() {
      (0, pX.reportError)(this, this.def.$dataError || pX.keyword$DataError);
    }
    reset() {
      if (this.errsCount === void 0) throw Error('add "trackErrors" to keyword definition');
      (0, pX.resetErrorsCount)(this.gen, this.errsCount);
    }
    ok(X) {
      if (!this.allErrors) this.gen.if(X);
    }
    setParams(X, Q) {
      if (Q) Object.assign(this.params, X);
      else this.params = X;
    }
    block$data(X, Q, $ = _.nil) {
      this.gen.block(() => {
        this.check$data(X, $), Q();
      });
    }
    check$data(X = _.nil, Q = _.nil) {
      if (!this.$data) return;
      let { gen: $, schemaCode: Y, schemaType: W, def: J } = this;
      if ($.if((0, _.or)(_._`${Y} === undefined`, Q)), X !== _.nil) $.assign(X, true);
      if (W.length || J.validateSchema) {
        if ($.elseIf(this.invalid$data()), this.$dataError(), X !== _.nil) $.assign(X, false);
      }
      $.else();
    }
    invalid$data() {
      let { gen: X, schemaCode: Q, schemaType: $, def: Y, it: W } = this;
      return (0, _.or)(J(), G());
      function J() {
        if ($.length) {
          if (!(Q instanceof _.Name)) throw Error("ajv implementation error");
          let H = Array.isArray($) ? $ : [$];
          return _._`${(0, k8.checkDataTypes)(H, Q, W.opts.strictNumbers, k8.DataType.Wrong)}`;
        }
        return _.nil;
      }
      function G() {
        if (Y.validateSchema) {
          let H = X.scopeValue("validate$data", { ref: Y.validateSchema });
          return _._`!${H}(${Q})`;
        }
        return _.nil;
      }
    }
    subschema(X, Q) {
      let $ = (0, AY.getSubschema)(this.it, X);
      (0, AY.extendSubschemaData)($, this.it, X), (0, AY.extendSubschemaMode)($, X);
      let Y = { ...this.it, ...$, items: void 0, props: void 0 };
      return Rw(Y, Q), Y;
    }
    mergeEvaluated(X, Q) {
      let { it: $, gen: Y } = this;
      if (!$.opts.unevaluated) return;
      if ($.props !== true && X.props !== void 0) $.props = I1.mergeEvaluated.props(Y, X.props, $.props, Q);
      if ($.items !== true && X.items !== void 0) $.items = I1.mergeEvaluated.items(Y, X.items, $.items, Q);
    }
    mergeValidEvaluated(X, Q) {
      let { it: $, gen: Y } = this;
      if ($.opts.unevaluated && ($.props !== true || $.items !== true)) return Y.if(Q, () => this.mergeEvaluated(X, _.Name)), true;
    }
  }
  u3.KeywordCxt = RY;
  function f3(X, Q, $, Y) {
    let W = new RY(X, $, Q);
    if ("code" in $) $.code(W, Y);
    else if (W.$data && $.validate) (0, dX.funcKeywordCode)(W, $);
    else if ("macro" in $) (0, dX.macroKeywordCode)(W, $);
    else if ($.compile || $.validate) (0, dX.funcKeywordCode)(W, $);
  }
  var gw = /^\/(?:[^~]|~0|~1)*$/, fw = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function h3(X, { dataLevel: Q, dataNames: $, dataPathArr: Y }) {
    let W, J;
    if (X === "") return u.default.rootData;
    if (X[0] === "/") {
      if (!gw.test(X)) throw Error(`Invalid JSON-pointer: ${X}`);
      W = X, J = u.default.rootData;
    } else {
      let z = fw.exec(X);
      if (!z) throw Error(`Invalid JSON-pointer: ${X}`);
      let K = +z[1];
      if (W = z[2], W === "#") {
        if (K >= Q) throw Error(B("property/index", K));
        return Y[Q - K];
      }
      if (K > Q) throw Error(B("data", K));
      if (J = $[Q - K], !W) return J;
    }
    let G = J, H = W.split("/");
    for (let z of H) if (z) J = _._`${J}${(0, _.getProperty)((0, I1.unescapeJsonPointer)(z))}`, G = _._`${G} && ${J}`;
    return G;
    function B(z, K) {
      return `Cannot access ${z} ${K} levels up, current level is ${Q}`;
    }
  }
  u3.getData = h3;
});
var v8 = P((c3) => {
  Object.defineProperty(c3, "__esModule", { value: true });
  class m3 extends Error {
    constructor(X) {
      super("validation failed");
      this.errors = X, this.ajv = this.validation = true;
    }
  }
  c3.default = m3;
});
var nX = P((d3) => {
  Object.defineProperty(d3, "__esModule", { value: true });
  var IY = cX();
  class p3 extends Error {
    constructor(X, Q, $, Y) {
      super(Y || `can't resolve reference ${$} from id ${Q}`);
      this.missingRef = (0, IY.resolveUrl)(X, Q, $), this.missingSchema = (0, IY.normalizeId)((0, IY.getFullPath)(X, this.missingRef));
    }
  }
  d3.default = p3;
});
var _8 = P((r3) => {
  Object.defineProperty(r3, "__esModule", { value: true });
  r3.resolveSchema = r3.getCompilingSchema = r3.resolveRef = r3.compileSchema = r3.SchemaEnv = void 0;
  var X1 = p(), cw = v8(), z6 = R1(), Q1 = cX(), i3 = e(), pw = iX();
  class rX {
    constructor(X) {
      var Q;
      this.refs = {}, this.dynamicAnchors = {};
      let $;
      if (typeof X.schema == "object") $ = X.schema;
      this.schema = X.schema, this.schemaId = X.schemaId, this.root = X.root || this, this.baseId = (Q = X.baseId) !== null && Q !== void 0 ? Q : (0, Q1.normalizeId)($ === null || $ === void 0 ? void 0 : $[X.schemaId || "$id"]), this.schemaPath = X.schemaPath, this.localRefs = X.localRefs, this.meta = X.meta, this.$async = $ === null || $ === void 0 ? void 0 : $.$async, this.refs = {};
    }
  }
  r3.SchemaEnv = rX;
  function bY(X) {
    let Q = n3.call(this, X);
    if (Q) return Q;
    let $ = (0, Q1.getFullPath)(this.opts.uriResolver, X.root.baseId), { es5: Y, lines: W } = this.opts.code, { ownProperties: J } = this.opts, G = new X1.CodeGen(this.scope, { es5: Y, lines: W, ownProperties: J }), H;
    if (X.$async) H = G.scopeValue("Error", { ref: cw.default, code: X1._`require("ajv/dist/runtime/validation_error").default` });
    let B = G.scopeName("validate");
    X.validateName = B;
    let z = { gen: G, allErrors: this.opts.allErrors, data: z6.default.data, parentData: z6.default.parentData, parentDataProperty: z6.default.parentDataProperty, dataNames: [z6.default.data], dataPathArr: [X1.nil], dataLevel: 0, dataTypes: [], definedProperties: /* @__PURE__ */ new Set(), topSchemaRef: G.scopeValue("schema", this.opts.code.source === true ? { ref: X.schema, code: (0, X1.stringify)(X.schema) } : { ref: X.schema }), validateName: B, ValidationError: H, schema: X.schema, schemaEnv: X, rootId: $, baseId: X.baseId || $, schemaPath: X1.nil, errSchemaPath: X.schemaPath || (this.opts.jtd ? "" : "#"), errorPath: X1._`""`, opts: this.opts, self: this }, K;
    try {
      this._compilations.add(X), (0, pw.validateFunctionCode)(z), G.optimize(this.opts.code.optimize);
      let V = G.toString();
      if (K = `${G.scopeRefs(z6.default.scope)}return ${V}`, this.opts.code.process) K = this.opts.code.process(K, X);
      let U = Function(`${z6.default.self}`, `${z6.default.scope}`, K)(this, this.scope.get());
      if (this.scope.value(B, { ref: U }), U.errors = null, U.schema = X.schema, U.schemaEnv = X, X.$async) U.$async = true;
      if (this.opts.code.source === true) U.source = { validateName: B, validateCode: V, scopeValues: G._values };
      if (this.opts.unevaluated) {
        let { props: F, items: q } = z;
        if (U.evaluated = { props: F instanceof X1.Name ? void 0 : F, items: q instanceof X1.Name ? void 0 : q, dynamicProps: F instanceof X1.Name, dynamicItems: q instanceof X1.Name }, U.source) U.source.evaluated = (0, X1.stringify)(U.evaluated);
      }
      return X.validate = U, X;
    } catch (V) {
      if (delete X.validate, delete X.validateName, K) this.logger.error("Error compiling schema, function code:", K);
      throw V;
    } finally {
      this._compilations.delete(X);
    }
  }
  r3.compileSchema = bY;
  function dw(X, Q, $) {
    var Y;
    $ = (0, Q1.resolveUrl)(this.opts.uriResolver, Q, $);
    let W = X.refs[$];
    if (W) return W;
    let J = rw.call(this, X, $);
    if (J === void 0) {
      let G = (Y = X.localRefs) === null || Y === void 0 ? void 0 : Y[$], { schemaId: H } = this.opts;
      if (G) J = new rX({ schema: G, schemaId: H, root: X, baseId: Q });
    }
    if (J === void 0) return;
    return X.refs[$] = iw.call(this, J);
  }
  r3.resolveRef = dw;
  function iw(X) {
    if ((0, Q1.inlineRef)(X.schema, this.opts.inlineRefs)) return X.schema;
    return X.validate ? X : bY.call(this, X);
  }
  function n3(X) {
    for (let Q of this._compilations) if (nw(Q, X)) return Q;
  }
  r3.getCompilingSchema = n3;
  function nw(X, Q) {
    return X.schema === Q.schema && X.root === Q.root && X.baseId === Q.baseId;
  }
  function rw(X, Q) {
    let $;
    while (typeof ($ = this.refs[Q]) == "string") Q = $;
    return $ || this.schemas[Q] || T8.call(this, X, Q);
  }
  function T8(X, Q) {
    let $ = this.opts.uriResolver.parse(Q), Y = (0, Q1._getFullPath)(this.opts.uriResolver, $), W = (0, Q1.getFullPath)(this.opts.uriResolver, X.baseId, void 0);
    if (Object.keys(X.schema).length > 0 && Y === W) return EY.call(this, $, X);
    let J = (0, Q1.normalizeId)(Y), G = this.refs[J] || this.schemas[J];
    if (typeof G == "string") {
      let H = T8.call(this, X, G);
      if (typeof (H === null || H === void 0 ? void 0 : H.schema) !== "object") return;
      return EY.call(this, $, H);
    }
    if (typeof (G === null || G === void 0 ? void 0 : G.schema) !== "object") return;
    if (!G.validate) bY.call(this, G);
    if (J === (0, Q1.normalizeId)(Q)) {
      let { schema: H } = G, { schemaId: B } = this.opts, z = H[B];
      if (z) W = (0, Q1.resolveUrl)(this.opts.uriResolver, W, z);
      return new rX({ schema: H, schemaId: B, root: X, baseId: W });
    }
    return EY.call(this, $, G);
  }
  r3.resolveSchema = T8;
  var ow = /* @__PURE__ */ new Set(["properties", "patternProperties", "enum", "dependencies", "definitions"]);
  function EY(X, { baseId: Q, schema: $, root: Y }) {
    var W;
    if (((W = X.fragment) === null || W === void 0 ? void 0 : W[0]) !== "/") return;
    for (let H of X.fragment.slice(1).split("/")) {
      if (typeof $ === "boolean") return;
      let B = $[(0, i3.unescapeFragment)(H)];
      if (B === void 0) return;
      $ = B;
      let z = typeof $ === "object" && $[this.opts.schemaId];
      if (!ow.has(H) && z) Q = (0, Q1.resolveUrl)(this.opts.uriResolver, Q, z);
    }
    let J;
    if (typeof $ != "boolean" && $.$ref && !(0, i3.schemaHasRulesButRef)($, this.RULES)) {
      let H = (0, Q1.resolveUrl)(this.opts.uriResolver, Q, $.$ref);
      J = T8.call(this, Y, H);
    }
    let { schemaId: G } = this.opts;
    if (J = J || new rX({ schema: $, schemaId: G, root: Y, baseId: Q }), J.schema !== J.root.schema) return J;
    return;
  }
});
var t3 = P((zT, XA) => {
  XA.exports = { $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#", description: "Meta-schema for $data reference (JSON AnySchema extension proposal)", type: "object", required: ["$data"], properties: { $data: { type: "string", anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }] } }, additionalProperties: false };
});
var s3 = P((KT, a3) => {
  var QA = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, a: 10, A: 10, b: 11, B: 11, c: 12, C: 12, d: 13, D: 13, e: 14, E: 14, f: 15, F: 15 };
  a3.exports = { HEX: QA };
});
var GH = P((UT, JH) => {
  var { HEX: $A } = s3(), YA = /^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u;
  function $H(X) {
    if (WH(X, ".") < 3) return { host: X, isIPV4: false };
    let Q = X.match(YA) || [], [$] = Q;
    if ($) return { host: JA($, "."), isIPV4: true };
    else return { host: X, isIPV4: false };
  }
  function PY(X, Q = false) {
    let $ = "", Y = true;
    for (let W of X) {
      if ($A[W] === void 0) return;
      if (W !== "0" && Y === true) Y = false;
      if (!Y) $ += W;
    }
    if (Q && $.length === 0) $ = "0";
    return $;
  }
  function WA(X) {
    let Q = 0, $ = { error: false, address: "", zone: "" }, Y = [], W = [], J = false, G = false, H = false;
    function B() {
      if (W.length) {
        if (J === false) {
          let z = PY(W);
          if (z !== void 0) Y.push(z);
          else return $.error = true, false;
        }
        W.length = 0;
      }
      return true;
    }
    for (let z = 0; z < X.length; z++) {
      let K = X[z];
      if (K === "[" || K === "]") continue;
      if (K === ":") {
        if (G === true) H = true;
        if (!B()) break;
        if (Q++, Y.push(":"), Q > 7) {
          $.error = true;
          break;
        }
        if (z - 1 >= 0 && X[z - 1] === ":") G = true;
        continue;
      } else if (K === "%") {
        if (!B()) break;
        J = true;
      } else {
        W.push(K);
        continue;
      }
    }
    if (W.length) if (J) $.zone = W.join("");
    else if (H) Y.push(W.join(""));
    else Y.push(PY(W));
    return $.address = Y.join(""), $;
  }
  function YH(X) {
    if (WH(X, ":") < 2) return { host: X, isIPV6: false };
    let Q = WA(X);
    if (!Q.error) {
      let { address: $, address: Y } = Q;
      if (Q.zone) $ += "%" + Q.zone, Y += "%25" + Q.zone;
      return { host: $, escapedHost: Y, isIPV6: true };
    } else return { host: X, isIPV6: false };
  }
  function JA(X, Q) {
    let $ = "", Y = true, W = X.length;
    for (let J = 0; J < W; J++) {
      let G = X[J];
      if (G === "0" && Y) {
        if (J + 1 <= W && X[J + 1] === Q || J + 1 === W) $ += G, Y = false;
      } else {
        if (G === Q) Y = true;
        else Y = false;
        $ += G;
      }
    }
    return $;
  }
  function WH(X, Q) {
    let $ = 0;
    for (let Y = 0; Y < X.length; Y++) if (X[Y] === Q) $++;
    return $;
  }
  var e3 = /^\.\.?\//u, XH = /^\/\.(?:\/|$)/u, QH = /^\/\.\.(?:\/|$)/u, GA = /^\/?(?:.|\n)*?(?=\/|$)/u;
  function HA(X) {
    let Q = [];
    while (X.length) if (X.match(e3)) X = X.replace(e3, "");
    else if (X.match(XH)) X = X.replace(XH, "/");
    else if (X.match(QH)) X = X.replace(QH, "/"), Q.pop();
    else if (X === "." || X === "..") X = "";
    else {
      let $ = X.match(GA);
      if ($) {
        let Y = $[0];
        X = X.slice(Y.length), Q.push(Y);
      } else throw Error("Unexpected dot segment condition");
    }
    return Q.join("");
  }
  function BA(X, Q) {
    let $ = Q !== true ? escape : unescape;
    if (X.scheme !== void 0) X.scheme = $(X.scheme);
    if (X.userinfo !== void 0) X.userinfo = $(X.userinfo);
    if (X.host !== void 0) X.host = $(X.host);
    if (X.path !== void 0) X.path = $(X.path);
    if (X.query !== void 0) X.query = $(X.query);
    if (X.fragment !== void 0) X.fragment = $(X.fragment);
    return X;
  }
  function zA(X) {
    let Q = [];
    if (X.userinfo !== void 0) Q.push(X.userinfo), Q.push("@");
    if (X.host !== void 0) {
      let $ = unescape(X.host), Y = $H($);
      if (Y.isIPV4) $ = Y.host;
      else {
        let W = YH(Y.host);
        if (W.isIPV6 === true) $ = `[${W.escapedHost}]`;
        else $ = X.host;
      }
      Q.push($);
    }
    if (typeof X.port === "number" || typeof X.port === "string") Q.push(":"), Q.push(String(X.port));
    return Q.length ? Q.join("") : void 0;
  }
  JH.exports = { recomposeAuthority: zA, normalizeComponentEncoding: BA, removeDotSegments: HA, normalizeIPv4: $H, normalizeIPv6: YH, stringArrayToHexStripped: PY };
});
var VH = P((VT, UH) => {
  var KA = /^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu, UA = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
  function HH(X) {
    return typeof X.secure === "boolean" ? X.secure : String(X.scheme).toLowerCase() === "wss";
  }
  function BH(X) {
    if (!X.host) X.error = X.error || "HTTP URIs must have a host.";
    return X;
  }
  function zH(X) {
    let Q = String(X.scheme).toLowerCase() === "https";
    if (X.port === (Q ? 443 : 80) || X.port === "") X.port = void 0;
    if (!X.path) X.path = "/";
    return X;
  }
  function VA(X) {
    return X.secure = HH(X), X.resourceName = (X.path || "/") + (X.query ? "?" + X.query : ""), X.path = void 0, X.query = void 0, X;
  }
  function LA(X) {
    if (X.port === (HH(X) ? 443 : 80) || X.port === "") X.port = void 0;
    if (typeof X.secure === "boolean") X.scheme = X.secure ? "wss" : "ws", X.secure = void 0;
    if (X.resourceName) {
      let [Q, $] = X.resourceName.split("?");
      X.path = Q && Q !== "/" ? Q : void 0, X.query = $, X.resourceName = void 0;
    }
    return X.fragment = void 0, X;
  }
  function qA(X, Q) {
    if (!X.path) return X.error = "URN can not be parsed", X;
    let $ = X.path.match(UA);
    if ($) {
      let Y = Q.scheme || X.scheme || "urn";
      X.nid = $[1].toLowerCase(), X.nss = $[2];
      let W = `${Y}:${Q.nid || X.nid}`, J = SY[W];
      if (X.path = void 0, J) X = J.parse(X, Q);
    } else X.error = X.error || "URN can not be parsed.";
    return X;
  }
  function FA(X, Q) {
    let $ = Q.scheme || X.scheme || "urn", Y = X.nid.toLowerCase(), W = `${$}:${Q.nid || Y}`, J = SY[W];
    if (J) X = J.serialize(X, Q);
    let G = X, H = X.nss;
    return G.path = `${Y || Q.nid}:${H}`, Q.skipEscape = true, G;
  }
  function NA(X, Q) {
    let $ = X;
    if ($.uuid = $.nss, $.nss = void 0, !Q.tolerant && (!$.uuid || !KA.test($.uuid))) $.error = $.error || "UUID is not valid.";
    return $;
  }
  function OA(X) {
    let Q = X;
    return Q.nss = (X.uuid || "").toLowerCase(), Q;
  }
  var KH = { scheme: "http", domainHost: true, parse: BH, serialize: zH }, DA = { scheme: "https", domainHost: KH.domainHost, parse: BH, serialize: zH }, x8 = { scheme: "ws", domainHost: true, parse: VA, serialize: LA }, wA = { scheme: "wss", domainHost: x8.domainHost, parse: x8.parse, serialize: x8.serialize }, AA = { scheme: "urn", parse: qA, serialize: FA, skipNormalize: true }, MA = { scheme: "urn:uuid", parse: NA, serialize: OA, skipNormalize: true }, SY = { http: KH, https: DA, ws: x8, wss: wA, urn: AA, "urn:uuid": MA };
  UH.exports = SY;
});
var qH = P((LT, g8) => {
  var { normalizeIPv6: jA, normalizeIPv4: RA, removeDotSegments: oX, recomposeAuthority: IA, normalizeComponentEncoding: y8 } = GH(), ZY = VH();
  function EA(X, Q) {
    if (typeof X === "string") X = U1(E1(X, Q), Q);
    else if (typeof X === "object") X = E1(U1(X, Q), Q);
    return X;
  }
  function bA(X, Q, $) {
    let Y = Object.assign({ scheme: "null" }, $), W = LH(E1(X, Y), E1(Q, Y), Y, true);
    return U1(W, { ...Y, skipEscape: true });
  }
  function LH(X, Q, $, Y) {
    let W = {};
    if (!Y) X = E1(U1(X, $), $), Q = E1(U1(Q, $), $);
    if ($ = $ || {}, !$.tolerant && Q.scheme) W.scheme = Q.scheme, W.userinfo = Q.userinfo, W.host = Q.host, W.port = Q.port, W.path = oX(Q.path || ""), W.query = Q.query;
    else {
      if (Q.userinfo !== void 0 || Q.host !== void 0 || Q.port !== void 0) W.userinfo = Q.userinfo, W.host = Q.host, W.port = Q.port, W.path = oX(Q.path || ""), W.query = Q.query;
      else {
        if (!Q.path) if (W.path = X.path, Q.query !== void 0) W.query = Q.query;
        else W.query = X.query;
        else {
          if (Q.path.charAt(0) === "/") W.path = oX(Q.path);
          else {
            if ((X.userinfo !== void 0 || X.host !== void 0 || X.port !== void 0) && !X.path) W.path = "/" + Q.path;
            else if (!X.path) W.path = Q.path;
            else W.path = X.path.slice(0, X.path.lastIndexOf("/") + 1) + Q.path;
            W.path = oX(W.path);
          }
          W.query = Q.query;
        }
        W.userinfo = X.userinfo, W.host = X.host, W.port = X.port;
      }
      W.scheme = X.scheme;
    }
    return W.fragment = Q.fragment, W;
  }
  function PA(X, Q, $) {
    if (typeof X === "string") X = unescape(X), X = U1(y8(E1(X, $), true), { ...$, skipEscape: true });
    else if (typeof X === "object") X = U1(y8(X, true), { ...$, skipEscape: true });
    if (typeof Q === "string") Q = unescape(Q), Q = U1(y8(E1(Q, $), true), { ...$, skipEscape: true });
    else if (typeof Q === "object") Q = U1(y8(Q, true), { ...$, skipEscape: true });
    return X.toLowerCase() === Q.toLowerCase();
  }
  function U1(X, Q) {
    let $ = { host: X.host, scheme: X.scheme, userinfo: X.userinfo, port: X.port, path: X.path, query: X.query, nid: X.nid, nss: X.nss, uuid: X.uuid, fragment: X.fragment, reference: X.reference, resourceName: X.resourceName, secure: X.secure, error: "" }, Y = Object.assign({}, Q), W = [], J = ZY[(Y.scheme || $.scheme || "").toLowerCase()];
    if (J && J.serialize) J.serialize($, Y);
    if ($.path !== void 0) if (!Y.skipEscape) {
      if ($.path = escape($.path), $.scheme !== void 0) $.path = $.path.split("%3A").join(":");
    } else $.path = unescape($.path);
    if (Y.reference !== "suffix" && $.scheme) W.push($.scheme, ":");
    let G = IA($);
    if (G !== void 0) {
      if (Y.reference !== "suffix") W.push("//");
      if (W.push(G), $.path && $.path.charAt(0) !== "/") W.push("/");
    }
    if ($.path !== void 0) {
      let H = $.path;
      if (!Y.absolutePath && (!J || !J.absolutePath)) H = oX(H);
      if (G === void 0) H = H.replace(/^\/\//u, "/%2F");
      W.push(H);
    }
    if ($.query !== void 0) W.push("?", $.query);
    if ($.fragment !== void 0) W.push("#", $.fragment);
    return W.join("");
  }
  var SA = Array.from({ length: 127 }, (X, Q) => /[^!"$&'()*+,\-.;=_`a-z{}~]/u.test(String.fromCharCode(Q)));
  function ZA(X) {
    let Q = 0;
    for (let $ = 0, Y = X.length; $ < Y; ++$) if (Q = X.charCodeAt($), Q > 126 || SA[Q]) return true;
    return false;
  }
  var CA = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
  function E1(X, Q) {
    let $ = Object.assign({}, Q), Y = { scheme: void 0, userinfo: void 0, host: "", port: void 0, path: "", query: void 0, fragment: void 0 }, W = X.indexOf("%") !== -1, J = false;
    if ($.reference === "suffix") X = ($.scheme ? $.scheme + ":" : "") + "//" + X;
    let G = X.match(CA);
    if (G) {
      if (Y.scheme = G[1], Y.userinfo = G[3], Y.host = G[4], Y.port = parseInt(G[5], 10), Y.path = G[6] || "", Y.query = G[7], Y.fragment = G[8], isNaN(Y.port)) Y.port = G[5];
      if (Y.host) {
        let B = RA(Y.host);
        if (B.isIPV4 === false) {
          let z = jA(B.host);
          Y.host = z.host.toLowerCase(), J = z.isIPV6;
        } else Y.host = B.host, J = true;
      }
      if (Y.scheme === void 0 && Y.userinfo === void 0 && Y.host === void 0 && Y.port === void 0 && Y.query === void 0 && !Y.path) Y.reference = "same-document";
      else if (Y.scheme === void 0) Y.reference = "relative";
      else if (Y.fragment === void 0) Y.reference = "absolute";
      else Y.reference = "uri";
      if ($.reference && $.reference !== "suffix" && $.reference !== Y.reference) Y.error = Y.error || "URI is not a " + $.reference + " reference.";
      let H = ZY[($.scheme || Y.scheme || "").toLowerCase()];
      if (!$.unicodeSupport && (!H || !H.unicodeSupport)) {
        if (Y.host && ($.domainHost || H && H.domainHost) && J === false && ZA(Y.host)) try {
          Y.host = URL.domainToASCII(Y.host.toLowerCase());
        } catch (B) {
          Y.error = Y.error || "Host's domain name can not be converted to ASCII: " + B;
        }
      }
      if (!H || H && !H.skipNormalize) {
        if (W && Y.scheme !== void 0) Y.scheme = unescape(Y.scheme);
        if (W && Y.host !== void 0) Y.host = unescape(Y.host);
        if (Y.path) Y.path = escape(unescape(Y.path));
        if (Y.fragment) Y.fragment = encodeURI(decodeURIComponent(Y.fragment));
      }
      if (H && H.parse) H.parse(Y, $);
    } else Y.error = Y.error || "URI can not be parsed.";
    return Y;
  }
  var CY = { SCHEMES: ZY, normalize: EA, resolve: bA, resolveComponents: LH, equal: PA, serialize: U1, parse: E1 };
  g8.exports = CY;
  g8.exports.default = CY;
  g8.exports.fastUri = CY;
});
var OH = P((NH) => {
  Object.defineProperty(NH, "__esModule", { value: true });
  var FH = qH();
  FH.code = 'require("ajv/dist/runtime/uri").default';
  NH.default = FH;
});
var EH = P((b1) => {
  Object.defineProperty(b1, "__esModule", { value: true });
  b1.CodeGen = b1.Name = b1.nil = b1.stringify = b1.str = b1._ = b1.KeywordCxt = void 0;
  var vA = iX();
  Object.defineProperty(b1, "KeywordCxt", { enumerable: true, get: function() {
    return vA.KeywordCxt;
  } });
  var c6 = p();
  Object.defineProperty(b1, "_", { enumerable: true, get: function() {
    return c6._;
  } });
  Object.defineProperty(b1, "str", { enumerable: true, get: function() {
    return c6.str;
  } });
  Object.defineProperty(b1, "stringify", { enumerable: true, get: function() {
    return c6.stringify;
  } });
  Object.defineProperty(b1, "nil", { enumerable: true, get: function() {
    return c6.nil;
  } });
  Object.defineProperty(b1, "Name", { enumerable: true, get: function() {
    return c6.Name;
  } });
  Object.defineProperty(b1, "CodeGen", { enumerable: true, get: function() {
    return c6.CodeGen;
  } });
  var TA = v8(), jH = nX(), _A = KY(), tX = _8(), xA = p(), aX = cX(), f8 = mX(), vY = e(), DH = t3(), yA = OH(), RH = (X, Q) => new RegExp(X, Q);
  RH.code = "new RegExp";
  var gA = ["removeAdditional", "useDefaults", "coerceTypes"], fA = /* @__PURE__ */ new Set(["validate", "serialize", "parse", "wrapper", "root", "schema", "keyword", "pattern", "formats", "validate$data", "func", "obj", "Error"]), hA = { errorDataPath: "", format: "`validateFormats: false` can be used instead.", nullable: '"nullable" keyword is supported by default.', jsonPointers: "Deprecated jsPropertySyntax can be used instead.", extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.", missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.", processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`", sourceCode: "Use option `code: {source: true}`", strictDefaults: "It is default now, see option `strict`.", strictKeywords: "It is default now, see option `strict`.", uniqueItems: '"uniqueItems" keyword is always validated.', unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).", cache: "Map is used as cache, schema object as key.", serialize: "Map is used as cache, schema object as key.", ajvErrors: "It is default now." }, uA = { ignoreKeywordsWithRef: "", jsPropertySyntax: "", unicode: '"minLength"/"maxLength" account for unicode characters by default.' }, wH = 200;
  function lA(X) {
    var Q, $, Y, W, J, G, H, B, z, K, V, L, U, F, q, N, w, M, R, S, C, K0, U0, s, D0;
    let q0 = X.strict, L1 = (Q = X.code) === null || Q === void 0 ? void 0 : Q.optimize, P1 = L1 === true || L1 === void 0 ? 1 : L1 || 0, o1 = (Y = ($ = X.code) === null || $ === void 0 ? void 0 : $.regExp) !== null && Y !== void 0 ? Y : RH, c = (W = X.uriResolver) !== null && W !== void 0 ? W : yA.default;
    return { strictSchema: (G = (J = X.strictSchema) !== null && J !== void 0 ? J : q0) !== null && G !== void 0 ? G : true, strictNumbers: (B = (H = X.strictNumbers) !== null && H !== void 0 ? H : q0) !== null && B !== void 0 ? B : true, strictTypes: (K = (z = X.strictTypes) !== null && z !== void 0 ? z : q0) !== null && K !== void 0 ? K : "log", strictTuples: (L = (V = X.strictTuples) !== null && V !== void 0 ? V : q0) !== null && L !== void 0 ? L : "log", strictRequired: (F = (U = X.strictRequired) !== null && U !== void 0 ? U : q0) !== null && F !== void 0 ? F : false, code: X.code ? { ...X.code, optimize: P1, regExp: o1 } : { optimize: P1, regExp: o1 }, loopRequired: (q = X.loopRequired) !== null && q !== void 0 ? q : wH, loopEnum: (N = X.loopEnum) !== null && N !== void 0 ? N : wH, meta: (w = X.meta) !== null && w !== void 0 ? w : true, messages: (M = X.messages) !== null && M !== void 0 ? M : true, inlineRefs: (R = X.inlineRefs) !== null && R !== void 0 ? R : true, schemaId: (S = X.schemaId) !== null && S !== void 0 ? S : "$id", addUsedSchema: (C = X.addUsedSchema) !== null && C !== void 0 ? C : true, validateSchema: (K0 = X.validateSchema) !== null && K0 !== void 0 ? K0 : true, validateFormats: (U0 = X.validateFormats) !== null && U0 !== void 0 ? U0 : true, unicodeRegExp: (s = X.unicodeRegExp) !== null && s !== void 0 ? s : true, int32range: (D0 = X.int32range) !== null && D0 !== void 0 ? D0 : true, uriResolver: c };
  }
  class h8 {
    constructor(X = {}) {
      this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), X = this.opts = { ...X, ...lA(X) };
      let { es5: Q, lines: $ } = this.opts.code;
      this.scope = new xA.ValueScope({ scope: {}, prefixes: fA, es5: Q, lines: $ }), this.logger = nA(X.logger);
      let Y = X.validateFormats;
      if (X.validateFormats = false, this.RULES = (0, _A.getRules)(), AH.call(this, hA, X, "NOT SUPPORTED"), AH.call(this, uA, X, "DEPRECATED", "warn"), this._metaOpts = dA.call(this), X.formats) cA.call(this);
      if (this._addVocabularies(), this._addDefaultMetaSchema(), X.keywords) pA.call(this, X.keywords);
      if (typeof X.meta == "object") this.addMetaSchema(X.meta);
      mA.call(this), X.validateFormats = Y;
    }
    _addVocabularies() {
      this.addKeyword("$async");
    }
    _addDefaultMetaSchema() {
      let { $data: X, meta: Q, schemaId: $ } = this.opts, Y = DH;
      if ($ === "id") Y = { ...DH }, Y.id = Y.$id, delete Y.$id;
      if (Q && X) this.addMetaSchema(Y, Y[$], false);
    }
    defaultMeta() {
      let { meta: X, schemaId: Q } = this.opts;
      return this.opts.defaultMeta = typeof X == "object" ? X[Q] || X : void 0;
    }
    validate(X, Q) {
      let $;
      if (typeof X == "string") {
        if ($ = this.getSchema(X), !$) throw Error(`no schema with key or ref "${X}"`);
      } else $ = this.compile(X);
      let Y = $(Q);
      if (!("$async" in $)) this.errors = $.errors;
      return Y;
    }
    compile(X, Q) {
      let $ = this._addSchema(X, Q);
      return $.validate || this._compileSchemaEnv($);
    }
    compileAsync(X, Q) {
      if (typeof this.opts.loadSchema != "function") throw Error("options.loadSchema should be a function");
      let { loadSchema: $ } = this.opts;
      return Y.call(this, X, Q);
      async function Y(z, K) {
        await W.call(this, z.$schema);
        let V = this._addSchema(z, K);
        return V.validate || J.call(this, V);
      }
      async function W(z) {
        if (z && !this.getSchema(z)) await Y.call(this, { $ref: z }, true);
      }
      async function J(z) {
        try {
          return this._compileSchemaEnv(z);
        } catch (K) {
          if (!(K instanceof jH.default)) throw K;
          return G.call(this, K), await H.call(this, K.missingSchema), J.call(this, z);
        }
      }
      function G({ missingSchema: z, missingRef: K }) {
        if (this.refs[z]) throw Error(`AnySchema ${z} is loaded but ${K} cannot be resolved`);
      }
      async function H(z) {
        let K = await B.call(this, z);
        if (!this.refs[z]) await W.call(this, K.$schema);
        if (!this.refs[z]) this.addSchema(K, z, Q);
      }
      async function B(z) {
        let K = this._loading[z];
        if (K) return K;
        try {
          return await (this._loading[z] = $(z));
        } finally {
          delete this._loading[z];
        }
      }
    }
    addSchema(X, Q, $, Y = this.opts.validateSchema) {
      if (Array.isArray(X)) {
        for (let J of X) this.addSchema(J, void 0, $, Y);
        return this;
      }
      let W;
      if (typeof X === "object") {
        let { schemaId: J } = this.opts;
        if (W = X[J], W !== void 0 && typeof W != "string") throw Error(`schema ${J} must be string`);
      }
      return Q = (0, aX.normalizeId)(Q || W), this._checkUnique(Q), this.schemas[Q] = this._addSchema(X, $, Q, Y, true), this;
    }
    addMetaSchema(X, Q, $ = this.opts.validateSchema) {
      return this.addSchema(X, Q, true, $), this;
    }
    validateSchema(X, Q) {
      if (typeof X == "boolean") return true;
      let $;
      if ($ = X.$schema, $ !== void 0 && typeof $ != "string") throw Error("$schema must be a string");
      if ($ = $ || this.opts.defaultMeta || this.defaultMeta(), !$) return this.logger.warn("meta-schema not available"), this.errors = null, true;
      let Y = this.validate($, X);
      if (!Y && Q) {
        let W = "schema is invalid: " + this.errorsText();
        if (this.opts.validateSchema === "log") this.logger.error(W);
        else throw Error(W);
      }
      return Y;
    }
    getSchema(X) {
      let Q;
      while (typeof (Q = MH.call(this, X)) == "string") X = Q;
      if (Q === void 0) {
        let { schemaId: $ } = this.opts, Y = new tX.SchemaEnv({ schema: {}, schemaId: $ });
        if (Q = tX.resolveSchema.call(this, Y, X), !Q) return;
        this.refs[X] = Q;
      }
      return Q.validate || this._compileSchemaEnv(Q);
    }
    removeSchema(X) {
      if (X instanceof RegExp) return this._removeAllSchemas(this.schemas, X), this._removeAllSchemas(this.refs, X), this;
      switch (typeof X) {
        case "undefined":
          return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
        case "string": {
          let Q = MH.call(this, X);
          if (typeof Q == "object") this._cache.delete(Q.schema);
          return delete this.schemas[X], delete this.refs[X], this;
        }
        case "object": {
          let Q = X;
          this._cache.delete(Q);
          let $ = X[this.opts.schemaId];
          if ($) $ = (0, aX.normalizeId)($), delete this.schemas[$], delete this.refs[$];
          return this;
        }
        default:
          throw Error("ajv.removeSchema: invalid parameter");
      }
    }
    addVocabulary(X) {
      for (let Q of X) this.addKeyword(Q);
      return this;
    }
    addKeyword(X, Q) {
      let $;
      if (typeof X == "string") {
        if ($ = X, typeof Q == "object") this.logger.warn("these parameters are deprecated, see docs for addKeyword"), Q.keyword = $;
      } else if (typeof X == "object" && Q === void 0) {
        if (Q = X, $ = Q.keyword, Array.isArray($) && !$.length) throw Error("addKeywords: keyword must be string or non-empty array");
      } else throw Error("invalid addKeywords parameters");
      if (oA.call(this, $, Q), !Q) return (0, vY.eachItem)($, (W) => kY.call(this, W)), this;
      aA.call(this, Q);
      let Y = { ...Q, type: (0, f8.getJSONTypes)(Q.type), schemaType: (0, f8.getJSONTypes)(Q.schemaType) };
      return (0, vY.eachItem)($, Y.type.length === 0 ? (W) => kY.call(this, W, Y) : (W) => Y.type.forEach((J) => kY.call(this, W, Y, J))), this;
    }
    getKeyword(X) {
      let Q = this.RULES.all[X];
      return typeof Q == "object" ? Q.definition : !!Q;
    }
    removeKeyword(X) {
      let { RULES: Q } = this;
      delete Q.keywords[X], delete Q.all[X];
      for (let $ of Q.rules) {
        let Y = $.rules.findIndex((W) => W.keyword === X);
        if (Y >= 0) $.rules.splice(Y, 1);
      }
      return this;
    }
    addFormat(X, Q) {
      if (typeof Q == "string") Q = new RegExp(Q);
      return this.formats[X] = Q, this;
    }
    errorsText(X = this.errors, { separator: Q = ", ", dataVar: $ = "data" } = {}) {
      if (!X || X.length === 0) return "No errors";
      return X.map((Y) => `${$}${Y.instancePath} ${Y.message}`).reduce((Y, W) => Y + Q + W);
    }
    $dataMetaSchema(X, Q) {
      let $ = this.RULES.all;
      X = JSON.parse(JSON.stringify(X));
      for (let Y of Q) {
        let W = Y.split("/").slice(1), J = X;
        for (let G of W) J = J[G];
        for (let G in $) {
          let H = $[G];
          if (typeof H != "object") continue;
          let { $data: B } = H.definition, z = J[G];
          if (B && z) J[G] = IH(z);
        }
      }
      return X;
    }
    _removeAllSchemas(X, Q) {
      for (let $ in X) {
        let Y = X[$];
        if (!Q || Q.test($)) {
          if (typeof Y == "string") delete X[$];
          else if (Y && !Y.meta) this._cache.delete(Y.schema), delete X[$];
        }
      }
    }
    _addSchema(X, Q, $, Y = this.opts.validateSchema, W = this.opts.addUsedSchema) {
      let J, { schemaId: G } = this.opts;
      if (typeof X == "object") J = X[G];
      else if (this.opts.jtd) throw Error("schema must be object");
      else if (typeof X != "boolean") throw Error("schema must be object or boolean");
      let H = this._cache.get(X);
      if (H !== void 0) return H;
      $ = (0, aX.normalizeId)(J || $);
      let B = aX.getSchemaRefs.call(this, X, $);
      if (H = new tX.SchemaEnv({ schema: X, schemaId: G, meta: Q, baseId: $, localRefs: B }), this._cache.set(H.schema, H), W && !$.startsWith("#")) {
        if ($) this._checkUnique($);
        this.refs[$] = H;
      }
      if (Y) this.validateSchema(X, true);
      return H;
    }
    _checkUnique(X) {
      if (this.schemas[X] || this.refs[X]) throw Error(`schema with key or id "${X}" already exists`);
    }
    _compileSchemaEnv(X) {
      if (X.meta) this._compileMetaSchema(X);
      else tX.compileSchema.call(this, X);
      if (!X.validate) throw Error("ajv implementation error");
      return X.validate;
    }
    _compileMetaSchema(X) {
      let Q = this.opts;
      this.opts = this._metaOpts;
      try {
        tX.compileSchema.call(this, X);
      } finally {
        this.opts = Q;
      }
    }
  }
  h8.ValidationError = TA.default;
  h8.MissingRefError = jH.default;
  b1.default = h8;
  function AH(X, Q, $, Y = "error") {
    for (let W in X) {
      let J = W;
      if (J in Q) this.logger[Y](`${$}: option ${W}. ${X[J]}`);
    }
  }
  function MH(X) {
    return X = (0, aX.normalizeId)(X), this.schemas[X] || this.refs[X];
  }
  function mA() {
    let X = this.opts.schemas;
    if (!X) return;
    if (Array.isArray(X)) this.addSchema(X);
    else for (let Q in X) this.addSchema(X[Q], Q);
  }
  function cA() {
    for (let X in this.opts.formats) {
      let Q = this.opts.formats[X];
      if (Q) this.addFormat(X, Q);
    }
  }
  function pA(X) {
    if (Array.isArray(X)) {
      this.addVocabulary(X);
      return;
    }
    this.logger.warn("keywords option as map is deprecated, pass array");
    for (let Q in X) {
      let $ = X[Q];
      if (!$.keyword) $.keyword = Q;
      this.addKeyword($);
    }
  }
  function dA() {
    let X = { ...this.opts };
    for (let Q of gA) delete X[Q];
    return X;
  }
  var iA = { log() {
  }, warn() {
  }, error() {
  } };
  function nA(X) {
    if (X === false) return iA;
    if (X === void 0) return console;
    if (X.log && X.warn && X.error) return X;
    throw Error("logger must implement log, warn and error methods");
  }
  var rA = /^[a-z_$][a-z0-9_$:-]*$/i;
  function oA(X, Q) {
    let { RULES: $ } = this;
    if ((0, vY.eachItem)(X, (Y) => {
      if ($.keywords[Y]) throw Error(`Keyword ${Y} is already defined`);
      if (!rA.test(Y)) throw Error(`Keyword ${Y} has invalid name`);
    }), !Q) return;
    if (Q.$data && !("code" in Q || "validate" in Q)) throw Error('$data keyword must have "code" or "validate" function');
  }
  function kY(X, Q, $) {
    var Y;
    let W = Q === null || Q === void 0 ? void 0 : Q.post;
    if ($ && W) throw Error('keyword with "post" flag cannot have "type"');
    let { RULES: J } = this, G = W ? J.post : J.rules.find(({ type: B }) => B === $);
    if (!G) G = { type: $, rules: [] }, J.rules.push(G);
    if (J.keywords[X] = true, !Q) return;
    let H = { keyword: X, definition: { ...Q, type: (0, f8.getJSONTypes)(Q.type), schemaType: (0, f8.getJSONTypes)(Q.schemaType) } };
    if (Q.before) tA.call(this, G, H, Q.before);
    else G.rules.push(H);
    J.all[X] = H, (Y = Q.implements) === null || Y === void 0 || Y.forEach((B) => this.addKeyword(B));
  }
  function tA(X, Q, $) {
    let Y = X.rules.findIndex((W) => W.keyword === $);
    if (Y >= 0) X.rules.splice(Y, 0, Q);
    else X.rules.push(Q), this.logger.warn(`rule ${$} is not defined`);
  }
  function aA(X) {
    let { metaSchema: Q } = X;
    if (Q === void 0) return;
    if (X.$data && this.opts.$data) Q = IH(Q);
    X.validateSchema = this.compile(Q, true);
  }
  var sA = { $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#" };
  function IH(X) {
    return { anyOf: [X, sA] };
  }
});
var PH = P((bH) => {
  Object.defineProperty(bH, "__esModule", { value: true });
  var QM = { keyword: "id", code() {
    throw Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
  } };
  bH.default = QM;
});
var TH = P((kH) => {
  Object.defineProperty(kH, "__esModule", { value: true });
  kH.callRef = kH.getValidate = void 0;
  var YM = nX(), SH = d0(), g0 = p(), p6 = R1(), ZH = _8(), u8 = e(), WM = { keyword: "$ref", schemaType: "string", code(X) {
    let { gen: Q, schema: $, it: Y } = X, { baseId: W, schemaEnv: J, validateName: G, opts: H, self: B } = Y, { root: z } = J;
    if (($ === "#" || $ === "#/") && W === z.baseId) return V();
    let K = ZH.resolveRef.call(B, z, W, $);
    if (K === void 0) throw new YM.default(Y.opts.uriResolver, W, $);
    if (K instanceof ZH.SchemaEnv) return L(K);
    return U(K);
    function V() {
      if (J === z) return l8(X, G, J, J.$async);
      let F = Q.scopeValue("root", { ref: z });
      return l8(X, g0._`${F}.validate`, z, z.$async);
    }
    function L(F) {
      let q = CH(X, F);
      l8(X, q, F, F.$async);
    }
    function U(F) {
      let q = Q.scopeValue("schema", H.code.source === true ? { ref: F, code: (0, g0.stringify)(F) } : { ref: F }), N = Q.name("valid"), w = X.subschema({ schema: F, dataTypes: [], schemaPath: g0.nil, topSchemaRef: q, errSchemaPath: $ }, N);
      X.mergeEvaluated(w), X.ok(N);
    }
  } };
  function CH(X, Q) {
    let { gen: $ } = X;
    return Q.validate ? $.scopeValue("validate", { ref: Q.validate }) : g0._`${$.scopeValue("wrapper", { ref: Q })}.validate`;
  }
  kH.getValidate = CH;
  function l8(X, Q, $, Y) {
    let { gen: W, it: J } = X, { allErrors: G, schemaEnv: H, opts: B } = J, z = B.passContext ? p6.default.this : g0.nil;
    if (Y) K();
    else V();
    function K() {
      if (!H.$async) throw Error("async schema referenced by sync schema");
      let F = W.let("valid");
      W.try(() => {
        if (W.code(g0._`await ${(0, SH.callValidateCode)(X, Q, z)}`), U(Q), !G) W.assign(F, true);
      }, (q) => {
        if (W.if(g0._`!(${q} instanceof ${J.ValidationError})`, () => W.throw(q)), L(q), !G) W.assign(F, false);
      }), X.ok(F);
    }
    function V() {
      X.result((0, SH.callValidateCode)(X, Q, z), () => U(Q), () => L(Q));
    }
    function L(F) {
      let q = g0._`${F}.errors`;
      W.assign(p6.default.vErrors, g0._`${p6.default.vErrors} === null ? ${q} : ${p6.default.vErrors}.concat(${q})`), W.assign(p6.default.errors, g0._`${p6.default.vErrors}.length`);
    }
    function U(F) {
      var q;
      if (!J.opts.unevaluated) return;
      let N = (q = $ === null || $ === void 0 ? void 0 : $.validate) === null || q === void 0 ? void 0 : q.evaluated;
      if (J.props !== true) if (N && !N.dynamicProps) {
        if (N.props !== void 0) J.props = u8.mergeEvaluated.props(W, N.props, J.props);
      } else {
        let w = W.var("props", g0._`${F}.evaluated.props`);
        J.props = u8.mergeEvaluated.props(W, w, J.props, g0.Name);
      }
      if (J.items !== true) if (N && !N.dynamicItems) {
        if (N.items !== void 0) J.items = u8.mergeEvaluated.items(W, N.items, J.items);
      } else {
        let w = W.var("items", g0._`${F}.evaluated.items`);
        J.items = u8.mergeEvaluated.items(W, w, J.items, g0.Name);
      }
    }
  }
  kH.callRef = l8;
  kH.default = WM;
});
var xH = P((_H) => {
  Object.defineProperty(_H, "__esModule", { value: true });
  var HM = PH(), BM = TH(), zM = ["$schema", "$id", "$defs", "$vocabulary", { keyword: "$comment" }, "definitions", HM.default, BM.default];
  _H.default = zM;
});
var gH = P((yH) => {
  Object.defineProperty(yH, "__esModule", { value: true });
  var m8 = p(), i1 = m8.operators, c8 = { maximum: { okStr: "<=", ok: i1.LTE, fail: i1.GT }, minimum: { okStr: ">=", ok: i1.GTE, fail: i1.LT }, exclusiveMaximum: { okStr: "<", ok: i1.LT, fail: i1.GTE }, exclusiveMinimum: { okStr: ">", ok: i1.GT, fail: i1.LTE } }, UM = { message: ({ keyword: X, schemaCode: Q }) => m8.str`must be ${c8[X].okStr} ${Q}`, params: ({ keyword: X, schemaCode: Q }) => m8._`{comparison: ${c8[X].okStr}, limit: ${Q}}` }, VM = { keyword: Object.keys(c8), type: "number", schemaType: "number", $data: true, error: UM, code(X) {
    let { keyword: Q, data: $, schemaCode: Y } = X;
    X.fail$data(m8._`${$} ${c8[Q].fail} ${Y} || isNaN(${$})`);
  } };
  yH.default = VM;
});
var hH = P((fH) => {
  Object.defineProperty(fH, "__esModule", { value: true });
  var sX = p(), qM = { message: ({ schemaCode: X }) => sX.str`must be multiple of ${X}`, params: ({ schemaCode: X }) => sX._`{multipleOf: ${X}}` }, FM = { keyword: "multipleOf", type: "number", schemaType: "number", $data: true, error: qM, code(X) {
    let { gen: Q, data: $, schemaCode: Y, it: W } = X, J = W.opts.multipleOfPrecision, G = Q.let("res"), H = J ? sX._`Math.abs(Math.round(${G}) - ${G}) > 1e-${J}` : sX._`${G} !== parseInt(${G})`;
    X.fail$data(sX._`(${Y} === 0 || (${G} = ${$}/${Y}, ${H}))`);
  } };
  fH.default = FM;
});
var mH = P((lH) => {
  Object.defineProperty(lH, "__esModule", { value: true });
  function uH(X) {
    let Q = X.length, $ = 0, Y = 0, W;
    while (Y < Q) if ($++, W = X.charCodeAt(Y++), W >= 55296 && W <= 56319 && Y < Q) {
      if (W = X.charCodeAt(Y), (W & 64512) === 56320) Y++;
    }
    return $;
  }
  lH.default = uH;
  uH.code = 'require("ajv/dist/runtime/ucs2length").default';
});
var pH = P((cH) => {
  Object.defineProperty(cH, "__esModule", { value: true });
  var K6 = p(), DM = e(), wM = mH(), AM = { message({ keyword: X, schemaCode: Q }) {
    let $ = X === "maxLength" ? "more" : "fewer";
    return K6.str`must NOT have ${$} than ${Q} characters`;
  }, params: ({ schemaCode: X }) => K6._`{limit: ${X}}` }, MM = { keyword: ["maxLength", "minLength"], type: "string", schemaType: "number", $data: true, error: AM, code(X) {
    let { keyword: Q, data: $, schemaCode: Y, it: W } = X, J = Q === "maxLength" ? K6.operators.GT : K6.operators.LT, G = W.opts.unicode === false ? K6._`${$}.length` : K6._`${(0, DM.useFunc)(X.gen, wM.default)}(${$})`;
    X.fail$data(K6._`${G} ${J} ${Y}`);
  } };
  cH.default = MM;
});
var iH = P((dH) => {
  Object.defineProperty(dH, "__esModule", { value: true });
  var RM = d0(), p8 = p(), IM = { message: ({ schemaCode: X }) => p8.str`must match pattern "${X}"`, params: ({ schemaCode: X }) => p8._`{pattern: ${X}}` }, EM = { keyword: "pattern", type: "string", schemaType: "string", $data: true, error: IM, code(X) {
    let { data: Q, $data: $, schema: Y, schemaCode: W, it: J } = X, G = J.opts.unicodeRegExp ? "u" : "", H = $ ? p8._`(new RegExp(${W}, ${G}))` : (0, RM.usePattern)(X, Y);
    X.fail$data(p8._`!${H}.test(${Q})`);
  } };
  dH.default = EM;
});
var rH = P((nH) => {
  Object.defineProperty(nH, "__esModule", { value: true });
  var eX = p(), PM = { message({ keyword: X, schemaCode: Q }) {
    let $ = X === "maxProperties" ? "more" : "fewer";
    return eX.str`must NOT have ${$} than ${Q} properties`;
  }, params: ({ schemaCode: X }) => eX._`{limit: ${X}}` }, SM = { keyword: ["maxProperties", "minProperties"], type: "object", schemaType: "number", $data: true, error: PM, code(X) {
    let { keyword: Q, data: $, schemaCode: Y } = X, W = Q === "maxProperties" ? eX.operators.GT : eX.operators.LT;
    X.fail$data(eX._`Object.keys(${$}).length ${W} ${Y}`);
  } };
  nH.default = SM;
});
var tH = P((oH) => {
  Object.defineProperty(oH, "__esModule", { value: true });
  var X4 = d0(), Q4 = p(), CM = e(), kM = { message: ({ params: { missingProperty: X } }) => Q4.str`must have required property '${X}'`, params: ({ params: { missingProperty: X } }) => Q4._`{missingProperty: ${X}}` }, vM = { keyword: "required", type: "object", schemaType: "array", $data: true, error: kM, code(X) {
    let { gen: Q, schema: $, schemaCode: Y, data: W, $data: J, it: G } = X, { opts: H } = G;
    if (!J && $.length === 0) return;
    let B = $.length >= H.loopRequired;
    if (G.allErrors) z();
    else K();
    if (H.strictRequired) {
      let U = X.parentSchema.properties, { definedProperties: F } = X.it;
      for (let q of $) if ((U === null || U === void 0 ? void 0 : U[q]) === void 0 && !F.has(q)) {
        let N = G.schemaEnv.baseId + G.errSchemaPath, w = `required property "${q}" is not defined at "${N}" (strictRequired)`;
        (0, CM.checkStrictMode)(G, w, G.opts.strictRequired);
      }
    }
    function z() {
      if (B || J) X.block$data(Q4.nil, V);
      else for (let U of $) (0, X4.checkReportMissingProp)(X, U);
    }
    function K() {
      let U = Q.let("missing");
      if (B || J) {
        let F = Q.let("valid", true);
        X.block$data(F, () => L(U, F)), X.ok(F);
      } else Q.if((0, X4.checkMissingProp)(X, $, U)), (0, X4.reportMissingProp)(X, U), Q.else();
    }
    function V() {
      Q.forOf("prop", Y, (U) => {
        X.setParams({ missingProperty: U }), Q.if((0, X4.noPropertyInData)(Q, W, U, H.ownProperties), () => X.error());
      });
    }
    function L(U, F) {
      X.setParams({ missingProperty: U }), Q.forOf(U, Y, () => {
        Q.assign(F, (0, X4.propertyInData)(Q, W, U, H.ownProperties)), Q.if((0, Q4.not)(F), () => {
          X.error(), Q.break();
        });
      }, Q4.nil);
    }
  } };
  oH.default = vM;
});
var sH = P((aH) => {
  Object.defineProperty(aH, "__esModule", { value: true });
  var $4 = p(), _M = { message({ keyword: X, schemaCode: Q }) {
    let $ = X === "maxItems" ? "more" : "fewer";
    return $4.str`must NOT have ${$} than ${Q} items`;
  }, params: ({ schemaCode: X }) => $4._`{limit: ${X}}` }, xM = { keyword: ["maxItems", "minItems"], type: "array", schemaType: "number", $data: true, error: _M, code(X) {
    let { keyword: Q, data: $, schemaCode: Y } = X, W = Q === "maxItems" ? $4.operators.GT : $4.operators.LT;
    X.fail$data($4._`${$}.length ${W} ${Y}`);
  } };
  aH.default = xM;
});
var d8 = P((XB) => {
  Object.defineProperty(XB, "__esModule", { value: true });
  var eH = DY();
  eH.code = 'require("ajv/dist/runtime/equal").default';
  XB.default = eH;
});
var $B = P((QB) => {
  Object.defineProperty(QB, "__esModule", { value: true });
  var TY = mX(), I0 = p(), fM = e(), hM = d8(), uM = { message: ({ params: { i: X, j: Q } }) => I0.str`must NOT have duplicate items (items ## ${Q} and ${X} are identical)`, params: ({ params: { i: X, j: Q } }) => I0._`{i: ${X}, j: ${Q}}` }, lM = { keyword: "uniqueItems", type: "array", schemaType: "boolean", $data: true, error: uM, code(X) {
    let { gen: Q, data: $, $data: Y, schema: W, parentSchema: J, schemaCode: G, it: H } = X;
    if (!Y && !W) return;
    let B = Q.let("valid"), z = J.items ? (0, TY.getSchemaTypes)(J.items) : [];
    X.block$data(B, K, I0._`${G} === false`), X.ok(B);
    function K() {
      let F = Q.let("i", I0._`${$}.length`), q = Q.let("j");
      X.setParams({ i: F, j: q }), Q.assign(B, true), Q.if(I0._`${F} > 1`, () => (V() ? L : U)(F, q));
    }
    function V() {
      return z.length > 0 && !z.some((F) => F === "object" || F === "array");
    }
    function L(F, q) {
      let N = Q.name("item"), w = (0, TY.checkDataTypes)(z, N, H.opts.strictNumbers, TY.DataType.Wrong), M = Q.const("indices", I0._`{}`);
      Q.for(I0._`;${F}--;`, () => {
        if (Q.let(N, I0._`${$}[${F}]`), Q.if(w, I0._`continue`), z.length > 1) Q.if(I0._`typeof ${N} == "string"`, I0._`${N} += "_"`);
        Q.if(I0._`typeof ${M}[${N}] == "number"`, () => {
          Q.assign(q, I0._`${M}[${N}]`), X.error(), Q.assign(B, false).break();
        }).code(I0._`${M}[${N}] = ${F}`);
      });
    }
    function U(F, q) {
      let N = (0, fM.useFunc)(Q, hM.default), w = Q.name("outer");
      Q.label(w).for(I0._`;${F}--;`, () => Q.for(I0._`${q} = ${F}; ${q}--;`, () => Q.if(I0._`${N}(${$}[${F}], ${$}[${q}])`, () => {
        X.error(), Q.assign(B, false).break(w);
      })));
    }
  } };
  QB.default = lM;
});
var WB = P((YB) => {
  Object.defineProperty(YB, "__esModule", { value: true });
  var _Y = p(), cM = e(), pM = d8(), dM = { message: "must be equal to constant", params: ({ schemaCode: X }) => _Y._`{allowedValue: ${X}}` }, iM = { keyword: "const", $data: true, error: dM, code(X) {
    let { gen: Q, data: $, $data: Y, schemaCode: W, schema: J } = X;
    if (Y || J && typeof J == "object") X.fail$data(_Y._`!${(0, cM.useFunc)(Q, pM.default)}(${$}, ${W})`);
    else X.fail(_Y._`${J} !== ${$}`);
  } };
  YB.default = iM;
});
var GB = P((JB) => {
  Object.defineProperty(JB, "__esModule", { value: true });
  var Y4 = p(), rM = e(), oM = d8(), tM = { message: "must be equal to one of the allowed values", params: ({ schemaCode: X }) => Y4._`{allowedValues: ${X}}` }, aM = { keyword: "enum", schemaType: "array", $data: true, error: tM, code(X) {
    let { gen: Q, data: $, $data: Y, schema: W, schemaCode: J, it: G } = X;
    if (!Y && W.length === 0) throw Error("enum must have non-empty array");
    let H = W.length >= G.opts.loopEnum, B, z = () => B !== null && B !== void 0 ? B : B = (0, rM.useFunc)(Q, oM.default), K;
    if (H || Y) K = Q.let("valid"), X.block$data(K, V);
    else {
      if (!Array.isArray(W)) throw Error("ajv implementation error");
      let U = Q.const("vSchema", J);
      K = (0, Y4.or)(...W.map((F, q) => L(U, q)));
    }
    X.pass(K);
    function V() {
      Q.assign(K, false), Q.forOf("v", J, (U) => Q.if(Y4._`${z()}(${$}, ${U})`, () => Q.assign(K, true).break()));
    }
    function L(U, F) {
      let q = W[F];
      return typeof q === "object" && q !== null ? Y4._`${z()}(${$}, ${U}[${F}])` : Y4._`${$} === ${q}`;
    }
  } };
  JB.default = aM;
});
var BB = P((HB) => {
  Object.defineProperty(HB, "__esModule", { value: true });
  var eM = gH(), Xj = hH(), Qj = pH(), $j = iH(), Yj = rH(), Wj = tH(), Jj = sH(), Gj = $B(), Hj = WB(), Bj = GB(), zj = [eM.default, Xj.default, Qj.default, $j.default, Yj.default, Wj.default, Jj.default, Gj.default, { keyword: "type", schemaType: ["string", "array"] }, { keyword: "nullable", schemaType: "boolean" }, Hj.default, Bj.default];
  HB.default = zj;
});
var yY = P((KB) => {
  Object.defineProperty(KB, "__esModule", { value: true });
  KB.validateAdditionalItems = void 0;
  var U6 = p(), xY = e(), Uj = { message: ({ params: { len: X } }) => U6.str`must NOT have more than ${X} items`, params: ({ params: { len: X } }) => U6._`{limit: ${X}}` }, Vj = { keyword: "additionalItems", type: "array", schemaType: ["boolean", "object"], before: "uniqueItems", error: Uj, code(X) {
    let { parentSchema: Q, it: $ } = X, { items: Y } = Q;
    if (!Array.isArray(Y)) {
      (0, xY.checkStrictMode)($, '"additionalItems" is ignored when "items" is not an array of schemas');
      return;
    }
    zB(X, Y);
  } };
  function zB(X, Q) {
    let { gen: $, schema: Y, data: W, keyword: J, it: G } = X;
    G.items = true;
    let H = $.const("len", U6._`${W}.length`);
    if (Y === false) X.setParams({ len: Q.length }), X.pass(U6._`${H} <= ${Q.length}`);
    else if (typeof Y == "object" && !(0, xY.alwaysValidSchema)(G, Y)) {
      let z = $.var("valid", U6._`${H} <= ${Q.length}`);
      $.if((0, U6.not)(z), () => B(z)), X.ok(z);
    }
    function B(z) {
      $.forRange("i", Q.length, H, (K) => {
        if (X.subschema({ keyword: J, dataProp: K, dataPropType: xY.Type.Num }, z), !G.allErrors) $.if((0, U6.not)(z), () => $.break());
      });
    }
  }
  KB.validateAdditionalItems = zB;
  KB.default = Vj;
});
var gY = P((qB) => {
  Object.defineProperty(qB, "__esModule", { value: true });
  qB.validateTuple = void 0;
  var VB = p(), i8 = e(), qj = d0(), Fj = { keyword: "items", type: "array", schemaType: ["object", "array", "boolean"], before: "uniqueItems", code(X) {
    let { schema: Q, it: $ } = X;
    if (Array.isArray(Q)) return LB(X, "additionalItems", Q);
    if ($.items = true, (0, i8.alwaysValidSchema)($, Q)) return;
    X.ok((0, qj.validateArray)(X));
  } };
  function LB(X, Q, $ = X.schema) {
    let { gen: Y, parentSchema: W, data: J, keyword: G, it: H } = X;
    if (K(W), H.opts.unevaluated && $.length && H.items !== true) H.items = i8.mergeEvaluated.items(Y, $.length, H.items);
    let B = Y.name("valid"), z = Y.const("len", VB._`${J}.length`);
    $.forEach((V, L) => {
      if ((0, i8.alwaysValidSchema)(H, V)) return;
      Y.if(VB._`${z} > ${L}`, () => X.subschema({ keyword: G, schemaProp: L, dataProp: L }, B)), X.ok(B);
    });
    function K(V) {
      let { opts: L, errSchemaPath: U } = H, F = $.length, q = F === V.minItems && (F === V.maxItems || V[Q] === false);
      if (L.strictTuples && !q) {
        let N = `"${G}" is ${F}-tuple, but minItems or maxItems/${Q} are not specified or different at path "${U}"`;
        (0, i8.checkStrictMode)(H, N, L.strictTuples);
      }
    }
  }
  qB.validateTuple = LB;
  qB.default = Fj;
});
var OB = P((NB) => {
  Object.defineProperty(NB, "__esModule", { value: true });
  var Oj = gY(), Dj = { keyword: "prefixItems", type: "array", schemaType: ["array"], before: "uniqueItems", code: (X) => (0, Oj.validateTuple)(X, "items") };
  NB.default = Dj;
});
var AB = P((wB) => {
  Object.defineProperty(wB, "__esModule", { value: true });
  var DB = p(), Aj = e(), Mj = d0(), jj = yY(), Rj = { message: ({ params: { len: X } }) => DB.str`must NOT have more than ${X} items`, params: ({ params: { len: X } }) => DB._`{limit: ${X}}` }, Ij = { keyword: "items", type: "array", schemaType: ["object", "boolean"], before: "uniqueItems", error: Rj, code(X) {
    let { schema: Q, parentSchema: $, it: Y } = X, { prefixItems: W } = $;
    if (Y.items = true, (0, Aj.alwaysValidSchema)(Y, Q)) return;
    if (W) (0, jj.validateAdditionalItems)(X, W);
    else X.ok((0, Mj.validateArray)(X));
  } };
  wB.default = Ij;
});
var jB = P((MB) => {
  Object.defineProperty(MB, "__esModule", { value: true });
  var i0 = p(), n8 = e(), bj = { message: ({ params: { min: X, max: Q } }) => Q === void 0 ? i0.str`must contain at least ${X} valid item(s)` : i0.str`must contain at least ${X} and no more than ${Q} valid item(s)`, params: ({ params: { min: X, max: Q } }) => Q === void 0 ? i0._`{minContains: ${X}}` : i0._`{minContains: ${X}, maxContains: ${Q}}` }, Pj = { keyword: "contains", type: "array", schemaType: ["object", "boolean"], before: "uniqueItems", trackErrors: true, error: bj, code(X) {
    let { gen: Q, schema: $, parentSchema: Y, data: W, it: J } = X, G, H, { minContains: B, maxContains: z } = Y;
    if (J.opts.next) G = B === void 0 ? 1 : B, H = z;
    else G = 1;
    let K = Q.const("len", i0._`${W}.length`);
    if (X.setParams({ min: G, max: H }), H === void 0 && G === 0) {
      (0, n8.checkStrictMode)(J, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
      return;
    }
    if (H !== void 0 && G > H) {
      (0, n8.checkStrictMode)(J, '"minContains" > "maxContains" is always invalid'), X.fail();
      return;
    }
    if ((0, n8.alwaysValidSchema)(J, $)) {
      let q = i0._`${K} >= ${G}`;
      if (H !== void 0) q = i0._`${q} && ${K} <= ${H}`;
      X.pass(q);
      return;
    }
    J.items = true;
    let V = Q.name("valid");
    if (H === void 0 && G === 1) U(V, () => Q.if(V, () => Q.break()));
    else if (G === 0) {
      if (Q.let(V, true), H !== void 0) Q.if(i0._`${W}.length > 0`, L);
    } else Q.let(V, false), L();
    X.result(V, () => X.reset());
    function L() {
      let q = Q.name("_valid"), N = Q.let("count", 0);
      U(q, () => Q.if(q, () => F(N)));
    }
    function U(q, N) {
      Q.forRange("i", 0, K, (w) => {
        X.subschema({ keyword: "contains", dataProp: w, dataPropType: n8.Type.Num, compositeRule: true }, q), N();
      });
    }
    function F(q) {
      if (Q.code(i0._`${q}++`), H === void 0) Q.if(i0._`${q} >= ${G}`, () => Q.assign(V, true).break());
      else if (Q.if(i0._`${q} > ${H}`, () => Q.assign(V, false).break()), G === 1) Q.assign(V, true);
      else Q.if(i0._`${q} >= ${G}`, () => Q.assign(V, true));
    }
  } };
  MB.default = Pj;
});
var SB = P((EB) => {
  Object.defineProperty(EB, "__esModule", { value: true });
  EB.validateSchemaDeps = EB.validatePropertyDeps = EB.error = void 0;
  var fY = p(), Zj = e(), W4 = d0();
  EB.error = { message: ({ params: { property: X, depsCount: Q, deps: $ } }) => {
    let Y = Q === 1 ? "property" : "properties";
    return fY.str`must have ${Y} ${$} when property ${X} is present`;
  }, params: ({ params: { property: X, depsCount: Q, deps: $, missingProperty: Y } }) => fY._`{property: ${X},
    missingProperty: ${Y},
    depsCount: ${Q},
    deps: ${$}}` };
  var Cj = { keyword: "dependencies", type: "object", schemaType: "object", error: EB.error, code(X) {
    let [Q, $] = kj(X);
    RB(X, Q), IB(X, $);
  } };
  function kj({ schema: X }) {
    let Q = {}, $ = {};
    for (let Y in X) {
      if (Y === "__proto__") continue;
      let W = Array.isArray(X[Y]) ? Q : $;
      W[Y] = X[Y];
    }
    return [Q, $];
  }
  function RB(X, Q = X.schema) {
    let { gen: $, data: Y, it: W } = X;
    if (Object.keys(Q).length === 0) return;
    let J = $.let("missing");
    for (let G in Q) {
      let H = Q[G];
      if (H.length === 0) continue;
      let B = (0, W4.propertyInData)($, Y, G, W.opts.ownProperties);
      if (X.setParams({ property: G, depsCount: H.length, deps: H.join(", ") }), W.allErrors) $.if(B, () => {
        for (let z of H) (0, W4.checkReportMissingProp)(X, z);
      });
      else $.if(fY._`${B} && (${(0, W4.checkMissingProp)(X, H, J)})`), (0, W4.reportMissingProp)(X, J), $.else();
    }
  }
  EB.validatePropertyDeps = RB;
  function IB(X, Q = X.schema) {
    let { gen: $, data: Y, keyword: W, it: J } = X, G = $.name("valid");
    for (let H in Q) {
      if ((0, Zj.alwaysValidSchema)(J, Q[H])) continue;
      $.if((0, W4.propertyInData)($, Y, H, J.opts.ownProperties), () => {
        let B = X.subschema({ keyword: W, schemaProp: H }, G);
        X.mergeValidEvaluated(B, G);
      }, () => $.var(G, true)), X.ok(G);
    }
  }
  EB.validateSchemaDeps = IB;
  EB.default = Cj;
});
var kB = P((CB) => {
  Object.defineProperty(CB, "__esModule", { value: true });
  var ZB = p(), _j = e(), xj = { message: "property name must be valid", params: ({ params: X }) => ZB._`{propertyName: ${X.propertyName}}` }, yj = { keyword: "propertyNames", type: "object", schemaType: ["object", "boolean"], error: xj, code(X) {
    let { gen: Q, schema: $, data: Y, it: W } = X;
    if ((0, _j.alwaysValidSchema)(W, $)) return;
    let J = Q.name("valid");
    Q.forIn("key", Y, (G) => {
      X.setParams({ propertyName: G }), X.subschema({ keyword: "propertyNames", data: G, dataTypes: ["string"], propertyName: G, compositeRule: true }, J), Q.if((0, ZB.not)(J), () => {
        if (X.error(true), !W.allErrors) Q.break();
      });
    }), X.ok(J);
  } };
  CB.default = yj;
});
var hY = P((vB) => {
  Object.defineProperty(vB, "__esModule", { value: true });
  var r8 = d0(), $1 = p(), fj = R1(), o8 = e(), hj = { message: "must NOT have additional properties", params: ({ params: X }) => $1._`{additionalProperty: ${X.additionalProperty}}` }, uj = { keyword: "additionalProperties", type: ["object"], schemaType: ["boolean", "object"], allowUndefined: true, trackErrors: true, error: hj, code(X) {
    let { gen: Q, schema: $, parentSchema: Y, data: W, errsCount: J, it: G } = X;
    if (!J) throw Error("ajv implementation error");
    let { allErrors: H, opts: B } = G;
    if (G.props = true, B.removeAdditional !== "all" && (0, o8.alwaysValidSchema)(G, $)) return;
    let z = (0, r8.allSchemaProperties)(Y.properties), K = (0, r8.allSchemaProperties)(Y.patternProperties);
    V(), X.ok($1._`${J} === ${fj.default.errors}`);
    function V() {
      Q.forIn("key", W, (N) => {
        if (!z.length && !K.length) F(N);
        else Q.if(L(N), () => F(N));
      });
    }
    function L(N) {
      let w;
      if (z.length > 8) {
        let M = (0, o8.schemaRefOrVal)(G, Y.properties, "properties");
        w = (0, r8.isOwnProperty)(Q, M, N);
      } else if (z.length) w = (0, $1.or)(...z.map((M) => $1._`${N} === ${M}`));
      else w = $1.nil;
      if (K.length) w = (0, $1.or)(w, ...K.map((M) => $1._`${(0, r8.usePattern)(X, M)}.test(${N})`));
      return (0, $1.not)(w);
    }
    function U(N) {
      Q.code($1._`delete ${W}[${N}]`);
    }
    function F(N) {
      if (B.removeAdditional === "all" || B.removeAdditional && $ === false) {
        U(N);
        return;
      }
      if ($ === false) {
        if (X.setParams({ additionalProperty: N }), X.error(), !H) Q.break();
        return;
      }
      if (typeof $ == "object" && !(0, o8.alwaysValidSchema)(G, $)) {
        let w = Q.name("valid");
        if (B.removeAdditional === "failing") q(N, w, false), Q.if((0, $1.not)(w), () => {
          X.reset(), U(N);
        });
        else if (q(N, w), !H) Q.if((0, $1.not)(w), () => Q.break());
      }
    }
    function q(N, w, M) {
      let R = { keyword: "additionalProperties", dataProp: N, dataPropType: o8.Type.Str };
      if (M === false) Object.assign(R, { compositeRule: true, createErrors: false, allErrors: false });
      X.subschema(R, w);
    }
  } };
  vB.default = uj;
});
var yB = P((xB) => {
  Object.defineProperty(xB, "__esModule", { value: true });
  var mj = iX(), TB = d0(), uY = e(), _B = hY(), cj = { keyword: "properties", type: "object", schemaType: "object", code(X) {
    let { gen: Q, schema: $, parentSchema: Y, data: W, it: J } = X;
    if (J.opts.removeAdditional === "all" && Y.additionalProperties === void 0) _B.default.code(new mj.KeywordCxt(J, _B.default, "additionalProperties"));
    let G = (0, TB.allSchemaProperties)($);
    for (let V of G) J.definedProperties.add(V);
    if (J.opts.unevaluated && G.length && J.props !== true) J.props = uY.mergeEvaluated.props(Q, (0, uY.toHash)(G), J.props);
    let H = G.filter((V) => !(0, uY.alwaysValidSchema)(J, $[V]));
    if (H.length === 0) return;
    let B = Q.name("valid");
    for (let V of H) {
      if (z(V)) K(V);
      else {
        if (Q.if((0, TB.propertyInData)(Q, W, V, J.opts.ownProperties)), K(V), !J.allErrors) Q.else().var(B, true);
        Q.endIf();
      }
      X.it.definedProperties.add(V), X.ok(B);
    }
    function z(V) {
      return J.opts.useDefaults && !J.compositeRule && $[V].default !== void 0;
    }
    function K(V) {
      X.subschema({ keyword: "properties", schemaProp: V, dataProp: V }, B);
    }
  } };
  xB.default = cj;
});
var lB = P((uB) => {
  Object.defineProperty(uB, "__esModule", { value: true });
  var gB = d0(), t8 = p(), fB = e(), hB = e(), dj = { keyword: "patternProperties", type: "object", schemaType: "object", code(X) {
    let { gen: Q, schema: $, data: Y, parentSchema: W, it: J } = X, { opts: G } = J, H = (0, gB.allSchemaProperties)($), B = H.filter((q) => (0, fB.alwaysValidSchema)(J, $[q]));
    if (H.length === 0 || B.length === H.length && (!J.opts.unevaluated || J.props === true)) return;
    let z = G.strictSchema && !G.allowMatchingProperties && W.properties, K = Q.name("valid");
    if (J.props !== true && !(J.props instanceof t8.Name)) J.props = (0, hB.evaluatedPropsToName)(Q, J.props);
    let { props: V } = J;
    L();
    function L() {
      for (let q of H) {
        if (z) U(q);
        if (J.allErrors) F(q);
        else Q.var(K, true), F(q), Q.if(K);
      }
    }
    function U(q) {
      for (let N in z) if (new RegExp(q).test(N)) (0, fB.checkStrictMode)(J, `property ${N} matches pattern ${q} (use allowMatchingProperties)`);
    }
    function F(q) {
      Q.forIn("key", Y, (N) => {
        Q.if(t8._`${(0, gB.usePattern)(X, q)}.test(${N})`, () => {
          let w = B.includes(q);
          if (!w) X.subschema({ keyword: "patternProperties", schemaProp: q, dataProp: N, dataPropType: hB.Type.Str }, K);
          if (J.opts.unevaluated && V !== true) Q.assign(t8._`${V}[${N}]`, true);
          else if (!w && !J.allErrors) Q.if((0, t8.not)(K), () => Q.break());
        });
      });
    }
  } };
  uB.default = dj;
});
var cB = P((mB) => {
  Object.defineProperty(mB, "__esModule", { value: true });
  var nj = e(), rj = { keyword: "not", schemaType: ["object", "boolean"], trackErrors: true, code(X) {
    let { gen: Q, schema: $, it: Y } = X;
    if ((0, nj.alwaysValidSchema)(Y, $)) {
      X.fail();
      return;
    }
    let W = Q.name("valid");
    X.subschema({ keyword: "not", compositeRule: true, createErrors: false, allErrors: false }, W), X.failResult(W, () => X.reset(), () => X.error());
  }, error: { message: "must NOT be valid" } };
  mB.default = rj;
});
var dB = P((pB) => {
  Object.defineProperty(pB, "__esModule", { value: true });
  var tj = d0(), aj = { keyword: "anyOf", schemaType: "array", trackErrors: true, code: tj.validateUnion, error: { message: "must match a schema in anyOf" } };
  pB.default = aj;
});
var nB = P((iB) => {
  Object.defineProperty(iB, "__esModule", { value: true });
  var a8 = p(), ej = e(), XR = { message: "must match exactly one schema in oneOf", params: ({ params: X }) => a8._`{passingSchemas: ${X.passing}}` }, QR = { keyword: "oneOf", schemaType: "array", trackErrors: true, error: XR, code(X) {
    let { gen: Q, schema: $, parentSchema: Y, it: W } = X;
    if (!Array.isArray($)) throw Error("ajv implementation error");
    if (W.opts.discriminator && Y.discriminator) return;
    let J = $, G = Q.let("valid", false), H = Q.let("passing", null), B = Q.name("_valid");
    X.setParams({ passing: H }), Q.block(z), X.result(G, () => X.reset(), () => X.error(true));
    function z() {
      J.forEach((K, V) => {
        let L;
        if ((0, ej.alwaysValidSchema)(W, K)) Q.var(B, true);
        else L = X.subschema({ keyword: "oneOf", schemaProp: V, compositeRule: true }, B);
        if (V > 0) Q.if(a8._`${B} && ${G}`).assign(G, false).assign(H, a8._`[${H}, ${V}]`).else();
        Q.if(B, () => {
          if (Q.assign(G, true), Q.assign(H, V), L) X.mergeEvaluated(L, a8.Name);
        });
      });
    }
  } };
  iB.default = QR;
});
var oB = P((rB) => {
  Object.defineProperty(rB, "__esModule", { value: true });
  var YR = e(), WR = { keyword: "allOf", schemaType: "array", code(X) {
    let { gen: Q, schema: $, it: Y } = X;
    if (!Array.isArray($)) throw Error("ajv implementation error");
    let W = Q.name("valid");
    $.forEach((J, G) => {
      if ((0, YR.alwaysValidSchema)(Y, J)) return;
      let H = X.subschema({ keyword: "allOf", schemaProp: G }, W);
      X.ok(W), X.mergeEvaluated(H);
    });
  } };
  rB.default = WR;
});
var eB = P((sB) => {
  Object.defineProperty(sB, "__esModule", { value: true });
  var s8 = p(), aB = e(), GR = { message: ({ params: X }) => s8.str`must match "${X.ifClause}" schema`, params: ({ params: X }) => s8._`{failingKeyword: ${X.ifClause}}` }, HR = { keyword: "if", schemaType: ["object", "boolean"], trackErrors: true, error: GR, code(X) {
    let { gen: Q, parentSchema: $, it: Y } = X;
    if ($.then === void 0 && $.else === void 0) (0, aB.checkStrictMode)(Y, '"if" without "then" and "else" is ignored');
    let W = tB(Y, "then"), J = tB(Y, "else");
    if (!W && !J) return;
    let G = Q.let("valid", true), H = Q.name("_valid");
    if (B(), X.reset(), W && J) {
      let K = Q.let("ifClause");
      X.setParams({ ifClause: K }), Q.if(H, z("then", K), z("else", K));
    } else if (W) Q.if(H, z("then"));
    else Q.if((0, s8.not)(H), z("else"));
    X.pass(G, () => X.error(true));
    function B() {
      let K = X.subschema({ keyword: "if", compositeRule: true, createErrors: false, allErrors: false }, H);
      X.mergeEvaluated(K);
    }
    function z(K, V) {
      return () => {
        let L = X.subschema({ keyword: K }, H);
        if (Q.assign(G, H), X.mergeValidEvaluated(L, G), V) Q.assign(V, s8._`${K}`);
        else X.setParams({ ifClause: K });
      };
    }
  } };
  function tB(X, Q) {
    let $ = X.schema[Q];
    return $ !== void 0 && !(0, aB.alwaysValidSchema)(X, $);
  }
  sB.default = HR;
});
var Qz = P((Xz) => {
  Object.defineProperty(Xz, "__esModule", { value: true });
  var zR = e(), KR = { keyword: ["then", "else"], schemaType: ["object", "boolean"], code({ keyword: X, parentSchema: Q, it: $ }) {
    if (Q.if === void 0) (0, zR.checkStrictMode)($, `"${X}" without "if" is ignored`);
  } };
  Xz.default = KR;
});
var Yz = P(($z) => {
  Object.defineProperty($z, "__esModule", { value: true });
  var VR = yY(), LR = OB(), qR = gY(), FR = AB(), NR = jB(), OR = SB(), DR = kB(), wR = hY(), AR = yB(), MR = lB(), jR = cB(), RR = dB(), IR = nB(), ER = oB(), bR = eB(), PR = Qz();
  function SR(X = false) {
    let Q = [jR.default, RR.default, IR.default, ER.default, bR.default, PR.default, DR.default, wR.default, OR.default, AR.default, MR.default];
    if (X) Q.push(LR.default, FR.default);
    else Q.push(VR.default, qR.default);
    return Q.push(NR.default), Q;
  }
  $z.default = SR;
});
var Jz = P((Wz) => {
  Object.defineProperty(Wz, "__esModule", { value: true });
  var L0 = p(), CR = { message: ({ schemaCode: X }) => L0.str`must match format "${X}"`, params: ({ schemaCode: X }) => L0._`{format: ${X}}` }, kR = { keyword: "format", type: ["number", "string"], schemaType: "string", $data: true, error: CR, code(X, Q) {
    let { gen: $, data: Y, $data: W, schema: J, schemaCode: G, it: H } = X, { opts: B, errSchemaPath: z, schemaEnv: K, self: V } = H;
    if (!B.validateFormats) return;
    if (W) L();
    else U();
    function L() {
      let F = $.scopeValue("formats", { ref: V.formats, code: B.code.formats }), q = $.const("fDef", L0._`${F}[${G}]`), N = $.let("fType"), w = $.let("format");
      $.if(L0._`typeof ${q} == "object" && !(${q} instanceof RegExp)`, () => $.assign(N, L0._`${q}.type || "string"`).assign(w, L0._`${q}.validate`), () => $.assign(N, L0._`"string"`).assign(w, q)), X.fail$data((0, L0.or)(M(), R()));
      function M() {
        if (B.strictSchema === false) return L0.nil;
        return L0._`${G} && !${w}`;
      }
      function R() {
        let S = K.$async ? L0._`(${q}.async ? await ${w}(${Y}) : ${w}(${Y}))` : L0._`${w}(${Y})`, C = L0._`(typeof ${w} == "function" ? ${S} : ${w}.test(${Y}))`;
        return L0._`${w} && ${w} !== true && ${N} === ${Q} && !${C}`;
      }
    }
    function U() {
      let F = V.formats[J];
      if (!F) {
        M();
        return;
      }
      if (F === true) return;
      let [q, N, w] = R(F);
      if (q === Q) X.pass(S());
      function M() {
        if (B.strictSchema === false) {
          V.logger.warn(C());
          return;
        }
        throw Error(C());
        function C() {
          return `unknown format "${J}" ignored in schema at path "${z}"`;
        }
      }
      function R(C) {
        let K0 = C instanceof RegExp ? (0, L0.regexpCode)(C) : B.code.formats ? L0._`${B.code.formats}${(0, L0.getProperty)(J)}` : void 0, U0 = $.scopeValue("formats", { key: J, ref: C, code: K0 });
        if (typeof C == "object" && !(C instanceof RegExp)) return [C.type || "string", C.validate, L0._`${U0}.validate`];
        return ["string", C, U0];
      }
      function S() {
        if (typeof F == "object" && !(F instanceof RegExp) && F.async) {
          if (!K.$async) throw Error("async format in sync schema");
          return L0._`await ${w}(${Y})`;
        }
        return typeof N == "function" ? L0._`${w}(${Y})` : L0._`${w}.test(${Y})`;
      }
    }
  } };
  Wz.default = kR;
});
var Hz = P((Gz) => {
  Object.defineProperty(Gz, "__esModule", { value: true });
  var TR = Jz(), _R = [TR.default];
  Gz.default = _R;
});
var Kz = P((Bz) => {
  Object.defineProperty(Bz, "__esModule", { value: true });
  Bz.contentVocabulary = Bz.metadataVocabulary = void 0;
  Bz.metadataVocabulary = ["title", "description", "default", "deprecated", "readOnly", "writeOnly", "examples"];
  Bz.contentVocabulary = ["contentMediaType", "contentEncoding", "contentSchema"];
});
var Lz = P((Vz) => {
  Object.defineProperty(Vz, "__esModule", { value: true });
  var gR = xH(), fR = BB(), hR = Yz(), uR = Hz(), Uz = Kz(), lR = [gR.default, fR.default, (0, hR.default)(), uR.default, Uz.metadataVocabulary, Uz.contentVocabulary];
  Vz.default = lR;
});
var Oz = P((Fz) => {
  Object.defineProperty(Fz, "__esModule", { value: true });
  Fz.DiscrError = void 0;
  var qz;
  (function(X) {
    X.Tag = "tag", X.Mapping = "mapping";
  })(qz || (Fz.DiscrError = qz = {}));
});
var Az = P((wz) => {
  Object.defineProperty(wz, "__esModule", { value: true });
  var d6 = p(), lY = Oz(), Dz = _8(), cR = nX(), pR = e(), dR = { message: ({ params: { discrError: X, tagName: Q } }) => X === lY.DiscrError.Tag ? `tag "${Q}" must be string` : `value of tag "${Q}" must be in oneOf`, params: ({ params: { discrError: X, tag: Q, tagName: $ } }) => d6._`{error: ${X}, tag: ${$}, tagValue: ${Q}}` }, iR = { keyword: "discriminator", type: "object", schemaType: "object", error: dR, code(X) {
    let { gen: Q, data: $, schema: Y, parentSchema: W, it: J } = X, { oneOf: G } = W;
    if (!J.opts.discriminator) throw Error("discriminator: requires discriminator option");
    let H = Y.propertyName;
    if (typeof H != "string") throw Error("discriminator: requires propertyName");
    if (Y.mapping) throw Error("discriminator: mapping is not supported");
    if (!G) throw Error("discriminator: requires oneOf keyword");
    let B = Q.let("valid", false), z = Q.const("tag", d6._`${$}${(0, d6.getProperty)(H)}`);
    Q.if(d6._`typeof ${z} == "string"`, () => K(), () => X.error(false, { discrError: lY.DiscrError.Tag, tag: z, tagName: H })), X.ok(B);
    function K() {
      let U = L();
      Q.if(false);
      for (let F in U) Q.elseIf(d6._`${z} === ${F}`), Q.assign(B, V(U[F]));
      Q.else(), X.error(false, { discrError: lY.DiscrError.Mapping, tag: z, tagName: H }), Q.endIf();
    }
    function V(U) {
      let F = Q.name("valid"), q = X.subschema({ keyword: "oneOf", schemaProp: U }, F);
      return X.mergeEvaluated(q, d6.Name), F;
    }
    function L() {
      var U;
      let F = {}, q = w(W), N = true;
      for (let S = 0; S < G.length; S++) {
        let C = G[S];
        if ((C === null || C === void 0 ? void 0 : C.$ref) && !(0, pR.schemaHasRulesButRef)(C, J.self.RULES)) {
          let U0 = C.$ref;
          if (C = Dz.resolveRef.call(J.self, J.schemaEnv.root, J.baseId, U0), C instanceof Dz.SchemaEnv) C = C.schema;
          if (C === void 0) throw new cR.default(J.opts.uriResolver, J.baseId, U0);
        }
        let K0 = (U = C === null || C === void 0 ? void 0 : C.properties) === null || U === void 0 ? void 0 : U[H];
        if (typeof K0 != "object") throw Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${H}"`);
        N = N && (q || w(C)), M(K0, S);
      }
      if (!N) throw Error(`discriminator: "${H}" must be required`);
      return F;
      function w({ required: S }) {
        return Array.isArray(S) && S.includes(H);
      }
      function M(S, C) {
        if (S.const) R(S.const, C);
        else if (S.enum) for (let K0 of S.enum) R(K0, C);
        else throw Error(`discriminator: "properties/${H}" must have "const" or "enum"`);
      }
      function R(S, C) {
        if (typeof S != "string" || S in F) throw Error(`discriminator: "${H}" values must be unique strings`);
        F[S] = C;
      }
    }
  } };
  wz.default = iR;
});
var Mz = P((H_, rR) => {
  rR.exports = { $schema: "http://json-schema.org/draft-07/schema#", $id: "http://json-schema.org/draft-07/schema#", title: "Core schema meta-schema", definitions: { schemaArray: { type: "array", minItems: 1, items: { $ref: "#" } }, nonNegativeInteger: { type: "integer", minimum: 0 }, nonNegativeIntegerDefault0: { allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }] }, simpleTypes: { enum: ["array", "boolean", "integer", "null", "number", "object", "string"] }, stringArray: { type: "array", items: { type: "string" }, uniqueItems: true, default: [] } }, type: ["object", "boolean"], properties: { $id: { type: "string", format: "uri-reference" }, $schema: { type: "string", format: "uri" }, $ref: { type: "string", format: "uri-reference" }, $comment: { type: "string" }, title: { type: "string" }, description: { type: "string" }, default: true, readOnly: { type: "boolean", default: false }, examples: { type: "array", items: true }, multipleOf: { type: "number", exclusiveMinimum: 0 }, maximum: { type: "number" }, exclusiveMaximum: { type: "number" }, minimum: { type: "number" }, exclusiveMinimum: { type: "number" }, maxLength: { $ref: "#/definitions/nonNegativeInteger" }, minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, pattern: { type: "string", format: "regex" }, additionalItems: { $ref: "#" }, items: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }], default: true }, maxItems: { $ref: "#/definitions/nonNegativeInteger" }, minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, uniqueItems: { type: "boolean", default: false }, contains: { $ref: "#" }, maxProperties: { $ref: "#/definitions/nonNegativeInteger" }, minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" }, required: { $ref: "#/definitions/stringArray" }, additionalProperties: { $ref: "#" }, definitions: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, properties: { type: "object", additionalProperties: { $ref: "#" }, default: {} }, patternProperties: { type: "object", additionalProperties: { $ref: "#" }, propertyNames: { format: "regex" }, default: {} }, dependencies: { type: "object", additionalProperties: { anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }] } }, propertyNames: { $ref: "#" }, const: true, enum: { type: "array", items: true, minItems: 1, uniqueItems: true }, type: { anyOf: [{ $ref: "#/definitions/simpleTypes" }, { type: "array", items: { $ref: "#/definitions/simpleTypes" }, minItems: 1, uniqueItems: true }] }, format: { type: "string" }, contentMediaType: { type: "string" }, contentEncoding: { type: "string" }, if: { $ref: "#" }, then: { $ref: "#" }, else: { $ref: "#" }, allOf: { $ref: "#/definitions/schemaArray" }, anyOf: { $ref: "#/definitions/schemaArray" }, oneOf: { $ref: "#/definitions/schemaArray" }, not: { $ref: "#" } }, default: true };
});
var cY = P((f0, mY) => {
  Object.defineProperty(f0, "__esModule", { value: true });
  f0.MissingRefError = f0.ValidationError = f0.CodeGen = f0.Name = f0.nil = f0.stringify = f0.str = f0._ = f0.KeywordCxt = f0.Ajv = void 0;
  var oR = EH(), tR = Lz(), aR = Az(), jz = Mz(), sR = ["/properties"], e8 = "http://json-schema.org/draft-07/schema";
  class J4 extends oR.default {
    _addVocabularies() {
      if (super._addVocabularies(), tR.default.forEach((X) => this.addVocabulary(X)), this.opts.discriminator) this.addKeyword(aR.default);
    }
    _addDefaultMetaSchema() {
      if (super._addDefaultMetaSchema(), !this.opts.meta) return;
      let X = this.opts.$data ? this.$dataMetaSchema(jz, sR) : jz;
      this.addMetaSchema(X, e8, false), this.refs["http://json-schema.org/schema"] = e8;
    }
    defaultMeta() {
      return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(e8) ? e8 : void 0);
    }
  }
  f0.Ajv = J4;
  mY.exports = f0 = J4;
  mY.exports.Ajv = J4;
  Object.defineProperty(f0, "__esModule", { value: true });
  f0.default = J4;
  var eR = iX();
  Object.defineProperty(f0, "KeywordCxt", { enumerable: true, get: function() {
    return eR.KeywordCxt;
  } });
  var i6 = p();
  Object.defineProperty(f0, "_", { enumerable: true, get: function() {
    return i6._;
  } });
  Object.defineProperty(f0, "str", { enumerable: true, get: function() {
    return i6.str;
  } });
  Object.defineProperty(f0, "stringify", { enumerable: true, get: function() {
    return i6.stringify;
  } });
  Object.defineProperty(f0, "nil", { enumerable: true, get: function() {
    return i6.nil;
  } });
  Object.defineProperty(f0, "Name", { enumerable: true, get: function() {
    return i6.Name;
  } });
  Object.defineProperty(f0, "CodeGen", { enumerable: true, get: function() {
    return i6.CodeGen;
  } });
  var XI = v8();
  Object.defineProperty(f0, "ValidationError", { enumerable: true, get: function() {
    return XI.default;
  } });
  var QI = nX();
  Object.defineProperty(f0, "MissingRefError", { enumerable: true, get: function() {
    return QI.default;
  } });
});
var vz = P((Cz) => {
  Object.defineProperty(Cz, "__esModule", { value: true });
  Cz.formatNames = Cz.fastFormats = Cz.fullFormats = void 0;
  function V1(X, Q) {
    return { validate: X, compare: Q };
  }
  Cz.fullFormats = { date: V1(bz, nY), time: V1(dY(true), rY), "date-time": V1(Rz(true), Sz), "iso-time": V1(dY(), Pz), "iso-date-time": V1(Rz(), Zz), duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/, uri: zI, "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i, url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu, email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i, hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i, ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/, ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i, regex: NI, uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i, "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/, "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i, "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/, byte: KI, int32: { type: "number", validate: LI }, int64: { type: "number", validate: qI }, float: { type: "number", validate: Ez }, double: { type: "number", validate: Ez }, password: true, binary: true };
  Cz.fastFormats = { ...Cz.fullFormats, date: V1(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, nY), time: V1(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, rY), "date-time": V1(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, Sz), "iso-time": V1(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, Pz), "iso-date-time": V1(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, Zz), uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i, "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i, email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i };
  Cz.formatNames = Object.keys(Cz.fullFormats);
  function WI(X) {
    return X % 4 === 0 && (X % 100 !== 0 || X % 400 === 0);
  }
  var JI = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, GI = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function bz(X) {
    let Q = JI.exec(X);
    if (!Q) return false;
    let $ = +Q[1], Y = +Q[2], W = +Q[3];
    return Y >= 1 && Y <= 12 && W >= 1 && W <= (Y === 2 && WI($) ? 29 : GI[Y]);
  }
  function nY(X, Q) {
    if (!(X && Q)) return;
    if (X > Q) return 1;
    if (X < Q) return -1;
    return 0;
  }
  var pY = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
  function dY(X) {
    return function($) {
      let Y = pY.exec($);
      if (!Y) return false;
      let W = +Y[1], J = +Y[2], G = +Y[3], H = Y[4], B = Y[5] === "-" ? -1 : 1, z = +(Y[6] || 0), K = +(Y[7] || 0);
      if (z > 23 || K > 59 || X && !H) return false;
      if (W <= 23 && J <= 59 && G < 60) return true;
      let V = J - K * B, L = W - z * B - (V < 0 ? 1 : 0);
      return (L === 23 || L === -1) && (V === 59 || V === -1) && G < 61;
    };
  }
  function rY(X, Q) {
    if (!(X && Q)) return;
    let $ = (/* @__PURE__ */ new Date("2020-01-01T" + X)).valueOf(), Y = (/* @__PURE__ */ new Date("2020-01-01T" + Q)).valueOf();
    if (!($ && Y)) return;
    return $ - Y;
  }
  function Pz(X, Q) {
    if (!(X && Q)) return;
    let $ = pY.exec(X), Y = pY.exec(Q);
    if (!($ && Y)) return;
    if (X = $[1] + $[2] + $[3], Q = Y[1] + Y[2] + Y[3], X > Q) return 1;
    if (X < Q) return -1;
    return 0;
  }
  var iY = /t|\s/i;
  function Rz(X) {
    let Q = dY(X);
    return function(Y) {
      let W = Y.split(iY);
      return W.length === 2 && bz(W[0]) && Q(W[1]);
    };
  }
  function Sz(X, Q) {
    if (!(X && Q)) return;
    let $ = new Date(X).valueOf(), Y = new Date(Q).valueOf();
    if (!($ && Y)) return;
    return $ - Y;
  }
  function Zz(X, Q) {
    if (!(X && Q)) return;
    let [$, Y] = X.split(iY), [W, J] = Q.split(iY), G = nY($, W);
    if (G === void 0) return;
    return G || rY(Y, J);
  }
  var HI = /\/|:/, BI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  function zI(X) {
    return HI.test(X) && BI.test(X);
  }
  var Iz = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
  function KI(X) {
    return Iz.lastIndex = 0, Iz.test(X);
  }
  var UI = -2147483648, VI = 2147483647;
  function LI(X) {
    return Number.isInteger(X) && X <= VI && X >= UI;
  }
  function qI(X) {
    return Number.isInteger(X);
  }
  function Ez() {
    return true;
  }
  var FI = /[^\\]\\Z/;
  function NI(X) {
    if (FI.test(X)) return false;
    try {
      return new RegExp(X), true;
    } catch (Q) {
      return false;
    }
  }
});
var _z = P((Tz) => {
  Object.defineProperty(Tz, "__esModule", { value: true });
  Tz.formatLimitDefinition = void 0;
  var DI = cY(), Y1 = p(), n1 = Y1.operators, X9 = { formatMaximum: { okStr: "<=", ok: n1.LTE, fail: n1.GT }, formatMinimum: { okStr: ">=", ok: n1.GTE, fail: n1.LT }, formatExclusiveMaximum: { okStr: "<", ok: n1.LT, fail: n1.GTE }, formatExclusiveMinimum: { okStr: ">", ok: n1.GT, fail: n1.LTE } }, wI = { message: ({ keyword: X, schemaCode: Q }) => Y1.str`should be ${X9[X].okStr} ${Q}`, params: ({ keyword: X, schemaCode: Q }) => Y1._`{comparison: ${X9[X].okStr}, limit: ${Q}}` };
  Tz.formatLimitDefinition = { keyword: Object.keys(X9), type: "string", schemaType: "string", $data: true, error: wI, code(X) {
    let { gen: Q, data: $, schemaCode: Y, keyword: W, it: J } = X, { opts: G, self: H } = J;
    if (!G.validateFormats) return;
    let B = new DI.KeywordCxt(J, H.RULES.all.format.definition, "format");
    if (B.$data) z();
    else K();
    function z() {
      let L = Q.scopeValue("formats", { ref: H.formats, code: G.code.formats }), U = Q.const("fmt", Y1._`${L}[${B.schemaCode}]`);
      X.fail$data((0, Y1.or)(Y1._`typeof ${U} != "object"`, Y1._`${U} instanceof RegExp`, Y1._`typeof ${U}.compare != "function"`, V(U)));
    }
    function K() {
      let L = B.schema, U = H.formats[L];
      if (!U || U === true) return;
      if (typeof U != "object" || U instanceof RegExp || typeof U.compare != "function") throw Error(`"${W}": format "${L}" does not define "compare" function`);
      let F = Q.scopeValue("formats", { key: L, ref: U, code: G.code.formats ? Y1._`${G.code.formats}${(0, Y1.getProperty)(L)}` : void 0 });
      X.fail$data(V(F));
    }
    function V(L) {
      return Y1._`${L}.compare(${$}, ${Y}) ${X9[W].fail} 0`;
    }
  }, dependencies: ["format"] };
  var AI = (X) => {
    return X.addKeyword(Tz.formatLimitDefinition), X;
  };
  Tz.default = AI;
});
var fz = P((G4, gz) => {
  Object.defineProperty(G4, "__esModule", { value: true });
  var n6 = vz(), jI = _z(), aY = p(), xz = new aY.Name("fullFormats"), RI = new aY.Name("fastFormats"), sY = (X, Q = { keywords: true }) => {
    if (Array.isArray(Q)) return yz(X, Q, n6.fullFormats, xz), X;
    let [$, Y] = Q.mode === "fast" ? [n6.fastFormats, RI] : [n6.fullFormats, xz], W = Q.formats || n6.formatNames;
    if (yz(X, W, $, Y), Q.keywords) (0, jI.default)(X);
    return X;
  };
  sY.get = (X, Q = "full") => {
    let Y = (Q === "fast" ? n6.fastFormats : n6.fullFormats)[X];
    if (!Y) throw Error(`Unknown format "${X}"`);
    return Y;
  };
  function yz(X, Q, $, Y) {
    var W, J;
    (W = (J = X.opts.code).formats) !== null && W !== void 0 || (J.formats = aY._`require("ajv-formats/dist/formats").${Y}`);
    for (let G of Q) X.addFormat(G, $[G]);
  }
  gz.exports = G4 = sY;
  Object.defineProperty(G4, "__esModule", { value: true });
  G4.default = sY;
});
var VK = 50;
function F6(X = VK) {
  let Q = new AbortController();
  return (0, import_events.setMaxListeners)(X, Q.signal), Q;
}
var LK = typeof global == "object" && global && global.Object === Object && global;
var q7 = LK;
var qK = typeof self == "object" && self && self.Object === Object && self;
var FK = q7 || qK || Function("return this")();
var N6 = FK;
var NK = N6.Symbol;
var O6 = NK;
var F7 = Object.prototype;
var OK = F7.hasOwnProperty;
var DK = F7.toString;
var e6 = O6 ? O6.toStringTag : void 0;
function wK(X) {
  var Q = OK.call(X, e6), $ = X[e6];
  try {
    X[e6] = void 0;
    var Y = true;
  } catch (J) {
  }
  var W = DK.call(X);
  if (Y) if (Q) X[e6] = $;
  else delete X[e6];
  return W;
}
var N7 = wK;
var AK = Object.prototype;
var MK = AK.toString;
function jK(X) {
  return MK.call(X);
}
var O7 = jK;
var RK = "[object Null]";
var IK = "[object Undefined]";
var D7 = O6 ? O6.toStringTag : void 0;
function EK(X) {
  if (X == null) return X === void 0 ? IK : RK;
  return D7 && D7 in Object(X) ? N7(X) : O7(X);
}
var w7 = EK;
function bK(X) {
  var Q = typeof X;
  return X != null && (Q == "object" || Q == "function");
}
var z4 = bK;
var PK = "[object AsyncFunction]";
var SK = "[object Function]";
var ZK = "[object GeneratorFunction]";
var CK = "[object Proxy]";
function kK(X) {
  if (!z4(X)) return false;
  var Q = w7(X);
  return Q == SK || Q == ZK || Q == PK || Q == CK;
}
var A7 = kK;
var vK = N6["__core-js_shared__"];
var K4 = vK;
var M7 = (function() {
  var X = /[^.]+$/.exec(K4 && K4.keys && K4.keys.IE_PROTO || "");
  return X ? "Symbol(src)_1." + X : "";
})();
function TK(X) {
  return !!M7 && M7 in X;
}
var j7 = TK;
var _K = Function.prototype;
var xK = _K.toString;
function yK(X) {
  if (X != null) {
    try {
      return xK.call(X);
    } catch (Q) {
    }
    try {
      return X + "";
    } catch (Q) {
    }
  }
  return "";
}
var R7 = yK;
var gK = /[\\^$.*+?()[\]{}|]/g;
var fK = /^\[object .+?Constructor\]$/;
var hK = Function.prototype;
var uK = Object.prototype;
var lK = hK.toString;
var mK = uK.hasOwnProperty;
var cK = RegExp("^" + lK.call(mK).replace(gK, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function pK(X) {
  if (!z4(X) || j7(X)) return false;
  var Q = A7(X) ? cK : fK;
  return Q.test(R7(X));
}
var I7 = pK;
function dK(X, Q) {
  return X == null ? void 0 : X[Q];
}
var E7 = dK;
function iK(X, Q) {
  var $ = E7(X, Q);
  return I7($) ? $ : void 0;
}
var U4 = iK;
var nK = U4(Object, "create");
var q1 = nK;
function rK() {
  this.__data__ = q1 ? q1(null) : {}, this.size = 0;
}
var b7 = rK;
function oK(X) {
  var Q = this.has(X) && delete this.__data__[X];
  return this.size -= Q ? 1 : 0, Q;
}
var P7 = oK;
var tK = "__lodash_hash_undefined__";
var aK = Object.prototype;
var sK = aK.hasOwnProperty;
function eK(X) {
  var Q = this.__data__;
  if (q1) {
    var $ = Q[X];
    return $ === tK ? void 0 : $;
  }
  return sK.call(Q, X) ? Q[X] : void 0;
}
var S7 = eK;
var XU = Object.prototype;
var QU = XU.hasOwnProperty;
function $U(X) {
  var Q = this.__data__;
  return q1 ? Q[X] !== void 0 : QU.call(Q, X);
}
var Z7 = $U;
var YU = "__lodash_hash_undefined__";
function WU(X, Q) {
  var $ = this.__data__;
  return this.size += this.has(X) ? 0 : 1, $[X] = q1 && Q === void 0 ? YU : Q, this;
}
var C7 = WU;
function D6(X) {
  var Q = -1, $ = X == null ? 0 : X.length;
  this.clear();
  while (++Q < $) {
    var Y = X[Q];
    this.set(Y[0], Y[1]);
  }
}
D6.prototype.clear = b7;
D6.prototype.delete = P7;
D6.prototype.get = S7;
D6.prototype.has = Z7;
D6.prototype.set = C7;
var W9 = D6;
function JU() {
  this.__data__ = [], this.size = 0;
}
var k7 = JU;
function GU(X, Q) {
  return X === Q || X !== X && Q !== Q;
}
var v7 = GU;
function HU(X, Q) {
  var $ = X.length;
  while ($--) if (v7(X[$][0], Q)) return $;
  return -1;
}
var Z1 = HU;
var BU = Array.prototype;
var zU = BU.splice;
function KU(X) {
  var Q = this.__data__, $ = Z1(Q, X);
  if ($ < 0) return false;
  var Y = Q.length - 1;
  if ($ == Y) Q.pop();
  else zU.call(Q, $, 1);
  return --this.size, true;
}
var T7 = KU;
function UU(X) {
  var Q = this.__data__, $ = Z1(Q, X);
  return $ < 0 ? void 0 : Q[$][1];
}
var _7 = UU;
function VU(X) {
  return Z1(this.__data__, X) > -1;
}
var x7 = VU;
function LU(X, Q) {
  var $ = this.__data__, Y = Z1($, X);
  if (Y < 0) ++this.size, $.push([X, Q]);
  else $[Y][1] = Q;
  return this;
}
var y7 = LU;
function w6(X) {
  var Q = -1, $ = X == null ? 0 : X.length;
  this.clear();
  while (++Q < $) {
    var Y = X[Q];
    this.set(Y[0], Y[1]);
  }
}
w6.prototype.clear = k7;
w6.prototype.delete = T7;
w6.prototype.get = _7;
w6.prototype.has = x7;
w6.prototype.set = y7;
var g7 = w6;
var qU = U4(N6, "Map");
var f7 = qU;
function FU() {
  this.size = 0, this.__data__ = { hash: new W9(), map: new (f7 || g7)(), string: new W9() };
}
var h7 = FU;
function NU(X) {
  var Q = typeof X;
  return Q == "string" || Q == "number" || Q == "symbol" || Q == "boolean" ? X !== "__proto__" : X === null;
}
var u7 = NU;
function OU(X, Q) {
  var $ = X.__data__;
  return u7(Q) ? $[typeof Q == "string" ? "string" : "hash"] : $.map;
}
var C1 = OU;
function DU(X) {
  var Q = C1(this, X).delete(X);
  return this.size -= Q ? 1 : 0, Q;
}
var l7 = DU;
function wU(X) {
  return C1(this, X).get(X);
}
var m7 = wU;
function AU(X) {
  return C1(this, X).has(X);
}
var c7 = AU;
function MU(X, Q) {
  var $ = C1(this, X), Y = $.size;
  return $.set(X, Q), this.size += $.size == Y ? 0 : 1, this;
}
var p7 = MU;
function A6(X) {
  var Q = -1, $ = X == null ? 0 : X.length;
  this.clear();
  while (++Q < $) {
    var Y = X[Q];
    this.set(Y[0], Y[1]);
  }
}
A6.prototype.clear = h7;
A6.prototype.delete = l7;
A6.prototype.get = m7;
A6.prototype.has = c7;
A6.prototype.set = p7;
var J9 = A6;
var jU = "Expected a function";
function G9(X, Q) {
  if (typeof X != "function" || Q != null && typeof Q != "function") throw TypeError(jU);
  var $ = function() {
    var Y = arguments, W = Q ? Q.apply(this, Y) : Y[0], J = $.cache;
    if (J.has(W)) return J.get(W);
    var G = X.apply(this, Y);
    return $.cache = J.set(W, G) || J, G;
  };
  return $.cache = new (G9.Cache || J9)(), $;
}
G9.Cache = J9;
var k1 = G9;
function RU(X, Q) {
  if (X.destroyed) return;
  X.write(Q);
}
function d7(X) {
  RU(process.stderr, X);
}
var i7 = k1((X) => {
  if (!X || X.trim() === "") return null;
  let Q = X.split(",").map((J) => J.trim()).filter(Boolean);
  if (Q.length === 0) return null;
  let $ = Q.some((J) => J.startsWith("!")), Y = Q.some((J) => !J.startsWith("!"));
  if ($ && Y) return null;
  let W = Q.map((J) => J.replace(/^!/, "").toLowerCase());
  return { include: $ ? [] : W, exclude: $ ? W : [], isExclusive: $ };
});
function IU(X) {
  let Q = [], $ = X.match(/^MCP server ["']([^"']+)["']/);
  if ($ && $[1]) Q.push("mcp"), Q.push($[1].toLowerCase());
  else {
    let J = X.match(/^([^:[]+):/);
    if (J && J[1]) Q.push(J[1].trim().toLowerCase());
  }
  let Y = X.match(/^\[([^\]]+)]/);
  if (Y && Y[1]) Q.push(Y[1].trim().toLowerCase());
  if (X.toLowerCase().includes("1p event:")) Q.push("1p");
  let W = X.match(/:\s*([^:]+?)(?:\s+(?:type|mode|status|event))?:/);
  if (W && W[1]) {
    let J = W[1].trim().toLowerCase();
    if (J.length < 30 && !J.includes(" ")) Q.push(J);
  }
  return Array.from(new Set(Q));
}
function EU(X, Q) {
  if (!Q) return true;
  if (X.length === 0) return false;
  if (Q.isExclusive) return !X.some(($) => Q.exclude.includes($));
  else return X.some(($) => Q.include.includes($));
}
function n7(X, Q) {
  if (!Q) return true;
  let $ = IU(X);
  return EU($, Q);
}
function V4() {
  var _a5;
  return (_a5 = process.env.CLAUDE_CONFIG_DIR) != null ? _a5 : (0, import_path41.join)((0, import_os.homedir)(), ".claude");
}
function H9(X) {
  if (!X) return false;
  if (typeof X === "boolean") return X;
  let Q = X.toLowerCase().trim();
  return ["1", "true", "yes", "on"].includes(Q);
}
function r7(X) {
  return { name: X, default: 3e4, validate: (Q) => {
    if (!Q) return { effective: 3e4, status: "valid" };
    let $ = parseInt(Q, 10);
    if (isNaN($) || $ <= 0) return { effective: 3e4, status: "invalid", message: `Invalid value "${Q}" (using default: 30000)` };
    if ($ > 15e4) return { effective: 15e4, status: "capped", message: `Capped from ${$} to 150000` };
    return { effective: $, status: "valid" };
  } };
}
var o7 = r7("BASH_MAX_OUTPUT_LENGTH");
var Pb = r7("TASK_MAX_OUTPUT_LENGTH");
var t7 = { name: "CLAUDE_CODE_MAX_OUTPUT_TOKENS", default: 32e3, validate: (X) => {
  if (!X) return { effective: 32e3, status: "valid" };
  let Y = parseInt(X, 10);
  if (isNaN(Y) || Y <= 0) return { effective: 32e3, status: "invalid", message: `Invalid value "${X}" (using default: 32000)` };
  if (Y > 64e3) return { effective: 64e3, status: "capped", message: `Capped from ${Y} to 64000` };
  return { effective: Y, status: "valid" };
} };
function CU() {
  let X = "";
  if (typeof process < "u" && typeof process.cwd === "function" && typeof import_fs.realpathSync === "function") X = (0, import_fs.realpathSync)((0, import_process.cwd)());
  return { originalCwd: X, projectRoot: X, totalCostUSD: 0, totalAPIDuration: 0, totalAPIDurationWithoutRetries: 0, totalToolDuration: 0, startTime: Date.now(), lastInteractionTime: Date.now(), totalLinesAdded: 0, totalLinesRemoved: 0, hasUnknownModelCost: false, cwd: X, modelUsage: {}, mainLoopModelOverride: void 0, initialMainLoopModel: null, modelStrings: null, isInteractive: false, clientType: "cli", sessionIngressToken: void 0, oauthTokenFromFd: void 0, apiKeyFromFd: void 0, flagSettingsPath: void 0, allowedSettingSources: ["userSettings", "projectSettings", "localSettings", "flagSettings", "policySettings"], meter: null, sessionCounter: null, locCounter: null, prCounter: null, commitCounter: null, costCounter: null, tokenCounter: null, codeEditToolDecisionCounter: null, activeTimeCounter: null, sessionId: (0, import_crypto.randomUUID)(), parentSessionId: void 0, loggerProvider: null, eventLogger: null, meterProvider: null, tracerProvider: null, agentColorMap: /* @__PURE__ */ new Map(), agentColorIndex: 0, envVarValidators: [o7, t7], lastAPIRequest: null, inMemoryErrorLog: [], inlinePlugins: [], useCoworkPlugins: false, sessionBypassPermissionsMode: false, sessionTrustAccepted: false, sessionPersistenceDisabled: false, hasExitedPlanMode: false, needsPlanModeExitAttachment: false, hasExitedDelegateMode: false, needsDelegateModeExitAttachment: false, lspRecommendationShownThisSession: false, initJsonSchema: null, registeredHooks: null, planSlugCache: /* @__PURE__ */ new Map(), teleportedSessionInfo: null, invokedSkills: /* @__PURE__ */ new Map(), slowOperations: [], promptCacheBreaks: [], sdkBetas: void 0, mainThreadAgentType: void 0, isRemoteMode: false, directConnectServerUrl: void 0, systemPromptSectionCache: /* @__PURE__ */ new Map(), additionalDirectoriesForClaudeMd: [], resumedTranscriptPath: null };
}
var kU = CU();
function s7() {
  return kU.sessionId;
}
function e7({ writeFn: X, flushIntervalMs: Q = 1e3, maxBufferSize: $ = 100, immediateMode: Y = false }) {
  let W = [], J = null;
  function G() {
    if (J) clearTimeout(J), J = null;
  }
  function H() {
    if (W.length === 0) return;
    X(W.join("")), W = [], G();
  }
  function B() {
    if (!J) J = setTimeout(H, Q);
  }
  return { write(z) {
    if (Y) {
      X(z);
      return;
    }
    if (W.push(z), B(), W.length >= $) H();
  }, flush: H, dispose() {
    H();
  } };
}
var XW = /* @__PURE__ */ new Set();
function QW(X) {
  return XW.add(X), () => XW.delete(X);
}
var B9 = 1 / 0;
function vU(X) {
  if (X === null) return "null";
  if (X === void 0) return "undefined";
  if (Array.isArray(X)) return `Array[${X.length}]`;
  if (typeof X === "object") return `Object{${Object.keys(X).length} keys}`;
  if (typeof X === "string") return `string(${X.length} chars)`;
  return typeof X;
}
function $W(X, Q) {
  let $ = performance.now();
  try {
    return Q();
  } finally {
    performance.now() - $ > B9;
  }
}
function Z0(X, Q, $) {
  let Y = vU(X);
  return $W(`JSON.stringify(${Y})`, () => JSON.stringify(X, Q, $));
}
var L4 = (X, Q) => {
  let $ = typeof X === "string" ? X.length : 0;
  return $W(`JSON.parse(${$} chars)`, () => JSON.parse(X, Q));
};
var TU = k1(() => {
  return H9(process.env.DEBUG) || H9(process.env.DEBUG_SDK) || process.argv.includes("--debug") || process.argv.includes("-d") || WW() || process.argv.some((X) => X.startsWith("--debug=")) || JW() !== null;
});
var _U = k1(() => {
  let X = process.argv.find(($) => $.startsWith("--debug="));
  if (!X) return null;
  let Q = X.substring(8);
  return i7(Q);
});
var WW = k1(() => {
  return process.argv.includes("--debug-to-stderr") || process.argv.includes("-d2e");
});
var JW = k1(() => {
  for (let X = 0; X < process.argv.length; X++) {
    let Q = process.argv[X];
    if (Q.startsWith("--debug-file=")) return Q.substring(13);
    if (Q === "--debug-file" && X + 1 < process.argv.length) return process.argv[X + 1];
  }
  return null;
});
function xU(X) {
  if (typeof process > "u" || typeof process.versions > "u" || typeof process.versions.node > "u") return false;
  let Q = _U();
  return n7(X, Q);
}
var yU = false;
var q4 = null;
function gU() {
  if (!q4) q4 = e7({ writeFn: (X) => {
    let Q = GW();
    if (!n0().existsSync((0, import_path42.dirname)(Q))) n0().mkdirSync((0, import_path42.dirname)(Q));
    n0().appendFileSync(Q, X), fU();
  }, flushIntervalMs: 1e3, maxBufferSize: 100, immediateMode: TU() }), QW(async () => q4 == null ? void 0 : q4.dispose());
  return q4;
}
function v1(X, { level: Q } = { level: "debug" }) {
  if (!xU(X)) return;
  if (yU && X.includes(`
`)) X = Z0(X);
  let Y = `${(/* @__PURE__ */ new Date()).toISOString()} [${Q.toUpperCase()}] ${X.trim()}
`;
  if (WW()) {
    d7(Y);
    return;
  }
  gU().write(Y);
}
function GW() {
  var _a5, _b;
  return (_b = (_a5 = JW()) != null ? _a5 : process.env.CLAUDE_CODE_DEBUG_LOGS_DIR) != null ? _b : (0, import_path42.join)(V4(), "debug", `${s7()}.txt`);
}
var fU = k1(() => {
  if (process.argv[2] === "--ripgrep") return;
  try {
    let X = GW(), Q = (0, import_path42.dirname)(X), $ = (0, import_path42.join)(Q, "latest");
    if (!n0().existsSync(Q)) n0().mkdirSync(Q);
    if (n0().existsSync($)) try {
      n0().unlinkSync($);
    } catch (e3) {
    }
    n0().symlinkSync(X, $);
  } catch (e3) {
  }
});
function F0(X, Q) {
  let $ = performance.now();
  try {
    return Q();
  } finally {
    performance.now() - $ > B9;
  }
}
var dU = { cwd() {
  return process.cwd();
}, existsSync(X) {
  return F0(`existsSync(${X})`, () => h.existsSync(X));
}, async stat(X) {
  return (0, import_promises.stat)(X);
}, async readdir(X) {
  return (0, import_promises.readdir)(X, { withFileTypes: true });
}, async unlink(X) {
  return (0, import_promises.unlink)(X);
}, async rmdir(X) {
  return (0, import_promises.rmdir)(X);
}, async rm(X, Q) {
  return (0, import_promises.rm)(X, Q);
}, statSync(X) {
  return F0(`statSync(${X})`, () => h.statSync(X));
}, lstatSync(X) {
  return F0(`lstatSync(${X})`, () => h.lstatSync(X));
}, readFileSync(X, Q) {
  return F0(`readFileSync(${X})`, () => h.readFileSync(X, { encoding: Q.encoding }));
}, readFileBytesSync(X) {
  return F0(`readFileBytesSync(${X})`, () => h.readFileSync(X));
}, readSync(X, Q) {
  return F0(`readSync(${X}, ${Q.length} bytes)`, () => {
    let $ = void 0;
    try {
      $ = h.openSync(X, "r");
      let Y = Buffer.alloc(Q.length), W = h.readSync($, Y, 0, Q.length, 0);
      return { buffer: Y, bytesRead: W };
    } finally {
      if ($) h.closeSync($);
    }
  });
}, appendFileSync(X, Q, $) {
  return F0(`appendFileSync(${X}, ${Q.length} chars)`, () => {
    if (!h.existsSync(X) && ($ == null ? void 0 : $.mode) !== void 0) {
      let Y = h.openSync(X, "a", $.mode);
      try {
        h.appendFileSync(Y, Q);
      } finally {
        h.closeSync(Y);
      }
    } else h.appendFileSync(X, Q);
  });
}, copyFileSync(X, Q) {
  return F0(`copyFileSync(${X} \u2192 ${Q})`, () => h.copyFileSync(X, Q));
}, unlinkSync(X) {
  return F0(`unlinkSync(${X})`, () => h.unlinkSync(X));
}, renameSync(X, Q) {
  return F0(`renameSync(${X} \u2192 ${Q})`, () => h.renameSync(X, Q));
}, linkSync(X, Q) {
  return F0(`linkSync(${X} \u2192 ${Q})`, () => h.linkSync(X, Q));
}, symlinkSync(X, Q) {
  return F0(`symlinkSync(${X} \u2192 ${Q})`, () => h.symlinkSync(X, Q));
}, readlinkSync(X) {
  return F0(`readlinkSync(${X})`, () => h.readlinkSync(X));
}, realpathSync(X) {
  return F0(`realpathSync(${X})`, () => h.realpathSync(X));
}, mkdirSync(X, Q) {
  return F0(`mkdirSync(${X})`, () => {
    if (!h.existsSync(X)) {
      let $ = { recursive: true };
      if ((Q == null ? void 0 : Q.mode) !== void 0) $.mode = Q.mode;
      h.mkdirSync(X, $);
    }
  });
}, readdirSync(X) {
  return F0(`readdirSync(${X})`, () => h.readdirSync(X, { withFileTypes: true }));
}, readdirStringSync(X) {
  return F0(`readdirStringSync(${X})`, () => h.readdirSync(X));
}, isDirEmptySync(X) {
  return F0(`isDirEmptySync(${X})`, () => {
    return this.readdirSync(X).length === 0;
  });
}, rmdirSync(X) {
  return F0(`rmdirSync(${X})`, () => h.rmdirSync(X));
}, rmSync(X, Q) {
  return F0(`rmSync(${X})`, () => h.rmSync(X, Q));
}, createWriteStream(X) {
  return h.createWriteStream(X);
} };
var iU = dU;
function n0() {
  return iU;
}
var F1 = class extends Error {
};
function M6() {
  return process.versions.bun !== void 0;
}
var F4 = null;
var BW = false;
function eU() {
  if (BW) return F4;
  if (BW = true, !process.env.DEBUG_CLAUDE_AGENT_SDK) return null;
  let X = (0, import_path43.join)(V4(), "debug");
  if (F4 = (0, import_path43.join)(X, `sdk-${(0, import_crypto2.randomUUID)()}.txt`), !(0, import_fs2.existsSync)(X)) (0, import_fs2.mkdirSync)(X, { recursive: true });
  return process.stderr.write(`SDK debug logs: ${F4}
`), F4;
}
function N1(X) {
  let Q = eU();
  if (!Q) return;
  let Y = `${(/* @__PURE__ */ new Date()).toISOString()} ${X}
`;
  (0, import_fs2.appendFileSync)(Q, Y);
}
function zW(X, Q) {
  let $ = { ...X };
  if (Q) {
    let Y = { sandbox: Q };
    if ($.settings) try {
      Y = { ...L4($.settings), sandbox: Q };
    } catch (e3) {
    }
    $.settings = Z0(Y);
  }
  return $;
}
var XX = class {
  constructor(X) {
    __publicField(this, "options");
    __publicField(this, "process");
    __publicField(this, "processStdin");
    __publicField(this, "processStdout");
    __publicField(this, "ready", false);
    __publicField(this, "abortController");
    __publicField(this, "exitError");
    __publicField(this, "exitListeners", []);
    __publicField(this, "processExitHandler");
    __publicField(this, "abortHandler");
    this.options = X;
    this.abortController = X.abortController || F6(), this.initialize();
  }
  getDefaultExecutable() {
    return M6() ? "bun" : "node";
  }
  spawnLocalProcess(X) {
    let { command: Q, args: $, cwd: Y, env: W, signal: J } = X, G = W.DEBUG_CLAUDE_AGENT_SDK || this.options.stderr ? "pipe" : "ignore", H = (0, import_child_process.spawn)(Q, $, { cwd: Y, stdio: ["pipe", "pipe", G], signal: J, env: W, windowsHide: true });
    if (W.DEBUG_CLAUDE_AGENT_SDK || this.options.stderr) H.stderr.on("data", (z) => {
      let K = z.toString();
      if (N1(K), this.options.stderr) this.options.stderr(K);
    });
    return { stdin: H.stdin, stdout: H.stdout, get killed() {
      return H.killed;
    }, get exitCode() {
      return H.exitCode;
    }, kill: H.kill.bind(H), on: H.on.bind(H), once: H.once.bind(H), off: H.off.bind(H) };
  }
  initialize() {
    try {
      let { additionalDirectories: X = [], agent: Q, betas: $, cwd: Y, executable: W = this.getDefaultExecutable(), executableArgs: J = [], extraArgs: G = {}, pathToClaudeCodeExecutable: H, env: B = { ...process.env }, maxThinkingTokens: z, maxTurns: K, maxBudgetUsd: V, model: L, fallbackModel: U, jsonSchema: F, permissionMode: q, allowDangerouslySkipPermissions: N, permissionPromptToolName: w, continueConversation: M, resume: R, settingSources: S, allowedTools: C = [], disallowedTools: K0 = [], tools: U0, mcpServers: s, strictMcpConfig: D0, canUseTool: q0, includePartialMessages: L1, plugins: P1, sandbox: o1 } = this.options, c = ["--output-format", "stream-json", "--verbose", "--input-format", "stream-json"];
      if (z !== void 0) c.push("--max-thinking-tokens", z.toString());
      if (K) c.push("--max-turns", K.toString());
      if (V !== void 0) c.push("--max-budget-usd", V.toString());
      if (L) c.push("--model", L);
      if (Q) c.push("--agent", Q);
      if ($ && $.length > 0) c.push("--betas", $.join(","));
      if (F) c.push("--json-schema", Z0(F));
      if (this.options.debugFile) c.push("--debug-file", this.options.debugFile);
      else if (this.options.debug) c.push("--debug");
      if (B.DEBUG_CLAUDE_AGENT_SDK) c.push("--debug-to-stderr");
      if (q0) {
        if (w) throw Error("canUseTool callback cannot be used with permissionPromptToolName. Please use one or the other.");
        c.push("--permission-prompt-tool", "stdio");
      } else if (w) c.push("--permission-prompt-tool", w);
      if (M) c.push("--continue");
      if (R) c.push("--resume", R);
      if (C.length > 0) c.push("--allowedTools", C.join(","));
      if (K0.length > 0) c.push("--disallowedTools", K0.join(","));
      if (U0 !== void 0) if (Array.isArray(U0)) if (U0.length === 0) c.push("--tools", "");
      else c.push("--tools", U0.join(","));
      else c.push("--tools", "default");
      if (s && Object.keys(s).length > 0) c.push("--mcp-config", Z0({ mcpServers: s }));
      if (S) c.push("--setting-sources", S.join(","));
      if (D0) c.push("--strict-mcp-config");
      if (q) c.push("--permission-mode", q);
      if (N) c.push("--allow-dangerously-skip-permissions");
      if (U) {
        if (L && U === L) throw Error("Fallback model cannot be the same as the main model. Please specify a different model for fallbackModel option.");
        c.push("--fallback-model", U);
      }
      if (L1) c.push("--include-partial-messages");
      for (let E0 of X) c.push("--add-dir", E0);
      if (P1 && P1.length > 0) for (let E0 of P1) if (E0.type === "local") c.push("--plugin-dir", E0.path);
      else throw Error(`Unsupported plugin type: ${E0.type}`);
      if (this.options.forkSession) c.push("--fork-session");
      if (this.options.resumeSessionAt) c.push("--resume-session-at", this.options.resumeSessionAt);
      if (this.options.sessionId) c.push("--session-id", this.options.sessionId);
      if (this.options.persistSession === false) c.push("--no-session-persistence");
      let Q9 = zW(G != null ? G : {}, o1);
      for (let [E0, S1] of Object.entries(Q9)) if (S1 === null) c.push(`--${E0}`);
      else c.push(`--${E0}`, S1);
      if (!B.CLAUDE_CODE_ENTRYPOINT) B.CLAUDE_CODE_ENTRYPOINT = "sdk-ts";
      if (delete B.NODE_OPTIONS, B.DEBUG_CLAUDE_AGENT_SDK) B.DEBUG = "1";
      else delete B.DEBUG;
      let r6 = $V(H), o6 = r6 ? H : W, t6 = r6 ? [...J, ...c] : [...J, H, ...c], a6 = { command: o6, args: t6, cwd: Y, env: B, signal: this.abortController.signal };
      if (this.options.spawnClaudeCodeProcess) N1(`Spawning Claude Code (custom): ${o6} ${t6.join(" ")}`), this.process = this.options.spawnClaudeCodeProcess(a6);
      else {
        if (!n0().existsSync(H)) {
          let S1 = r6 ? `Claude Code native binary not found at ${H}. Please ensure Claude Code is installed via native installer or specify a valid path with options.pathToClaudeCodeExecutable.` : `Claude Code executable not found at ${H}. Is options.pathToClaudeCodeExecutable set?`;
          throw ReferenceError(S1);
        }
        N1(`Spawning Claude Code: ${o6} ${t6.join(" ")}`), this.process = this.spawnLocalProcess(a6);
      }
      this.processStdin = this.process.stdin, this.processStdout = this.process.stdout;
      let B4 = () => {
        if (this.process && !this.process.killed) this.process.kill("SIGTERM");
      };
      this.processExitHandler = B4, this.abortHandler = B4, process.on("exit", this.processExitHandler), this.abortController.signal.addEventListener("abort", this.abortHandler), this.process.on("error", (E0) => {
        if (this.ready = false, this.abortController.signal.aborted) this.exitError = new F1("Claude Code process aborted by user");
        else this.exitError = Error(`Failed to spawn Claude Code process: ${E0.message}`), N1(this.exitError.message);
      }), this.process.on("exit", (E0, S1) => {
        if (this.ready = false, this.abortController.signal.aborted) this.exitError = new F1("Claude Code process aborted by user");
        else {
          let s6 = this.getProcessExitError(E0, S1);
          if (s6) this.exitError = s6, N1(s6.message);
        }
      }), this.ready = true;
    } catch (X) {
      throw this.ready = false, X;
    }
  }
  getProcessExitError(X, Q) {
    if (X !== 0 && X !== null) return Error(`Claude Code process exited with code ${X}`);
    else if (Q) return Error(`Claude Code process terminated by signal ${Q}`);
    return;
  }
  write(X) {
    var _a5, _b;
    if (this.abortController.signal.aborted) throw new F1("Operation aborted");
    if (!this.ready || !this.processStdin) throw Error("ProcessTransport is not ready for writing");
    if (((_a5 = this.process) == null ? void 0 : _a5.killed) || ((_b = this.process) == null ? void 0 : _b.exitCode) !== null) throw Error("Cannot write to terminated process");
    if (this.exitError) throw Error(`Cannot write to process that exited with error: ${this.exitError.message}`);
    N1(`[ProcessTransport] Writing to stdin: ${X.substring(0, 100)}`);
    try {
      if (!this.processStdin.write(X)) N1("[ProcessTransport] Write buffer full, data queued");
    } catch (Q) {
      throw this.ready = false, Error(`Failed to write to process stdin: ${Q.message}`);
    }
  }
  close() {
    var _a5;
    if (this.processStdin) this.processStdin.end(), this.processStdin = void 0;
    if (this.abortHandler) this.abortController.signal.removeEventListener("abort", this.abortHandler), this.abortHandler = void 0;
    for (let { handler: X } of this.exitListeners) (_a5 = this.process) == null ? void 0 : _a5.off("exit", X);
    if (this.exitListeners = [], this.process && !this.process.killed) this.process.kill("SIGTERM"), setTimeout(() => {
      if (this.process && !this.process.killed) this.process.kill("SIGKILL");
    }, 5e3);
    if (this.ready = false, this.processExitHandler) process.off("exit", this.processExitHandler), this.processExitHandler = void 0;
  }
  isReady() {
    return this.ready;
  }
  async *readMessages() {
    if (!this.processStdout) throw Error("ProcessTransport output stream not available");
    let X = (0, import_readline.createInterface)({ input: this.processStdout });
    try {
      for await (let Q of X) if (Q.trim()) try {
        yield L4(Q);
      } catch ($) {
        throw N1(`Non-JSON stdout: ${Q}`), Error(`CLI output was not valid JSON. This may indicate an error during startup. Output: ${Q.slice(0, 200)}${Q.length > 200 ? "..." : ""}`);
      }
      await this.waitForExit();
    } catch (Q) {
      throw Q;
    } finally {
      X.close();
    }
  }
  endInput() {
    if (this.processStdin) this.processStdin.end();
  }
  getInputStream() {
    return this.processStdin;
  }
  onExit(X) {
    if (!this.process) return () => {
    };
    let Q = ($, Y) => {
      let W = this.getProcessExitError($, Y);
      X(W);
    };
    return this.process.on("exit", Q), this.exitListeners.push({ callback: X, handler: Q }), () => {
      if (this.process) this.process.off("exit", Q);
      let $ = this.exitListeners.findIndex((Y) => Y.handler === Q);
      if ($ !== -1) this.exitListeners.splice($, 1);
    };
  }
  async waitForExit() {
    if (!this.process) {
      if (this.exitError) throw this.exitError;
      return;
    }
    if (this.process.exitCode !== null || this.process.killed) {
      if (this.exitError) throw this.exitError;
      return;
    }
    return new Promise((X, Q) => {
      let $ = (W, J) => {
        if (this.abortController.signal.aborted) {
          Q(new F1("Operation aborted"));
          return;
        }
        let G = this.getProcessExitError(W, J);
        if (G) Q(G);
        else X();
      };
      this.process.once("exit", $);
      let Y = (W) => {
        this.process.off("exit", $), Q(W);
      };
      this.process.once("error", Y), this.process.once("exit", () => {
        this.process.off("error", Y);
      });
    });
  }
};
function $V(X) {
  return ![".js", ".mjs", ".tsx", ".ts", ".jsx"].some(($) => X.endsWith($));
}
var QX = class {
  constructor(X) {
    __publicField(this, "returned");
    __publicField(this, "queue", []);
    __publicField(this, "readResolve");
    __publicField(this, "readReject");
    __publicField(this, "isDone", false);
    __publicField(this, "hasError");
    __publicField(this, "started", false);
    this.returned = X;
  }
  [Symbol.asyncIterator]() {
    if (this.started) throw Error("Stream can only be iterated once");
    return this.started = true, this;
  }
  next() {
    if (this.queue.length > 0) return Promise.resolve({ done: false, value: this.queue.shift() });
    if (this.isDone) return Promise.resolve({ done: true, value: void 0 });
    if (this.hasError) return Promise.reject(this.hasError);
    return new Promise((X, Q) => {
      this.readResolve = X, this.readReject = Q;
    });
  }
  enqueue(X) {
    if (this.readResolve) {
      let Q = this.readResolve;
      this.readResolve = void 0, this.readReject = void 0, Q({ done: false, value: X });
    } else this.queue.push(X);
  }
  done() {
    if (this.isDone = true, this.readResolve) {
      let X = this.readResolve;
      this.readResolve = void 0, this.readReject = void 0, X({ done: true, value: void 0 });
    }
  }
  error(X) {
    if (this.hasError = X, this.readReject) {
      let Q = this.readReject;
      this.readResolve = void 0, this.readReject = void 0, Q(X);
    }
  }
  return() {
    if (this.isDone = true, this.returned) this.returned();
    return Promise.resolve({ done: true, value: void 0 });
  }
};
var K9 = class {
  constructor(X) {
    __publicField(this, "sendMcpMessage");
    __publicField(this, "isClosed", false);
    __publicField(this, "onclose");
    __publicField(this, "onerror");
    __publicField(this, "onmessage");
    this.sendMcpMessage = X;
  }
  async start() {
  }
  async send(X) {
    if (this.isClosed) throw Error("Transport is closed");
    this.sendMcpMessage(X);
  }
  async close() {
    var _a5;
    if (this.isClosed) return;
    this.isClosed = true, (_a5 = this.onclose) == null ? void 0 : _a5.call(this);
  }
};
var $X = class {
  constructor(X, Q, $, Y, W, J = /* @__PURE__ */ new Map(), G, H) {
    __publicField(this, "transport");
    __publicField(this, "isSingleUserTurn");
    __publicField(this, "canUseTool");
    __publicField(this, "hooks");
    __publicField(this, "abortController");
    __publicField(this, "jsonSchema");
    __publicField(this, "initConfig");
    __publicField(this, "pendingControlResponses", /* @__PURE__ */ new Map());
    __publicField(this, "cleanupPerformed", false);
    __publicField(this, "sdkMessages");
    __publicField(this, "inputStream", new QX());
    __publicField(this, "initialization");
    __publicField(this, "cancelControllers", /* @__PURE__ */ new Map());
    __publicField(this, "hookCallbacks", /* @__PURE__ */ new Map());
    __publicField(this, "nextCallbackId", 0);
    __publicField(this, "sdkMcpTransports", /* @__PURE__ */ new Map());
    __publicField(this, "sdkMcpServerInstances", /* @__PURE__ */ new Map());
    __publicField(this, "pendingMcpResponses", /* @__PURE__ */ new Map());
    __publicField(this, "firstResultReceivedResolve");
    __publicField(this, "firstResultReceived", false);
    this.transport = X;
    this.isSingleUserTurn = Q;
    this.canUseTool = $;
    this.hooks = Y;
    this.abortController = W;
    this.jsonSchema = G;
    this.initConfig = H;
    for (let [B, z] of J) this.connectSdkMcpServer(B, z);
    this.sdkMessages = this.readSdkMessages(), this.readMessages(), this.initialization = this.initialize(), this.initialization.catch(() => {
    });
  }
  hasBidirectionalNeeds() {
    return this.sdkMcpTransports.size > 0 || this.hooks !== void 0 && Object.keys(this.hooks).length > 0 || this.canUseTool !== void 0;
  }
  setError(X) {
    this.inputStream.error(X);
  }
  close() {
    this.cleanup();
  }
  cleanup(X) {
    if (this.cleanupPerformed) return;
    this.cleanupPerformed = true;
    try {
      this.transport.close(), this.pendingControlResponses.clear(), this.pendingMcpResponses.clear(), this.cancelControllers.clear(), this.hookCallbacks.clear();
      for (let Q of this.sdkMcpTransports.values()) try {
        Q.close();
      } catch (e3) {
      }
      if (this.sdkMcpTransports.clear(), X) this.inputStream.error(X);
      else this.inputStream.done();
    } catch (Q) {
    }
  }
  next(...[X]) {
    return this.sdkMessages.next(...[X]);
  }
  return(X) {
    return this.sdkMessages.return(X);
  }
  throw(X) {
    return this.sdkMessages.throw(X);
  }
  [Symbol.asyncIterator]() {
    return this.sdkMessages;
  }
  [Symbol.asyncDispose]() {
    return this.sdkMessages[Symbol.asyncDispose]();
  }
  async readMessages() {
    try {
      for await (let X of this.transport.readMessages()) {
        if (X.type === "control_response") {
          let Q = this.pendingControlResponses.get(X.response.request_id);
          if (Q) Q(X.response);
          continue;
        } else if (X.type === "control_request") {
          this.handleControlRequest(X);
          continue;
        } else if (X.type === "control_cancel_request") {
          this.handleControlCancelRequest(X);
          continue;
        } else if (X.type === "keep_alive") continue;
        if (X.type === "streamlined_text" || X.type === "streamlined_tool_use_summary") continue;
        if (X.type === "result") {
          if (this.firstResultReceived = true, this.firstResultReceivedResolve) this.firstResultReceivedResolve();
          if (this.isSingleUserTurn) v1("[Query.readMessages] First result received for single-turn query, closing stdin"), this.transport.endInput();
        }
        this.inputStream.enqueue(X);
      }
      if (this.firstResultReceivedResolve) this.firstResultReceivedResolve();
      this.inputStream.done(), this.cleanup();
    } catch (X) {
      if (this.firstResultReceivedResolve) this.firstResultReceivedResolve();
      this.inputStream.error(X), this.cleanup(X);
    }
  }
  async handleControlRequest(X) {
    let Q = new AbortController();
    this.cancelControllers.set(X.request_id, Q);
    try {
      let $ = await this.processControlRequest(X, Q.signal), Y = { type: "control_response", response: { subtype: "success", request_id: X.request_id, response: $ } };
      await Promise.resolve(this.transport.write(Z0(Y) + `
`));
    } catch ($) {
      let Y = { type: "control_response", response: { subtype: "error", request_id: X.request_id, error: $.message || String($) } };
      await Promise.resolve(this.transport.write(Z0(Y) + `
`));
    } finally {
      this.cancelControllers.delete(X.request_id);
    }
  }
  handleControlCancelRequest(X) {
    let Q = this.cancelControllers.get(X.request_id);
    if (Q) Q.abort(), this.cancelControllers.delete(X.request_id);
  }
  async processControlRequest(X, Q) {
    if (X.request.subtype === "can_use_tool") {
      if (!this.canUseTool) throw Error("canUseTool callback is not provided.");
      return { ...await this.canUseTool(X.request.tool_name, X.request.input, { signal: Q, suggestions: X.request.permission_suggestions, blockedPath: X.request.blocked_path, decisionReason: X.request.decision_reason, toolUseID: X.request.tool_use_id, agentID: X.request.agent_id }), toolUseID: X.request.tool_use_id };
    } else if (X.request.subtype === "hook_callback") return await this.handleHookCallbacks(X.request.callback_id, X.request.input, X.request.tool_use_id, Q);
    else if (X.request.subtype === "mcp_message") {
      let $ = X.request, Y = this.sdkMcpTransports.get($.server_name);
      if (!Y) throw Error(`SDK MCP server not found: ${$.server_name}`);
      if ("method" in $.message && "id" in $.message && $.message.id !== null) return { mcp_response: await this.handleMcpControlRequest($.server_name, $, Y) };
      else {
        if (Y.onmessage) Y.onmessage($.message);
        return { mcp_response: { jsonrpc: "2.0", result: {}, id: 0 } };
      }
    }
    throw Error("Unsupported control request subtype: " + X.request.subtype);
  }
  async *readSdkMessages() {
    for await (let X of this.inputStream) yield X;
  }
  async initialize() {
    var _a5, _b, _c;
    let X;
    if (this.hooks) {
      X = {};
      for (let [W, J] of Object.entries(this.hooks)) if (J.length > 0) X[W] = J.map((G) => {
        let H = [];
        for (let B of G.hooks) {
          let z = `hook_${this.nextCallbackId++}`;
          this.hookCallbacks.set(z, B), H.push(z);
        }
        return { matcher: G.matcher, hookCallbackIds: H, timeout: G.timeout };
      });
    }
    let Q = this.sdkMcpTransports.size > 0 ? Array.from(this.sdkMcpTransports.keys()) : void 0, $ = { subtype: "initialize", hooks: X, sdkMcpServers: Q, jsonSchema: this.jsonSchema, systemPrompt: (_a5 = this.initConfig) == null ? void 0 : _a5.systemPrompt, appendSystemPrompt: (_b = this.initConfig) == null ? void 0 : _b.appendSystemPrompt, agents: (_c = this.initConfig) == null ? void 0 : _c.agents };
    return (await this.request($)).response;
  }
  async interrupt() {
    await this.request({ subtype: "interrupt" });
  }
  async setPermissionMode(X) {
    await this.request({ subtype: "set_permission_mode", mode: X });
  }
  async setModel(X) {
    await this.request({ subtype: "set_model", model: X });
  }
  async setMaxThinkingTokens(X) {
    await this.request({ subtype: "set_max_thinking_tokens", max_thinking_tokens: X });
  }
  async rewindFiles(X, Q) {
    return (await this.request({ subtype: "rewind_files", user_message_id: X, dry_run: Q == null ? void 0 : Q.dryRun })).response;
  }
  async processPendingPermissionRequests(X) {
    for (let Q of X) if (Q.request.subtype === "can_use_tool") this.handleControlRequest(Q).catch(() => {
    });
  }
  request(X) {
    let Q = Math.random().toString(36).substring(2, 15), $ = { request_id: Q, type: "control_request", request: X };
    return new Promise((Y, W) => {
      this.pendingControlResponses.set(Q, (J) => {
        if (J.subtype === "success") Y(J);
        else if (W(Error(J.error)), J.pending_permission_requests) this.processPendingPermissionRequests(J.pending_permission_requests);
      }), Promise.resolve(this.transport.write(Z0($) + `
`));
    });
  }
  async initializationResult() {
    return this.initialization;
  }
  async supportedCommands() {
    return (await this.initialization).commands;
  }
  async supportedModels() {
    return (await this.initialization).models;
  }
  async reconnectMcpServer(X) {
    await this.request({ subtype: "mcp_reconnect", serverName: X });
  }
  async toggleMcpServer(X, Q) {
    await this.request({ subtype: "mcp_toggle", serverName: X, enabled: Q });
  }
  async mcpServerStatus() {
    return (await this.request({ subtype: "mcp_status" })).response.mcpServers;
  }
  async setMcpServers(X) {
    let Q = {}, $ = {};
    for (let [H, B] of Object.entries(X)) if (B.type === "sdk" && "instance" in B) Q[H] = B.instance;
    else $[H] = B;
    let Y = new Set(this.sdkMcpServerInstances.keys()), W = new Set(Object.keys(Q));
    for (let H of Y) if (!W.has(H)) await this.disconnectSdkMcpServer(H);
    for (let [H, B] of Object.entries(Q)) if (!Y.has(H)) this.connectSdkMcpServer(H, B);
    let J = {};
    for (let H of Object.keys(Q)) J[H] = { type: "sdk", name: H };
    return (await this.request({ subtype: "mcp_set_servers", servers: { ...$, ...J } })).response;
  }
  async accountInfo() {
    return (await this.initialization).account;
  }
  async streamInput(X) {
    var _a5;
    v1("[Query.streamInput] Starting to process input stream");
    try {
      let Q = 0;
      for await (let $ of X) {
        if (Q++, v1(`[Query.streamInput] Processing message ${Q}: ${$.type}`), (_a5 = this.abortController) == null ? void 0 : _a5.signal.aborted) break;
        await Promise.resolve(this.transport.write(Z0($) + `
`));
      }
      if (v1(`[Query.streamInput] Finished processing ${Q} messages from input stream`), Q > 0 && this.hasBidirectionalNeeds()) v1("[Query.streamInput] Has bidirectional needs, waiting for first result"), await this.waitForFirstResult();
      v1("[Query] Calling transport.endInput() to close stdin to CLI process"), this.transport.endInput();
    } catch (Q) {
      if (!(Q instanceof F1)) throw Q;
    }
  }
  waitForFirstResult() {
    if (this.firstResultReceived) return v1("[Query.waitForFirstResult] Result already received, returning immediately"), Promise.resolve();
    return new Promise((X) => {
      var _a5, _b;
      if ((_a5 = this.abortController) == null ? void 0 : _a5.signal.aborted) {
        X();
        return;
      }
      (_b = this.abortController) == null ? void 0 : _b.signal.addEventListener("abort", () => X(), { once: true }), this.firstResultReceivedResolve = X;
    });
  }
  handleHookCallbacks(X, Q, $, Y) {
    let W = this.hookCallbacks.get(X);
    if (!W) throw Error(`No hook callback found for ID: ${X}`);
    return W(Q, $, { signal: Y });
  }
  connectSdkMcpServer(X, Q) {
    let $ = new K9((Y) => this.sendMcpServerMessageToCli(X, Y));
    this.sdkMcpTransports.set(X, $), this.sdkMcpServerInstances.set(X, Q), Q.connect($);
  }
  async disconnectSdkMcpServer(X) {
    let Q = this.sdkMcpTransports.get(X);
    if (Q) await Q.close(), this.sdkMcpTransports.delete(X);
    this.sdkMcpServerInstances.delete(X);
  }
  sendMcpServerMessageToCli(X, Q) {
    if ("id" in Q && Q.id !== null && Q.id !== void 0) {
      let Y = `${X}:${Q.id}`, W = this.pendingMcpResponses.get(Y);
      if (W) {
        W.resolve(Q), this.pendingMcpResponses.delete(Y);
        return;
      }
    }
    let $ = { type: "control_request", request_id: (0, import_crypto3.randomUUID)(), request: { subtype: "mcp_message", server_name: X, message: Q } };
    this.transport.write(Z0($) + `
`);
  }
  handleMcpControlRequest(X, Q, $) {
    let Y = "id" in Q.message ? Q.message.id : null, W = `${X}:${Y}`;
    return new Promise((J, G) => {
      let H = () => {
        this.pendingMcpResponses.delete(W);
      }, B = (K) => {
        H(), J(K);
      }, z = (K) => {
        H(), G(K);
      };
      if (this.pendingMcpResponses.set(W, { resolve: B, reject: z }), $.onmessage) $.onmessage(Q.message);
      else {
        H(), G(Error("No message handler registered"));
        return;
      }
    });
  }
};
var n;
(function(X) {
  X.assertEqual = (W) => {
  };
  function Q(W) {
  }
  X.assertIs = Q;
  function $(W) {
    throw Error();
  }
  X.assertNever = $, X.arrayToEnum = (W) => {
    let J = {};
    for (let G of W) J[G] = G;
    return J;
  }, X.getValidEnumValues = (W) => {
    let J = X.objectKeys(W).filter((H) => typeof W[W[H]] !== "number"), G = {};
    for (let H of J) G[H] = W[H];
    return X.objectValues(G);
  }, X.objectValues = (W) => {
    return X.objectKeys(W).map(function(J) {
      return W[J];
    });
  }, X.objectKeys = typeof Object.keys === "function" ? (W) => Object.keys(W) : (W) => {
    let J = [];
    for (let G in W) if (Object.prototype.hasOwnProperty.call(W, G)) J.push(G);
    return J;
  }, X.find = (W, J) => {
    for (let G of W) if (J(G)) return G;
    return;
  }, X.isInteger = typeof Number.isInteger === "function" ? (W) => Number.isInteger(W) : (W) => typeof W === "number" && Number.isFinite(W) && Math.floor(W) === W;
  function Y(W, J = " | ") {
    return W.map((G) => typeof G === "string" ? `'${G}'` : G).join(J);
  }
  X.joinValues = Y, X.jsonStringifyReplacer = (W, J) => {
    if (typeof J === "bigint") return J.toString();
    return J;
  };
})(n || (n = {}));
var VW;
(function(X) {
  X.mergeShapes = (Q, $) => {
    return { ...Q, ...$ };
  };
})(VW || (VW = {}));
var I = n.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]);
var O1 = (X) => {
  switch (typeof X) {
    case "undefined":
      return I.undefined;
    case "string":
      return I.string;
    case "number":
      return Number.isNaN(X) ? I.nan : I.number;
    case "boolean":
      return I.boolean;
    case "function":
      return I.function;
    case "bigint":
      return I.bigint;
    case "symbol":
      return I.symbol;
    case "object":
      if (Array.isArray(X)) return I.array;
      if (X === null) return I.null;
      if (X.then && typeof X.then === "function" && X.catch && typeof X.catch === "function") return I.promise;
      if (typeof Map < "u" && X instanceof Map) return I.map;
      if (typeof Set < "u" && X instanceof Set) return I.set;
      if (typeof Date < "u" && X instanceof Date) return I.date;
      return I.object;
    default:
      return I.unknown;
  }
};
var A = n.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]);
var h0 = class _h0 extends Error {
  get errors() {
    return this.issues;
  }
  constructor(X) {
    super();
    this.issues = [], this.addIssue = ($) => {
      this.issues = [...this.issues, $];
    }, this.addIssues = ($ = []) => {
      this.issues = [...this.issues, ...$];
    };
    let Q = new.target.prototype;
    if (Object.setPrototypeOf) Object.setPrototypeOf(this, Q);
    else this.__proto__ = Q;
    this.name = "ZodError", this.issues = X;
  }
  format(X) {
    let Q = X || function(W) {
      return W.message;
    }, $ = { _errors: [] }, Y = (W) => {
      for (let J of W.issues) if (J.code === "invalid_union") J.unionErrors.map(Y);
      else if (J.code === "invalid_return_type") Y(J.returnTypeError);
      else if (J.code === "invalid_arguments") Y(J.argumentsError);
      else if (J.path.length === 0) $._errors.push(Q(J));
      else {
        let G = $, H = 0;
        while (H < J.path.length) {
          let B = J.path[H];
          if (H !== J.path.length - 1) G[B] = G[B] || { _errors: [] };
          else G[B] = G[B] || { _errors: [] }, G[B]._errors.push(Q(J));
          G = G[B], H++;
        }
      }
    };
    return Y(this), $;
  }
  static assert(X) {
    if (!(X instanceof _h0)) throw Error(`Not a ZodError: ${X}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, n.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(X = (Q) => Q.message) {
    let Q = {}, $ = [];
    for (let Y of this.issues) if (Y.path.length > 0) {
      let W = Y.path[0];
      Q[W] = Q[W] || [], Q[W].push(X(Y));
    } else $.push(X(Y));
    return { formErrors: $, fieldErrors: Q };
  }
  get formErrors() {
    return this.flatten();
  }
};
h0.create = (X) => {
  return new h0(X);
};
var JV = (X, Q) => {
  let $;
  switch (X.code) {
    case A.invalid_type:
      if (X.received === I.undefined) $ = "Required";
      else $ = `Expected ${X.expected}, received ${X.received}`;
      break;
    case A.invalid_literal:
      $ = `Invalid literal value, expected ${JSON.stringify(X.expected, n.jsonStringifyReplacer)}`;
      break;
    case A.unrecognized_keys:
      $ = `Unrecognized key(s) in object: ${n.joinValues(X.keys, ", ")}`;
      break;
    case A.invalid_union:
      $ = "Invalid input";
      break;
    case A.invalid_union_discriminator:
      $ = `Invalid discriminator value. Expected ${n.joinValues(X.options)}`;
      break;
    case A.invalid_enum_value:
      $ = `Invalid enum value. Expected ${n.joinValues(X.options)}, received '${X.received}'`;
      break;
    case A.invalid_arguments:
      $ = "Invalid function arguments";
      break;
    case A.invalid_return_type:
      $ = "Invalid function return type";
      break;
    case A.invalid_date:
      $ = "Invalid date";
      break;
    case A.invalid_string:
      if (typeof X.validation === "object") if ("includes" in X.validation) {
        if ($ = `Invalid input: must include "${X.validation.includes}"`, typeof X.validation.position === "number") $ = `${$} at one or more positions greater than or equal to ${X.validation.position}`;
      } else if ("startsWith" in X.validation) $ = `Invalid input: must start with "${X.validation.startsWith}"`;
      else if ("endsWith" in X.validation) $ = `Invalid input: must end with "${X.validation.endsWith}"`;
      else n.assertNever(X.validation);
      else if (X.validation !== "regex") $ = `Invalid ${X.validation}`;
      else $ = "Invalid";
      break;
    case A.too_small:
      if (X.type === "array") $ = `Array must contain ${X.exact ? "exactly" : X.inclusive ? "at least" : "more than"} ${X.minimum} element(s)`;
      else if (X.type === "string") $ = `String must contain ${X.exact ? "exactly" : X.inclusive ? "at least" : "over"} ${X.minimum} character(s)`;
      else if (X.type === "number") $ = `Number must be ${X.exact ? "exactly equal to " : X.inclusive ? "greater than or equal to " : "greater than "}${X.minimum}`;
      else if (X.type === "bigint") $ = `Number must be ${X.exact ? "exactly equal to " : X.inclusive ? "greater than or equal to " : "greater than "}${X.minimum}`;
      else if (X.type === "date") $ = `Date must be ${X.exact ? "exactly equal to " : X.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(X.minimum))}`;
      else $ = "Invalid input";
      break;
    case A.too_big:
      if (X.type === "array") $ = `Array must contain ${X.exact ? "exactly" : X.inclusive ? "at most" : "less than"} ${X.maximum} element(s)`;
      else if (X.type === "string") $ = `String must contain ${X.exact ? "exactly" : X.inclusive ? "at most" : "under"} ${X.maximum} character(s)`;
      else if (X.type === "number") $ = `Number must be ${X.exact ? "exactly" : X.inclusive ? "less than or equal to" : "less than"} ${X.maximum}`;
      else if (X.type === "bigint") $ = `BigInt must be ${X.exact ? "exactly" : X.inclusive ? "less than or equal to" : "less than"} ${X.maximum}`;
      else if (X.type === "date") $ = `Date must be ${X.exact ? "exactly" : X.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(X.maximum))}`;
      else $ = "Invalid input";
      break;
    case A.custom:
      $ = "Invalid input";
      break;
    case A.invalid_intersection_types:
      $ = "Intersection results could not be merged";
      break;
    case A.not_multiple_of:
      $ = `Number must be a multiple of ${X.multipleOf}`;
      break;
    case A.not_finite:
      $ = "Number must be finite";
      break;
    default:
      $ = Q.defaultError, n.assertNever(X);
  }
  return { message: $ };
};
var T1 = JV;
var GV = T1;
function YX() {
  return GV;
}
var N4 = (X) => {
  let { data: Q, path: $, errorMaps: Y, issueData: W } = X, J = [...$, ...W.path || []], G = { ...W, path: J };
  if (W.message !== void 0) return { ...W, path: J, message: W.message };
  let H = "", B = Y.filter((z) => !!z).slice().reverse();
  for (let z of B) H = z(G, { data: Q, defaultError: H }).message;
  return { ...W, path: J, message: H };
};
function b(X, Q) {
  let $ = YX(), Y = N4({ issueData: Q, data: X.data, path: X.path, errorMaps: [X.common.contextualErrorMap, X.schemaErrorMap, $, $ === T1 ? void 0 : T1].filter((W) => !!W) });
  X.common.issues.push(Y);
}
var b0 = class _b0 {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid") this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted") this.value = "aborted";
  }
  static mergeArray(X, Q) {
    let $ = [];
    for (let Y of Q) {
      if (Y.status === "aborted") return g;
      if (Y.status === "dirty") X.dirty();
      $.push(Y.value);
    }
    return { status: X.value, value: $ };
  }
  static async mergeObjectAsync(X, Q) {
    let $ = [];
    for (let Y of Q) {
      let W = await Y.key, J = await Y.value;
      $.push({ key: W, value: J });
    }
    return _b0.mergeObjectSync(X, $);
  }
  static mergeObjectSync(X, Q) {
    let $ = {};
    for (let Y of Q) {
      let { key: W, value: J } = Y;
      if (W.status === "aborted") return g;
      if (J.status === "aborted") return g;
      if (W.status === "dirty") X.dirty();
      if (J.status === "dirty") X.dirty();
      if (W.value !== "__proto__" && (typeof J.value < "u" || Y.alwaysSet)) $[W.value] = J.value;
    }
    return { status: X.value, value: $ };
  }
};
var g = Object.freeze({ status: "aborted" });
var j6 = (X) => ({ status: "dirty", value: X });
var C0 = (X) => ({ status: "valid", value: X });
var L9 = (X) => X.status === "aborted";
var q9 = (X) => X.status === "dirty";
var t1 = (X) => X.status === "valid";
var WX = (X) => typeof Promise < "u" && X instanceof Promise;
var Z;
(function(X) {
  X.errToObj = (Q) => typeof Q === "string" ? { message: Q } : Q || {}, X.toString = (Q) => typeof Q === "string" ? Q : Q == null ? void 0 : Q.message;
})(Z || (Z = {}));
var r0 = class {
  constructor(X, Q, $, Y) {
    this._cachedPath = [], this.parent = X, this.data = Q, this._path = $, this._key = Y;
  }
  get path() {
    if (!this._cachedPath.length) if (Array.isArray(this._key)) this._cachedPath.push(...this._path, ...this._key);
    else this._cachedPath.push(...this._path, this._key);
    return this._cachedPath;
  }
};
var LW = (X, Q) => {
  if (t1(Q)) return { success: true, data: Q.value };
  else {
    if (!X.common.issues.length) throw Error("Validation failed but no issues detected.");
    return { success: false, get error() {
      if (this._error) return this._error;
      let $ = new h0(X.common.issues);
      return this._error = $, this._error;
    } };
  }
};
function l(X) {
  if (!X) return {};
  let { errorMap: Q, invalid_type_error: $, required_error: Y, description: W } = X;
  if (Q && ($ || Y)) throw Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  if (Q) return { errorMap: Q, description: W };
  return { errorMap: (G, H) => {
    var _a5, _b;
    let { message: B } = X;
    if (G.code === "invalid_enum_value") return { message: B != null ? B : H.defaultError };
    if (typeof H.data > "u") return { message: (_a5 = B != null ? B : Y) != null ? _a5 : H.defaultError };
    if (G.code !== "invalid_type") return { message: H.defaultError };
    return { message: (_b = B != null ? B : $) != null ? _b : H.defaultError };
  }, description: W };
}
var d = class {
  get description() {
    return this._def.description;
  }
  _getType(X) {
    return O1(X.data);
  }
  _getOrReturnCtx(X, Q) {
    return Q || { common: X.parent.common, data: X.data, parsedType: O1(X.data), schemaErrorMap: this._def.errorMap, path: X.path, parent: X.parent };
  }
  _processInputParams(X) {
    return { status: new b0(), ctx: { common: X.parent.common, data: X.data, parsedType: O1(X.data), schemaErrorMap: this._def.errorMap, path: X.path, parent: X.parent } };
  }
  _parseSync(X) {
    let Q = this._parse(X);
    if (WX(Q)) throw Error("Synchronous parse encountered promise.");
    return Q;
  }
  _parseAsync(X) {
    let Q = this._parse(X);
    return Promise.resolve(Q);
  }
  parse(X, Q) {
    let $ = this.safeParse(X, Q);
    if ($.success) return $.data;
    throw $.error;
  }
  safeParse(X, Q) {
    var _a5;
    let $ = { common: { issues: [], async: (_a5 = Q == null ? void 0 : Q.async) != null ? _a5 : false, contextualErrorMap: Q == null ? void 0 : Q.errorMap }, path: (Q == null ? void 0 : Q.path) || [], schemaErrorMap: this._def.errorMap, parent: null, data: X, parsedType: O1(X) }, Y = this._parseSync({ data: X, path: $.path, parent: $ });
    return LW($, Y);
  }
  "~validate"(X) {
    var _a5, _b;
    let Q = { common: { issues: [], async: !!this["~standard"].async }, path: [], schemaErrorMap: this._def.errorMap, parent: null, data: X, parsedType: O1(X) };
    if (!this["~standard"].async) try {
      let $ = this._parseSync({ data: X, path: [], parent: Q });
      return t1($) ? { value: $.value } : { issues: Q.common.issues };
    } catch ($) {
      if ((_b = (_a5 = $ == null ? void 0 : $.message) == null ? void 0 : _a5.toLowerCase()) == null ? void 0 : _b.includes("encountered")) this["~standard"].async = true;
      Q.common = { issues: [], async: true };
    }
    return this._parseAsync({ data: X, path: [], parent: Q }).then(($) => t1($) ? { value: $.value } : { issues: Q.common.issues });
  }
  async parseAsync(X, Q) {
    let $ = await this.safeParseAsync(X, Q);
    if ($.success) return $.data;
    throw $.error;
  }
  async safeParseAsync(X, Q) {
    let $ = { common: { issues: [], contextualErrorMap: Q == null ? void 0 : Q.errorMap, async: true }, path: (Q == null ? void 0 : Q.path) || [], schemaErrorMap: this._def.errorMap, parent: null, data: X, parsedType: O1(X) }, Y = this._parse({ data: X, path: $.path, parent: $ }), W = await (WX(Y) ? Y : Promise.resolve(Y));
    return LW($, W);
  }
  refine(X, Q) {
    let $ = (Y) => {
      if (typeof Q === "string" || typeof Q > "u") return { message: Q };
      else if (typeof Q === "function") return Q(Y);
      else return Q;
    };
    return this._refinement((Y, W) => {
      let J = X(Y), G = () => W.addIssue({ code: A.custom, ...$(Y) });
      if (typeof Promise < "u" && J instanceof Promise) return J.then((H) => {
        if (!H) return G(), false;
        else return true;
      });
      if (!J) return G(), false;
      else return true;
    });
  }
  refinement(X, Q) {
    return this._refinement(($, Y) => {
      if (!X($)) return Y.addIssue(typeof Q === "function" ? Q($, Y) : Q), false;
      else return true;
    });
  }
  _refinement(X) {
    return new G1({ schema: this, typeName: j.ZodEffects, effect: { type: "refinement", refinement: X } });
  }
  superRefine(X) {
    return this._refinement(X);
  }
  constructor(X) {
    this.spa = this.safeParseAsync, this._def = X, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = { version: 1, vendor: "zod", validate: (Q) => this["~validate"](Q) };
  }
  optional() {
    return J1.create(this, this._def);
  }
  nullable() {
    return _1.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return W1.create(this);
  }
  promise() {
    return P6.create(this, this._def);
  }
  or(X) {
    return zX.create([this, X], this._def);
  }
  and(X) {
    return KX.create(this, X, this._def);
  }
  transform(X) {
    return new G1({ ...l(this._def), schema: this, typeName: j.ZodEffects, effect: { type: "transform", transform: X } });
  }
  default(X) {
    let Q = typeof X === "function" ? X : () => X;
    return new qX({ ...l(this._def), innerType: this, defaultValue: Q, typeName: j.ZodDefault });
  }
  brand() {
    return new D9({ typeName: j.ZodBranded, type: this, ...l(this._def) });
  }
  catch(X) {
    let Q = typeof X === "function" ? X : () => X;
    return new FX({ ...l(this._def), innerType: this, catchValue: Q, typeName: j.ZodCatch });
  }
  describe(X) {
    return new this.constructor({ ...this._def, description: X });
  }
  pipe(X) {
    return I4.create(this, X);
  }
  readonly() {
    return NX.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var HV = /^c[^\s-]{8,}$/i;
var BV = /^[0-9a-z]+$/;
var zV = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
var KV = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var UV = /^[a-z0-9_-]{21}$/i;
var VV = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
var LV = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var qV = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var FV = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
var F9;
var NV = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var OV = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
var DV = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
var wV = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var AV = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var MV = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
var qW = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))";
var jV = new RegExp(`^${qW}$`);
function FW(X) {
  let Q = "[0-5]\\d";
  if (X.precision) Q = `${Q}\\.\\d{${X.precision}}`;
  else if (X.precision == null) Q = `${Q}(\\.\\d+)?`;
  let $ = X.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${Q})${$}`;
}
function RV(X) {
  return new RegExp(`^${FW(X)}$`);
}
function IV(X) {
  let Q = `${qW}T${FW(X)}`, $ = [];
  if ($.push(X.local ? "Z?" : "Z"), X.offset) $.push("([+-]\\d{2}:?\\d{2})");
  return Q = `${Q}(${$.join("|")})`, new RegExp(`^${Q}$`);
}
function EV(X, Q) {
  if ((Q === "v4" || !Q) && NV.test(X)) return true;
  if ((Q === "v6" || !Q) && DV.test(X)) return true;
  return false;
}
function bV(X, Q) {
  if (!VV.test(X)) return false;
  try {
    let [$] = X.split(".");
    if (!$) return false;
    let Y = $.replace(/-/g, "+").replace(/_/g, "/").padEnd($.length + (4 - $.length % 4) % 4, "="), W = JSON.parse(atob(Y));
    if (typeof W !== "object" || W === null) return false;
    if ("typ" in W && (W == null ? void 0 : W.typ) !== "JWT") return false;
    if (!W.alg) return false;
    if (Q && W.alg !== Q) return false;
    return true;
  } catch (e3) {
    return false;
  }
}
function PV(X, Q) {
  if ((Q === "v4" || !Q) && OV.test(X)) return true;
  if ((Q === "v6" || !Q) && wV.test(X)) return true;
  return false;
}
var w1 = class _w1 extends d {
  _parse(X) {
    if (this._def.coerce) X.data = String(X.data);
    if (this._getType(X) !== I.string) {
      let W = this._getOrReturnCtx(X);
      return b(W, { code: A.invalid_type, expected: I.string, received: W.parsedType }), g;
    }
    let $ = new b0(), Y = void 0;
    for (let W of this._def.checks) if (W.kind === "min") {
      if (X.data.length < W.value) Y = this._getOrReturnCtx(X, Y), b(Y, { code: A.too_small, minimum: W.value, type: "string", inclusive: true, exact: false, message: W.message }), $.dirty();
    } else if (W.kind === "max") {
      if (X.data.length > W.value) Y = this._getOrReturnCtx(X, Y), b(Y, { code: A.too_big, maximum: W.value, type: "string", inclusive: true, exact: false, message: W.message }), $.dirty();
    } else if (W.kind === "length") {
      let J = X.data.length > W.value, G = X.data.length < W.value;
      if (J || G) {
        if (Y = this._getOrReturnCtx(X, Y), J) b(Y, { code: A.too_big, maximum: W.value, type: "string", inclusive: true, exact: true, message: W.message });
        else if (G) b(Y, { code: A.too_small, minimum: W.value, type: "string", inclusive: true, exact: true, message: W.message });
        $.dirty();
      }
    } else if (W.kind === "email") {
      if (!qV.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "email", code: A.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "emoji") {
      if (!F9) F9 = new RegExp(FV, "u");
      if (!F9.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "emoji", code: A.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "uuid") {
      if (!KV.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "uuid", code: A.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "nanoid") {
      if (!UV.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "nanoid", code: A.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "cuid") {
      if (!HV.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "cuid", code: A.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "cuid2") {
      if (!BV.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "cuid2", code: A.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "ulid") {
      if (!zV.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "ulid", code: A.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "url") try {
      new URL(X.data);
    } catch (e3) {
      Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "url", code: A.invalid_string, message: W.message }), $.dirty();
    }
    else if (W.kind === "regex") {
      if (W.regex.lastIndex = 0, !W.regex.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "regex", code: A.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "trim") X.data = X.data.trim();
    else if (W.kind === "includes") {
      if (!X.data.includes(W.value, W.position)) Y = this._getOrReturnCtx(X, Y), b(Y, { code: A.invalid_string, validation: { includes: W.value, position: W.position }, message: W.message }), $.dirty();
    } else if (W.kind === "toLowerCase") X.data = X.data.toLowerCase();
    else if (W.kind === "toUpperCase") X.data = X.data.toUpperCase();
    else if (W.kind === "startsWith") {
      if (!X.data.startsWith(W.value)) Y = this._getOrReturnCtx(X, Y), b(Y, { code: A.invalid_string, validation: { startsWith: W.value }, message: W.message }), $.dirty();
    } else if (W.kind === "endsWith") {
      if (!X.data.endsWith(W.value)) Y = this._getOrReturnCtx(X, Y), b(Y, { code: A.invalid_string, validation: { endsWith: W.value }, message: W.message }), $.dirty();
    } else if (W.kind === "datetime") {
      if (!IV(W).test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { code: A.invalid_string, validation: "datetime", message: W.message }), $.dirty();
    } else if (W.kind === "date") {
      if (!jV.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { code: A.invalid_string, validation: "date", message: W.message }), $.dirty();
    } else if (W.kind === "time") {
      if (!RV(W).test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { code: A.invalid_string, validation: "time", message: W.message }), $.dirty();
    } else if (W.kind === "duration") {
      if (!LV.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "duration", code: A.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "ip") {
      if (!EV(X.data, W.version)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "ip", code: A.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "jwt") {
      if (!bV(X.data, W.alg)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "jwt", code: A.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "cidr") {
      if (!PV(X.data, W.version)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "cidr", code: A.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "base64") {
      if (!AV.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "base64", code: A.invalid_string, message: W.message }), $.dirty();
    } else if (W.kind === "base64url") {
      if (!MV.test(X.data)) Y = this._getOrReturnCtx(X, Y), b(Y, { validation: "base64url", code: A.invalid_string, message: W.message }), $.dirty();
    } else n.assertNever(W);
    return { status: $.value, value: X.data };
  }
  _regex(X, Q, $) {
    return this.refinement((Y) => X.test(Y), { validation: Q, code: A.invalid_string, ...Z.errToObj($) });
  }
  _addCheck(X) {
    return new _w1({ ...this._def, checks: [...this._def.checks, X] });
  }
  email(X) {
    return this._addCheck({ kind: "email", ...Z.errToObj(X) });
  }
  url(X) {
    return this._addCheck({ kind: "url", ...Z.errToObj(X) });
  }
  emoji(X) {
    return this._addCheck({ kind: "emoji", ...Z.errToObj(X) });
  }
  uuid(X) {
    return this._addCheck({ kind: "uuid", ...Z.errToObj(X) });
  }
  nanoid(X) {
    return this._addCheck({ kind: "nanoid", ...Z.errToObj(X) });
  }
  cuid(X) {
    return this._addCheck({ kind: "cuid", ...Z.errToObj(X) });
  }
  cuid2(X) {
    return this._addCheck({ kind: "cuid2", ...Z.errToObj(X) });
  }
  ulid(X) {
    return this._addCheck({ kind: "ulid", ...Z.errToObj(X) });
  }
  base64(X) {
    return this._addCheck({ kind: "base64", ...Z.errToObj(X) });
  }
  base64url(X) {
    return this._addCheck({ kind: "base64url", ...Z.errToObj(X) });
  }
  jwt(X) {
    return this._addCheck({ kind: "jwt", ...Z.errToObj(X) });
  }
  ip(X) {
    return this._addCheck({ kind: "ip", ...Z.errToObj(X) });
  }
  cidr(X) {
    return this._addCheck({ kind: "cidr", ...Z.errToObj(X) });
  }
  datetime(X) {
    var _a5, _b;
    if (typeof X === "string") return this._addCheck({ kind: "datetime", precision: null, offset: false, local: false, message: X });
    return this._addCheck({ kind: "datetime", precision: typeof (X == null ? void 0 : X.precision) > "u" ? null : X == null ? void 0 : X.precision, offset: (_a5 = X == null ? void 0 : X.offset) != null ? _a5 : false, local: (_b = X == null ? void 0 : X.local) != null ? _b : false, ...Z.errToObj(X == null ? void 0 : X.message) });
  }
  date(X) {
    return this._addCheck({ kind: "date", message: X });
  }
  time(X) {
    if (typeof X === "string") return this._addCheck({ kind: "time", precision: null, message: X });
    return this._addCheck({ kind: "time", precision: typeof (X == null ? void 0 : X.precision) > "u" ? null : X == null ? void 0 : X.precision, ...Z.errToObj(X == null ? void 0 : X.message) });
  }
  duration(X) {
    return this._addCheck({ kind: "duration", ...Z.errToObj(X) });
  }
  regex(X, Q) {
    return this._addCheck({ kind: "regex", regex: X, ...Z.errToObj(Q) });
  }
  includes(X, Q) {
    return this._addCheck({ kind: "includes", value: X, position: Q == null ? void 0 : Q.position, ...Z.errToObj(Q == null ? void 0 : Q.message) });
  }
  startsWith(X, Q) {
    return this._addCheck({ kind: "startsWith", value: X, ...Z.errToObj(Q) });
  }
  endsWith(X, Q) {
    return this._addCheck({ kind: "endsWith", value: X, ...Z.errToObj(Q) });
  }
  min(X, Q) {
    return this._addCheck({ kind: "min", value: X, ...Z.errToObj(Q) });
  }
  max(X, Q) {
    return this._addCheck({ kind: "max", value: X, ...Z.errToObj(Q) });
  }
  length(X, Q) {
    return this._addCheck({ kind: "length", value: X, ...Z.errToObj(Q) });
  }
  nonempty(X) {
    return this.min(1, Z.errToObj(X));
  }
  trim() {
    return new _w1({ ...this._def, checks: [...this._def.checks, { kind: "trim" }] });
  }
  toLowerCase() {
    return new _w1({ ...this._def, checks: [...this._def.checks, { kind: "toLowerCase" }] });
  }
  toUpperCase() {
    return new _w1({ ...this._def, checks: [...this._def.checks, { kind: "toUpperCase" }] });
  }
  get isDatetime() {
    return !!this._def.checks.find((X) => X.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((X) => X.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((X) => X.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((X) => X.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((X) => X.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((X) => X.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((X) => X.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((X) => X.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((X) => X.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((X) => X.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((X) => X.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((X) => X.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((X) => X.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((X) => X.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((X) => X.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((X) => X.kind === "base64url");
  }
  get minLength() {
    let X = null;
    for (let Q of this._def.checks) if (Q.kind === "min") {
      if (X === null || Q.value > X) X = Q.value;
    }
    return X;
  }
  get maxLength() {
    let X = null;
    for (let Q of this._def.checks) if (Q.kind === "max") {
      if (X === null || Q.value < X) X = Q.value;
    }
    return X;
  }
};
w1.create = (X) => {
  var _a5;
  return new w1({ checks: [], typeName: j.ZodString, coerce: (_a5 = X == null ? void 0 : X.coerce) != null ? _a5 : false, ...l(X) });
};
function SV(X, Q) {
  let $ = (X.toString().split(".")[1] || "").length, Y = (Q.toString().split(".")[1] || "").length, W = $ > Y ? $ : Y, J = Number.parseInt(X.toFixed(W).replace(".", "")), G = Number.parseInt(Q.toFixed(W).replace(".", ""));
  return J % G / 10 ** W;
}
var I6 = class _I6 extends d {
  constructor() {
    super(...arguments);
    this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(X) {
    if (this._def.coerce) X.data = Number(X.data);
    if (this._getType(X) !== I.number) {
      let W = this._getOrReturnCtx(X);
      return b(W, { code: A.invalid_type, expected: I.number, received: W.parsedType }), g;
    }
    let $ = void 0, Y = new b0();
    for (let W of this._def.checks) if (W.kind === "int") {
      if (!n.isInteger(X.data)) $ = this._getOrReturnCtx(X, $), b($, { code: A.invalid_type, expected: "integer", received: "float", message: W.message }), Y.dirty();
    } else if (W.kind === "min") {
      if (W.inclusive ? X.data < W.value : X.data <= W.value) $ = this._getOrReturnCtx(X, $), b($, { code: A.too_small, minimum: W.value, type: "number", inclusive: W.inclusive, exact: false, message: W.message }), Y.dirty();
    } else if (W.kind === "max") {
      if (W.inclusive ? X.data > W.value : X.data >= W.value) $ = this._getOrReturnCtx(X, $), b($, { code: A.too_big, maximum: W.value, type: "number", inclusive: W.inclusive, exact: false, message: W.message }), Y.dirty();
    } else if (W.kind === "multipleOf") {
      if (SV(X.data, W.value) !== 0) $ = this._getOrReturnCtx(X, $), b($, { code: A.not_multiple_of, multipleOf: W.value, message: W.message }), Y.dirty();
    } else if (W.kind === "finite") {
      if (!Number.isFinite(X.data)) $ = this._getOrReturnCtx(X, $), b($, { code: A.not_finite, message: W.message }), Y.dirty();
    } else n.assertNever(W);
    return { status: Y.value, value: X.data };
  }
  gte(X, Q) {
    return this.setLimit("min", X, true, Z.toString(Q));
  }
  gt(X, Q) {
    return this.setLimit("min", X, false, Z.toString(Q));
  }
  lte(X, Q) {
    return this.setLimit("max", X, true, Z.toString(Q));
  }
  lt(X, Q) {
    return this.setLimit("max", X, false, Z.toString(Q));
  }
  setLimit(X, Q, $, Y) {
    return new _I6({ ...this._def, checks: [...this._def.checks, { kind: X, value: Q, inclusive: $, message: Z.toString(Y) }] });
  }
  _addCheck(X) {
    return new _I6({ ...this._def, checks: [...this._def.checks, X] });
  }
  int(X) {
    return this._addCheck({ kind: "int", message: Z.toString(X) });
  }
  positive(X) {
    return this._addCheck({ kind: "min", value: 0, inclusive: false, message: Z.toString(X) });
  }
  negative(X) {
    return this._addCheck({ kind: "max", value: 0, inclusive: false, message: Z.toString(X) });
  }
  nonpositive(X) {
    return this._addCheck({ kind: "max", value: 0, inclusive: true, message: Z.toString(X) });
  }
  nonnegative(X) {
    return this._addCheck({ kind: "min", value: 0, inclusive: true, message: Z.toString(X) });
  }
  multipleOf(X, Q) {
    return this._addCheck({ kind: "multipleOf", value: X, message: Z.toString(Q) });
  }
  finite(X) {
    return this._addCheck({ kind: "finite", message: Z.toString(X) });
  }
  safe(X) {
    return this._addCheck({ kind: "min", inclusive: true, value: Number.MIN_SAFE_INTEGER, message: Z.toString(X) })._addCheck({ kind: "max", inclusive: true, value: Number.MAX_SAFE_INTEGER, message: Z.toString(X) });
  }
  get minValue() {
    let X = null;
    for (let Q of this._def.checks) if (Q.kind === "min") {
      if (X === null || Q.value > X) X = Q.value;
    }
    return X;
  }
  get maxValue() {
    let X = null;
    for (let Q of this._def.checks) if (Q.kind === "max") {
      if (X === null || Q.value < X) X = Q.value;
    }
    return X;
  }
  get isInt() {
    return !!this._def.checks.find((X) => X.kind === "int" || X.kind === "multipleOf" && n.isInteger(X.value));
  }
  get isFinite() {
    let X = null, Q = null;
    for (let $ of this._def.checks) if ($.kind === "finite" || $.kind === "int" || $.kind === "multipleOf") return true;
    else if ($.kind === "min") {
      if (Q === null || $.value > Q) Q = $.value;
    } else if ($.kind === "max") {
      if (X === null || $.value < X) X = $.value;
    }
    return Number.isFinite(Q) && Number.isFinite(X);
  }
};
I6.create = (X) => {
  return new I6({ checks: [], typeName: j.ZodNumber, coerce: (X == null ? void 0 : X.coerce) || false, ...l(X) });
};
var E6 = class _E6 extends d {
  constructor() {
    super(...arguments);
    this.min = this.gte, this.max = this.lte;
  }
  _parse(X) {
    if (this._def.coerce) try {
      X.data = BigInt(X.data);
    } catch (e3) {
      return this._getInvalidInput(X);
    }
    if (this._getType(X) !== I.bigint) return this._getInvalidInput(X);
    let $ = void 0, Y = new b0();
    for (let W of this._def.checks) if (W.kind === "min") {
      if (W.inclusive ? X.data < W.value : X.data <= W.value) $ = this._getOrReturnCtx(X, $), b($, { code: A.too_small, type: "bigint", minimum: W.value, inclusive: W.inclusive, message: W.message }), Y.dirty();
    } else if (W.kind === "max") {
      if (W.inclusive ? X.data > W.value : X.data >= W.value) $ = this._getOrReturnCtx(X, $), b($, { code: A.too_big, type: "bigint", maximum: W.value, inclusive: W.inclusive, message: W.message }), Y.dirty();
    } else if (W.kind === "multipleOf") {
      if (X.data % W.value !== BigInt(0)) $ = this._getOrReturnCtx(X, $), b($, { code: A.not_multiple_of, multipleOf: W.value, message: W.message }), Y.dirty();
    } else n.assertNever(W);
    return { status: Y.value, value: X.data };
  }
  _getInvalidInput(X) {
    let Q = this._getOrReturnCtx(X);
    return b(Q, { code: A.invalid_type, expected: I.bigint, received: Q.parsedType }), g;
  }
  gte(X, Q) {
    return this.setLimit("min", X, true, Z.toString(Q));
  }
  gt(X, Q) {
    return this.setLimit("min", X, false, Z.toString(Q));
  }
  lte(X, Q) {
    return this.setLimit("max", X, true, Z.toString(Q));
  }
  lt(X, Q) {
    return this.setLimit("max", X, false, Z.toString(Q));
  }
  setLimit(X, Q, $, Y) {
    return new _E6({ ...this._def, checks: [...this._def.checks, { kind: X, value: Q, inclusive: $, message: Z.toString(Y) }] });
  }
  _addCheck(X) {
    return new _E6({ ...this._def, checks: [...this._def.checks, X] });
  }
  positive(X) {
    return this._addCheck({ kind: "min", value: BigInt(0), inclusive: false, message: Z.toString(X) });
  }
  negative(X) {
    return this._addCheck({ kind: "max", value: BigInt(0), inclusive: false, message: Z.toString(X) });
  }
  nonpositive(X) {
    return this._addCheck({ kind: "max", value: BigInt(0), inclusive: true, message: Z.toString(X) });
  }
  nonnegative(X) {
    return this._addCheck({ kind: "min", value: BigInt(0), inclusive: true, message: Z.toString(X) });
  }
  multipleOf(X, Q) {
    return this._addCheck({ kind: "multipleOf", value: X, message: Z.toString(Q) });
  }
  get minValue() {
    let X = null;
    for (let Q of this._def.checks) if (Q.kind === "min") {
      if (X === null || Q.value > X) X = Q.value;
    }
    return X;
  }
  get maxValue() {
    let X = null;
    for (let Q of this._def.checks) if (Q.kind === "max") {
      if (X === null || Q.value < X) X = Q.value;
    }
    return X;
  }
};
E6.create = (X) => {
  var _a5;
  return new E6({ checks: [], typeName: j.ZodBigInt, coerce: (_a5 = X == null ? void 0 : X.coerce) != null ? _a5 : false, ...l(X) });
};
var O4 = class extends d {
  _parse(X) {
    if (this._def.coerce) X.data = Boolean(X.data);
    if (this._getType(X) !== I.boolean) {
      let $ = this._getOrReturnCtx(X);
      return b($, { code: A.invalid_type, expected: I.boolean, received: $.parsedType }), g;
    }
    return C0(X.data);
  }
};
O4.create = (X) => {
  return new O4({ typeName: j.ZodBoolean, coerce: (X == null ? void 0 : X.coerce) || false, ...l(X) });
};
var GX = class _GX extends d {
  _parse(X) {
    if (this._def.coerce) X.data = new Date(X.data);
    if (this._getType(X) !== I.date) {
      let W = this._getOrReturnCtx(X);
      return b(W, { code: A.invalid_type, expected: I.date, received: W.parsedType }), g;
    }
    if (Number.isNaN(X.data.getTime())) {
      let W = this._getOrReturnCtx(X);
      return b(W, { code: A.invalid_date }), g;
    }
    let $ = new b0(), Y = void 0;
    for (let W of this._def.checks) if (W.kind === "min") {
      if (X.data.getTime() < W.value) Y = this._getOrReturnCtx(X, Y), b(Y, { code: A.too_small, message: W.message, inclusive: true, exact: false, minimum: W.value, type: "date" }), $.dirty();
    } else if (W.kind === "max") {
      if (X.data.getTime() > W.value) Y = this._getOrReturnCtx(X, Y), b(Y, { code: A.too_big, message: W.message, inclusive: true, exact: false, maximum: W.value, type: "date" }), $.dirty();
    } else n.assertNever(W);
    return { status: $.value, value: new Date(X.data.getTime()) };
  }
  _addCheck(X) {
    return new _GX({ ...this._def, checks: [...this._def.checks, X] });
  }
  min(X, Q) {
    return this._addCheck({ kind: "min", value: X.getTime(), message: Z.toString(Q) });
  }
  max(X, Q) {
    return this._addCheck({ kind: "max", value: X.getTime(), message: Z.toString(Q) });
  }
  get minDate() {
    let X = null;
    for (let Q of this._def.checks) if (Q.kind === "min") {
      if (X === null || Q.value > X) X = Q.value;
    }
    return X != null ? new Date(X) : null;
  }
  get maxDate() {
    let X = null;
    for (let Q of this._def.checks) if (Q.kind === "max") {
      if (X === null || Q.value < X) X = Q.value;
    }
    return X != null ? new Date(X) : null;
  }
};
GX.create = (X) => {
  return new GX({ checks: [], coerce: (X == null ? void 0 : X.coerce) || false, typeName: j.ZodDate, ...l(X) });
};
var D4 = class extends d {
  _parse(X) {
    if (this._getType(X) !== I.symbol) {
      let $ = this._getOrReturnCtx(X);
      return b($, { code: A.invalid_type, expected: I.symbol, received: $.parsedType }), g;
    }
    return C0(X.data);
  }
};
D4.create = (X) => {
  return new D4({ typeName: j.ZodSymbol, ...l(X) });
};
var HX = class extends d {
  _parse(X) {
    if (this._getType(X) !== I.undefined) {
      let $ = this._getOrReturnCtx(X);
      return b($, { code: A.invalid_type, expected: I.undefined, received: $.parsedType }), g;
    }
    return C0(X.data);
  }
};
HX.create = (X) => {
  return new HX({ typeName: j.ZodUndefined, ...l(X) });
};
var BX = class extends d {
  _parse(X) {
    if (this._getType(X) !== I.null) {
      let $ = this._getOrReturnCtx(X);
      return b($, { code: A.invalid_type, expected: I.null, received: $.parsedType }), g;
    }
    return C0(X.data);
  }
};
BX.create = (X) => {
  return new BX({ typeName: j.ZodNull, ...l(X) });
};
var w4 = class extends d {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(X) {
    return C0(X.data);
  }
};
w4.create = (X) => {
  return new w4({ typeName: j.ZodAny, ...l(X) });
};
var a1 = class extends d {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(X) {
    return C0(X.data);
  }
};
a1.create = (X) => {
  return new a1({ typeName: j.ZodUnknown, ...l(X) });
};
var A1 = class extends d {
  _parse(X) {
    let Q = this._getOrReturnCtx(X);
    return b(Q, { code: A.invalid_type, expected: I.never, received: Q.parsedType }), g;
  }
};
A1.create = (X) => {
  return new A1({ typeName: j.ZodNever, ...l(X) });
};
var A4 = class extends d {
  _parse(X) {
    if (this._getType(X) !== I.undefined) {
      let $ = this._getOrReturnCtx(X);
      return b($, { code: A.invalid_type, expected: I.void, received: $.parsedType }), g;
    }
    return C0(X.data);
  }
};
A4.create = (X) => {
  return new A4({ typeName: j.ZodVoid, ...l(X) });
};
var W1 = class _W1 extends d {
  _parse(X) {
    let { ctx: Q, status: $ } = this._processInputParams(X), Y = this._def;
    if (Q.parsedType !== I.array) return b(Q, { code: A.invalid_type, expected: I.array, received: Q.parsedType }), g;
    if (Y.exactLength !== null) {
      let J = Q.data.length > Y.exactLength.value, G = Q.data.length < Y.exactLength.value;
      if (J || G) b(Q, { code: J ? A.too_big : A.too_small, minimum: G ? Y.exactLength.value : void 0, maximum: J ? Y.exactLength.value : void 0, type: "array", inclusive: true, exact: true, message: Y.exactLength.message }), $.dirty();
    }
    if (Y.minLength !== null) {
      if (Q.data.length < Y.minLength.value) b(Q, { code: A.too_small, minimum: Y.minLength.value, type: "array", inclusive: true, exact: false, message: Y.minLength.message }), $.dirty();
    }
    if (Y.maxLength !== null) {
      if (Q.data.length > Y.maxLength.value) b(Q, { code: A.too_big, maximum: Y.maxLength.value, type: "array", inclusive: true, exact: false, message: Y.maxLength.message }), $.dirty();
    }
    if (Q.common.async) return Promise.all([...Q.data].map((J, G) => {
      return Y.type._parseAsync(new r0(Q, J, Q.path, G));
    })).then((J) => {
      return b0.mergeArray($, J);
    });
    let W = [...Q.data].map((J, G) => {
      return Y.type._parseSync(new r0(Q, J, Q.path, G));
    });
    return b0.mergeArray($, W);
  }
  get element() {
    return this._def.type;
  }
  min(X, Q) {
    return new _W1({ ...this._def, minLength: { value: X, message: Z.toString(Q) } });
  }
  max(X, Q) {
    return new _W1({ ...this._def, maxLength: { value: X, message: Z.toString(Q) } });
  }
  length(X, Q) {
    return new _W1({ ...this._def, exactLength: { value: X, message: Z.toString(Q) } });
  }
  nonempty(X) {
    return this.min(1, X);
  }
};
W1.create = (X, Q) => {
  return new W1({ type: X, minLength: null, maxLength: null, exactLength: null, typeName: j.ZodArray, ...l(Q) });
};
function R6(X) {
  if (X instanceof V0) {
    let Q = {};
    for (let $ in X.shape) {
      let Y = X.shape[$];
      Q[$] = J1.create(R6(Y));
    }
    return new V0({ ...X._def, shape: () => Q });
  } else if (X instanceof W1) return new W1({ ...X._def, type: R6(X.element) });
  else if (X instanceof J1) return J1.create(R6(X.unwrap()));
  else if (X instanceof _1) return _1.create(R6(X.unwrap()));
  else if (X instanceof M1) return M1.create(X.items.map((Q) => R6(Q)));
  else return X;
}
var V0 = class _V0 extends d {
  constructor() {
    super(...arguments);
    this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null) return this._cached;
    let X = this._def.shape(), Q = n.objectKeys(X);
    return this._cached = { shape: X, keys: Q }, this._cached;
  }
  _parse(X) {
    if (this._getType(X) !== I.object) {
      let B = this._getOrReturnCtx(X);
      return b(B, { code: A.invalid_type, expected: I.object, received: B.parsedType }), g;
    }
    let { status: $, ctx: Y } = this._processInputParams(X), { shape: W, keys: J } = this._getCached(), G = [];
    if (!(this._def.catchall instanceof A1 && this._def.unknownKeys === "strip")) {
      for (let B in Y.data) if (!J.includes(B)) G.push(B);
    }
    let H = [];
    for (let B of J) {
      let z = W[B], K = Y.data[B];
      H.push({ key: { status: "valid", value: B }, value: z._parse(new r0(Y, K, Y.path, B)), alwaysSet: B in Y.data });
    }
    if (this._def.catchall instanceof A1) {
      let B = this._def.unknownKeys;
      if (B === "passthrough") for (let z of G) H.push({ key: { status: "valid", value: z }, value: { status: "valid", value: Y.data[z] } });
      else if (B === "strict") {
        if (G.length > 0) b(Y, { code: A.unrecognized_keys, keys: G }), $.dirty();
      } else if (B === "strip") ;
      else throw Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      let B = this._def.catchall;
      for (let z of G) {
        let K = Y.data[z];
        H.push({ key: { status: "valid", value: z }, value: B._parse(new r0(Y, K, Y.path, z)), alwaysSet: z in Y.data });
      }
    }
    if (Y.common.async) return Promise.resolve().then(async () => {
      let B = [];
      for (let z of H) {
        let K = await z.key, V = await z.value;
        B.push({ key: K, value: V, alwaysSet: z.alwaysSet });
      }
      return B;
    }).then((B) => {
      return b0.mergeObjectSync($, B);
    });
    else return b0.mergeObjectSync($, H);
  }
  get shape() {
    return this._def.shape();
  }
  strict(X) {
    return Z.errToObj, new _V0({ ...this._def, unknownKeys: "strict", ...X !== void 0 ? { errorMap: (Q, $) => {
      var _a5, _b, _c, _d;
      let Y = (_c = (_b = (_a5 = this._def).errorMap) == null ? void 0 : _b.call(_a5, Q, $).message) != null ? _c : $.defaultError;
      if (Q.code === "unrecognized_keys") return { message: (_d = Z.errToObj(X).message) != null ? _d : Y };
      return { message: Y };
    } } : {} });
  }
  strip() {
    return new _V0({ ...this._def, unknownKeys: "strip" });
  }
  passthrough() {
    return new _V0({ ...this._def, unknownKeys: "passthrough" });
  }
  extend(X) {
    return new _V0({ ...this._def, shape: () => ({ ...this._def.shape(), ...X }) });
  }
  merge(X) {
    return new _V0({ unknownKeys: X._def.unknownKeys, catchall: X._def.catchall, shape: () => ({ ...this._def.shape(), ...X._def.shape() }), typeName: j.ZodObject });
  }
  setKey(X, Q) {
    return this.augment({ [X]: Q });
  }
  catchall(X) {
    return new _V0({ ...this._def, catchall: X });
  }
  pick(X) {
    let Q = {};
    for (let $ of n.objectKeys(X)) if (X[$] && this.shape[$]) Q[$] = this.shape[$];
    return new _V0({ ...this._def, shape: () => Q });
  }
  omit(X) {
    let Q = {};
    for (let $ of n.objectKeys(this.shape)) if (!X[$]) Q[$] = this.shape[$];
    return new _V0({ ...this._def, shape: () => Q });
  }
  deepPartial() {
    return R6(this);
  }
  partial(X) {
    let Q = {};
    for (let $ of n.objectKeys(this.shape)) {
      let Y = this.shape[$];
      if (X && !X[$]) Q[$] = Y;
      else Q[$] = Y.optional();
    }
    return new _V0({ ...this._def, shape: () => Q });
  }
  required(X) {
    let Q = {};
    for (let $ of n.objectKeys(this.shape)) if (X && !X[$]) Q[$] = this.shape[$];
    else {
      let W = this.shape[$];
      while (W instanceof J1) W = W._def.innerType;
      Q[$] = W;
    }
    return new _V0({ ...this._def, shape: () => Q });
  }
  keyof() {
    return NW(n.objectKeys(this.shape));
  }
};
V0.create = (X, Q) => {
  return new V0({ shape: () => X, unknownKeys: "strip", catchall: A1.create(), typeName: j.ZodObject, ...l(Q) });
};
V0.strictCreate = (X, Q) => {
  return new V0({ shape: () => X, unknownKeys: "strict", catchall: A1.create(), typeName: j.ZodObject, ...l(Q) });
};
V0.lazycreate = (X, Q) => {
  return new V0({ shape: X, unknownKeys: "strip", catchall: A1.create(), typeName: j.ZodObject, ...l(Q) });
};
var zX = class extends d {
  _parse(X) {
    let { ctx: Q } = this._processInputParams(X), $ = this._def.options;
    function Y(W) {
      for (let G of W) if (G.result.status === "valid") return G.result;
      for (let G of W) if (G.result.status === "dirty") return Q.common.issues.push(...G.ctx.common.issues), G.result;
      let J = W.map((G) => new h0(G.ctx.common.issues));
      return b(Q, { code: A.invalid_union, unionErrors: J }), g;
    }
    if (Q.common.async) return Promise.all($.map(async (W) => {
      let J = { ...Q, common: { ...Q.common, issues: [] }, parent: null };
      return { result: await W._parseAsync({ data: Q.data, path: Q.path, parent: J }), ctx: J };
    })).then(Y);
    else {
      let W = void 0, J = [];
      for (let H of $) {
        let B = { ...Q, common: { ...Q.common, issues: [] }, parent: null }, z = H._parseSync({ data: Q.data, path: Q.path, parent: B });
        if (z.status === "valid") return z;
        else if (z.status === "dirty" && !W) W = { result: z, ctx: B };
        if (B.common.issues.length) J.push(B.common.issues);
      }
      if (W) return Q.common.issues.push(...W.ctx.common.issues), W.result;
      let G = J.map((H) => new h0(H));
      return b(Q, { code: A.invalid_union, unionErrors: G }), g;
    }
  }
  get options() {
    return this._def.options;
  }
};
zX.create = (X, Q) => {
  return new zX({ options: X, typeName: j.ZodUnion, ...l(Q) });
};
var D1 = (X) => {
  if (X instanceof UX) return D1(X.schema);
  else if (X instanceof G1) return D1(X.innerType());
  else if (X instanceof VX) return [X.value];
  else if (X instanceof s1) return X.options;
  else if (X instanceof LX) return n.objectValues(X.enum);
  else if (X instanceof qX) return D1(X._def.innerType);
  else if (X instanceof HX) return [void 0];
  else if (X instanceof BX) return [null];
  else if (X instanceof J1) return [void 0, ...D1(X.unwrap())];
  else if (X instanceof _1) return [null, ...D1(X.unwrap())];
  else if (X instanceof D9) return D1(X.unwrap());
  else if (X instanceof NX) return D1(X.unwrap());
  else if (X instanceof FX) return D1(X._def.innerType);
  else return [];
};
var O9 = class _O9 extends d {
  _parse(X) {
    let { ctx: Q } = this._processInputParams(X);
    if (Q.parsedType !== I.object) return b(Q, { code: A.invalid_type, expected: I.object, received: Q.parsedType }), g;
    let $ = this.discriminator, Y = Q.data[$], W = this.optionsMap.get(Y);
    if (!W) return b(Q, { code: A.invalid_union_discriminator, options: Array.from(this.optionsMap.keys()), path: [$] }), g;
    if (Q.common.async) return W._parseAsync({ data: Q.data, path: Q.path, parent: Q });
    else return W._parseSync({ data: Q.data, path: Q.path, parent: Q });
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(X, Q, $) {
    let Y = /* @__PURE__ */ new Map();
    for (let W of Q) {
      let J = D1(W.shape[X]);
      if (!J.length) throw Error(`A discriminator value for key \`${X}\` could not be extracted from all schema options`);
      for (let G of J) {
        if (Y.has(G)) throw Error(`Discriminator property ${String(X)} has duplicate value ${String(G)}`);
        Y.set(G, W);
      }
    }
    return new _O9({ typeName: j.ZodDiscriminatedUnion, discriminator: X, options: Q, optionsMap: Y, ...l($) });
  }
};
function N9(X, Q) {
  let $ = O1(X), Y = O1(Q);
  if (X === Q) return { valid: true, data: X };
  else if ($ === I.object && Y === I.object) {
    let W = n.objectKeys(Q), J = n.objectKeys(X).filter((H) => W.indexOf(H) !== -1), G = { ...X, ...Q };
    for (let H of J) {
      let B = N9(X[H], Q[H]);
      if (!B.valid) return { valid: false };
      G[H] = B.data;
    }
    return { valid: true, data: G };
  } else if ($ === I.array && Y === I.array) {
    if (X.length !== Q.length) return { valid: false };
    let W = [];
    for (let J = 0; J < X.length; J++) {
      let G = X[J], H = Q[J], B = N9(G, H);
      if (!B.valid) return { valid: false };
      W.push(B.data);
    }
    return { valid: true, data: W };
  } else if ($ === I.date && Y === I.date && +X === +Q) return { valid: true, data: X };
  else return { valid: false };
}
var KX = class extends d {
  _parse(X) {
    let { status: Q, ctx: $ } = this._processInputParams(X), Y = (W, J) => {
      if (L9(W) || L9(J)) return g;
      let G = N9(W.value, J.value);
      if (!G.valid) return b($, { code: A.invalid_intersection_types }), g;
      if (q9(W) || q9(J)) Q.dirty();
      return { status: Q.value, value: G.data };
    };
    if ($.common.async) return Promise.all([this._def.left._parseAsync({ data: $.data, path: $.path, parent: $ }), this._def.right._parseAsync({ data: $.data, path: $.path, parent: $ })]).then(([W, J]) => Y(W, J));
    else return Y(this._def.left._parseSync({ data: $.data, path: $.path, parent: $ }), this._def.right._parseSync({ data: $.data, path: $.path, parent: $ }));
  }
};
KX.create = (X, Q, $) => {
  return new KX({ left: X, right: Q, typeName: j.ZodIntersection, ...l($) });
};
var M1 = class _M1 extends d {
  _parse(X) {
    let { status: Q, ctx: $ } = this._processInputParams(X);
    if ($.parsedType !== I.array) return b($, { code: A.invalid_type, expected: I.array, received: $.parsedType }), g;
    if ($.data.length < this._def.items.length) return b($, { code: A.too_small, minimum: this._def.items.length, inclusive: true, exact: false, type: "array" }), g;
    if (!this._def.rest && $.data.length > this._def.items.length) b($, { code: A.too_big, maximum: this._def.items.length, inclusive: true, exact: false, type: "array" }), Q.dirty();
    let W = [...$.data].map((J, G) => {
      let H = this._def.items[G] || this._def.rest;
      if (!H) return null;
      return H._parse(new r0($, J, $.path, G));
    }).filter((J) => !!J);
    if ($.common.async) return Promise.all(W).then((J) => {
      return b0.mergeArray(Q, J);
    });
    else return b0.mergeArray(Q, W);
  }
  get items() {
    return this._def.items;
  }
  rest(X) {
    return new _M1({ ...this._def, rest: X });
  }
};
M1.create = (X, Q) => {
  if (!Array.isArray(X)) throw Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new M1({ items: X, typeName: j.ZodTuple, rest: null, ...l(Q) });
};
var M4 = class _M4 extends d {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(X) {
    let { status: Q, ctx: $ } = this._processInputParams(X);
    if ($.parsedType !== I.object) return b($, { code: A.invalid_type, expected: I.object, received: $.parsedType }), g;
    let Y = [], W = this._def.keyType, J = this._def.valueType;
    for (let G in $.data) Y.push({ key: W._parse(new r0($, G, $.path, G)), value: J._parse(new r0($, $.data[G], $.path, G)), alwaysSet: G in $.data });
    if ($.common.async) return b0.mergeObjectAsync(Q, Y);
    else return b0.mergeObjectSync(Q, Y);
  }
  get element() {
    return this._def.valueType;
  }
  static create(X, Q, $) {
    if (Q instanceof d) return new _M4({ keyType: X, valueType: Q, typeName: j.ZodRecord, ...l($) });
    return new _M4({ keyType: w1.create(), valueType: X, typeName: j.ZodRecord, ...l(Q) });
  }
};
var j4 = class extends d {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(X) {
    let { status: Q, ctx: $ } = this._processInputParams(X);
    if ($.parsedType !== I.map) return b($, { code: A.invalid_type, expected: I.map, received: $.parsedType }), g;
    let Y = this._def.keyType, W = this._def.valueType, J = [...$.data.entries()].map(([G, H], B) => {
      return { key: Y._parse(new r0($, G, $.path, [B, "key"])), value: W._parse(new r0($, H, $.path, [B, "value"])) };
    });
    if ($.common.async) {
      let G = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (let H of J) {
          let B = await H.key, z = await H.value;
          if (B.status === "aborted" || z.status === "aborted") return g;
          if (B.status === "dirty" || z.status === "dirty") Q.dirty();
          G.set(B.value, z.value);
        }
        return { status: Q.value, value: G };
      });
    } else {
      let G = /* @__PURE__ */ new Map();
      for (let H of J) {
        let { key: B, value: z } = H;
        if (B.status === "aborted" || z.status === "aborted") return g;
        if (B.status === "dirty" || z.status === "dirty") Q.dirty();
        G.set(B.value, z.value);
      }
      return { status: Q.value, value: G };
    }
  }
};
j4.create = (X, Q, $) => {
  return new j4({ valueType: Q, keyType: X, typeName: j.ZodMap, ...l($) });
};
var b6 = class _b6 extends d {
  _parse(X) {
    let { status: Q, ctx: $ } = this._processInputParams(X);
    if ($.parsedType !== I.set) return b($, { code: A.invalid_type, expected: I.set, received: $.parsedType }), g;
    let Y = this._def;
    if (Y.minSize !== null) {
      if ($.data.size < Y.minSize.value) b($, { code: A.too_small, minimum: Y.minSize.value, type: "set", inclusive: true, exact: false, message: Y.minSize.message }), Q.dirty();
    }
    if (Y.maxSize !== null) {
      if ($.data.size > Y.maxSize.value) b($, { code: A.too_big, maximum: Y.maxSize.value, type: "set", inclusive: true, exact: false, message: Y.maxSize.message }), Q.dirty();
    }
    let W = this._def.valueType;
    function J(H) {
      let B = /* @__PURE__ */ new Set();
      for (let z of H) {
        if (z.status === "aborted") return g;
        if (z.status === "dirty") Q.dirty();
        B.add(z.value);
      }
      return { status: Q.value, value: B };
    }
    let G = [...$.data.values()].map((H, B) => W._parse(new r0($, H, $.path, B)));
    if ($.common.async) return Promise.all(G).then((H) => J(H));
    else return J(G);
  }
  min(X, Q) {
    return new _b6({ ...this._def, minSize: { value: X, message: Z.toString(Q) } });
  }
  max(X, Q) {
    return new _b6({ ...this._def, maxSize: { value: X, message: Z.toString(Q) } });
  }
  size(X, Q) {
    return this.min(X, Q).max(X, Q);
  }
  nonempty(X) {
    return this.min(1, X);
  }
};
b6.create = (X, Q) => {
  return new b6({ valueType: X, minSize: null, maxSize: null, typeName: j.ZodSet, ...l(Q) });
};
var JX = class _JX extends d {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(X) {
    let { ctx: Q } = this._processInputParams(X);
    if (Q.parsedType !== I.function) return b(Q, { code: A.invalid_type, expected: I.function, received: Q.parsedType }), g;
    function $(G, H) {
      return N4({ data: G, path: Q.path, errorMaps: [Q.common.contextualErrorMap, Q.schemaErrorMap, YX(), T1].filter((B) => !!B), issueData: { code: A.invalid_arguments, argumentsError: H } });
    }
    function Y(G, H) {
      return N4({ data: G, path: Q.path, errorMaps: [Q.common.contextualErrorMap, Q.schemaErrorMap, YX(), T1].filter((B) => !!B), issueData: { code: A.invalid_return_type, returnTypeError: H } });
    }
    let W = { errorMap: Q.common.contextualErrorMap }, J = Q.data;
    if (this._def.returns instanceof P6) {
      let G = this;
      return C0(async function(...H) {
        let B = new h0([]), z = await G._def.args.parseAsync(H, W).catch((L) => {
          throw B.addIssue($(H, L)), B;
        }), K = await Reflect.apply(J, this, z);
        return await G._def.returns._def.type.parseAsync(K, W).catch((L) => {
          throw B.addIssue(Y(K, L)), B;
        });
      });
    } else {
      let G = this;
      return C0(function(...H) {
        let B = G._def.args.safeParse(H, W);
        if (!B.success) throw new h0([$(H, B.error)]);
        let z = Reflect.apply(J, this, B.data), K = G._def.returns.safeParse(z, W);
        if (!K.success) throw new h0([Y(z, K.error)]);
        return K.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...X) {
    return new _JX({ ...this._def, args: M1.create(X).rest(a1.create()) });
  }
  returns(X) {
    return new _JX({ ...this._def, returns: X });
  }
  implement(X) {
    return this.parse(X);
  }
  strictImplement(X) {
    return this.parse(X);
  }
  static create(X, Q, $) {
    return new _JX({ args: X ? X : M1.create([]).rest(a1.create()), returns: Q || a1.create(), typeName: j.ZodFunction, ...l($) });
  }
};
var UX = class extends d {
  get schema() {
    return this._def.getter();
  }
  _parse(X) {
    let { ctx: Q } = this._processInputParams(X);
    return this._def.getter()._parse({ data: Q.data, path: Q.path, parent: Q });
  }
};
UX.create = (X, Q) => {
  return new UX({ getter: X, typeName: j.ZodLazy, ...l(Q) });
};
var VX = class extends d {
  _parse(X) {
    if (X.data !== this._def.value) {
      let Q = this._getOrReturnCtx(X);
      return b(Q, { received: Q.data, code: A.invalid_literal, expected: this._def.value }), g;
    }
    return { status: "valid", value: X.data };
  }
  get value() {
    return this._def.value;
  }
};
VX.create = (X, Q) => {
  return new VX({ value: X, typeName: j.ZodLiteral, ...l(Q) });
};
function NW(X, Q) {
  return new s1({ values: X, typeName: j.ZodEnum, ...l(Q) });
}
var s1 = class _s1 extends d {
  _parse(X) {
    if (typeof X.data !== "string") {
      let Q = this._getOrReturnCtx(X), $ = this._def.values;
      return b(Q, { expected: n.joinValues($), received: Q.parsedType, code: A.invalid_type }), g;
    }
    if (!this._cache) this._cache = new Set(this._def.values);
    if (!this._cache.has(X.data)) {
      let Q = this._getOrReturnCtx(X), $ = this._def.values;
      return b(Q, { received: Q.data, code: A.invalid_enum_value, options: $ }), g;
    }
    return C0(X.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    let X = {};
    for (let Q of this._def.values) X[Q] = Q;
    return X;
  }
  get Values() {
    let X = {};
    for (let Q of this._def.values) X[Q] = Q;
    return X;
  }
  get Enum() {
    let X = {};
    for (let Q of this._def.values) X[Q] = Q;
    return X;
  }
  extract(X, Q = this._def) {
    return _s1.create(X, { ...this._def, ...Q });
  }
  exclude(X, Q = this._def) {
    return _s1.create(this.options.filter(($) => !X.includes($)), { ...this._def, ...Q });
  }
};
s1.create = NW;
var LX = class extends d {
  _parse(X) {
    let Q = n.getValidEnumValues(this._def.values), $ = this._getOrReturnCtx(X);
    if ($.parsedType !== I.string && $.parsedType !== I.number) {
      let Y = n.objectValues(Q);
      return b($, { expected: n.joinValues(Y), received: $.parsedType, code: A.invalid_type }), g;
    }
    if (!this._cache) this._cache = new Set(n.getValidEnumValues(this._def.values));
    if (!this._cache.has(X.data)) {
      let Y = n.objectValues(Q);
      return b($, { received: $.data, code: A.invalid_enum_value, options: Y }), g;
    }
    return C0(X.data);
  }
  get enum() {
    return this._def.values;
  }
};
LX.create = (X, Q) => {
  return new LX({ values: X, typeName: j.ZodNativeEnum, ...l(Q) });
};
var P6 = class extends d {
  unwrap() {
    return this._def.type;
  }
  _parse(X) {
    let { ctx: Q } = this._processInputParams(X);
    if (Q.parsedType !== I.promise && Q.common.async === false) return b(Q, { code: A.invalid_type, expected: I.promise, received: Q.parsedType }), g;
    let $ = Q.parsedType === I.promise ? Q.data : Promise.resolve(Q.data);
    return C0($.then((Y) => {
      return this._def.type.parseAsync(Y, { path: Q.path, errorMap: Q.common.contextualErrorMap });
    }));
  }
};
P6.create = (X, Q) => {
  return new P6({ type: X, typeName: j.ZodPromise, ...l(Q) });
};
var G1 = class extends d {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === j.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(X) {
    let { status: Q, ctx: $ } = this._processInputParams(X), Y = this._def.effect || null, W = { addIssue: (J) => {
      if (b($, J), J.fatal) Q.abort();
      else Q.dirty();
    }, get path() {
      return $.path;
    } };
    if (W.addIssue = W.addIssue.bind(W), Y.type === "preprocess") {
      let J = Y.transform($.data, W);
      if ($.common.async) return Promise.resolve(J).then(async (G) => {
        if (Q.value === "aborted") return g;
        let H = await this._def.schema._parseAsync({ data: G, path: $.path, parent: $ });
        if (H.status === "aborted") return g;
        if (H.status === "dirty") return j6(H.value);
        if (Q.value === "dirty") return j6(H.value);
        return H;
      });
      else {
        if (Q.value === "aborted") return g;
        let G = this._def.schema._parseSync({ data: J, path: $.path, parent: $ });
        if (G.status === "aborted") return g;
        if (G.status === "dirty") return j6(G.value);
        if (Q.value === "dirty") return j6(G.value);
        return G;
      }
    }
    if (Y.type === "refinement") {
      let J = (G) => {
        let H = Y.refinement(G, W);
        if ($.common.async) return Promise.resolve(H);
        if (H instanceof Promise) throw Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return G;
      };
      if ($.common.async === false) {
        let G = this._def.schema._parseSync({ data: $.data, path: $.path, parent: $ });
        if (G.status === "aborted") return g;
        if (G.status === "dirty") Q.dirty();
        return J(G.value), { status: Q.value, value: G.value };
      } else return this._def.schema._parseAsync({ data: $.data, path: $.path, parent: $ }).then((G) => {
        if (G.status === "aborted") return g;
        if (G.status === "dirty") Q.dirty();
        return J(G.value).then(() => {
          return { status: Q.value, value: G.value };
        });
      });
    }
    if (Y.type === "transform") if ($.common.async === false) {
      let J = this._def.schema._parseSync({ data: $.data, path: $.path, parent: $ });
      if (!t1(J)) return g;
      let G = Y.transform(J.value, W);
      if (G instanceof Promise) throw Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
      return { status: Q.value, value: G };
    } else return this._def.schema._parseAsync({ data: $.data, path: $.path, parent: $ }).then((J) => {
      if (!t1(J)) return g;
      return Promise.resolve(Y.transform(J.value, W)).then((G) => ({ status: Q.value, value: G }));
    });
    n.assertNever(Y);
  }
};
G1.create = (X, Q, $) => {
  return new G1({ schema: X, typeName: j.ZodEffects, effect: Q, ...l($) });
};
G1.createWithPreprocess = (X, Q, $) => {
  return new G1({ schema: Q, effect: { type: "preprocess", transform: X }, typeName: j.ZodEffects, ...l($) });
};
var J1 = class extends d {
  _parse(X) {
    if (this._getType(X) === I.undefined) return C0(void 0);
    return this._def.innerType._parse(X);
  }
  unwrap() {
    return this._def.innerType;
  }
};
J1.create = (X, Q) => {
  return new J1({ innerType: X, typeName: j.ZodOptional, ...l(Q) });
};
var _1 = class extends d {
  _parse(X) {
    if (this._getType(X) === I.null) return C0(null);
    return this._def.innerType._parse(X);
  }
  unwrap() {
    return this._def.innerType;
  }
};
_1.create = (X, Q) => {
  return new _1({ innerType: X, typeName: j.ZodNullable, ...l(Q) });
};
var qX = class extends d {
  _parse(X) {
    let { ctx: Q } = this._processInputParams(X), $ = Q.data;
    if (Q.parsedType === I.undefined) $ = this._def.defaultValue();
    return this._def.innerType._parse({ data: $, path: Q.path, parent: Q });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
qX.create = (X, Q) => {
  return new qX({ innerType: X, typeName: j.ZodDefault, defaultValue: typeof Q.default === "function" ? Q.default : () => Q.default, ...l(Q) });
};
var FX = class extends d {
  _parse(X) {
    let { ctx: Q } = this._processInputParams(X), $ = { ...Q, common: { ...Q.common, issues: [] } }, Y = this._def.innerType._parse({ data: $.data, path: $.path, parent: { ...$ } });
    if (WX(Y)) return Y.then((W) => {
      return { status: "valid", value: W.status === "valid" ? W.value : this._def.catchValue({ get error() {
        return new h0($.common.issues);
      }, input: $.data }) };
    });
    else return { status: "valid", value: Y.status === "valid" ? Y.value : this._def.catchValue({ get error() {
      return new h0($.common.issues);
    }, input: $.data }) };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
FX.create = (X, Q) => {
  return new FX({ innerType: X, typeName: j.ZodCatch, catchValue: typeof Q.catch === "function" ? Q.catch : () => Q.catch, ...l(Q) });
};
var R4 = class extends d {
  _parse(X) {
    if (this._getType(X) !== I.nan) {
      let $ = this._getOrReturnCtx(X);
      return b($, { code: A.invalid_type, expected: I.nan, received: $.parsedType }), g;
    }
    return { status: "valid", value: X.data };
  }
};
R4.create = (X) => {
  return new R4({ typeName: j.ZodNaN, ...l(X) });
};
var D9 = class extends d {
  _parse(X) {
    let { ctx: Q } = this._processInputParams(X), $ = Q.data;
    return this._def.type._parse({ data: $, path: Q.path, parent: Q });
  }
  unwrap() {
    return this._def.type;
  }
};
var I4 = class _I4 extends d {
  _parse(X) {
    let { status: Q, ctx: $ } = this._processInputParams(X);
    if ($.common.async) return (async () => {
      let W = await this._def.in._parseAsync({ data: $.data, path: $.path, parent: $ });
      if (W.status === "aborted") return g;
      if (W.status === "dirty") return Q.dirty(), j6(W.value);
      else return this._def.out._parseAsync({ data: W.value, path: $.path, parent: $ });
    })();
    else {
      let Y = this._def.in._parseSync({ data: $.data, path: $.path, parent: $ });
      if (Y.status === "aborted") return g;
      if (Y.status === "dirty") return Q.dirty(), { status: "dirty", value: Y.value };
      else return this._def.out._parseSync({ data: Y.value, path: $.path, parent: $ });
    }
  }
  static create(X, Q) {
    return new _I4({ in: X, out: Q, typeName: j.ZodPipeline });
  }
};
var NX = class extends d {
  _parse(X) {
    let Q = this._def.innerType._parse(X), $ = (Y) => {
      if (t1(Y)) Y.value = Object.freeze(Y.value);
      return Y;
    };
    return WX(Q) ? Q.then((Y) => $(Y)) : $(Q);
  }
  unwrap() {
    return this._def.innerType;
  }
};
NX.create = (X, Q) => {
  return new NX({ innerType: X, typeName: j.ZodReadonly, ...l(Q) });
};
var j2 = { object: V0.lazycreate };
var j;
(function(X) {
  X.ZodString = "ZodString", X.ZodNumber = "ZodNumber", X.ZodNaN = "ZodNaN", X.ZodBigInt = "ZodBigInt", X.ZodBoolean = "ZodBoolean", X.ZodDate = "ZodDate", X.ZodSymbol = "ZodSymbol", X.ZodUndefined = "ZodUndefined", X.ZodNull = "ZodNull", X.ZodAny = "ZodAny", X.ZodUnknown = "ZodUnknown", X.ZodNever = "ZodNever", X.ZodVoid = "ZodVoid", X.ZodArray = "ZodArray", X.ZodObject = "ZodObject", X.ZodUnion = "ZodUnion", X.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", X.ZodIntersection = "ZodIntersection", X.ZodTuple = "ZodTuple", X.ZodRecord = "ZodRecord", X.ZodMap = "ZodMap", X.ZodSet = "ZodSet", X.ZodFunction = "ZodFunction", X.ZodLazy = "ZodLazy", X.ZodLiteral = "ZodLiteral", X.ZodEnum = "ZodEnum", X.ZodEffects = "ZodEffects", X.ZodNativeEnum = "ZodNativeEnum", X.ZodOptional = "ZodOptional", X.ZodNullable = "ZodNullable", X.ZodDefault = "ZodDefault", X.ZodCatch = "ZodCatch", X.ZodPromise = "ZodPromise", X.ZodBranded = "ZodBranded", X.ZodPipeline = "ZodPipeline", X.ZodReadonly = "ZodReadonly";
})(j || (j = {}));
var R2 = w1.create;
var I2 = I6.create;
var E2 = R4.create;
var b2 = E6.create;
var P2 = O4.create;
var S2 = GX.create;
var Z2 = D4.create;
var C2 = HX.create;
var k2 = BX.create;
var v2 = w4.create;
var T2 = a1.create;
var _2 = A1.create;
var x2 = A4.create;
var y2 = W1.create;
var OW = V0.create;
var g2 = V0.strictCreate;
var f2 = zX.create;
var h2 = O9.create;
var u2 = KX.create;
var l2 = M1.create;
var m2 = M4.create;
var c2 = j4.create;
var p2 = b6.create;
var d2 = JX.create;
var i2 = UX.create;
var n2 = VX.create;
var r2 = s1.create;
var o2 = LX.create;
var t2 = P6.create;
var a2 = G1.create;
var s2 = J1.create;
var e2 = _1.create;
var XS = G1.createWithPreprocess;
var QS = I4.create;
var ZV = Object.freeze({ status: "aborted" });
function O(X, Q, $) {
  var _a5;
  function Y(H, B) {
    var _a6, _b;
    var z;
    Object.defineProperty(H, "_zod", { value: (_a6 = H._zod) != null ? _a6 : {}, enumerable: false }), (_b = (z = H._zod).traits) != null ? _b : z.traits = /* @__PURE__ */ new Set(), H._zod.traits.add(X), Q(H, B);
    for (let K in G.prototype) if (!(K in H)) Object.defineProperty(H, K, { value: G.prototype[K].bind(H) });
    H._zod.constr = G, H._zod.def = B;
  }
  let W = (_a5 = $ == null ? void 0 : $.Parent) != null ? _a5 : Object;
  class J extends W {
  }
  Object.defineProperty(J, "name", { value: X });
  function G(H) {
    var _a6;
    var B;
    let z = ($ == null ? void 0 : $.Parent) ? new J() : this;
    Y(z, H), (_a6 = (B = z._zod).deferred) != null ? _a6 : B.deferred = [];
    for (let K of z._zod.deferred) K();
    return z;
  }
  return Object.defineProperty(G, "init", { value: Y }), Object.defineProperty(G, Symbol.hasInstance, { value: (H) => {
    var _a6, _b;
    if (($ == null ? void 0 : $.Parent) && H instanceof $.Parent) return true;
    return (_b = (_a6 = H == null ? void 0 : H._zod) == null ? void 0 : _a6.traits) == null ? void 0 : _b.has(X);
  } }), Object.defineProperty(G, "name", { value: X }), G;
}
var x1 = class extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
};
var E4 = {};
function u0(X) {
  if (X) Object.assign(E4, X);
  return E4;
}
var i = {};
U7(i, { unwrapMessage: () => OX, stringifyPrimitive: () => S4, required: () => nV, randomString: () => fV, propertyKeyTypes: () => I9, promiseAllObject: () => gV, primitiveTypes: () => DW, prefixIssues: () => H1, pick: () => mV, partial: () => iV, optionalKeys: () => E9, omit: () => cV, numKeys: () => hV, nullish: () => AX, normalizeParams: () => y, merge: () => dV, jsonStringifyReplacer: () => A9, joinValues: () => b4, issue: () => P9, isPlainObject: () => Z6, isObject: () => S6, getSizableOrigin: () => AW, getParsedType: () => uV, getLengthableOrigin: () => jX, getEnumValues: () => DX, getElementAtPath: () => yV, floatSafeRemainder: () => M9, finalizeIssue: () => o0, extend: () => pV, escapeRegex: () => y1, esc: () => e1, defineLazy: () => Y0, createTransparentProxy: () => lV, clone: () => l0, cleanRegex: () => MX, cleanEnum: () => rV, captureStackTrace: () => P4, cached: () => wX, assignProp: () => j9, assertNotEqual: () => vV, assertNever: () => _V, assertIs: () => TV, assertEqual: () => kV, assert: () => xV, allowsEval: () => R9, aborted: () => X6, NUMBER_FORMAT_RANGES: () => b9, Class: () => MW, BIGINT_FORMAT_RANGES: () => wW });
function kV(X) {
  return X;
}
function vV(X) {
  return X;
}
function TV(X) {
}
function _V(X) {
  throw Error();
}
function xV(X) {
}
function DX(X) {
  let Q = Object.values(X).filter((Y) => typeof Y === "number");
  return Object.entries(X).filter(([Y, W]) => Q.indexOf(+Y) === -1).map(([Y, W]) => W);
}
function b4(X, Q = "|") {
  return X.map(($) => S4($)).join(Q);
}
function A9(X, Q) {
  if (typeof Q === "bigint") return Q.toString();
  return Q;
}
function wX(X) {
  return { get value() {
    {
      let $ = X();
      return Object.defineProperty(this, "value", { value: $ }), $;
    }
    throw Error("cached value already set");
  } };
}
function AX(X) {
  return X === null || X === void 0;
}
function MX(X) {
  let Q = X.startsWith("^") ? 1 : 0, $ = X.endsWith("$") ? X.length - 1 : X.length;
  return X.slice(Q, $);
}
function M9(X, Q) {
  let $ = (X.toString().split(".")[1] || "").length, Y = (Q.toString().split(".")[1] || "").length, W = $ > Y ? $ : Y, J = Number.parseInt(X.toFixed(W).replace(".", "")), G = Number.parseInt(Q.toFixed(W).replace(".", ""));
  return J % G / 10 ** W;
}
function Y0(X, Q, $) {
  Object.defineProperty(X, Q, { get() {
    {
      let W = $();
      return X[Q] = W, W;
    }
    throw Error("cached value already set");
  }, set(W) {
    Object.defineProperty(X, Q, { value: W });
  }, configurable: true });
}
function j9(X, Q, $) {
  Object.defineProperty(X, Q, { value: $, writable: true, enumerable: true, configurable: true });
}
function yV(X, Q) {
  if (!Q) return X;
  return Q.reduce(($, Y) => $ == null ? void 0 : $[Y], X);
}
function gV(X) {
  let Q = Object.keys(X), $ = Q.map((Y) => X[Y]);
  return Promise.all($).then((Y) => {
    let W = {};
    for (let J = 0; J < Q.length; J++) W[Q[J]] = Y[J];
    return W;
  });
}
function fV(X = 10) {
  let $ = "";
  for (let Y = 0; Y < X; Y++) $ += "abcdefghijklmnopqrstuvwxyz"[Math.floor(Math.random() * 26)];
  return $;
}
function e1(X) {
  return JSON.stringify(X);
}
var P4 = Error.captureStackTrace ? Error.captureStackTrace : (...X) => {
};
function S6(X) {
  return typeof X === "object" && X !== null && !Array.isArray(X);
}
var R9 = wX(() => {
  var _a5;
  if (typeof navigator < "u" && ((_a5 = navigator == null ? void 0 : navigator.userAgent) == null ? void 0 : _a5.includes("Cloudflare"))) return false;
  try {
    return new Function(""), true;
  } catch (X) {
    return false;
  }
});
function Z6(X) {
  if (S6(X) === false) return false;
  let Q = X.constructor;
  if (Q === void 0) return true;
  let $ = Q.prototype;
  if (S6($) === false) return false;
  if (Object.prototype.hasOwnProperty.call($, "isPrototypeOf") === false) return false;
  return true;
}
function hV(X) {
  let Q = 0;
  for (let $ in X) if (Object.prototype.hasOwnProperty.call(X, $)) Q++;
  return Q;
}
var uV = (X) => {
  let Q = typeof X;
  switch (Q) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(X) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(X)) return "array";
      if (X === null) return "null";
      if (X.then && typeof X.then === "function" && X.catch && typeof X.catch === "function") return "promise";
      if (typeof Map < "u" && X instanceof Map) return "map";
      if (typeof Set < "u" && X instanceof Set) return "set";
      if (typeof Date < "u" && X instanceof Date) return "date";
      if (typeof File < "u" && X instanceof File) return "file";
      return "object";
    default:
      throw Error(`Unknown data type: ${Q}`);
  }
};
var I9 = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
var DW = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function y1(X) {
  return X.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function l0(X, Q, $) {
  let Y = new X._zod.constr(Q != null ? Q : X._zod.def);
  if (!Q || ($ == null ? void 0 : $.parent)) Y._zod.parent = X;
  return Y;
}
function y(X) {
  let Q = X;
  if (!Q) return {};
  if (typeof Q === "string") return { error: () => Q };
  if ((Q == null ? void 0 : Q.message) !== void 0) {
    if ((Q == null ? void 0 : Q.error) !== void 0) throw Error("Cannot specify both `message` and `error` params");
    Q.error = Q.message;
  }
  if (delete Q.message, typeof Q.error === "string") return { ...Q, error: () => Q.error };
  return Q;
}
function lV(X) {
  let Q;
  return new Proxy({}, { get($, Y, W) {
    return Q != null ? Q : Q = X(), Reflect.get(Q, Y, W);
  }, set($, Y, W, J) {
    return Q != null ? Q : Q = X(), Reflect.set(Q, Y, W, J);
  }, has($, Y) {
    return Q != null ? Q : Q = X(), Reflect.has(Q, Y);
  }, deleteProperty($, Y) {
    return Q != null ? Q : Q = X(), Reflect.deleteProperty(Q, Y);
  }, ownKeys($) {
    return Q != null ? Q : Q = X(), Reflect.ownKeys(Q);
  }, getOwnPropertyDescriptor($, Y) {
    return Q != null ? Q : Q = X(), Reflect.getOwnPropertyDescriptor(Q, Y);
  }, defineProperty($, Y, W) {
    return Q != null ? Q : Q = X(), Reflect.defineProperty(Q, Y, W);
  } });
}
function S4(X) {
  if (typeof X === "bigint") return X.toString() + "n";
  if (typeof X === "string") return `"${X}"`;
  return `${X}`;
}
function E9(X) {
  return Object.keys(X).filter((Q) => {
    return X[Q]._zod.optin === "optional" && X[Q]._zod.optout === "optional";
  });
}
var b9 = { safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER], int32: [-2147483648, 2147483647], uint32: [0, 4294967295], float32: [-34028234663852886e22, 34028234663852886e22], float64: [-Number.MAX_VALUE, Number.MAX_VALUE] };
var wW = { int64: [BigInt("-9223372036854775808"), BigInt("9223372036854775807")], uint64: [BigInt(0), BigInt("18446744073709551615")] };
function mV(X, Q) {
  let $ = {}, Y = X._zod.def;
  for (let W in Q) {
    if (!(W in Y.shape)) throw Error(`Unrecognized key: "${W}"`);
    if (!Q[W]) continue;
    $[W] = Y.shape[W];
  }
  return l0(X, { ...X._zod.def, shape: $, checks: [] });
}
function cV(X, Q) {
  let $ = { ...X._zod.def.shape }, Y = X._zod.def;
  for (let W in Q) {
    if (!(W in Y.shape)) throw Error(`Unrecognized key: "${W}"`);
    if (!Q[W]) continue;
    delete $[W];
  }
  return l0(X, { ...X._zod.def, shape: $, checks: [] });
}
function pV(X, Q) {
  if (!Z6(Q)) throw Error("Invalid input to extend: expected a plain object");
  let $ = { ...X._zod.def, get shape() {
    let Y = { ...X._zod.def.shape, ...Q };
    return j9(this, "shape", Y), Y;
  }, checks: [] };
  return l0(X, $);
}
function dV(X, Q) {
  return l0(X, { ...X._zod.def, get shape() {
    let $ = { ...X._zod.def.shape, ...Q._zod.def.shape };
    return j9(this, "shape", $), $;
  }, catchall: Q._zod.def.catchall, checks: [] });
}
function iV(X, Q, $) {
  let Y = Q._zod.def.shape, W = { ...Y };
  if ($) for (let J in $) {
    if (!(J in Y)) throw Error(`Unrecognized key: "${J}"`);
    if (!$[J]) continue;
    W[J] = X ? new X({ type: "optional", innerType: Y[J] }) : Y[J];
  }
  else for (let J in Y) W[J] = X ? new X({ type: "optional", innerType: Y[J] }) : Y[J];
  return l0(Q, { ...Q._zod.def, shape: W, checks: [] });
}
function nV(X, Q, $) {
  let Y = Q._zod.def.shape, W = { ...Y };
  if ($) for (let J in $) {
    if (!(J in W)) throw Error(`Unrecognized key: "${J}"`);
    if (!$[J]) continue;
    W[J] = new X({ type: "nonoptional", innerType: Y[J] });
  }
  else for (let J in Y) W[J] = new X({ type: "nonoptional", innerType: Y[J] });
  return l0(Q, { ...Q._zod.def, shape: W, checks: [] });
}
function X6(X, Q = 0) {
  var _a5;
  for (let $ = Q; $ < X.issues.length; $++) if (((_a5 = X.issues[$]) == null ? void 0 : _a5.continue) !== true) return true;
  return false;
}
function H1(X, Q) {
  return Q.map(($) => {
    var _a5;
    var Y;
    return (_a5 = (Y = $).path) != null ? _a5 : Y.path = [], $.path.unshift(X), $;
  });
}
function OX(X) {
  return typeof X === "string" ? X : X == null ? void 0 : X.message;
}
function o0(X, Q, $) {
  var _a5, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
  let Y = { ...X, path: (_a5 = X.path) != null ? _a5 : [] };
  if (!X.message) {
    let W = (_k = (_j = (_h = (_f = OX((_d = (_c = (_b = X.inst) == null ? void 0 : _b._zod.def) == null ? void 0 : _c.error) == null ? void 0 : _d.call(_c, X))) != null ? _f : OX((_e = Q == null ? void 0 : Q.error) == null ? void 0 : _e.call(Q, X))) != null ? _h : OX((_g = $.customError) == null ? void 0 : _g.call($, X))) != null ? _j : OX((_i = $.localeError) == null ? void 0 : _i.call($, X))) != null ? _k : "Invalid input";
    Y.message = W;
  }
  if (delete Y.inst, delete Y.continue, !(Q == null ? void 0 : Q.reportInput)) delete Y.input;
  return Y;
}
function AW(X) {
  if (X instanceof Set) return "set";
  if (X instanceof Map) return "map";
  if (X instanceof File) return "file";
  return "unknown";
}
function jX(X) {
  if (Array.isArray(X)) return "array";
  if (typeof X === "string") return "string";
  return "unknown";
}
function P9(...X) {
  let [Q, $, Y] = X;
  if (typeof Q === "string") return { message: Q, code: "custom", input: $, inst: Y };
  return { ...Q };
}
function rV(X) {
  return Object.entries(X).filter(([Q, $]) => {
    return Number.isNaN(Number.parseInt(Q, 10));
  }).map((Q) => Q[1]);
}
var MW = class {
  constructor(...X) {
  }
};
var jW = (X, Q) => {
  X.name = "$ZodError", Object.defineProperty(X, "_zod", { value: X._zod, enumerable: false }), Object.defineProperty(X, "issues", { value: Q, enumerable: false }), Object.defineProperty(X, "message", { get() {
    return JSON.stringify(Q, A9, 2);
  }, enumerable: true });
};
var Z4 = O("$ZodError", jW);
var RX = O("$ZodError", jW, { Parent: Error });
function S9(X, Q = ($) => $.message) {
  let $ = {}, Y = [];
  for (let W of X.issues) if (W.path.length > 0) $[W.path[0]] = $[W.path[0]] || [], $[W.path[0]].push(Q(W));
  else Y.push(Q(W));
  return { formErrors: Y, fieldErrors: $ };
}
function Z9(X, Q) {
  let $ = Q || function(J) {
    return J.message;
  }, Y = { _errors: [] }, W = (J) => {
    for (let G of J.issues) if (G.code === "invalid_union" && G.errors.length) G.errors.map((H) => W({ issues: H }));
    else if (G.code === "invalid_key") W({ issues: G.issues });
    else if (G.code === "invalid_element") W({ issues: G.issues });
    else if (G.path.length === 0) Y._errors.push($(G));
    else {
      let H = Y, B = 0;
      while (B < G.path.length) {
        let z = G.path[B];
        if (B !== G.path.length - 1) H[z] = H[z] || { _errors: [] };
        else H[z] = H[z] || { _errors: [] }, H[z]._errors.push($(G));
        H = H[z], B++;
      }
    }
  };
  return W(X), Y;
}
var C9 = (X) => (Q, $, Y, W) => {
  var _a5;
  let J = Y ? Object.assign(Y, { async: false }) : { async: false }, G = Q._zod.run({ value: $, issues: [] }, J);
  if (G instanceof Promise) throw new x1();
  if (G.issues.length) {
    let H = new ((_a5 = W == null ? void 0 : W.Err) != null ? _a5 : X)(G.issues.map((B) => o0(B, J, u0())));
    throw P4(H, W == null ? void 0 : W.callee), H;
  }
  return G.value;
};
var k9 = C9(RX);
var v9 = (X) => async (Q, $, Y, W) => {
  var _a5;
  let J = Y ? Object.assign(Y, { async: true }) : { async: true }, G = Q._zod.run({ value: $, issues: [] }, J);
  if (G instanceof Promise) G = await G;
  if (G.issues.length) {
    let H = new ((_a5 = W == null ? void 0 : W.Err) != null ? _a5 : X)(G.issues.map((B) => o0(B, J, u0())));
    throw P4(H, W == null ? void 0 : W.callee), H;
  }
  return G.value;
};
var T9 = v9(RX);
var _9 = (X) => (Q, $, Y) => {
  let W = Y ? { ...Y, async: false } : { async: false }, J = Q._zod.run({ value: $, issues: [] }, W);
  if (J instanceof Promise) throw new x1();
  return J.issues.length ? { success: false, error: new (X != null ? X : Z4)(J.issues.map((G) => o0(G, W, u0()))) } : { success: true, data: J.value };
};
var Q6 = _9(RX);
var x9 = (X) => async (Q, $, Y) => {
  let W = Y ? Object.assign(Y, { async: true }) : { async: true }, J = Q._zod.run({ value: $, issues: [] }, W);
  if (J instanceof Promise) J = await J;
  return J.issues.length ? { success: false, error: new X(J.issues.map((G) => o0(G, W, u0()))) } : { success: true, data: J.value };
};
var $6 = x9(RX);
var RW = /^[cC][^\s-]{8,}$/;
var IW = /^[0-9a-z]+$/;
var EW = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var bW = /^[0-9a-vA-V]{20}$/;
var PW = /^[A-Za-z0-9]{27}$/;
var SW = /^[a-zA-Z0-9_-]{21}$/;
var ZW = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var CW = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var y9 = (X) => {
  if (!X) return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${X}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
var kW = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
function vW() {
  return new RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
}
var TW = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var _W = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;
var xW = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var yW = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var gW = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var g9 = /^[A-Za-z0-9_-]*$/;
var fW = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/;
var hW = /^\+(?:[0-9]){6,14}[0-9]$/;
var uW = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))";
var lW = new RegExp(`^${uW}$`);
function mW(X) {
  return typeof X.precision === "number" ? X.precision === -1 ? "(?:[01]\\d|2[0-3]):[0-5]\\d" : X.precision === 0 ? "(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d" : `(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d\\.\\d{${X.precision}}` : "(?:[01]\\d|2[0-3]):[0-5]\\d(?::[0-5]\\d(?:\\.\\d+)?)?";
}
function cW(X) {
  return new RegExp(`^${mW(X)}$`);
}
function pW(X) {
  let Q = mW({ precision: X.precision }), $ = ["Z"];
  if (X.local) $.push("");
  if (X.offset) $.push("([+-]\\d{2}:\\d{2})");
  let Y = `${Q}(?:${$.join("|")})`;
  return new RegExp(`^${uW}T(?:${Y})$`);
}
var dW = (X) => {
  var _a5, _b;
  let Q = X ? `[\\s\\S]{${(_a5 = X == null ? void 0 : X.minimum) != null ? _a5 : 0},${(_b = X == null ? void 0 : X.maximum) != null ? _b : ""}}` : "[\\s\\S]*";
  return new RegExp(`^${Q}$`);
};
var iW = /^\d+$/;
var nW = /^-?\d+(?:\.\d+)?/i;
var rW = /true|false/i;
var oW = /null/i;
var tW = /^[^A-Z]*$/;
var aW = /^[^a-z]*$/;
var A0 = O("$ZodCheck", (X, Q) => {
  var _a5, _b;
  var $;
  (_a5 = X._zod) != null ? _a5 : X._zod = {}, X._zod.def = Q, (_b = ($ = X._zod).onattach) != null ? _b : $.onattach = [];
});
var sW = { number: "number", bigint: "bigint", object: "date" };
var f9 = O("$ZodCheckLessThan", (X, Q) => {
  A0.init(X, Q);
  let $ = sW[typeof Q.value];
  X._zod.onattach.push((Y) => {
    var _a5;
    let W = Y._zod.bag, J = (_a5 = Q.inclusive ? W.maximum : W.exclusiveMaximum) != null ? _a5 : Number.POSITIVE_INFINITY;
    if (Q.value < J) if (Q.inclusive) W.maximum = Q.value;
    else W.exclusiveMaximum = Q.value;
  }), X._zod.check = (Y) => {
    if (Q.inclusive ? Y.value <= Q.value : Y.value < Q.value) return;
    Y.issues.push({ origin: $, code: "too_big", maximum: Q.value, input: Y.value, inclusive: Q.inclusive, inst: X, continue: !Q.abort });
  };
});
var h9 = O("$ZodCheckGreaterThan", (X, Q) => {
  A0.init(X, Q);
  let $ = sW[typeof Q.value];
  X._zod.onattach.push((Y) => {
    var _a5;
    let W = Y._zod.bag, J = (_a5 = Q.inclusive ? W.minimum : W.exclusiveMinimum) != null ? _a5 : Number.NEGATIVE_INFINITY;
    if (Q.value > J) if (Q.inclusive) W.minimum = Q.value;
    else W.exclusiveMinimum = Q.value;
  }), X._zod.check = (Y) => {
    if (Q.inclusive ? Y.value >= Q.value : Y.value > Q.value) return;
    Y.issues.push({ origin: $, code: "too_small", minimum: Q.value, input: Y.value, inclusive: Q.inclusive, inst: X, continue: !Q.abort });
  };
});
var eW = O("$ZodCheckMultipleOf", (X, Q) => {
  A0.init(X, Q), X._zod.onattach.push(($) => {
    var _a5;
    var Y;
    (_a5 = (Y = $._zod.bag).multipleOf) != null ? _a5 : Y.multipleOf = Q.value;
  }), X._zod.check = ($) => {
    if (typeof $.value !== typeof Q.value) throw Error("Cannot mix number and bigint in multiple_of check.");
    if (typeof $.value === "bigint" ? $.value % Q.value === BigInt(0) : M9($.value, Q.value) === 0) return;
    $.issues.push({ origin: typeof $.value, code: "not_multiple_of", divisor: Q.value, input: $.value, inst: X, continue: !Q.abort });
  };
});
var XJ = O("$ZodCheckNumberFormat", (X, Q) => {
  var _a5;
  A0.init(X, Q), Q.format = Q.format || "float64";
  let $ = (_a5 = Q.format) == null ? void 0 : _a5.includes("int"), Y = $ ? "int" : "number", [W, J] = b9[Q.format];
  X._zod.onattach.push((G) => {
    let H = G._zod.bag;
    if (H.format = Q.format, H.minimum = W, H.maximum = J, $) H.pattern = iW;
  }), X._zod.check = (G) => {
    let H = G.value;
    if ($) {
      if (!Number.isInteger(H)) {
        G.issues.push({ expected: Y, format: Q.format, code: "invalid_type", input: H, inst: X });
        return;
      }
      if (!Number.isSafeInteger(H)) {
        if (H > 0) G.issues.push({ input: H, code: "too_big", maximum: Number.MAX_SAFE_INTEGER, note: "Integers must be within the safe integer range.", inst: X, origin: Y, continue: !Q.abort });
        else G.issues.push({ input: H, code: "too_small", minimum: Number.MIN_SAFE_INTEGER, note: "Integers must be within the safe integer range.", inst: X, origin: Y, continue: !Q.abort });
        return;
      }
    }
    if (H < W) G.issues.push({ origin: "number", input: H, code: "too_small", minimum: W, inclusive: true, inst: X, continue: !Q.abort });
    if (H > J) G.issues.push({ origin: "number", input: H, code: "too_big", maximum: J, inst: X });
  };
});
var QJ = O("$ZodCheckMaxLength", (X, Q) => {
  A0.init(X, Q), X._zod.when = ($) => {
    let Y = $.value;
    return !AX(Y) && Y.length !== void 0;
  }, X._zod.onattach.push(($) => {
    var _a5;
    let Y = (_a5 = $._zod.bag.maximum) != null ? _a5 : Number.POSITIVE_INFINITY;
    if (Q.maximum < Y) $._zod.bag.maximum = Q.maximum;
  }), X._zod.check = ($) => {
    let Y = $.value;
    if (Y.length <= Q.maximum) return;
    let J = jX(Y);
    $.issues.push({ origin: J, code: "too_big", maximum: Q.maximum, inclusive: true, input: Y, inst: X, continue: !Q.abort });
  };
});
var $J = O("$ZodCheckMinLength", (X, Q) => {
  A0.init(X, Q), X._zod.when = ($) => {
    let Y = $.value;
    return !AX(Y) && Y.length !== void 0;
  }, X._zod.onattach.push(($) => {
    var _a5;
    let Y = (_a5 = $._zod.bag.minimum) != null ? _a5 : Number.NEGATIVE_INFINITY;
    if (Q.minimum > Y) $._zod.bag.minimum = Q.minimum;
  }), X._zod.check = ($) => {
    let Y = $.value;
    if (Y.length >= Q.minimum) return;
    let J = jX(Y);
    $.issues.push({ origin: J, code: "too_small", minimum: Q.minimum, inclusive: true, input: Y, inst: X, continue: !Q.abort });
  };
});
var YJ = O("$ZodCheckLengthEquals", (X, Q) => {
  A0.init(X, Q), X._zod.when = ($) => {
    let Y = $.value;
    return !AX(Y) && Y.length !== void 0;
  }, X._zod.onattach.push(($) => {
    let Y = $._zod.bag;
    Y.minimum = Q.length, Y.maximum = Q.length, Y.length = Q.length;
  }), X._zod.check = ($) => {
    let Y = $.value, W = Y.length;
    if (W === Q.length) return;
    let J = jX(Y), G = W > Q.length;
    $.issues.push({ origin: J, ...G ? { code: "too_big", maximum: Q.length } : { code: "too_small", minimum: Q.length }, inclusive: true, exact: true, input: $.value, inst: X, continue: !Q.abort });
  };
});
var IX = O("$ZodCheckStringFormat", (X, Q) => {
  var _a5, _b;
  var $, Y;
  if (A0.init(X, Q), X._zod.onattach.push((W) => {
    var _a6;
    let J = W._zod.bag;
    if (J.format = Q.format, Q.pattern) (_a6 = J.patterns) != null ? _a6 : J.patterns = /* @__PURE__ */ new Set(), J.patterns.add(Q.pattern);
  }), Q.pattern) (_a5 = ($ = X._zod).check) != null ? _a5 : $.check = (W) => {
    if (Q.pattern.lastIndex = 0, Q.pattern.test(W.value)) return;
    W.issues.push({ origin: "string", code: "invalid_format", format: Q.format, input: W.value, ...Q.pattern ? { pattern: Q.pattern.toString() } : {}, inst: X, continue: !Q.abort });
  };
  else (_b = (Y = X._zod).check) != null ? _b : Y.check = () => {
  };
});
var WJ = O("$ZodCheckRegex", (X, Q) => {
  IX.init(X, Q), X._zod.check = ($) => {
    if (Q.pattern.lastIndex = 0, Q.pattern.test($.value)) return;
    $.issues.push({ origin: "string", code: "invalid_format", format: "regex", input: $.value, pattern: Q.pattern.toString(), inst: X, continue: !Q.abort });
  };
});
var JJ = O("$ZodCheckLowerCase", (X, Q) => {
  var _a5;
  (_a5 = Q.pattern) != null ? _a5 : Q.pattern = tW, IX.init(X, Q);
});
var GJ = O("$ZodCheckUpperCase", (X, Q) => {
  var _a5;
  (_a5 = Q.pattern) != null ? _a5 : Q.pattern = aW, IX.init(X, Q);
});
var HJ = O("$ZodCheckIncludes", (X, Q) => {
  A0.init(X, Q);
  let $ = y1(Q.includes), Y = new RegExp(typeof Q.position === "number" ? `^.{${Q.position}}${$}` : $);
  Q.pattern = Y, X._zod.onattach.push((W) => {
    var _a5;
    let J = W._zod.bag;
    (_a5 = J.patterns) != null ? _a5 : J.patterns = /* @__PURE__ */ new Set(), J.patterns.add(Y);
  }), X._zod.check = (W) => {
    if (W.value.includes(Q.includes, Q.position)) return;
    W.issues.push({ origin: "string", code: "invalid_format", format: "includes", includes: Q.includes, input: W.value, inst: X, continue: !Q.abort });
  };
});
var BJ = O("$ZodCheckStartsWith", (X, Q) => {
  var _a5;
  A0.init(X, Q);
  let $ = new RegExp(`^${y1(Q.prefix)}.*`);
  (_a5 = Q.pattern) != null ? _a5 : Q.pattern = $, X._zod.onattach.push((Y) => {
    var _a6;
    let W = Y._zod.bag;
    (_a6 = W.patterns) != null ? _a6 : W.patterns = /* @__PURE__ */ new Set(), W.patterns.add($);
  }), X._zod.check = (Y) => {
    if (Y.value.startsWith(Q.prefix)) return;
    Y.issues.push({ origin: "string", code: "invalid_format", format: "starts_with", prefix: Q.prefix, input: Y.value, inst: X, continue: !Q.abort });
  };
});
var zJ = O("$ZodCheckEndsWith", (X, Q) => {
  var _a5;
  A0.init(X, Q);
  let $ = new RegExp(`.*${y1(Q.suffix)}$`);
  (_a5 = Q.pattern) != null ? _a5 : Q.pattern = $, X._zod.onattach.push((Y) => {
    var _a6;
    let W = Y._zod.bag;
    (_a6 = W.patterns) != null ? _a6 : W.patterns = /* @__PURE__ */ new Set(), W.patterns.add($);
  }), X._zod.check = (Y) => {
    if (Y.value.endsWith(Q.suffix)) return;
    Y.issues.push({ origin: "string", code: "invalid_format", format: "ends_with", suffix: Q.suffix, input: Y.value, inst: X, continue: !Q.abort });
  };
});
var KJ = O("$ZodCheckOverwrite", (X, Q) => {
  A0.init(X, Q), X._zod.check = ($) => {
    $.value = Q.tx($.value);
  };
});
var u9 = class {
  constructor(X = []) {
    if (this.content = [], this.indent = 0, this) this.args = X;
  }
  indented(X) {
    this.indent += 1, X(this), this.indent -= 1;
  }
  write(X) {
    if (typeof X === "function") {
      X(this, { execution: "sync" }), X(this, { execution: "async" });
      return;
    }
    let $ = X.split(`
`).filter((J) => J), Y = Math.min(...$.map((J) => J.length - J.trimStart().length)), W = $.map((J) => J.slice(Y)).map((J) => " ".repeat(this.indent * 2) + J);
    for (let J of W) this.content.push(J);
  }
  compile() {
    var _a5;
    let X = Function, Q = this == null ? void 0 : this.args, Y = [...((_a5 = this == null ? void 0 : this.content) != null ? _a5 : [""]).map((W) => `  ${W}`)];
    return new X(...Q, Y.join(`
`));
  }
};
var VJ = { major: 4, minor: 0, patch: 0 };
var X0 = O("$ZodType", (X, Q) => {
  var _a5, _b, _c;
  var $;
  X != null ? X : X = {}, X._zod.def = Q, X._zod.bag = X._zod.bag || {}, X._zod.version = VJ;
  let Y = [...(_a5 = X._zod.def.checks) != null ? _a5 : []];
  if (X._zod.traits.has("$ZodCheck")) Y.unshift(X);
  for (let W of Y) for (let J of W._zod.onattach) J(X);
  if (Y.length === 0) (_b = ($ = X._zod).deferred) != null ? _b : $.deferred = [], (_c = X._zod.deferred) == null ? void 0 : _c.push(() => {
    X._zod.run = X._zod.parse;
  });
  else {
    let W = (J, G, H) => {
      let B = X6(J), z;
      for (let K of G) {
        if (K._zod.when) {
          if (!K._zod.when(J)) continue;
        } else if (B) continue;
        let V = J.issues.length, L = K._zod.check(J);
        if (L instanceof Promise && (H == null ? void 0 : H.async) === false) throw new x1();
        if (z || L instanceof Promise) z = (z != null ? z : Promise.resolve()).then(async () => {
          if (await L, J.issues.length === V) return;
          if (!B) B = X6(J, V);
        });
        else {
          if (J.issues.length === V) continue;
          if (!B) B = X6(J, V);
        }
      }
      if (z) return z.then(() => {
        return J;
      });
      return J;
    };
    X._zod.run = (J, G) => {
      let H = X._zod.parse(J, G);
      if (H instanceof Promise) {
        if (G.async === false) throw new x1();
        return H.then((B) => W(B, Y, G));
      }
      return W(H, Y, G);
    };
  }
  X["~standard"] = { validate: (W) => {
    var _a6;
    try {
      let J = Q6(X, W);
      return J.success ? { value: J.data } : { issues: (_a6 = J.error) == null ? void 0 : _a6.issues };
    } catch (J) {
      return $6(X, W).then((G) => {
        var _a7;
        return G.success ? { value: G.data } : { issues: (_a7 = G.error) == null ? void 0 : _a7.issues };
      });
    }
  }, vendor: "zod", version: 1 };
});
var EX = O("$ZodString", (X, Q) => {
  var _a5, _b, _c;
  X0.init(X, Q), X._zod.pattern = (_c = [...(_b = (_a5 = X == null ? void 0 : X._zod.bag) == null ? void 0 : _a5.patterns) != null ? _b : []].pop()) != null ? _c : dW(X._zod.bag), X._zod.parse = ($, Y) => {
    if (Q.coerce) try {
      $.value = String($.value);
    } catch (W) {
    }
    if (typeof $.value === "string") return $;
    return $.issues.push({ expected: "string", code: "invalid_type", input: $.value, inst: X }), $;
  };
});
var W0 = O("$ZodStringFormat", (X, Q) => {
  IX.init(X, Q), EX.init(X, Q);
});
var m9 = O("$ZodGUID", (X, Q) => {
  var _a5;
  (_a5 = Q.pattern) != null ? _a5 : Q.pattern = CW, W0.init(X, Q);
});
var c9 = O("$ZodUUID", (X, Q) => {
  var _a5, _b;
  if (Q.version) {
    let Y = { v1: 1, v2: 2, v3: 3, v4: 4, v5: 5, v6: 6, v7: 7, v8: 8 }[Q.version];
    if (Y === void 0) throw Error(`Invalid UUID version: "${Q.version}"`);
    (_a5 = Q.pattern) != null ? _a5 : Q.pattern = y9(Y);
  } else (_b = Q.pattern) != null ? _b : Q.pattern = y9();
  W0.init(X, Q);
});
var p9 = O("$ZodEmail", (X, Q) => {
  var _a5;
  (_a5 = Q.pattern) != null ? _a5 : Q.pattern = kW, W0.init(X, Q);
});
var d9 = O("$ZodURL", (X, Q) => {
  W0.init(X, Q), X._zod.check = ($) => {
    try {
      let Y = $.value, W = new URL(Y), J = W.href;
      if (Q.hostname) {
        if (Q.hostname.lastIndex = 0, !Q.hostname.test(W.hostname)) $.issues.push({ code: "invalid_format", format: "url", note: "Invalid hostname", pattern: fW.source, input: $.value, inst: X, continue: !Q.abort });
      }
      if (Q.protocol) {
        if (Q.protocol.lastIndex = 0, !Q.protocol.test(W.protocol.endsWith(":") ? W.protocol.slice(0, -1) : W.protocol)) $.issues.push({ code: "invalid_format", format: "url", note: "Invalid protocol", pattern: Q.protocol.source, input: $.value, inst: X, continue: !Q.abort });
      }
      if (!Y.endsWith("/") && J.endsWith("/")) $.value = J.slice(0, -1);
      else $.value = J;
      return;
    } catch (Y) {
      $.issues.push({ code: "invalid_format", format: "url", input: $.value, inst: X, continue: !Q.abort });
    }
  };
});
var i9 = O("$ZodEmoji", (X, Q) => {
  var _a5;
  (_a5 = Q.pattern) != null ? _a5 : Q.pattern = vW(), W0.init(X, Q);
});
var n9 = O("$ZodNanoID", (X, Q) => {
  var _a5;
  (_a5 = Q.pattern) != null ? _a5 : Q.pattern = SW, W0.init(X, Q);
});
var r9 = O("$ZodCUID", (X, Q) => {
  var _a5;
  (_a5 = Q.pattern) != null ? _a5 : Q.pattern = RW, W0.init(X, Q);
});
var o9 = O("$ZodCUID2", (X, Q) => {
  var _a5;
  (_a5 = Q.pattern) != null ? _a5 : Q.pattern = IW, W0.init(X, Q);
});
var t9 = O("$ZodULID", (X, Q) => {
  var _a5;
  (_a5 = Q.pattern) != null ? _a5 : Q.pattern = EW, W0.init(X, Q);
});
var a9 = O("$ZodXID", (X, Q) => {
  var _a5;
  (_a5 = Q.pattern) != null ? _a5 : Q.pattern = bW, W0.init(X, Q);
});
var s9 = O("$ZodKSUID", (X, Q) => {
  var _a5;
  (_a5 = Q.pattern) != null ? _a5 : Q.pattern = PW, W0.init(X, Q);
});
var jJ = O("$ZodISODateTime", (X, Q) => {
  var _a5;
  (_a5 = Q.pattern) != null ? _a5 : Q.pattern = pW(Q), W0.init(X, Q);
});
var RJ = O("$ZodISODate", (X, Q) => {
  var _a5;
  (_a5 = Q.pattern) != null ? _a5 : Q.pattern = lW, W0.init(X, Q);
});
var IJ = O("$ZodISOTime", (X, Q) => {
  var _a5;
  (_a5 = Q.pattern) != null ? _a5 : Q.pattern = cW(Q), W0.init(X, Q);
});
var EJ = O("$ZodISODuration", (X, Q) => {
  var _a5;
  (_a5 = Q.pattern) != null ? _a5 : Q.pattern = ZW, W0.init(X, Q);
});
var e9 = O("$ZodIPv4", (X, Q) => {
  var _a5;
  (_a5 = Q.pattern) != null ? _a5 : Q.pattern = TW, W0.init(X, Q), X._zod.onattach.push(($) => {
    let Y = $._zod.bag;
    Y.format = "ipv4";
  });
});
var XQ = O("$ZodIPv6", (X, Q) => {
  var _a5;
  (_a5 = Q.pattern) != null ? _a5 : Q.pattern = _W, W0.init(X, Q), X._zod.onattach.push(($) => {
    let Y = $._zod.bag;
    Y.format = "ipv6";
  }), X._zod.check = ($) => {
    try {
      new URL(`http://[${$.value}]`);
    } catch (e3) {
      $.issues.push({ code: "invalid_format", format: "ipv6", input: $.value, inst: X, continue: !Q.abort });
    }
  };
});
var QQ = O("$ZodCIDRv4", (X, Q) => {
  var _a5;
  (_a5 = Q.pattern) != null ? _a5 : Q.pattern = xW, W0.init(X, Q);
});
var $Q = O("$ZodCIDRv6", (X, Q) => {
  var _a5;
  (_a5 = Q.pattern) != null ? _a5 : Q.pattern = yW, W0.init(X, Q), X._zod.check = ($) => {
    let [Y, W] = $.value.split("/");
    try {
      if (!W) throw Error();
      let J = Number(W);
      if (`${J}` !== W) throw Error();
      if (J < 0 || J > 128) throw Error();
      new URL(`http://[${Y}]`);
    } catch (e3) {
      $.issues.push({ code: "invalid_format", format: "cidrv6", input: $.value, inst: X, continue: !Q.abort });
    }
  };
});
function bJ(X) {
  if (X === "") return true;
  if (X.length % 4 !== 0) return false;
  try {
    return atob(X), true;
  } catch (e3) {
    return false;
  }
}
var YQ = O("$ZodBase64", (X, Q) => {
  var _a5;
  (_a5 = Q.pattern) != null ? _a5 : Q.pattern = gW, W0.init(X, Q), X._zod.onattach.push(($) => {
    $._zod.bag.contentEncoding = "base64";
  }), X._zod.check = ($) => {
    if (bJ($.value)) return;
    $.issues.push({ code: "invalid_format", format: "base64", input: $.value, inst: X, continue: !Q.abort });
  };
});
function tV(X) {
  if (!g9.test(X)) return false;
  let Q = X.replace(/[-_]/g, (Y) => Y === "-" ? "+" : "/"), $ = Q.padEnd(Math.ceil(Q.length / 4) * 4, "=");
  return bJ($);
}
var WQ = O("$ZodBase64URL", (X, Q) => {
  var _a5;
  (_a5 = Q.pattern) != null ? _a5 : Q.pattern = g9, W0.init(X, Q), X._zod.onattach.push(($) => {
    $._zod.bag.contentEncoding = "base64url";
  }), X._zod.check = ($) => {
    if (tV($.value)) return;
    $.issues.push({ code: "invalid_format", format: "base64url", input: $.value, inst: X, continue: !Q.abort });
  };
});
var JQ = O("$ZodE164", (X, Q) => {
  var _a5;
  (_a5 = Q.pattern) != null ? _a5 : Q.pattern = hW, W0.init(X, Q);
});
function aV(X, Q = null) {
  try {
    let $ = X.split(".");
    if ($.length !== 3) return false;
    let [Y] = $;
    if (!Y) return false;
    let W = JSON.parse(atob(Y));
    if ("typ" in W && (W == null ? void 0 : W.typ) !== "JWT") return false;
    if (!W.alg) return false;
    if (Q && (!("alg" in W) || W.alg !== Q)) return false;
    return true;
  } catch (e3) {
    return false;
  }
}
var GQ = O("$ZodJWT", (X, Q) => {
  W0.init(X, Q), X._zod.check = ($) => {
    if (aV($.value, Q.alg)) return;
    $.issues.push({ code: "invalid_format", format: "jwt", input: $.value, inst: X, continue: !Q.abort });
  };
});
var v4 = O("$ZodNumber", (X, Q) => {
  var _a5;
  X0.init(X, Q), X._zod.pattern = (_a5 = X._zod.bag.pattern) != null ? _a5 : nW, X._zod.parse = ($, Y) => {
    if (Q.coerce) try {
      $.value = Number($.value);
    } catch (G) {
    }
    let W = $.value;
    if (typeof W === "number" && !Number.isNaN(W) && Number.isFinite(W)) return $;
    let J = typeof W === "number" ? Number.isNaN(W) ? "NaN" : !Number.isFinite(W) ? "Infinity" : void 0 : void 0;
    return $.issues.push({ expected: "number", code: "invalid_type", input: W, inst: X, ...J ? { received: J } : {} }), $;
  };
});
var HQ = O("$ZodNumber", (X, Q) => {
  XJ.init(X, Q), v4.init(X, Q);
});
var BQ = O("$ZodBoolean", (X, Q) => {
  X0.init(X, Q), X._zod.pattern = rW, X._zod.parse = ($, Y) => {
    if (Q.coerce) try {
      $.value = Boolean($.value);
    } catch (J) {
    }
    let W = $.value;
    if (typeof W === "boolean") return $;
    return $.issues.push({ expected: "boolean", code: "invalid_type", input: W, inst: X }), $;
  };
});
var zQ = O("$ZodNull", (X, Q) => {
  X0.init(X, Q), X._zod.pattern = oW, X._zod.values = /* @__PURE__ */ new Set([null]), X._zod.parse = ($, Y) => {
    let W = $.value;
    if (W === null) return $;
    return $.issues.push({ expected: "null", code: "invalid_type", input: W, inst: X }), $;
  };
});
var KQ = O("$ZodUnknown", (X, Q) => {
  X0.init(X, Q), X._zod.parse = ($) => $;
});
var UQ = O("$ZodNever", (X, Q) => {
  X0.init(X, Q), X._zod.parse = ($, Y) => {
    return $.issues.push({ expected: "never", code: "invalid_type", input: $.value, inst: X }), $;
  };
});
function LJ(X, Q, $) {
  if (X.issues.length) Q.issues.push(...H1($, X.issues));
  Q.value[$] = X.value;
}
var VQ = O("$ZodArray", (X, Q) => {
  X0.init(X, Q), X._zod.parse = ($, Y) => {
    let W = $.value;
    if (!Array.isArray(W)) return $.issues.push({ expected: "array", code: "invalid_type", input: W, inst: X }), $;
    $.value = Array(W.length);
    let J = [];
    for (let G = 0; G < W.length; G++) {
      let H = W[G], B = Q.element._zod.run({ value: H, issues: [] }, Y);
      if (B instanceof Promise) J.push(B.then((z) => LJ(z, $, G)));
      else LJ(B, $, G);
    }
    if (J.length) return Promise.all(J).then(() => $);
    return $;
  };
});
function k4(X, Q, $) {
  if (X.issues.length) Q.issues.push(...H1($, X.issues));
  Q.value[$] = X.value;
}
function qJ(X, Q, $, Y) {
  if (X.issues.length) if (Y[$] === void 0) if ($ in Y) Q.value[$] = void 0;
  else Q.value[$] = X.value;
  else Q.issues.push(...H1($, X.issues));
  else if (X.value === void 0) {
    if ($ in Y) Q.value[$] = void 0;
  } else Q.value[$] = X.value;
}
var T4 = O("$ZodObject", (X, Q) => {
  X0.init(X, Q);
  let $ = wX(() => {
    let V = Object.keys(Q.shape);
    for (let U of V) if (!(Q.shape[U] instanceof X0)) throw Error(`Invalid element at key "${U}": expected a Zod schema`);
    let L = E9(Q.shape);
    return { shape: Q.shape, keys: V, keySet: new Set(V), numKeys: V.length, optionalKeys: new Set(L) };
  });
  Y0(X._zod, "propValues", () => {
    var _a5;
    let V = Q.shape, L = {};
    for (let U in V) {
      let F = V[U]._zod;
      if (F.values) {
        (_a5 = L[U]) != null ? _a5 : L[U] = /* @__PURE__ */ new Set();
        for (let q of F.values) L[U].add(q);
      }
    }
    return L;
  });
  let Y = (V) => {
    let L = new u9(["shape", "payload", "ctx"]), U = $.value, F = (M) => {
      let R = e1(M);
      return `shape[${R}]._zod.run({ value: input[${R}], issues: [] }, ctx)`;
    };
    L.write("const input = payload.value;");
    let q = /* @__PURE__ */ Object.create(null), N = 0;
    for (let M of U.keys) q[M] = `key_${N++}`;
    L.write("const newResult = {}");
    for (let M of U.keys) if (U.optionalKeys.has(M)) {
      let R = q[M];
      L.write(`const ${R} = ${F(M)};`);
      let S = e1(M);
      L.write(`
        if (${R}.issues.length) {
          if (input[${S}] === undefined) {
            if (${S} in input) {
              newResult[${S}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${R}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${S}, ...iss.path] : [${S}],
              }))
            );
          }
        } else if (${R}.value === undefined) {
          if (${S} in input) newResult[${S}] = undefined;
        } else {
          newResult[${S}] = ${R}.value;
        }
        `);
    } else {
      let R = q[M];
      L.write(`const ${R} = ${F(M)};`), L.write(`
          if (${R}.issues.length) payload.issues = payload.issues.concat(${R}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${e1(M)}, ...iss.path] : [${e1(M)}]
          })));`), L.write(`newResult[${e1(M)}] = ${R}.value`);
    }
    L.write("payload.value = newResult;"), L.write("return payload;");
    let w = L.compile();
    return (M, R) => w(V, M, R);
  }, W, J = S6, G = !E4.jitless, B = G && R9.value, z = Q.catchall, K;
  X._zod.parse = (V, L) => {
    K != null ? K : K = $.value;
    let U = V.value;
    if (!J(U)) return V.issues.push({ expected: "object", code: "invalid_type", input: U, inst: X }), V;
    let F = [];
    if (G && B && (L == null ? void 0 : L.async) === false && L.jitless !== true) {
      if (!W) W = Y(Q.shape);
      V = W(V, L);
    } else {
      V.value = {};
      let R = K.shape;
      for (let S of K.keys) {
        let C = R[S], K0 = C._zod.run({ value: U[S], issues: [] }, L), U0 = C._zod.optin === "optional" && C._zod.optout === "optional";
        if (K0 instanceof Promise) F.push(K0.then((s) => U0 ? qJ(s, V, S, U) : k4(s, V, S)));
        else if (U0) qJ(K0, V, S, U);
        else k4(K0, V, S);
      }
    }
    if (!z) return F.length ? Promise.all(F).then(() => V) : V;
    let q = [], N = K.keySet, w = z._zod, M = w.def.type;
    for (let R of Object.keys(U)) {
      if (N.has(R)) continue;
      if (M === "never") {
        q.push(R);
        continue;
      }
      let S = w.run({ value: U[R], issues: [] }, L);
      if (S instanceof Promise) F.push(S.then((C) => k4(C, V, R)));
      else k4(S, V, R);
    }
    if (q.length) V.issues.push({ code: "unrecognized_keys", keys: q, input: U, inst: X });
    if (!F.length) return V;
    return Promise.all(F).then(() => {
      return V;
    });
  };
});
function FJ(X, Q, $, Y) {
  for (let W of X) if (W.issues.length === 0) return Q.value = W.value, Q;
  return Q.issues.push({ code: "invalid_union", input: Q.value, inst: $, errors: X.map((W) => W.issues.map((J) => o0(J, Y, u0()))) }), Q;
}
var _4 = O("$ZodUnion", (X, Q) => {
  X0.init(X, Q), Y0(X._zod, "optin", () => Q.options.some(($) => $._zod.optin === "optional") ? "optional" : void 0), Y0(X._zod, "optout", () => Q.options.some(($) => $._zod.optout === "optional") ? "optional" : void 0), Y0(X._zod, "values", () => {
    if (Q.options.every(($) => $._zod.values)) return new Set(Q.options.flatMap(($) => Array.from($._zod.values)));
    return;
  }), Y0(X._zod, "pattern", () => {
    if (Q.options.every(($) => $._zod.pattern)) {
      let $ = Q.options.map((Y) => Y._zod.pattern);
      return new RegExp(`^(${$.map((Y) => MX(Y.source)).join("|")})$`);
    }
    return;
  }), X._zod.parse = ($, Y) => {
    let W = false, J = [];
    for (let G of Q.options) {
      let H = G._zod.run({ value: $.value, issues: [] }, Y);
      if (H instanceof Promise) J.push(H), W = true;
      else {
        if (H.issues.length === 0) return H;
        J.push(H);
      }
    }
    if (!W) return FJ(J, $, X, Y);
    return Promise.all(J).then((G) => {
      return FJ(G, $, X, Y);
    });
  };
});
var LQ = O("$ZodDiscriminatedUnion", (X, Q) => {
  _4.init(X, Q);
  let $ = X._zod.parse;
  Y0(X._zod, "propValues", () => {
    let W = {};
    for (let J of Q.options) {
      let G = J._zod.propValues;
      if (!G || Object.keys(G).length === 0) throw Error(`Invalid discriminated union option at index "${Q.options.indexOf(J)}"`);
      for (let [H, B] of Object.entries(G)) {
        if (!W[H]) W[H] = /* @__PURE__ */ new Set();
        for (let z of B) W[H].add(z);
      }
    }
    return W;
  });
  let Y = wX(() => {
    let W = Q.options, J = /* @__PURE__ */ new Map();
    for (let G of W) {
      let H = G._zod.propValues[Q.discriminator];
      if (!H || H.size === 0) throw Error(`Invalid discriminated union option at index "${Q.options.indexOf(G)}"`);
      for (let B of H) {
        if (J.has(B)) throw Error(`Duplicate discriminator value "${String(B)}"`);
        J.set(B, G);
      }
    }
    return J;
  });
  X._zod.parse = (W, J) => {
    let G = W.value;
    if (!S6(G)) return W.issues.push({ code: "invalid_type", expected: "object", input: G, inst: X }), W;
    let H = Y.value.get(G == null ? void 0 : G[Q.discriminator]);
    if (H) return H._zod.run(W, J);
    if (Q.unionFallback) return $(W, J);
    return W.issues.push({ code: "invalid_union", errors: [], note: "No matching discriminator", input: G, path: [Q.discriminator], inst: X }), W;
  };
});
var qQ = O("$ZodIntersection", (X, Q) => {
  X0.init(X, Q), X._zod.parse = ($, Y) => {
    let W = $.value, J = Q.left._zod.run({ value: W, issues: [] }, Y), G = Q.right._zod.run({ value: W, issues: [] }, Y);
    if (J instanceof Promise || G instanceof Promise) return Promise.all([J, G]).then(([B, z]) => {
      return NJ($, B, z);
    });
    return NJ($, J, G);
  };
});
function l9(X, Q) {
  if (X === Q) return { valid: true, data: X };
  if (X instanceof Date && Q instanceof Date && +X === +Q) return { valid: true, data: X };
  if (Z6(X) && Z6(Q)) {
    let $ = Object.keys(Q), Y = Object.keys(X).filter((J) => $.indexOf(J) !== -1), W = { ...X, ...Q };
    for (let J of Y) {
      let G = l9(X[J], Q[J]);
      if (!G.valid) return { valid: false, mergeErrorPath: [J, ...G.mergeErrorPath] };
      W[J] = G.data;
    }
    return { valid: true, data: W };
  }
  if (Array.isArray(X) && Array.isArray(Q)) {
    if (X.length !== Q.length) return { valid: false, mergeErrorPath: [] };
    let $ = [];
    for (let Y = 0; Y < X.length; Y++) {
      let W = X[Y], J = Q[Y], G = l9(W, J);
      if (!G.valid) return { valid: false, mergeErrorPath: [Y, ...G.mergeErrorPath] };
      $.push(G.data);
    }
    return { valid: true, data: $ };
  }
  return { valid: false, mergeErrorPath: [] };
}
function NJ(X, Q, $) {
  if (Q.issues.length) X.issues.push(...Q.issues);
  if ($.issues.length) X.issues.push(...$.issues);
  if (X6(X)) return X;
  let Y = l9(Q.value, $.value);
  if (!Y.valid) throw Error(`Unmergable intersection. Error path: ${JSON.stringify(Y.mergeErrorPath)}`);
  return X.value = Y.data, X;
}
var FQ = O("$ZodRecord", (X, Q) => {
  X0.init(X, Q), X._zod.parse = ($, Y) => {
    let W = $.value;
    if (!Z6(W)) return $.issues.push({ expected: "record", code: "invalid_type", input: W, inst: X }), $;
    let J = [];
    if (Q.keyType._zod.values) {
      let G = Q.keyType._zod.values;
      $.value = {};
      for (let B of G) if (typeof B === "string" || typeof B === "number" || typeof B === "symbol") {
        let z = Q.valueType._zod.run({ value: W[B], issues: [] }, Y);
        if (z instanceof Promise) J.push(z.then((K) => {
          if (K.issues.length) $.issues.push(...H1(B, K.issues));
          $.value[B] = K.value;
        }));
        else {
          if (z.issues.length) $.issues.push(...H1(B, z.issues));
          $.value[B] = z.value;
        }
      }
      let H;
      for (let B in W) if (!G.has(B)) H = H != null ? H : [], H.push(B);
      if (H && H.length > 0) $.issues.push({ code: "unrecognized_keys", input: W, inst: X, keys: H });
    } else {
      $.value = {};
      for (let G of Reflect.ownKeys(W)) {
        if (G === "__proto__") continue;
        let H = Q.keyType._zod.run({ value: G, issues: [] }, Y);
        if (H instanceof Promise) throw Error("Async schemas not supported in object keys currently");
        if (H.issues.length) {
          $.issues.push({ origin: "record", code: "invalid_key", issues: H.issues.map((z) => o0(z, Y, u0())), input: G, path: [G], inst: X }), $.value[H.value] = H.value;
          continue;
        }
        let B = Q.valueType._zod.run({ value: W[G], issues: [] }, Y);
        if (B instanceof Promise) J.push(B.then((z) => {
          if (z.issues.length) $.issues.push(...H1(G, z.issues));
          $.value[H.value] = z.value;
        }));
        else {
          if (B.issues.length) $.issues.push(...H1(G, B.issues));
          $.value[H.value] = B.value;
        }
      }
    }
    if (J.length) return Promise.all(J).then(() => $);
    return $;
  };
});
var NQ = O("$ZodEnum", (X, Q) => {
  X0.init(X, Q);
  let $ = DX(Q.entries);
  X._zod.values = new Set($), X._zod.pattern = new RegExp(`^(${$.filter((Y) => I9.has(typeof Y)).map((Y) => typeof Y === "string" ? y1(Y) : Y.toString()).join("|")})$`), X._zod.parse = (Y, W) => {
    let J = Y.value;
    if (X._zod.values.has(J)) return Y;
    return Y.issues.push({ code: "invalid_value", values: $, input: J, inst: X }), Y;
  };
});
var OQ = O("$ZodLiteral", (X, Q) => {
  X0.init(X, Q), X._zod.values = new Set(Q.values), X._zod.pattern = new RegExp(`^(${Q.values.map(($) => typeof $ === "string" ? y1($) : $ ? $.toString() : String($)).join("|")})$`), X._zod.parse = ($, Y) => {
    let W = $.value;
    if (X._zod.values.has(W)) return $;
    return $.issues.push({ code: "invalid_value", values: Q.values, input: W, inst: X }), $;
  };
});
var DQ = O("$ZodTransform", (X, Q) => {
  X0.init(X, Q), X._zod.parse = ($, Y) => {
    let W = Q.transform($.value, $);
    if (Y.async) return (W instanceof Promise ? W : Promise.resolve(W)).then((G) => {
      return $.value = G, $;
    });
    if (W instanceof Promise) throw new x1();
    return $.value = W, $;
  };
});
var wQ = O("$ZodOptional", (X, Q) => {
  X0.init(X, Q), X._zod.optin = "optional", X._zod.optout = "optional", Y0(X._zod, "values", () => {
    return Q.innerType._zod.values ? /* @__PURE__ */ new Set([...Q.innerType._zod.values, void 0]) : void 0;
  }), Y0(X._zod, "pattern", () => {
    let $ = Q.innerType._zod.pattern;
    return $ ? new RegExp(`^(${MX($.source)})?$`) : void 0;
  }), X._zod.parse = ($, Y) => {
    if (Q.innerType._zod.optin === "optional") return Q.innerType._zod.run($, Y);
    if ($.value === void 0) return $;
    return Q.innerType._zod.run($, Y);
  };
});
var AQ = O("$ZodNullable", (X, Q) => {
  X0.init(X, Q), Y0(X._zod, "optin", () => Q.innerType._zod.optin), Y0(X._zod, "optout", () => Q.innerType._zod.optout), Y0(X._zod, "pattern", () => {
    let $ = Q.innerType._zod.pattern;
    return $ ? new RegExp(`^(${MX($.source)}|null)$`) : void 0;
  }), Y0(X._zod, "values", () => {
    return Q.innerType._zod.values ? /* @__PURE__ */ new Set([...Q.innerType._zod.values, null]) : void 0;
  }), X._zod.parse = ($, Y) => {
    if ($.value === null) return $;
    return Q.innerType._zod.run($, Y);
  };
});
var MQ = O("$ZodDefault", (X, Q) => {
  X0.init(X, Q), X._zod.optin = "optional", Y0(X._zod, "values", () => Q.innerType._zod.values), X._zod.parse = ($, Y) => {
    if ($.value === void 0) return $.value = Q.defaultValue, $;
    let W = Q.innerType._zod.run($, Y);
    if (W instanceof Promise) return W.then((J) => OJ(J, Q));
    return OJ(W, Q);
  };
});
function OJ(X, Q) {
  if (X.value === void 0) X.value = Q.defaultValue;
  return X;
}
var jQ = O("$ZodPrefault", (X, Q) => {
  X0.init(X, Q), X._zod.optin = "optional", Y0(X._zod, "values", () => Q.innerType._zod.values), X._zod.parse = ($, Y) => {
    if ($.value === void 0) $.value = Q.defaultValue;
    return Q.innerType._zod.run($, Y);
  };
});
var RQ = O("$ZodNonOptional", (X, Q) => {
  X0.init(X, Q), Y0(X._zod, "values", () => {
    let $ = Q.innerType._zod.values;
    return $ ? new Set([...$].filter((Y) => Y !== void 0)) : void 0;
  }), X._zod.parse = ($, Y) => {
    let W = Q.innerType._zod.run($, Y);
    if (W instanceof Promise) return W.then((J) => DJ(J, X));
    return DJ(W, X);
  };
});
function DJ(X, Q) {
  if (!X.issues.length && X.value === void 0) X.issues.push({ code: "invalid_type", expected: "nonoptional", input: X.value, inst: Q });
  return X;
}
var IQ = O("$ZodCatch", (X, Q) => {
  X0.init(X, Q), X._zod.optin = "optional", Y0(X._zod, "optout", () => Q.innerType._zod.optout), Y0(X._zod, "values", () => Q.innerType._zod.values), X._zod.parse = ($, Y) => {
    let W = Q.innerType._zod.run($, Y);
    if (W instanceof Promise) return W.then((J) => {
      if ($.value = J.value, J.issues.length) $.value = Q.catchValue({ ...$, error: { issues: J.issues.map((G) => o0(G, Y, u0())) }, input: $.value }), $.issues = [];
      return $;
    });
    if ($.value = W.value, W.issues.length) $.value = Q.catchValue({ ...$, error: { issues: W.issues.map((J) => o0(J, Y, u0())) }, input: $.value }), $.issues = [];
    return $;
  };
});
var EQ = O("$ZodPipe", (X, Q) => {
  X0.init(X, Q), Y0(X._zod, "values", () => Q.in._zod.values), Y0(X._zod, "optin", () => Q.in._zod.optin), Y0(X._zod, "optout", () => Q.out._zod.optout), X._zod.parse = ($, Y) => {
    let W = Q.in._zod.run($, Y);
    if (W instanceof Promise) return W.then((J) => wJ(J, Q, Y));
    return wJ(W, Q, Y);
  };
});
function wJ(X, Q, $) {
  if (X6(X)) return X;
  return Q.out._zod.run({ value: X.value, issues: X.issues }, $);
}
var bQ = O("$ZodReadonly", (X, Q) => {
  X0.init(X, Q), Y0(X._zod, "propValues", () => Q.innerType._zod.propValues), Y0(X._zod, "values", () => Q.innerType._zod.values), Y0(X._zod, "optin", () => Q.innerType._zod.optin), Y0(X._zod, "optout", () => Q.innerType._zod.optout), X._zod.parse = ($, Y) => {
    let W = Q.innerType._zod.run($, Y);
    if (W instanceof Promise) return W.then(AJ);
    return AJ(W);
  };
});
function AJ(X) {
  return X.value = Object.freeze(X.value), X;
}
var PQ = O("$ZodCustom", (X, Q) => {
  A0.init(X, Q), X0.init(X, Q), X._zod.parse = ($, Y) => {
    return $;
  }, X._zod.check = ($) => {
    let Y = $.value, W = Q.fn(Y);
    if (W instanceof Promise) return W.then((J) => MJ(J, $, Y, X));
    MJ(W, $, Y, X);
    return;
  };
});
function MJ(X, Q, $, Y) {
  var _a5;
  if (!X) {
    let W = { code: "custom", input: $, inst: Y, path: [...(_a5 = Y._zod.def.path) != null ? _a5 : []], continue: !Y._zod.def.abort };
    if (Y._zod.def.params) W.params = Y._zod.def.params;
    Q.issues.push(P9(W));
  }
}
var sV = (X) => {
  let Q = typeof X;
  switch (Q) {
    case "number":
      return Number.isNaN(X) ? "NaN" : "number";
    case "object": {
      if (Array.isArray(X)) return "array";
      if (X === null) return "null";
      if (Object.getPrototypeOf(X) !== Object.prototype && X.constructor) return X.constructor.name;
    }
  }
  return Q;
};
var eV = () => {
  let X = { string: { unit: "characters", verb: "to have" }, file: { unit: "bytes", verb: "to have" }, array: { unit: "items", verb: "to have" }, set: { unit: "items", verb: "to have" } };
  function Q(Y) {
    var _a5;
    return (_a5 = X[Y]) != null ? _a5 : null;
  }
  let $ = { regex: "input", email: "email address", url: "URL", emoji: "emoji", uuid: "UUID", uuidv4: "UUIDv4", uuidv6: "UUIDv6", nanoid: "nanoid", guid: "GUID", cuid: "cuid", cuid2: "cuid2", ulid: "ULID", xid: "XID", ksuid: "KSUID", datetime: "ISO datetime", date: "ISO date", time: "ISO time", duration: "ISO duration", ipv4: "IPv4 address", ipv6: "IPv6 address", cidrv4: "IPv4 range", cidrv6: "IPv6 range", base64: "base64-encoded string", base64url: "base64url-encoded string", json_string: "JSON string", e164: "E.164 number", jwt: "JWT", template_literal: "input" };
  return (Y) => {
    var _a5, _b, _c, _d;
    switch (Y.code) {
      case "invalid_type":
        return `Invalid input: expected ${Y.expected}, received ${sV(Y.input)}`;
      case "invalid_value":
        if (Y.values.length === 1) return `Invalid input: expected ${S4(Y.values[0])}`;
        return `Invalid option: expected one of ${b4(Y.values, "|")}`;
      case "too_big": {
        let W = Y.inclusive ? "<=" : "<", J = Q(Y.origin);
        if (J) return `Too big: expected ${(_a5 = Y.origin) != null ? _a5 : "value"} to have ${W}${Y.maximum.toString()} ${(_b = J.unit) != null ? _b : "elements"}`;
        return `Too big: expected ${(_c = Y.origin) != null ? _c : "value"} to be ${W}${Y.maximum.toString()}`;
      }
      case "too_small": {
        let W = Y.inclusive ? ">=" : ">", J = Q(Y.origin);
        if (J) return `Too small: expected ${Y.origin} to have ${W}${Y.minimum.toString()} ${J.unit}`;
        return `Too small: expected ${Y.origin} to be ${W}${Y.minimum.toString()}`;
      }
      case "invalid_format": {
        let W = Y;
        if (W.format === "starts_with") return `Invalid string: must start with "${W.prefix}"`;
        if (W.format === "ends_with") return `Invalid string: must end with "${W.suffix}"`;
        if (W.format === "includes") return `Invalid string: must include "${W.includes}"`;
        if (W.format === "regex") return `Invalid string: must match pattern ${W.pattern}`;
        return `Invalid ${(_d = $[W.format]) != null ? _d : Y.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${Y.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${Y.keys.length > 1 ? "s" : ""}: ${b4(Y.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${Y.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${Y.origin}`;
      default:
        return "Invalid input";
    }
  };
};
function SQ() {
  return { localeError: eV() };
}
var x4 = class {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map();
  }
  add(X, ...Q) {
    let $ = Q[0];
    if (this._map.set(X, $), $ && typeof $ === "object" && "id" in $) {
      if (this._idmap.has($.id)) throw Error(`ID ${$.id} already exists in the registry`);
      this._idmap.set($.id, X);
    }
    return this;
  }
  remove(X) {
    return this._map.delete(X), this;
  }
  get(X) {
    var _a5;
    let Q = X._zod.parent;
    if (Q) {
      let $ = { ...(_a5 = this.get(Q)) != null ? _a5 : {} };
      return delete $.id, { ...$, ...this._map.get(X) };
    }
    return this._map.get(X);
  }
  has(X) {
    return this._map.has(X);
  }
};
function PJ() {
  return new x4();
}
var g1 = PJ();
function ZQ(X, Q) {
  return new X({ type: "string", ...y(Q) });
}
function CQ(X, Q) {
  return new X({ type: "string", format: "email", check: "string_format", abort: false, ...y(Q) });
}
function y4(X, Q) {
  return new X({ type: "string", format: "guid", check: "string_format", abort: false, ...y(Q) });
}
function kQ(X, Q) {
  return new X({ type: "string", format: "uuid", check: "string_format", abort: false, ...y(Q) });
}
function vQ(X, Q) {
  return new X({ type: "string", format: "uuid", check: "string_format", abort: false, version: "v4", ...y(Q) });
}
function TQ(X, Q) {
  return new X({ type: "string", format: "uuid", check: "string_format", abort: false, version: "v6", ...y(Q) });
}
function _Q(X, Q) {
  return new X({ type: "string", format: "uuid", check: "string_format", abort: false, version: "v7", ...y(Q) });
}
function xQ(X, Q) {
  return new X({ type: "string", format: "url", check: "string_format", abort: false, ...y(Q) });
}
function yQ(X, Q) {
  return new X({ type: "string", format: "emoji", check: "string_format", abort: false, ...y(Q) });
}
function gQ(X, Q) {
  return new X({ type: "string", format: "nanoid", check: "string_format", abort: false, ...y(Q) });
}
function fQ(X, Q) {
  return new X({ type: "string", format: "cuid", check: "string_format", abort: false, ...y(Q) });
}
function hQ(X, Q) {
  return new X({ type: "string", format: "cuid2", check: "string_format", abort: false, ...y(Q) });
}
function uQ(X, Q) {
  return new X({ type: "string", format: "ulid", check: "string_format", abort: false, ...y(Q) });
}
function lQ(X, Q) {
  return new X({ type: "string", format: "xid", check: "string_format", abort: false, ...y(Q) });
}
function mQ(X, Q) {
  return new X({ type: "string", format: "ksuid", check: "string_format", abort: false, ...y(Q) });
}
function cQ(X, Q) {
  return new X({ type: "string", format: "ipv4", check: "string_format", abort: false, ...y(Q) });
}
function pQ(X, Q) {
  return new X({ type: "string", format: "ipv6", check: "string_format", abort: false, ...y(Q) });
}
function dQ(X, Q) {
  return new X({ type: "string", format: "cidrv4", check: "string_format", abort: false, ...y(Q) });
}
function iQ(X, Q) {
  return new X({ type: "string", format: "cidrv6", check: "string_format", abort: false, ...y(Q) });
}
function nQ(X, Q) {
  return new X({ type: "string", format: "base64", check: "string_format", abort: false, ...y(Q) });
}
function rQ(X, Q) {
  return new X({ type: "string", format: "base64url", check: "string_format", abort: false, ...y(Q) });
}
function oQ(X, Q) {
  return new X({ type: "string", format: "e164", check: "string_format", abort: false, ...y(Q) });
}
function tQ(X, Q) {
  return new X({ type: "string", format: "jwt", check: "string_format", abort: false, ...y(Q) });
}
function SJ(X, Q) {
  return new X({ type: "string", format: "datetime", check: "string_format", offset: false, local: false, precision: null, ...y(Q) });
}
function ZJ(X, Q) {
  return new X({ type: "string", format: "date", check: "string_format", ...y(Q) });
}
function CJ(X, Q) {
  return new X({ type: "string", format: "time", check: "string_format", precision: null, ...y(Q) });
}
function kJ(X, Q) {
  return new X({ type: "string", format: "duration", check: "string_format", ...y(Q) });
}
function aQ(X, Q) {
  return new X({ type: "number", checks: [], ...y(Q) });
}
function sQ(X, Q) {
  return new X({ type: "number", check: "number_format", abort: false, format: "safeint", ...y(Q) });
}
function eQ(X, Q) {
  return new X({ type: "boolean", ...y(Q) });
}
function X$(X, Q) {
  return new X({ type: "null", ...y(Q) });
}
function Q$(X) {
  return new X({ type: "unknown" });
}
function $$(X, Q) {
  return new X({ type: "never", ...y(Q) });
}
function g4(X, Q) {
  return new f9({ check: "less_than", ...y(Q), value: X, inclusive: false });
}
function bX(X, Q) {
  return new f9({ check: "less_than", ...y(Q), value: X, inclusive: true });
}
function f4(X, Q) {
  return new h9({ check: "greater_than", ...y(Q), value: X, inclusive: false });
}
function PX(X, Q) {
  return new h9({ check: "greater_than", ...y(Q), value: X, inclusive: true });
}
function h4(X, Q) {
  return new eW({ check: "multiple_of", ...y(Q), value: X });
}
function u4(X, Q) {
  return new QJ({ check: "max_length", ...y(Q), maximum: X });
}
function C6(X, Q) {
  return new $J({ check: "min_length", ...y(Q), minimum: X });
}
function l4(X, Q) {
  return new YJ({ check: "length_equals", ...y(Q), length: X });
}
function Y$(X, Q) {
  return new WJ({ check: "string_format", format: "regex", ...y(Q), pattern: X });
}
function W$(X) {
  return new JJ({ check: "string_format", format: "lowercase", ...y(X) });
}
function J$(X) {
  return new GJ({ check: "string_format", format: "uppercase", ...y(X) });
}
function G$(X, Q) {
  return new HJ({ check: "string_format", format: "includes", ...y(Q), includes: X });
}
function H$(X, Q) {
  return new BJ({ check: "string_format", format: "starts_with", ...y(Q), prefix: X });
}
function B$(X, Q) {
  return new zJ({ check: "string_format", format: "ends_with", ...y(Q), suffix: X });
}
function Y6(X) {
  return new KJ({ check: "overwrite", tx: X });
}
function z$(X) {
  return Y6((Q) => Q.normalize(X));
}
function K$() {
  return Y6((X) => X.trim());
}
function U$() {
  return Y6((X) => X.toLowerCase());
}
function V$() {
  return Y6((X) => X.toUpperCase());
}
function vJ(X, Q, $) {
  return new X({ type: "array", element: Q, ...y($) });
}
function L$(X, Q, $) {
  var _a5;
  let Y = y($);
  return (_a5 = Y.abort) != null ? _a5 : Y.abort = true, new X({ type: "custom", check: "custom", fn: Q, ...Y });
}
function q$(X, Q, $) {
  return new X({ type: "custom", check: "custom", fn: Q, ...y($) });
}
var yL = O("ZodMiniType", (X, Q) => {
  if (!X._zod) throw Error("Uninitialized schema in ZodMiniType.");
  X0.init(X, Q), X.def = Q, X.parse = ($, Y) => k9(X, $, Y, { callee: X.parse }), X.safeParse = ($, Y) => Q6(X, $, Y), X.parseAsync = async ($, Y) => T9(X, $, Y, { callee: X.parseAsync }), X.safeParseAsync = async ($, Y) => $6(X, $, Y), X.check = (...$) => {
    var _a5;
    return X.clone({ ...Q, checks: [...(_a5 = Q.checks) != null ? _a5 : [], ...$.map((Y) => typeof Y === "function" ? { _zod: { check: Y, def: { check: "custom" }, onattach: [] } } : Y)] });
  }, X.clone = ($, Y) => l0(X, $, Y), X.brand = () => X, X.register = ($, Y) => {
    return $.add(X, Y), X;
  };
});
var gL = O("ZodMiniObject", (X, Q) => {
  T4.init(X, Q), yL.init(X, Q), i.defineLazy(X, "shape", () => Q.shape);
});
var SX = {};
U7(SX, { time: () => A$, duration: () => M$, datetime: () => D$, date: () => w$, ZodISOTime: () => fJ, ZodISODuration: () => hJ, ZodISODateTime: () => yJ, ZodISODate: () => gJ });
var yJ = O("ZodISODateTime", (X, Q) => {
  jJ.init(X, Q), H0.init(X, Q);
});
function D$(X) {
  return SJ(yJ, X);
}
var gJ = O("ZodISODate", (X, Q) => {
  RJ.init(X, Q), H0.init(X, Q);
});
function w$(X) {
  return ZJ(gJ, X);
}
var fJ = O("ZodISOTime", (X, Q) => {
  IJ.init(X, Q), H0.init(X, Q);
});
function A$(X) {
  return CJ(fJ, X);
}
var hJ = O("ZodISODuration", (X, Q) => {
  EJ.init(X, Q), H0.init(X, Q);
});
function M$(X) {
  return kJ(hJ, X);
}
var uJ = (X, Q) => {
  Z4.init(X, Q), X.name = "ZodError", Object.defineProperties(X, { format: { value: ($) => Z9(X, $) }, flatten: { value: ($) => S9(X, $) }, addIssue: { value: ($) => X.issues.push($) }, addIssues: { value: ($) => X.issues.push(...$) }, isEmpty: { get() {
    return X.issues.length === 0;
  } } });
};
var HZ = O("ZodError", uJ);
var ZX = O("ZodError", uJ, { Parent: Error });
var lJ = C9(ZX);
var mJ = v9(ZX);
var cJ = _9(ZX);
var pJ = x9(ZX);
var z0 = O("ZodType", (X, Q) => {
  return X0.init(X, Q), X.def = Q, Object.defineProperty(X, "_def", { value: Q }), X.check = (...$) => {
    var _a5;
    return X.clone({ ...Q, checks: [...(_a5 = Q.checks) != null ? _a5 : [], ...$.map((Y) => typeof Y === "function" ? { _zod: { check: Y, def: { check: "custom" }, onattach: [] } } : Y)] });
  }, X.clone = ($, Y) => l0(X, $, Y), X.brand = () => X, X.register = ($, Y) => {
    return $.add(X, Y), X;
  }, X.parse = ($, Y) => lJ(X, $, Y, { callee: X.parse }), X.safeParse = ($, Y) => cJ(X, $, Y), X.parseAsync = async ($, Y) => mJ(X, $, Y, { callee: X.parseAsync }), X.safeParseAsync = async ($, Y) => pJ(X, $, Y), X.spa = X.safeParseAsync, X.refine = ($, Y) => X.check(_q($, Y)), X.superRefine = ($) => X.check(xq($)), X.overwrite = ($) => X.check(Y6($)), X.optional = () => v(X), X.nullable = () => nJ(X), X.nullish = () => v(nJ(X)), X.nonoptional = ($) => Pq(X, $), X.array = () => r(X), X.or = ($) => J0([X, $]), X.and = ($) => i4(X, $), X.transform = ($) => R$(X, sJ($)), X.default = ($) => Iq(X, $), X.prefault = ($) => bq(X, $), X.catch = ($) => Zq(X, $), X.pipe = ($) => R$(X, $), X.readonly = () => vq(X), X.describe = ($) => {
    let Y = X.clone();
    return g1.add(Y, { description: $ }), Y;
  }, Object.defineProperty(X, "description", { get() {
    var _a5;
    return (_a5 = g1.get(X)) == null ? void 0 : _a5.description;
  }, configurable: true }), X.meta = (...$) => {
    if ($.length === 0) return g1.get(X);
    let Y = X.clone();
    return g1.add(Y, $[0]), Y;
  }, X.isOptional = () => X.safeParse(void 0).success, X.isNullable = () => X.safeParse(null).success, X;
});
var rJ = O("_ZodString", (X, Q) => {
  var _a5, _b, _c;
  EX.init(X, Q), z0.init(X, Q);
  let $ = X._zod.bag;
  X.format = (_a5 = $.format) != null ? _a5 : null, X.minLength = (_b = $.minimum) != null ? _b : null, X.maxLength = (_c = $.maximum) != null ? _c : null, X.regex = (...Y) => X.check(Y$(...Y)), X.includes = (...Y) => X.check(G$(...Y)), X.startsWith = (...Y) => X.check(H$(...Y)), X.endsWith = (...Y) => X.check(B$(...Y)), X.min = (...Y) => X.check(C6(...Y)), X.max = (...Y) => X.check(u4(...Y)), X.length = (...Y) => X.check(l4(...Y)), X.nonempty = (...Y) => X.check(C6(1, ...Y)), X.lowercase = (Y) => X.check(W$(Y)), X.uppercase = (Y) => X.check(J$(Y)), X.trim = () => X.check(K$()), X.normalize = (...Y) => X.check(z$(...Y)), X.toLowerCase = () => X.check(U$()), X.toUpperCase = () => X.check(V$());
});
var iL = O("ZodString", (X, Q) => {
  EX.init(X, Q), rJ.init(X, Q), X.email = ($) => X.check(CQ(nL, $)), X.url = ($) => X.check(xQ(rL, $)), X.jwt = ($) => X.check(tQ(zq, $)), X.emoji = ($) => X.check(yQ(oL, $)), X.guid = ($) => X.check(y4(dJ, $)), X.uuid = ($) => X.check(kQ(d4, $)), X.uuidv4 = ($) => X.check(vQ(d4, $)), X.uuidv6 = ($) => X.check(TQ(d4, $)), X.uuidv7 = ($) => X.check(_Q(d4, $)), X.nanoid = ($) => X.check(gQ(tL, $)), X.guid = ($) => X.check(y4(dJ, $)), X.cuid = ($) => X.check(fQ(aL, $)), X.cuid2 = ($) => X.check(hQ(sL, $)), X.ulid = ($) => X.check(uQ(eL, $)), X.base64 = ($) => X.check(nQ(Gq, $)), X.base64url = ($) => X.check(rQ(Hq, $)), X.xid = ($) => X.check(lQ(Xq, $)), X.ksuid = ($) => X.check(mQ(Qq, $)), X.ipv4 = ($) => X.check(cQ($q, $)), X.ipv6 = ($) => X.check(pQ(Yq, $)), X.cidrv4 = ($) => X.check(dQ(Wq, $)), X.cidrv6 = ($) => X.check(iQ(Jq, $)), X.e164 = ($) => X.check(oQ(Bq, $)), X.datetime = ($) => X.check(D$($)), X.date = ($) => X.check(w$($)), X.time = ($) => X.check(A$($)), X.duration = ($) => X.check(M$($));
});
function D(X) {
  return ZQ(iL, X);
}
var H0 = O("ZodStringFormat", (X, Q) => {
  W0.init(X, Q), rJ.init(X, Q);
});
var nL = O("ZodEmail", (X, Q) => {
  p9.init(X, Q), H0.init(X, Q);
});
var dJ = O("ZodGUID", (X, Q) => {
  m9.init(X, Q), H0.init(X, Q);
});
var d4 = O("ZodUUID", (X, Q) => {
  c9.init(X, Q), H0.init(X, Q);
});
var rL = O("ZodURL", (X, Q) => {
  d9.init(X, Q), H0.init(X, Q);
});
var oL = O("ZodEmoji", (X, Q) => {
  i9.init(X, Q), H0.init(X, Q);
});
var tL = O("ZodNanoID", (X, Q) => {
  n9.init(X, Q), H0.init(X, Q);
});
var aL = O("ZodCUID", (X, Q) => {
  r9.init(X, Q), H0.init(X, Q);
});
var sL = O("ZodCUID2", (X, Q) => {
  o9.init(X, Q), H0.init(X, Q);
});
var eL = O("ZodULID", (X, Q) => {
  t9.init(X, Q), H0.init(X, Q);
});
var Xq = O("ZodXID", (X, Q) => {
  a9.init(X, Q), H0.init(X, Q);
});
var Qq = O("ZodKSUID", (X, Q) => {
  s9.init(X, Q), H0.init(X, Q);
});
var $q = O("ZodIPv4", (X, Q) => {
  e9.init(X, Q), H0.init(X, Q);
});
var Yq = O("ZodIPv6", (X, Q) => {
  XQ.init(X, Q), H0.init(X, Q);
});
var Wq = O("ZodCIDRv4", (X, Q) => {
  QQ.init(X, Q), H0.init(X, Q);
});
var Jq = O("ZodCIDRv6", (X, Q) => {
  $Q.init(X, Q), H0.init(X, Q);
});
var Gq = O("ZodBase64", (X, Q) => {
  YQ.init(X, Q), H0.init(X, Q);
});
var Hq = O("ZodBase64URL", (X, Q) => {
  WQ.init(X, Q), H0.init(X, Q);
});
var Bq = O("ZodE164", (X, Q) => {
  JQ.init(X, Q), H0.init(X, Q);
});
var zq = O("ZodJWT", (X, Q) => {
  GQ.init(X, Q), H0.init(X, Q);
});
var oJ = O("ZodNumber", (X, Q) => {
  var _a5, _b, _c, _d, _e, _f, _g, _h, _i;
  v4.init(X, Q), z0.init(X, Q), X.gt = (Y, W) => X.check(f4(Y, W)), X.gte = (Y, W) => X.check(PX(Y, W)), X.min = (Y, W) => X.check(PX(Y, W)), X.lt = (Y, W) => X.check(g4(Y, W)), X.lte = (Y, W) => X.check(bX(Y, W)), X.max = (Y, W) => X.check(bX(Y, W)), X.int = (Y) => X.check(iJ(Y)), X.safe = (Y) => X.check(iJ(Y)), X.positive = (Y) => X.check(f4(0, Y)), X.nonnegative = (Y) => X.check(PX(0, Y)), X.negative = (Y) => X.check(g4(0, Y)), X.nonpositive = (Y) => X.check(bX(0, Y)), X.multipleOf = (Y, W) => X.check(h4(Y, W)), X.step = (Y, W) => X.check(h4(Y, W)), X.finite = () => X;
  let $ = X._zod.bag;
  X.minValue = (_c = Math.max((_a5 = $.minimum) != null ? _a5 : Number.NEGATIVE_INFINITY, (_b = $.exclusiveMinimum) != null ? _b : Number.NEGATIVE_INFINITY)) != null ? _c : null, X.maxValue = (_f = Math.min((_d = $.maximum) != null ? _d : Number.POSITIVE_INFINITY, (_e = $.exclusiveMaximum) != null ? _e : Number.POSITIVE_INFINITY)) != null ? _f : null, X.isInt = ((_g = $.format) != null ? _g : "").includes("int") || Number.isSafeInteger((_h = $.multipleOf) != null ? _h : 0.5), X.isFinite = true, X.format = (_i = $.format) != null ? _i : null;
});
function Q0(X) {
  return aQ(oJ, X);
}
var Kq = O("ZodNumberFormat", (X, Q) => {
  HQ.init(X, Q), oJ.init(X, Q);
});
function iJ(X) {
  return sQ(Kq, X);
}
var Uq = O("ZodBoolean", (X, Q) => {
  BQ.init(X, Q), z0.init(X, Q);
});
function M0(X) {
  return eQ(Uq, X);
}
var Vq = O("ZodNull", (X, Q) => {
  zQ.init(X, Q), z0.init(X, Q);
});
function I$(X) {
  return X$(Vq, X);
}
var Lq = O("ZodUnknown", (X, Q) => {
  KQ.init(X, Q), z0.init(X, Q);
});
function N0() {
  return Q$(Lq);
}
var qq = O("ZodNever", (X, Q) => {
  UQ.init(X, Q), z0.init(X, Q);
});
function Fq(X) {
  return $$(qq, X);
}
var Nq = O("ZodArray", (X, Q) => {
  VQ.init(X, Q), z0.init(X, Q), X.element = Q.element, X.min = ($, Y) => X.check(C6($, Y)), X.nonempty = ($) => X.check(C6(1, $)), X.max = ($, Y) => X.check(u4($, Y)), X.length = ($, Y) => X.check(l4($, Y)), X.unwrap = () => X.element;
});
function r(X, Q) {
  return vJ(Nq, X, Q);
}
var tJ = O("ZodObject", (X, Q) => {
  T4.init(X, Q), z0.init(X, Q), i.defineLazy(X, "shape", () => Q.shape), X.keyof = () => j0(Object.keys(X._zod.def.shape)), X.catchall = ($) => X.clone({ ...X._zod.def, catchall: $ }), X.passthrough = () => X.clone({ ...X._zod.def, catchall: N0() }), X.loose = () => X.clone({ ...X._zod.def, catchall: N0() }), X.strict = () => X.clone({ ...X._zod.def, catchall: Fq() }), X.strip = () => X.clone({ ...X._zod.def, catchall: void 0 }), X.extend = ($) => {
    return i.extend(X, $);
  }, X.merge = ($) => i.merge(X, $), X.pick = ($) => i.pick(X, $), X.omit = ($) => i.omit(X, $), X.partial = (...$) => i.partial(eJ, X, $[0]), X.required = (...$) => i.required(X5, X, $[0]);
});
function E(X, Q) {
  let $ = { type: "object", get shape() {
    return i.assignProp(this, "shape", { ...X }), this.shape;
  }, ...i.normalizeParams(Q) };
  return new tJ($);
}
function c0(X, Q) {
  return new tJ({ type: "object", get shape() {
    return i.assignProp(this, "shape", { ...X }), this.shape;
  }, catchall: N0(), ...i.normalizeParams(Q) });
}
var aJ = O("ZodUnion", (X, Q) => {
  _4.init(X, Q), z0.init(X, Q), X.options = Q.options;
});
function J0(X, Q) {
  return new aJ({ type: "union", options: X, ...i.normalizeParams(Q) });
}
var Oq = O("ZodDiscriminatedUnion", (X, Q) => {
  aJ.init(X, Q), LQ.init(X, Q);
});
function E$(X, Q, $) {
  return new Oq({ type: "union", options: Q, discriminator: X, ...i.normalizeParams($) });
}
var Dq = O("ZodIntersection", (X, Q) => {
  qQ.init(X, Q), z0.init(X, Q);
});
function i4(X, Q) {
  return new Dq({ type: "intersection", left: X, right: Q });
}
var wq = O("ZodRecord", (X, Q) => {
  FQ.init(X, Q), z0.init(X, Q), X.keyType = Q.keyType, X.valueType = Q.valueType;
});
function O0(X, Q, $) {
  return new wq({ type: "record", keyType: X, valueType: Q, ...i.normalizeParams($) });
}
var j$ = O("ZodEnum", (X, Q) => {
  NQ.init(X, Q), z0.init(X, Q), X.enum = Q.entries, X.options = Object.values(Q.entries);
  let $ = new Set(Object.keys(Q.entries));
  X.extract = (Y, W) => {
    let J = {};
    for (let G of Y) if ($.has(G)) J[G] = Q.entries[G];
    else throw Error(`Key ${G} not found in enum`);
    return new j$({ ...Q, checks: [], ...i.normalizeParams(W), entries: J });
  }, X.exclude = (Y, W) => {
    let J = { ...Q.entries };
    for (let G of Y) if ($.has(G)) delete J[G];
    else throw Error(`Key ${G} not found in enum`);
    return new j$({ ...Q, checks: [], ...i.normalizeParams(W), entries: J });
  };
});
function j0(X, Q) {
  let $ = Array.isArray(X) ? Object.fromEntries(X.map((Y) => [Y, Y])) : X;
  return new j$({ type: "enum", entries: $, ...i.normalizeParams(Q) });
}
var Aq = O("ZodLiteral", (X, Q) => {
  OQ.init(X, Q), z0.init(X, Q), X.values = new Set(Q.values), Object.defineProperty(X, "value", { get() {
    if (Q.values.length > 1) throw Error("This schema contains multiple valid literal values. Use `.values` instead.");
    return Q.values[0];
  } });
});
function T(X, Q) {
  return new Aq({ type: "literal", values: Array.isArray(X) ? X : [X], ...i.normalizeParams(Q) });
}
var Mq = O("ZodTransform", (X, Q) => {
  DQ.init(X, Q), z0.init(X, Q), X._zod.parse = ($, Y) => {
    $.addIssue = (J) => {
      var _a5, _b, _c, _d;
      if (typeof J === "string") $.issues.push(i.issue(J, $.value, Q));
      else {
        let G = J;
        if (G.fatal) G.continue = false;
        (_a5 = G.code) != null ? _a5 : G.code = "custom", (_b = G.input) != null ? _b : G.input = $.value, (_c = G.inst) != null ? _c : G.inst = X, (_d = G.continue) != null ? _d : G.continue = true, $.issues.push(i.issue(G));
      }
    };
    let W = Q.transform($.value, $);
    if (W instanceof Promise) return W.then((J) => {
      return $.value = J, $;
    });
    return $.value = W, $;
  };
});
function sJ(X) {
  return new Mq({ type: "transform", transform: X });
}
var eJ = O("ZodOptional", (X, Q) => {
  wQ.init(X, Q), z0.init(X, Q), X.unwrap = () => X._zod.def.innerType;
});
function v(X) {
  return new eJ({ type: "optional", innerType: X });
}
var jq = O("ZodNullable", (X, Q) => {
  AQ.init(X, Q), z0.init(X, Q), X.unwrap = () => X._zod.def.innerType;
});
function nJ(X) {
  return new jq({ type: "nullable", innerType: X });
}
var Rq = O("ZodDefault", (X, Q) => {
  MQ.init(X, Q), z0.init(X, Q), X.unwrap = () => X._zod.def.innerType, X.removeDefault = X.unwrap;
});
function Iq(X, Q) {
  return new Rq({ type: "default", innerType: X, get defaultValue() {
    return typeof Q === "function" ? Q() : Q;
  } });
}
var Eq = O("ZodPrefault", (X, Q) => {
  jQ.init(X, Q), z0.init(X, Q), X.unwrap = () => X._zod.def.innerType;
});
function bq(X, Q) {
  return new Eq({ type: "prefault", innerType: X, get defaultValue() {
    return typeof Q === "function" ? Q() : Q;
  } });
}
var X5 = O("ZodNonOptional", (X, Q) => {
  RQ.init(X, Q), z0.init(X, Q), X.unwrap = () => X._zod.def.innerType;
});
function Pq(X, Q) {
  return new X5({ type: "nonoptional", innerType: X, ...i.normalizeParams(Q) });
}
var Sq = O("ZodCatch", (X, Q) => {
  IQ.init(X, Q), z0.init(X, Q), X.unwrap = () => X._zod.def.innerType, X.removeCatch = X.unwrap;
});
function Zq(X, Q) {
  return new Sq({ type: "catch", innerType: X, catchValue: typeof Q === "function" ? Q : () => Q });
}
var Cq = O("ZodPipe", (X, Q) => {
  EQ.init(X, Q), z0.init(X, Q), X.in = Q.in, X.out = Q.out;
});
function R$(X, Q) {
  return new Cq({ type: "pipe", in: X, out: Q });
}
var kq = O("ZodReadonly", (X, Q) => {
  bQ.init(X, Q), z0.init(X, Q);
});
function vq(X) {
  return new kq({ type: "readonly", innerType: X });
}
var Q5 = O("ZodCustom", (X, Q) => {
  PQ.init(X, Q), z0.init(X, Q);
});
function Tq(X, Q) {
  let $ = new A0({ check: "custom", ...i.normalizeParams(Q) });
  return $._zod.check = X, $;
}
function $5(X, Q) {
  return L$(Q5, X != null ? X : (() => true), Q);
}
function _q(X, Q = {}) {
  return q$(Q5, X, Q);
}
function xq(X, Q) {
  let $ = Tq((Y) => {
    return Y.addIssue = (W) => {
      var _a5, _b, _c, _d;
      if (typeof W === "string") Y.issues.push(i.issue(W, Y.value, $._zod.def));
      else {
        let J = W;
        if (J.fatal) J.continue = false;
        (_a5 = J.code) != null ? _a5 : J.code = "custom", (_b = J.input) != null ? _b : J.input = Y.value, (_c = J.inst) != null ? _c : J.inst = $, (_d = J.continue) != null ? _d : J.continue = !$._zod.def.abort, Y.issues.push(i.issue(J));
      }
    }, X(Y.value, Y);
  }, Q);
  return $;
}
function b$(X, Q) {
  return R$(sJ(X), Q);
}
u0(SQ());
var z1 = "io.modelcontextprotocol/related-task";
var r4 = "2.0";
var B1 = $5((X) => X !== null && (typeof X === "object" || typeof X === "function"));
var W5 = J0([D(), Q0().int()]);
var J5 = D();
var yq = c0({ ttl: J0([Q0(), I$()]).optional(), pollInterval: Q0().optional() });
var S$ = c0({ taskId: D() });
var gq = c0({ progressToken: W5.optional(), [z1]: S$.optional() });
var _0 = c0({ task: yq.optional(), _meta: gq.optional() });
var R0 = E({ method: D(), params: _0.optional() });
var J6 = c0({ _meta: E({ [z1]: v(S$) }).passthrough().optional() });
var p0 = E({ method: D(), params: J6.optional() });
var P0 = c0({ _meta: c0({ [z1]: S$.optional() }).optional() });
var o4 = J0([D(), Q0().int()]);
var G5 = E({ jsonrpc: T(r4), id: o4, ...R0.shape }).strict();
var H5 = E({ jsonrpc: T(r4), ...p0.shape }).strict();
var z5 = E({ jsonrpc: T(r4), id: o4, result: P0 }).strict();
var x;
(function(X) {
  X[X.ConnectionClosed = -32e3] = "ConnectionClosed", X[X.RequestTimeout = -32001] = "RequestTimeout", X[X.ParseError = -32700] = "ParseError", X[X.InvalidRequest = -32600] = "InvalidRequest", X[X.MethodNotFound = -32601] = "MethodNotFound", X[X.InvalidParams = -32602] = "InvalidParams", X[X.InternalError = -32603] = "InternalError", X[X.UrlElicitationRequired = -32042] = "UrlElicitationRequired";
})(x || (x = {}));
var K5 = E({ jsonrpc: T(r4), id: o4, error: E({ code: Q0().int(), message: D(), data: v(N0()) }) }).strict();
var MZ = J0([G5, H5, z5, K5]);
var t4 = P0.strict();
var fq = J6.extend({ requestId: o4, reason: D().optional() });
var a4 = p0.extend({ method: T("notifications/cancelled"), params: fq });
var hq = E({ src: D(), mimeType: D().optional(), sizes: r(D()).optional() });
var kX = E({ icons: r(hq).optional() });
var T6 = E({ name: D(), title: D().optional() });
var V5 = T6.extend({ ...T6.shape, ...kX.shape, version: D(), websiteUrl: D().optional() });
var uq = i4(E({ applyDefaults: M0().optional() }), O0(D(), N0()));
var lq = b$((X) => {
  if (X && typeof X === "object" && !Array.isArray(X)) {
    if (Object.keys(X).length === 0) return { form: {} };
  }
  return X;
}, i4(E({ form: uq.optional(), url: B1.optional() }), O0(D(), N0()).optional()));
var mq = E({ list: v(E({}).passthrough()), cancel: v(E({}).passthrough()), requests: v(E({ sampling: v(E({ createMessage: v(E({}).passthrough()) }).passthrough()), elicitation: v(E({ create: v(E({}).passthrough()) }).passthrough()) }).passthrough()) }).passthrough();
var cq = E({ list: v(E({}).passthrough()), cancel: v(E({}).passthrough()), requests: v(E({ tools: v(E({ call: v(E({}).passthrough()) }).passthrough()) }).passthrough()) }).passthrough();
var pq = E({ experimental: O0(D(), B1).optional(), sampling: E({ context: B1.optional(), tools: B1.optional() }).optional(), elicitation: lq.optional(), roots: E({ listChanged: M0().optional() }).optional(), tasks: v(mq) });
var dq = _0.extend({ protocolVersion: D(), capabilities: pq, clientInfo: V5 });
var C$ = R0.extend({ method: T("initialize"), params: dq });
var iq = E({ experimental: O0(D(), B1).optional(), logging: B1.optional(), completions: B1.optional(), prompts: v(E({ listChanged: v(M0()) })), resources: E({ subscribe: M0().optional(), listChanged: M0().optional() }).optional(), tools: E({ listChanged: M0().optional() }).optional(), tasks: v(cq) }).passthrough();
var nq = P0.extend({ protocolVersion: D(), capabilities: iq, serverInfo: V5, instructions: D().optional() });
var k$ = p0.extend({ method: T("notifications/initialized") });
var s4 = R0.extend({ method: T("ping") });
var rq = E({ progress: Q0(), total: v(Q0()), message: v(D()) });
var oq = E({ ...J6.shape, ...rq.shape, progressToken: W5 });
var e4 = p0.extend({ method: T("notifications/progress"), params: oq });
var tq = _0.extend({ cursor: J5.optional() });
var vX = R0.extend({ params: tq.optional() });
var TX = P0.extend({ nextCursor: v(J5) });
var _X = E({ taskId: D(), status: j0(["working", "input_required", "completed", "failed", "cancelled"]), ttl: J0([Q0(), I$()]), createdAt: D(), lastUpdatedAt: D(), pollInterval: v(Q0()), statusMessage: v(D()) });
var _6 = P0.extend({ task: _X });
var aq = J6.merge(_X);
var xX = p0.extend({ method: T("notifications/tasks/status"), params: aq });
var X8 = R0.extend({ method: T("tasks/get"), params: _0.extend({ taskId: D() }) });
var Q8 = P0.merge(_X);
var $8 = R0.extend({ method: T("tasks/result"), params: _0.extend({ taskId: D() }) });
var Y8 = vX.extend({ method: T("tasks/list") });
var W8 = TX.extend({ tasks: r(_X) });
var L5 = R0.extend({ method: T("tasks/cancel"), params: _0.extend({ taskId: D() }) });
var q5 = P0.merge(_X);
var F5 = E({ uri: D(), mimeType: v(D()), _meta: O0(D(), N0()).optional() });
var N5 = F5.extend({ text: D() });
var v$ = D().refine((X) => {
  try {
    return atob(X), true;
  } catch (Q) {
    return false;
  }
}, { message: "Invalid Base64 string" });
var O5 = F5.extend({ blob: v$ });
var x6 = E({ audience: r(j0(["user", "assistant"])).optional(), priority: Q0().min(0).max(1).optional(), lastModified: SX.datetime({ offset: true }).optional() });
var D5 = E({ ...T6.shape, ...kX.shape, uri: D(), description: v(D()), mimeType: v(D()), annotations: x6.optional(), _meta: v(c0({})) });
var sq = E({ ...T6.shape, ...kX.shape, uriTemplate: D(), description: v(D()), mimeType: v(D()), annotations: x6.optional(), _meta: v(c0({})) });
var J8 = vX.extend({ method: T("resources/list") });
var eq = TX.extend({ resources: r(D5) });
var G8 = vX.extend({ method: T("resources/templates/list") });
var XF = TX.extend({ resourceTemplates: r(sq) });
var T$ = _0.extend({ uri: D() });
var QF = T$;
var H8 = R0.extend({ method: T("resources/read"), params: QF });
var $F = P0.extend({ contents: r(J0([N5, O5])) });
var YF = p0.extend({ method: T("notifications/resources/list_changed") });
var WF = T$;
var JF = R0.extend({ method: T("resources/subscribe"), params: WF });
var GF = T$;
var HF = R0.extend({ method: T("resources/unsubscribe"), params: GF });
var BF = J6.extend({ uri: D() });
var zF = p0.extend({ method: T("notifications/resources/updated"), params: BF });
var KF = E({ name: D(), description: v(D()), required: v(M0()) });
var UF = E({ ...T6.shape, ...kX.shape, description: v(D()), arguments: v(r(KF)), _meta: v(c0({})) });
var B8 = vX.extend({ method: T("prompts/list") });
var VF = TX.extend({ prompts: r(UF) });
var LF = _0.extend({ name: D(), arguments: O0(D(), D()).optional() });
var z8 = R0.extend({ method: T("prompts/get"), params: LF });
var _$ = E({ type: T("text"), text: D(), annotations: x6.optional(), _meta: O0(D(), N0()).optional() });
var x$ = E({ type: T("image"), data: v$, mimeType: D(), annotations: x6.optional(), _meta: O0(D(), N0()).optional() });
var y$ = E({ type: T("audio"), data: v$, mimeType: D(), annotations: x6.optional(), _meta: O0(D(), N0()).optional() });
var qF = E({ type: T("tool_use"), name: D(), id: D(), input: E({}).passthrough(), _meta: v(E({}).passthrough()) }).passthrough();
var FF = E({ type: T("resource"), resource: J0([N5, O5]), annotations: x6.optional(), _meta: O0(D(), N0()).optional() });
var NF = D5.extend({ type: T("resource_link") });
var g$ = J0([_$, x$, y$, NF, FF]);
var OF = E({ role: j0(["user", "assistant"]), content: g$ });
var DF = P0.extend({ description: v(D()), messages: r(OF) });
var wF = p0.extend({ method: T("notifications/prompts/list_changed") });
var AF = E({ title: D().optional(), readOnlyHint: M0().optional(), destructiveHint: M0().optional(), idempotentHint: M0().optional(), openWorldHint: M0().optional() });
var MF = E({ taskSupport: j0(["required", "optional", "forbidden"]).optional() });
var w5 = E({ ...T6.shape, ...kX.shape, description: D().optional(), inputSchema: E({ type: T("object"), properties: O0(D(), B1).optional(), required: r(D()).optional() }).catchall(N0()), outputSchema: E({ type: T("object"), properties: O0(D(), B1).optional(), required: r(D()).optional() }).catchall(N0()).optional(), annotations: v(AF), execution: v(MF), _meta: O0(D(), N0()).optional() });
var K8 = vX.extend({ method: T("tools/list") });
var jF = TX.extend({ tools: r(w5) });
var U8 = P0.extend({ content: r(g$).default([]), structuredContent: O0(D(), N0()).optional(), isError: v(M0()) });
var jZ = U8.or(P0.extend({ toolResult: N0() }));
var RF = _0.extend({ name: D(), arguments: v(O0(D(), N0())) });
var y6 = R0.extend({ method: T("tools/call"), params: RF });
var IF = p0.extend({ method: T("notifications/tools/list_changed") });
var yX = j0(["debug", "info", "notice", "warning", "error", "critical", "alert", "emergency"]);
var EF = _0.extend({ level: yX });
var f$ = R0.extend({ method: T("logging/setLevel"), params: EF });
var bF = J6.extend({ level: yX, logger: D().optional(), data: N0() });
var PF = p0.extend({ method: T("notifications/message"), params: bF });
var SF = E({ name: D().optional() });
var ZF = E({ hints: v(r(SF)), costPriority: v(Q0().min(0).max(1)), speedPriority: v(Q0().min(0).max(1)), intelligencePriority: v(Q0().min(0).max(1)) });
var CF = E({ mode: v(j0(["auto", "required", "none"])) });
var kF = E({ type: T("tool_result"), toolUseId: D().describe("The unique identifier for the corresponding tool call."), content: r(g$).default([]), structuredContent: E({}).passthrough().optional(), isError: v(M0()), _meta: v(E({}).passthrough()) }).passthrough();
var vF = E$("type", [_$, x$, y$]);
var n4 = E$("type", [_$, x$, y$, qF, kF]);
var TF = E({ role: j0(["user", "assistant"]), content: J0([n4, r(n4)]), _meta: v(E({}).passthrough()) }).passthrough();
var _F = _0.extend({ messages: r(TF), modelPreferences: ZF.optional(), systemPrompt: D().optional(), includeContext: j0(["none", "thisServer", "allServers"]).optional(), temperature: Q0().optional(), maxTokens: Q0().int(), stopSequences: r(D()).optional(), metadata: B1.optional(), tools: v(r(w5)), toolChoice: v(CF) });
var xF = R0.extend({ method: T("sampling/createMessage"), params: _F });
var h$ = P0.extend({ model: D(), stopReason: v(j0(["endTurn", "stopSequence", "maxTokens"]).or(D())), role: j0(["user", "assistant"]), content: vF });
var u$ = P0.extend({ model: D(), stopReason: v(j0(["endTurn", "stopSequence", "maxTokens", "toolUse"]).or(D())), role: j0(["user", "assistant"]), content: J0([n4, r(n4)]) });
var yF = E({ type: T("boolean"), title: D().optional(), description: D().optional(), default: M0().optional() });
var gF = E({ type: T("string"), title: D().optional(), description: D().optional(), minLength: Q0().optional(), maxLength: Q0().optional(), format: j0(["email", "uri", "date", "date-time"]).optional(), default: D().optional() });
var fF = E({ type: j0(["number", "integer"]), title: D().optional(), description: D().optional(), minimum: Q0().optional(), maximum: Q0().optional(), default: Q0().optional() });
var hF = E({ type: T("string"), title: D().optional(), description: D().optional(), enum: r(D()), default: D().optional() });
var uF = E({ type: T("string"), title: D().optional(), description: D().optional(), oneOf: r(E({ const: D(), title: D() })), default: D().optional() });
var lF = E({ type: T("string"), title: D().optional(), description: D().optional(), enum: r(D()), enumNames: r(D()).optional(), default: D().optional() });
var mF = J0([hF, uF]);
var cF = E({ type: T("array"), title: D().optional(), description: D().optional(), minItems: Q0().optional(), maxItems: Q0().optional(), items: E({ type: T("string"), enum: r(D()) }), default: r(D()).optional() });
var pF = E({ type: T("array"), title: D().optional(), description: D().optional(), minItems: Q0().optional(), maxItems: Q0().optional(), items: E({ anyOf: r(E({ const: D(), title: D() })) }), default: r(D()).optional() });
var dF = J0([cF, pF]);
var iF = J0([lF, mF, dF]);
var nF = J0([iF, yF, gF, fF]);
var rF = _0.extend({ mode: T("form").optional(), message: D(), requestedSchema: E({ type: T("object"), properties: O0(D(), nF), required: r(D()).optional() }) });
var oF = _0.extend({ mode: T("url"), message: D(), elicitationId: D(), url: D().url() });
var tF = J0([rF, oF]);
var aF = R0.extend({ method: T("elicitation/create"), params: tF });
var sF = J6.extend({ elicitationId: D() });
var eF = p0.extend({ method: T("notifications/elicitation/complete"), params: sF });
var V8 = P0.extend({ action: j0(["accept", "decline", "cancel"]), content: b$((X) => X === null ? void 0 : X, O0(D(), J0([D(), Q0(), M0(), r(D())])).optional()) });
var XN = E({ type: T("ref/resource"), uri: D() });
var QN = E({ type: T("ref/prompt"), name: D() });
var $N = _0.extend({ ref: J0([QN, XN]), argument: E({ name: D(), value: D() }), context: E({ arguments: O0(D(), D()).optional() }).optional() });
var L8 = R0.extend({ method: T("completion/complete"), params: $N });
var YN = P0.extend({ completion: c0({ values: r(D()).max(100), total: v(Q0().int()), hasMore: v(M0()) }) });
var WN = E({ uri: D().startsWith("file://"), name: D().optional(), _meta: O0(D(), N0()).optional() });
var JN = R0.extend({ method: T("roots/list") });
var l$ = P0.extend({ roots: r(WN) });
var GN = p0.extend({ method: T("notifications/roots/list_changed") });
var RZ = J0([s4, C$, L8, f$, z8, B8, J8, G8, H8, JF, HF, y6, K8, X8, $8, Y8]);
var IZ = J0([a4, e4, k$, GN, xX]);
var EZ = J0([t4, h$, u$, V8, l$, Q8, W8, _6]);
var bZ = J0([s4, xF, aF, JN, X8, $8, Y8]);
var PZ = J0([a4, e4, PF, zF, YF, IF, wF, xX, eF]);
var SZ = J0([t4, nq, YN, DF, VF, eq, XF, $F, U8, jF, Q8, W8, _6]);
var zN = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
var hz = K7(cY(), 1);
var uz = K7(fz(), 1);
var cz;
(function(X) {
  X.Completable = "McpCompletable";
})(cz || (cz = {}));
function s_({ prompt: X, options: Q }) {
  let { systemPrompt: $, settingSources: Y, sandbox: W, ...J } = Q != null ? Q : {}, G, H;
  if ($ === void 0) G = "";
  else if (typeof $ === "string") G = $;
  else if ($.type === "preset") H = $.append;
  let B = J.pathToClaudeCodeExecutable;
  if (!B) {
    let L6 = (0, import_url.fileURLToPath)(import_meta.url), q6 = (0, import_path40.join)(L6, "..");
    B = (0, import_path40.join)(q6, "cli.js");
  }
  process.env.CLAUDE_AGENT_SDK_VERSION = "0.2.37";
  let { abortController: z = F6(), additionalDirectories: K = [], agent: V, agents: L, allowedTools: U = [], betas: F, canUseTool: q, continue: N, cwd: w, debug: M, debugFile: R, disallowedTools: S = [], tools: C, env: K0, executable: U0 = M6() ? "bun" : "node", executableArgs: s = [], extraArgs: D0 = {}, fallbackModel: q0, enableFileCheckpointing: L1, forkSession: P1, hooks: o1, includePartialMessages: c, persistSession: Q9, maxThinkingTokens: r6, maxTurns: o6, maxBudgetUsd: t6, mcpServers: a6, model: B4, outputFormat: E0, permissionMode: S1 = "default", allowDangerouslySkipPermissions: s6 = false, permissionPromptToolName: az, plugins: sz, resume: ez, resumeSessionAt: XK, sessionId: QK, stderr: $K, strictMcpConfig: YK } = J, G7 = (E0 == null ? void 0 : E0.type) === "json_schema" ? E0.schema : void 0, V6 = K0;
  if (!V6) V6 = { ...process.env };
  if (!V6.CLAUDE_CODE_ENTRYPOINT) V6.CLAUDE_CODE_ENTRYPOINT = "sdk-ts";
  if (L1) V6.CLAUDE_CODE_ENABLE_SDK_FILE_CHECKPOINTING = "true";
  if (!B) throw Error("pathToClaudeCodeExecutable is required");
  let $9 = {}, H7 = /* @__PURE__ */ new Map();
  if (a6) for (let [L6, q6] of Object.entries(a6)) if (q6.type === "sdk" && "instance" in q6) H7.set(L6, q6.instance), $9[L6] = { type: "sdk", name: L6 };
  else $9[L6] = q6;
  let WK = typeof X === "string", B7 = new XX({ abortController: z, additionalDirectories: K, agent: V, betas: F, cwd: w, debug: M, debugFile: R, executable: U0, executableArgs: s, extraArgs: D0, pathToClaudeCodeExecutable: B, env: V6, forkSession: P1, stderr: $K, maxThinkingTokens: r6, maxTurns: o6, maxBudgetUsd: t6, model: B4, fallbackModel: q0, jsonSchema: G7, permissionMode: S1, allowDangerouslySkipPermissions: s6, permissionPromptToolName: az, continueConversation: N, resume: ez, resumeSessionAt: XK, sessionId: QK, settingSources: Y != null ? Y : [], allowedTools: U, disallowedTools: S, tools: C, mcpServers: $9, strictMcpConfig: YK, canUseTool: !!q, hooks: !!o1, includePartialMessages: c, persistSession: Q9, plugins: sz, sandbox: W, spawnClaudeCodeProcess: J.spawnClaudeCodeProcess }), z7 = new $X(B7, WK, q, o1, z, H7, G7, { systemPrompt: G, appendSystemPrompt: H, agents: L });
  if (typeof X === "string") B7.write(Z0({ type: "user", session_id: "", message: { role: "user", content: [{ type: "text", text: X }] }, parent_tool_use_id: null }) + `
`);
  else z7.streamInput(X);
  return z7;
}

// src/services/ClaudeAgentSDKInstaller.ts
var import_obsidian = require("obsidian");
var SDK_PACKAGE = "@anthropic-ai/claude-agent-sdk@0.2.37";
var INSTALL_TIMEOUT_MS = 12e4;
function resolveNpmPath() {
  const fs = require("fs");
  const homedir = require("os").homedir();
  const isWin = process.platform === "win32";
  const bin = isWin ? "npm.cmd" : "npm";
  const candidates = [];
  if (!isWin) {
    const nvmDir = `${homedir}/.nvm/versions/node`;
    try {
      if (fs.existsSync(nvmDir)) {
        const versions = fs.readdirSync(nvmDir).sort().reverse();
        if (versions.length > 0) {
          candidates.push(`${nvmDir}/${versions[0]}/bin/npm`);
        }
      }
    } catch (e3) {
    }
  }
  if (isWin) {
    const appData = process.env.APPDATA || `${homedir}\\AppData\\Roaming`;
    candidates.push(
      `${appData}\\nvm\\npm.cmd`,
      `${homedir}\\.volta\\bin\\npm.cmd`,
      "C:\\Program Files\\nodejs\\npm.cmd"
    );
  } else {
    candidates.push(
      `${homedir}/.volta/bin/npm`,
      `${homedir}/.local/share/fnm/aliases/default/bin/npm`,
      `${homedir}/.asdf/shims/npm`,
      `${homedir}/.local/bin/npm`,
      "/usr/local/bin/npm",
      "/usr/bin/npm",
      "/snap/bin/npm"
    );
  }
  for (const candidate of candidates) {
    try {
      if (fs.existsSync(candidate)) {
        return candidate;
      }
    } catch (e3) {
    }
  }
  return bin;
}
function isSDKInstalled(pluginDir) {
  const path4 = require("path");
  const fs = require("fs");
  const cliPath = path4.join(
    pluginDir,
    "node_modules",
    "@anthropic-ai",
    "claude-agent-sdk",
    "cli.js"
  );
  return fs.existsSync(cliPath);
}
var installPromise = null;
async function ensureSDKInstalled(pluginDir) {
  if (isSDKInstalled(pluginDir)) return;
  if (installPromise) return installPromise;
  installPromise = doInstall(pluginDir);
  try {
    await installPromise;
  } finally {
    installPromise = null;
  }
}
function ensurePackageJson(pluginDir) {
  const path4 = require("path");
  const fs = require("fs");
  const pkgPath = path4.join(pluginDir, "package.json");
  if (!fs.existsSync(pkgPath)) {
    fs.writeFileSync(pkgPath, '{"private":true}\n');
  }
}
function doInstall(pluginDir) {
  const path4 = require("path");
  const { spawn } = require("child_process");
  const npmPath = resolveNpmPath();
  const isWin = process.platform === "win32";
  const nodeBin = isWin ? "node.exe" : "node";
  const nodePath = path4.join(path4.dirname(npmPath), nodeBin);
  ensurePackageJson(pluginDir);
  return new Promise((resolve, reject) => {
    const notice = new import_obsidian.Notice(
      "Installing Claude Code runtime (~69 MB). This is a one-time setup...",
      0
      // persistent until hidden
    );
    const args = [
      npmPath,
      "install",
      SDK_PACKAGE,
      "--no-save",
      "--no-package-lock",
      "--no-optional"
    ];
    const child = spawn(nodePath, args, {
      cwd: pluginDir,
      stdio: ["ignore", "pipe", "pipe"]
    });
    const timeout = setTimeout(() => {
      child.kill();
      notice.hide();
      reject(new Error("SDK installation failed: timed out after 2 minutes"));
    }, INSTALL_TIMEOUT_MS);
    child.on("error", (err) => {
      clearTimeout(timeout);
      notice.hide();
      reject(new Error("SDK installation failed: " + err.message));
    });
    child.on("close", (code) => {
      clearTimeout(timeout);
      notice.hide();
      if (code !== 0) {
        reject(new Error("SDK installation failed: npm exited with code " + code));
        return;
      }
      if (!isSDKInstalled(pluginDir)) {
        reject(new Error("SDK installation failed: cli.js not found after install"));
        return;
      }
      new import_obsidian.Notice("Claude Code runtime installed successfully!");
      resolve();
    });
  });
}

// src/Plugin/Components/SingletonNotice.ts
var import_obsidian2 = require("obsidian");
var _SingletonNotice = class _SingletonNotice {
  static show(message, duration = 4e3) {
    if (_SingletonNotice.activeNotice) return;
    _SingletonNotice.activeNotice = new import_obsidian2.Notice(message, duration);
    setTimeout(() => {
      _SingletonNotice.activeNotice = null;
    }, duration);
  }
};
_SingletonNotice.activeNotice = null;
var SingletonNotice = _SingletonNotice;

// node_modules/@google/genai/dist/web/index.mjs
var _defaultBaseGeminiUrl = void 0;
var _defaultBaseVertexUrl = void 0;
function getDefaultBaseUrls() {
  return {
    geminiUrl: _defaultBaseGeminiUrl,
    vertexUrl: _defaultBaseVertexUrl
  };
}
function getBaseUrl(httpOptions, vertexai, vertexBaseUrlFromEnv, geminiBaseUrlFromEnv) {
  var _a5, _b;
  if (!(httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.baseUrl)) {
    const defaultBaseUrls = getDefaultBaseUrls();
    if (vertexai) {
      return (_a5 = defaultBaseUrls.vertexUrl) !== null && _a5 !== void 0 ? _a5 : vertexBaseUrlFromEnv;
    } else {
      return (_b = defaultBaseUrls.geminiUrl) !== null && _b !== void 0 ? _b : geminiBaseUrlFromEnv;
    }
  }
  return httpOptions.baseUrl;
}
var BaseModule = class {
};
function formatMap(templateString, valueMap) {
  const regex = /\{([^}]+)\}/g;
  return templateString.replace(regex, (match, key) => {
    if (Object.prototype.hasOwnProperty.call(valueMap, key)) {
      const value = valueMap[key];
      return value !== void 0 && value !== null ? String(value) : "";
    } else {
      throw new Error(`Key '${key}' not found in valueMap.`);
    }
  });
}
function setValueByPath(data, keys, value) {
  for (let i3 = 0; i3 < keys.length - 1; i3++) {
    const key = keys[i3];
    if (key.endsWith("[]")) {
      const keyName = key.slice(0, -2);
      if (!(keyName in data)) {
        if (Array.isArray(value)) {
          data[keyName] = Array.from({ length: value.length }, () => ({}));
        } else {
          throw new Error(`Value must be a list given an array path ${key}`);
        }
      }
      if (Array.isArray(data[keyName])) {
        const arrayData = data[keyName];
        if (Array.isArray(value)) {
          for (let j3 = 0; j3 < arrayData.length; j3++) {
            const entry = arrayData[j3];
            setValueByPath(entry, keys.slice(i3 + 1), value[j3]);
          }
        } else {
          for (const d3 of arrayData) {
            setValueByPath(d3, keys.slice(i3 + 1), value);
          }
        }
      }
      return;
    } else if (key.endsWith("[0]")) {
      const keyName = key.slice(0, -3);
      if (!(keyName in data)) {
        data[keyName] = [{}];
      }
      const arrayData = data[keyName];
      setValueByPath(arrayData[0], keys.slice(i3 + 1), value);
      return;
    }
    if (!data[key] || typeof data[key] !== "object") {
      data[key] = {};
    }
    data = data[key];
  }
  const keyToSet = keys[keys.length - 1];
  const existingData = data[keyToSet];
  if (existingData !== void 0) {
    if (!value || typeof value === "object" && Object.keys(value).length === 0) {
      return;
    }
    if (value === existingData) {
      return;
    }
    if (typeof existingData === "object" && typeof value === "object" && existingData !== null && value !== null) {
      Object.assign(existingData, value);
    } else {
      throw new Error(`Cannot set value for an existing key. Key: ${keyToSet}`);
    }
  } else {
    if (keyToSet === "_self" && typeof value === "object" && value !== null && !Array.isArray(value)) {
      const valueAsRecord = value;
      Object.assign(data, valueAsRecord);
    } else {
      data[keyToSet] = value;
    }
  }
}
function getValueByPath(data, keys, defaultValue = void 0) {
  try {
    if (keys.length === 1 && keys[0] === "_self") {
      return data;
    }
    for (let i3 = 0; i3 < keys.length; i3++) {
      if (typeof data !== "object" || data === null) {
        return defaultValue;
      }
      const key = keys[i3];
      if (key.endsWith("[]")) {
        const keyName = key.slice(0, -2);
        if (keyName in data) {
          const arrayData = data[keyName];
          if (!Array.isArray(arrayData)) {
            return defaultValue;
          }
          return arrayData.map((d3) => getValueByPath(d3, keys.slice(i3 + 1), defaultValue));
        } else {
          return defaultValue;
        }
      } else {
        data = data[key];
      }
    }
    return data;
  } catch (error) {
    if (error instanceof TypeError) {
      return defaultValue;
    }
    throw error;
  }
}
function moveValueByPath(data, paths) {
  for (const [sourcePath, destPath] of Object.entries(paths)) {
    const sourceKeys = sourcePath.split(".");
    const destKeys = destPath.split(".");
    const excludeKeys = /* @__PURE__ */ new Set();
    let wildcardIdx = -1;
    for (let i3 = 0; i3 < sourceKeys.length; i3++) {
      if (sourceKeys[i3] === "*") {
        wildcardIdx = i3;
        break;
      }
    }
    if (wildcardIdx !== -1 && destKeys.length > wildcardIdx) {
      for (let i3 = wildcardIdx; i3 < destKeys.length; i3++) {
        const key = destKeys[i3];
        if (key !== "*" && !key.endsWith("[]") && !key.endsWith("[0]")) {
          excludeKeys.add(key);
        }
      }
    }
    _moveValueRecursive(data, sourceKeys, destKeys, 0, excludeKeys);
  }
}
function _moveValueRecursive(data, sourceKeys, destKeys, keyIdx, excludeKeys) {
  if (keyIdx >= sourceKeys.length) {
    return;
  }
  if (typeof data !== "object" || data === null) {
    return;
  }
  const key = sourceKeys[keyIdx];
  if (key.endsWith("[]")) {
    const keyName = key.slice(0, -2);
    const dataRecord = data;
    if (keyName in dataRecord && Array.isArray(dataRecord[keyName])) {
      for (const item of dataRecord[keyName]) {
        _moveValueRecursive(item, sourceKeys, destKeys, keyIdx + 1, excludeKeys);
      }
    }
  } else if (key === "*") {
    if (typeof data === "object" && data !== null && !Array.isArray(data)) {
      const dataRecord = data;
      const keysToMove = Object.keys(dataRecord).filter((k) => !k.startsWith("_") && !excludeKeys.has(k));
      const valuesToMove = {};
      for (const k of keysToMove) {
        valuesToMove[k] = dataRecord[k];
      }
      for (const [k, v3] of Object.entries(valuesToMove)) {
        const newDestKeys = [];
        for (const dk of destKeys.slice(keyIdx)) {
          if (dk === "*") {
            newDestKeys.push(k);
          } else {
            newDestKeys.push(dk);
          }
        }
        setValueByPath(dataRecord, newDestKeys, v3);
      }
      for (const k of keysToMove) {
        delete dataRecord[k];
      }
    }
  } else {
    const dataRecord = data;
    if (key in dataRecord) {
      _moveValueRecursive(dataRecord[key], sourceKeys, destKeys, keyIdx + 1, excludeKeys);
    }
  }
}
function tBytes$1(fromBytes) {
  if (typeof fromBytes !== "string") {
    throw new Error("fromImageBytes must be a string");
  }
  return fromBytes;
}
function fetchPredictOperationParametersToVertex(fromObject) {
  const toObject = {};
  const fromOperationName = getValueByPath(fromObject, [
    "operationName"
  ]);
  if (fromOperationName != null) {
    setValueByPath(toObject, ["operationName"], fromOperationName);
  }
  const fromResourceName = getValueByPath(fromObject, ["resourceName"]);
  if (fromResourceName != null) {
    setValueByPath(toObject, ["_url", "resourceName"], fromResourceName);
  }
  return toObject;
}
function generateVideosOperationFromMldev$1(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromMetadata = getValueByPath(fromObject, ["metadata"]);
  if (fromMetadata != null) {
    setValueByPath(toObject, ["metadata"], fromMetadata);
  }
  const fromDone = getValueByPath(fromObject, ["done"]);
  if (fromDone != null) {
    setValueByPath(toObject, ["done"], fromDone);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fromError);
  }
  const fromResponse = getValueByPath(fromObject, [
    "response",
    "generateVideoResponse"
  ]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], generateVideosResponseFromMldev$1(fromResponse));
  }
  return toObject;
}
function generateVideosOperationFromVertex$1(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromMetadata = getValueByPath(fromObject, ["metadata"]);
  if (fromMetadata != null) {
    setValueByPath(toObject, ["metadata"], fromMetadata);
  }
  const fromDone = getValueByPath(fromObject, ["done"]);
  if (fromDone != null) {
    setValueByPath(toObject, ["done"], fromDone);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fromError);
  }
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], generateVideosResponseFromVertex$1(fromResponse));
  }
  return toObject;
}
function generateVideosResponseFromMldev$1(fromObject) {
  const toObject = {};
  const fromGeneratedVideos = getValueByPath(fromObject, [
    "generatedSamples"
  ]);
  if (fromGeneratedVideos != null) {
    let transformedList = fromGeneratedVideos;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return generatedVideoFromMldev$1(item);
      });
    }
    setValueByPath(toObject, ["generatedVideos"], transformedList);
  }
  const fromRaiMediaFilteredCount = getValueByPath(fromObject, [
    "raiMediaFilteredCount"
  ]);
  if (fromRaiMediaFilteredCount != null) {
    setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
  }
  const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [
    "raiMediaFilteredReasons"
  ]);
  if (fromRaiMediaFilteredReasons != null) {
    setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
  }
  return toObject;
}
function generateVideosResponseFromVertex$1(fromObject) {
  const toObject = {};
  const fromGeneratedVideos = getValueByPath(fromObject, ["videos"]);
  if (fromGeneratedVideos != null) {
    let transformedList = fromGeneratedVideos;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return generatedVideoFromVertex$1(item);
      });
    }
    setValueByPath(toObject, ["generatedVideos"], transformedList);
  }
  const fromRaiMediaFilteredCount = getValueByPath(fromObject, [
    "raiMediaFilteredCount"
  ]);
  if (fromRaiMediaFilteredCount != null) {
    setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
  }
  const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [
    "raiMediaFilteredReasons"
  ]);
  if (fromRaiMediaFilteredReasons != null) {
    setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
  }
  return toObject;
}
function generatedVideoFromMldev$1(fromObject) {
  const toObject = {};
  const fromVideo = getValueByPath(fromObject, ["video"]);
  if (fromVideo != null) {
    setValueByPath(toObject, ["video"], videoFromMldev$1(fromVideo));
  }
  return toObject;
}
function generatedVideoFromVertex$1(fromObject) {
  const toObject = {};
  const fromVideo = getValueByPath(fromObject, ["_self"]);
  if (fromVideo != null) {
    setValueByPath(toObject, ["video"], videoFromVertex$1(fromVideo));
  }
  return toObject;
}
function getOperationParametersToMldev(fromObject) {
  const toObject = {};
  const fromOperationName = getValueByPath(fromObject, [
    "operationName"
  ]);
  if (fromOperationName != null) {
    setValueByPath(toObject, ["_url", "operationName"], fromOperationName);
  }
  return toObject;
}
function getOperationParametersToVertex(fromObject) {
  const toObject = {};
  const fromOperationName = getValueByPath(fromObject, [
    "operationName"
  ]);
  if (fromOperationName != null) {
    setValueByPath(toObject, ["_url", "operationName"], fromOperationName);
  }
  return toObject;
}
function importFileOperationFromMldev$1(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromMetadata = getValueByPath(fromObject, ["metadata"]);
  if (fromMetadata != null) {
    setValueByPath(toObject, ["metadata"], fromMetadata);
  }
  const fromDone = getValueByPath(fromObject, ["done"]);
  if (fromDone != null) {
    setValueByPath(toObject, ["done"], fromDone);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fromError);
  }
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], importFileResponseFromMldev$1(fromResponse));
  }
  return toObject;
}
function importFileResponseFromMldev$1(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromParent = getValueByPath(fromObject, ["parent"]);
  if (fromParent != null) {
    setValueByPath(toObject, ["parent"], fromParent);
  }
  const fromDocumentName = getValueByPath(fromObject, ["documentName"]);
  if (fromDocumentName != null) {
    setValueByPath(toObject, ["documentName"], fromDocumentName);
  }
  return toObject;
}
function uploadToFileSearchStoreOperationFromMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromMetadata = getValueByPath(fromObject, ["metadata"]);
  if (fromMetadata != null) {
    setValueByPath(toObject, ["metadata"], fromMetadata);
  }
  const fromDone = getValueByPath(fromObject, ["done"]);
  if (fromDone != null) {
    setValueByPath(toObject, ["done"], fromDone);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fromError);
  }
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], uploadToFileSearchStoreResponseFromMldev(fromResponse));
  }
  return toObject;
}
function uploadToFileSearchStoreResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromParent = getValueByPath(fromObject, ["parent"]);
  if (fromParent != null) {
    setValueByPath(toObject, ["parent"], fromParent);
  }
  const fromDocumentName = getValueByPath(fromObject, ["documentName"]);
  if (fromDocumentName != null) {
    setValueByPath(toObject, ["documentName"], fromDocumentName);
  }
  return toObject;
}
function videoFromMldev$1(fromObject) {
  const toObject = {};
  const fromUri = getValueByPath(fromObject, ["uri"]);
  if (fromUri != null) {
    setValueByPath(toObject, ["uri"], fromUri);
  }
  const fromVideoBytes = getValueByPath(fromObject, ["encodedVideo"]);
  if (fromVideoBytes != null) {
    setValueByPath(toObject, ["videoBytes"], tBytes$1(fromVideoBytes));
  }
  const fromMimeType = getValueByPath(fromObject, ["encoding"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function videoFromVertex$1(fromObject) {
  const toObject = {};
  const fromUri = getValueByPath(fromObject, ["gcsUri"]);
  if (fromUri != null) {
    setValueByPath(toObject, ["uri"], fromUri);
  }
  const fromVideoBytes = getValueByPath(fromObject, [
    "bytesBase64Encoded"
  ]);
  if (fromVideoBytes != null) {
    setValueByPath(toObject, ["videoBytes"], tBytes$1(fromVideoBytes));
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
var Outcome;
(function(Outcome2) {
  Outcome2["OUTCOME_UNSPECIFIED"] = "OUTCOME_UNSPECIFIED";
  Outcome2["OUTCOME_OK"] = "OUTCOME_OK";
  Outcome2["OUTCOME_FAILED"] = "OUTCOME_FAILED";
  Outcome2["OUTCOME_DEADLINE_EXCEEDED"] = "OUTCOME_DEADLINE_EXCEEDED";
})(Outcome || (Outcome = {}));
var Language;
(function(Language2) {
  Language2["LANGUAGE_UNSPECIFIED"] = "LANGUAGE_UNSPECIFIED";
  Language2["PYTHON"] = "PYTHON";
})(Language || (Language = {}));
var FunctionResponseScheduling;
(function(FunctionResponseScheduling2) {
  FunctionResponseScheduling2["SCHEDULING_UNSPECIFIED"] = "SCHEDULING_UNSPECIFIED";
  FunctionResponseScheduling2["SILENT"] = "SILENT";
  FunctionResponseScheduling2["WHEN_IDLE"] = "WHEN_IDLE";
  FunctionResponseScheduling2["INTERRUPT"] = "INTERRUPT";
})(FunctionResponseScheduling || (FunctionResponseScheduling = {}));
var Type;
(function(Type2) {
  Type2["TYPE_UNSPECIFIED"] = "TYPE_UNSPECIFIED";
  Type2["STRING"] = "STRING";
  Type2["NUMBER"] = "NUMBER";
  Type2["INTEGER"] = "INTEGER";
  Type2["BOOLEAN"] = "BOOLEAN";
  Type2["ARRAY"] = "ARRAY";
  Type2["OBJECT"] = "OBJECT";
  Type2["NULL"] = "NULL";
})(Type || (Type = {}));
var ApiSpec;
(function(ApiSpec2) {
  ApiSpec2["API_SPEC_UNSPECIFIED"] = "API_SPEC_UNSPECIFIED";
  ApiSpec2["SIMPLE_SEARCH"] = "SIMPLE_SEARCH";
  ApiSpec2["ELASTIC_SEARCH"] = "ELASTIC_SEARCH";
})(ApiSpec || (ApiSpec = {}));
var AuthType;
(function(AuthType2) {
  AuthType2["AUTH_TYPE_UNSPECIFIED"] = "AUTH_TYPE_UNSPECIFIED";
  AuthType2["NO_AUTH"] = "NO_AUTH";
  AuthType2["API_KEY_AUTH"] = "API_KEY_AUTH";
  AuthType2["HTTP_BASIC_AUTH"] = "HTTP_BASIC_AUTH";
  AuthType2["GOOGLE_SERVICE_ACCOUNT_AUTH"] = "GOOGLE_SERVICE_ACCOUNT_AUTH";
  AuthType2["OAUTH"] = "OAUTH";
  AuthType2["OIDC_AUTH"] = "OIDC_AUTH";
})(AuthType || (AuthType = {}));
var HttpElementLocation;
(function(HttpElementLocation2) {
  HttpElementLocation2["HTTP_IN_UNSPECIFIED"] = "HTTP_IN_UNSPECIFIED";
  HttpElementLocation2["HTTP_IN_QUERY"] = "HTTP_IN_QUERY";
  HttpElementLocation2["HTTP_IN_HEADER"] = "HTTP_IN_HEADER";
  HttpElementLocation2["HTTP_IN_PATH"] = "HTTP_IN_PATH";
  HttpElementLocation2["HTTP_IN_BODY"] = "HTTP_IN_BODY";
  HttpElementLocation2["HTTP_IN_COOKIE"] = "HTTP_IN_COOKIE";
})(HttpElementLocation || (HttpElementLocation = {}));
var PhishBlockThreshold;
(function(PhishBlockThreshold2) {
  PhishBlockThreshold2["PHISH_BLOCK_THRESHOLD_UNSPECIFIED"] = "PHISH_BLOCK_THRESHOLD_UNSPECIFIED";
  PhishBlockThreshold2["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
  PhishBlockThreshold2["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
  PhishBlockThreshold2["BLOCK_HIGH_AND_ABOVE"] = "BLOCK_HIGH_AND_ABOVE";
  PhishBlockThreshold2["BLOCK_HIGHER_AND_ABOVE"] = "BLOCK_HIGHER_AND_ABOVE";
  PhishBlockThreshold2["BLOCK_VERY_HIGH_AND_ABOVE"] = "BLOCK_VERY_HIGH_AND_ABOVE";
  PhishBlockThreshold2["BLOCK_ONLY_EXTREMELY_HIGH"] = "BLOCK_ONLY_EXTREMELY_HIGH";
})(PhishBlockThreshold || (PhishBlockThreshold = {}));
var Behavior;
(function(Behavior2) {
  Behavior2["UNSPECIFIED"] = "UNSPECIFIED";
  Behavior2["BLOCKING"] = "BLOCKING";
  Behavior2["NON_BLOCKING"] = "NON_BLOCKING";
})(Behavior || (Behavior = {}));
var DynamicRetrievalConfigMode;
(function(DynamicRetrievalConfigMode2) {
  DynamicRetrievalConfigMode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
  DynamicRetrievalConfigMode2["MODE_DYNAMIC"] = "MODE_DYNAMIC";
})(DynamicRetrievalConfigMode || (DynamicRetrievalConfigMode = {}));
var FunctionCallingConfigMode;
(function(FunctionCallingConfigMode2) {
  FunctionCallingConfigMode2["MODE_UNSPECIFIED"] = "MODE_UNSPECIFIED";
  FunctionCallingConfigMode2["AUTO"] = "AUTO";
  FunctionCallingConfigMode2["ANY"] = "ANY";
  FunctionCallingConfigMode2["NONE"] = "NONE";
  FunctionCallingConfigMode2["VALIDATED"] = "VALIDATED";
})(FunctionCallingConfigMode || (FunctionCallingConfigMode = {}));
var ThinkingLevel;
(function(ThinkingLevel2) {
  ThinkingLevel2["THINKING_LEVEL_UNSPECIFIED"] = "THINKING_LEVEL_UNSPECIFIED";
  ThinkingLevel2["LOW"] = "LOW";
  ThinkingLevel2["MEDIUM"] = "MEDIUM";
  ThinkingLevel2["HIGH"] = "HIGH";
  ThinkingLevel2["MINIMAL"] = "MINIMAL";
})(ThinkingLevel || (ThinkingLevel = {}));
var HarmCategory;
(function(HarmCategory2) {
  HarmCategory2["HARM_CATEGORY_UNSPECIFIED"] = "HARM_CATEGORY_UNSPECIFIED";
  HarmCategory2["HARM_CATEGORY_HARASSMENT"] = "HARM_CATEGORY_HARASSMENT";
  HarmCategory2["HARM_CATEGORY_HATE_SPEECH"] = "HARM_CATEGORY_HATE_SPEECH";
  HarmCategory2["HARM_CATEGORY_SEXUALLY_EXPLICIT"] = "HARM_CATEGORY_SEXUALLY_EXPLICIT";
  HarmCategory2["HARM_CATEGORY_DANGEROUS_CONTENT"] = "HARM_CATEGORY_DANGEROUS_CONTENT";
  HarmCategory2["HARM_CATEGORY_CIVIC_INTEGRITY"] = "HARM_CATEGORY_CIVIC_INTEGRITY";
  HarmCategory2["HARM_CATEGORY_IMAGE_HATE"] = "HARM_CATEGORY_IMAGE_HATE";
  HarmCategory2["HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT"] = "HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT";
  HarmCategory2["HARM_CATEGORY_IMAGE_HARASSMENT"] = "HARM_CATEGORY_IMAGE_HARASSMENT";
  HarmCategory2["HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT"] = "HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT";
  HarmCategory2["HARM_CATEGORY_JAILBREAK"] = "HARM_CATEGORY_JAILBREAK";
})(HarmCategory || (HarmCategory = {}));
var HarmBlockMethod;
(function(HarmBlockMethod2) {
  HarmBlockMethod2["HARM_BLOCK_METHOD_UNSPECIFIED"] = "HARM_BLOCK_METHOD_UNSPECIFIED";
  HarmBlockMethod2["SEVERITY"] = "SEVERITY";
  HarmBlockMethod2["PROBABILITY"] = "PROBABILITY";
})(HarmBlockMethod || (HarmBlockMethod = {}));
var HarmBlockThreshold;
(function(HarmBlockThreshold2) {
  HarmBlockThreshold2["HARM_BLOCK_THRESHOLD_UNSPECIFIED"] = "HARM_BLOCK_THRESHOLD_UNSPECIFIED";
  HarmBlockThreshold2["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
  HarmBlockThreshold2["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
  HarmBlockThreshold2["BLOCK_ONLY_HIGH"] = "BLOCK_ONLY_HIGH";
  HarmBlockThreshold2["BLOCK_NONE"] = "BLOCK_NONE";
  HarmBlockThreshold2["OFF"] = "OFF";
})(HarmBlockThreshold || (HarmBlockThreshold = {}));
var FinishReason;
(function(FinishReason2) {
  FinishReason2["FINISH_REASON_UNSPECIFIED"] = "FINISH_REASON_UNSPECIFIED";
  FinishReason2["STOP"] = "STOP";
  FinishReason2["MAX_TOKENS"] = "MAX_TOKENS";
  FinishReason2["SAFETY"] = "SAFETY";
  FinishReason2["RECITATION"] = "RECITATION";
  FinishReason2["LANGUAGE"] = "LANGUAGE";
  FinishReason2["OTHER"] = "OTHER";
  FinishReason2["BLOCKLIST"] = "BLOCKLIST";
  FinishReason2["PROHIBITED_CONTENT"] = "PROHIBITED_CONTENT";
  FinishReason2["SPII"] = "SPII";
  FinishReason2["MALFORMED_FUNCTION_CALL"] = "MALFORMED_FUNCTION_CALL";
  FinishReason2["IMAGE_SAFETY"] = "IMAGE_SAFETY";
  FinishReason2["UNEXPECTED_TOOL_CALL"] = "UNEXPECTED_TOOL_CALL";
  FinishReason2["IMAGE_PROHIBITED_CONTENT"] = "IMAGE_PROHIBITED_CONTENT";
  FinishReason2["NO_IMAGE"] = "NO_IMAGE";
  FinishReason2["IMAGE_RECITATION"] = "IMAGE_RECITATION";
  FinishReason2["IMAGE_OTHER"] = "IMAGE_OTHER";
})(FinishReason || (FinishReason = {}));
var HarmProbability;
(function(HarmProbability2) {
  HarmProbability2["HARM_PROBABILITY_UNSPECIFIED"] = "HARM_PROBABILITY_UNSPECIFIED";
  HarmProbability2["NEGLIGIBLE"] = "NEGLIGIBLE";
  HarmProbability2["LOW"] = "LOW";
  HarmProbability2["MEDIUM"] = "MEDIUM";
  HarmProbability2["HIGH"] = "HIGH";
})(HarmProbability || (HarmProbability = {}));
var HarmSeverity;
(function(HarmSeverity2) {
  HarmSeverity2["HARM_SEVERITY_UNSPECIFIED"] = "HARM_SEVERITY_UNSPECIFIED";
  HarmSeverity2["HARM_SEVERITY_NEGLIGIBLE"] = "HARM_SEVERITY_NEGLIGIBLE";
  HarmSeverity2["HARM_SEVERITY_LOW"] = "HARM_SEVERITY_LOW";
  HarmSeverity2["HARM_SEVERITY_MEDIUM"] = "HARM_SEVERITY_MEDIUM";
  HarmSeverity2["HARM_SEVERITY_HIGH"] = "HARM_SEVERITY_HIGH";
})(HarmSeverity || (HarmSeverity = {}));
var UrlRetrievalStatus;
(function(UrlRetrievalStatus2) {
  UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_UNSPECIFIED"] = "URL_RETRIEVAL_STATUS_UNSPECIFIED";
  UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_SUCCESS"] = "URL_RETRIEVAL_STATUS_SUCCESS";
  UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_ERROR"] = "URL_RETRIEVAL_STATUS_ERROR";
  UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_PAYWALL"] = "URL_RETRIEVAL_STATUS_PAYWALL";
  UrlRetrievalStatus2["URL_RETRIEVAL_STATUS_UNSAFE"] = "URL_RETRIEVAL_STATUS_UNSAFE";
})(UrlRetrievalStatus || (UrlRetrievalStatus = {}));
var BlockedReason;
(function(BlockedReason2) {
  BlockedReason2["BLOCKED_REASON_UNSPECIFIED"] = "BLOCKED_REASON_UNSPECIFIED";
  BlockedReason2["SAFETY"] = "SAFETY";
  BlockedReason2["OTHER"] = "OTHER";
  BlockedReason2["BLOCKLIST"] = "BLOCKLIST";
  BlockedReason2["PROHIBITED_CONTENT"] = "PROHIBITED_CONTENT";
  BlockedReason2["IMAGE_SAFETY"] = "IMAGE_SAFETY";
  BlockedReason2["MODEL_ARMOR"] = "MODEL_ARMOR";
  BlockedReason2["JAILBREAK"] = "JAILBREAK";
})(BlockedReason || (BlockedReason = {}));
var TrafficType;
(function(TrafficType2) {
  TrafficType2["TRAFFIC_TYPE_UNSPECIFIED"] = "TRAFFIC_TYPE_UNSPECIFIED";
  TrafficType2["ON_DEMAND"] = "ON_DEMAND";
  TrafficType2["PROVISIONED_THROUGHPUT"] = "PROVISIONED_THROUGHPUT";
})(TrafficType || (TrafficType = {}));
var Modality;
(function(Modality2) {
  Modality2["MODALITY_UNSPECIFIED"] = "MODALITY_UNSPECIFIED";
  Modality2["TEXT"] = "TEXT";
  Modality2["IMAGE"] = "IMAGE";
  Modality2["AUDIO"] = "AUDIO";
})(Modality || (Modality = {}));
var MediaResolution;
(function(MediaResolution2) {
  MediaResolution2["MEDIA_RESOLUTION_UNSPECIFIED"] = "MEDIA_RESOLUTION_UNSPECIFIED";
  MediaResolution2["MEDIA_RESOLUTION_LOW"] = "MEDIA_RESOLUTION_LOW";
  MediaResolution2["MEDIA_RESOLUTION_MEDIUM"] = "MEDIA_RESOLUTION_MEDIUM";
  MediaResolution2["MEDIA_RESOLUTION_HIGH"] = "MEDIA_RESOLUTION_HIGH";
})(MediaResolution || (MediaResolution = {}));
var TuningMode;
(function(TuningMode2) {
  TuningMode2["TUNING_MODE_UNSPECIFIED"] = "TUNING_MODE_UNSPECIFIED";
  TuningMode2["TUNING_MODE_FULL"] = "TUNING_MODE_FULL";
  TuningMode2["TUNING_MODE_PEFT_ADAPTER"] = "TUNING_MODE_PEFT_ADAPTER";
})(TuningMode || (TuningMode = {}));
var AdapterSize;
(function(AdapterSize2) {
  AdapterSize2["ADAPTER_SIZE_UNSPECIFIED"] = "ADAPTER_SIZE_UNSPECIFIED";
  AdapterSize2["ADAPTER_SIZE_ONE"] = "ADAPTER_SIZE_ONE";
  AdapterSize2["ADAPTER_SIZE_TWO"] = "ADAPTER_SIZE_TWO";
  AdapterSize2["ADAPTER_SIZE_FOUR"] = "ADAPTER_SIZE_FOUR";
  AdapterSize2["ADAPTER_SIZE_EIGHT"] = "ADAPTER_SIZE_EIGHT";
  AdapterSize2["ADAPTER_SIZE_SIXTEEN"] = "ADAPTER_SIZE_SIXTEEN";
  AdapterSize2["ADAPTER_SIZE_THIRTY_TWO"] = "ADAPTER_SIZE_THIRTY_TWO";
})(AdapterSize || (AdapterSize = {}));
var JobState;
(function(JobState2) {
  JobState2["JOB_STATE_UNSPECIFIED"] = "JOB_STATE_UNSPECIFIED";
  JobState2["JOB_STATE_QUEUED"] = "JOB_STATE_QUEUED";
  JobState2["JOB_STATE_PENDING"] = "JOB_STATE_PENDING";
  JobState2["JOB_STATE_RUNNING"] = "JOB_STATE_RUNNING";
  JobState2["JOB_STATE_SUCCEEDED"] = "JOB_STATE_SUCCEEDED";
  JobState2["JOB_STATE_FAILED"] = "JOB_STATE_FAILED";
  JobState2["JOB_STATE_CANCELLING"] = "JOB_STATE_CANCELLING";
  JobState2["JOB_STATE_CANCELLED"] = "JOB_STATE_CANCELLED";
  JobState2["JOB_STATE_PAUSED"] = "JOB_STATE_PAUSED";
  JobState2["JOB_STATE_EXPIRED"] = "JOB_STATE_EXPIRED";
  JobState2["JOB_STATE_UPDATING"] = "JOB_STATE_UPDATING";
  JobState2["JOB_STATE_PARTIALLY_SUCCEEDED"] = "JOB_STATE_PARTIALLY_SUCCEEDED";
})(JobState || (JobState = {}));
var TuningTask;
(function(TuningTask2) {
  TuningTask2["TUNING_TASK_UNSPECIFIED"] = "TUNING_TASK_UNSPECIFIED";
  TuningTask2["TUNING_TASK_I2V"] = "TUNING_TASK_I2V";
  TuningTask2["TUNING_TASK_T2V"] = "TUNING_TASK_T2V";
  TuningTask2["TUNING_TASK_R2V"] = "TUNING_TASK_R2V";
})(TuningTask || (TuningTask = {}));
var PartMediaResolutionLevel;
(function(PartMediaResolutionLevel2) {
  PartMediaResolutionLevel2["MEDIA_RESOLUTION_UNSPECIFIED"] = "MEDIA_RESOLUTION_UNSPECIFIED";
  PartMediaResolutionLevel2["MEDIA_RESOLUTION_LOW"] = "MEDIA_RESOLUTION_LOW";
  PartMediaResolutionLevel2["MEDIA_RESOLUTION_MEDIUM"] = "MEDIA_RESOLUTION_MEDIUM";
  PartMediaResolutionLevel2["MEDIA_RESOLUTION_HIGH"] = "MEDIA_RESOLUTION_HIGH";
  PartMediaResolutionLevel2["MEDIA_RESOLUTION_ULTRA_HIGH"] = "MEDIA_RESOLUTION_ULTRA_HIGH";
})(PartMediaResolutionLevel || (PartMediaResolutionLevel = {}));
var ResourceScope;
(function(ResourceScope2) {
  ResourceScope2["COLLECTION"] = "COLLECTION";
})(ResourceScope || (ResourceScope = {}));
var FeatureSelectionPreference;
(function(FeatureSelectionPreference2) {
  FeatureSelectionPreference2["FEATURE_SELECTION_PREFERENCE_UNSPECIFIED"] = "FEATURE_SELECTION_PREFERENCE_UNSPECIFIED";
  FeatureSelectionPreference2["PRIORITIZE_QUALITY"] = "PRIORITIZE_QUALITY";
  FeatureSelectionPreference2["BALANCED"] = "BALANCED";
  FeatureSelectionPreference2["PRIORITIZE_COST"] = "PRIORITIZE_COST";
})(FeatureSelectionPreference || (FeatureSelectionPreference = {}));
var Environment;
(function(Environment2) {
  Environment2["ENVIRONMENT_UNSPECIFIED"] = "ENVIRONMENT_UNSPECIFIED";
  Environment2["ENVIRONMENT_BROWSER"] = "ENVIRONMENT_BROWSER";
})(Environment || (Environment = {}));
var SafetyFilterLevel;
(function(SafetyFilterLevel2) {
  SafetyFilterLevel2["BLOCK_LOW_AND_ABOVE"] = "BLOCK_LOW_AND_ABOVE";
  SafetyFilterLevel2["BLOCK_MEDIUM_AND_ABOVE"] = "BLOCK_MEDIUM_AND_ABOVE";
  SafetyFilterLevel2["BLOCK_ONLY_HIGH"] = "BLOCK_ONLY_HIGH";
  SafetyFilterLevel2["BLOCK_NONE"] = "BLOCK_NONE";
})(SafetyFilterLevel || (SafetyFilterLevel = {}));
var PersonGeneration;
(function(PersonGeneration2) {
  PersonGeneration2["DONT_ALLOW"] = "DONT_ALLOW";
  PersonGeneration2["ALLOW_ADULT"] = "ALLOW_ADULT";
  PersonGeneration2["ALLOW_ALL"] = "ALLOW_ALL";
})(PersonGeneration || (PersonGeneration = {}));
var ImagePromptLanguage;
(function(ImagePromptLanguage2) {
  ImagePromptLanguage2["auto"] = "auto";
  ImagePromptLanguage2["en"] = "en";
  ImagePromptLanguage2["ja"] = "ja";
  ImagePromptLanguage2["ko"] = "ko";
  ImagePromptLanguage2["hi"] = "hi";
  ImagePromptLanguage2["zh"] = "zh";
  ImagePromptLanguage2["pt"] = "pt";
  ImagePromptLanguage2["es"] = "es";
})(ImagePromptLanguage || (ImagePromptLanguage = {}));
var MaskReferenceMode;
(function(MaskReferenceMode2) {
  MaskReferenceMode2["MASK_MODE_DEFAULT"] = "MASK_MODE_DEFAULT";
  MaskReferenceMode2["MASK_MODE_USER_PROVIDED"] = "MASK_MODE_USER_PROVIDED";
  MaskReferenceMode2["MASK_MODE_BACKGROUND"] = "MASK_MODE_BACKGROUND";
  MaskReferenceMode2["MASK_MODE_FOREGROUND"] = "MASK_MODE_FOREGROUND";
  MaskReferenceMode2["MASK_MODE_SEMANTIC"] = "MASK_MODE_SEMANTIC";
})(MaskReferenceMode || (MaskReferenceMode = {}));
var ControlReferenceType;
(function(ControlReferenceType2) {
  ControlReferenceType2["CONTROL_TYPE_DEFAULT"] = "CONTROL_TYPE_DEFAULT";
  ControlReferenceType2["CONTROL_TYPE_CANNY"] = "CONTROL_TYPE_CANNY";
  ControlReferenceType2["CONTROL_TYPE_SCRIBBLE"] = "CONTROL_TYPE_SCRIBBLE";
  ControlReferenceType2["CONTROL_TYPE_FACE_MESH"] = "CONTROL_TYPE_FACE_MESH";
})(ControlReferenceType || (ControlReferenceType = {}));
var SubjectReferenceType;
(function(SubjectReferenceType2) {
  SubjectReferenceType2["SUBJECT_TYPE_DEFAULT"] = "SUBJECT_TYPE_DEFAULT";
  SubjectReferenceType2["SUBJECT_TYPE_PERSON"] = "SUBJECT_TYPE_PERSON";
  SubjectReferenceType2["SUBJECT_TYPE_ANIMAL"] = "SUBJECT_TYPE_ANIMAL";
  SubjectReferenceType2["SUBJECT_TYPE_PRODUCT"] = "SUBJECT_TYPE_PRODUCT";
})(SubjectReferenceType || (SubjectReferenceType = {}));
var EditMode;
(function(EditMode2) {
  EditMode2["EDIT_MODE_DEFAULT"] = "EDIT_MODE_DEFAULT";
  EditMode2["EDIT_MODE_INPAINT_REMOVAL"] = "EDIT_MODE_INPAINT_REMOVAL";
  EditMode2["EDIT_MODE_INPAINT_INSERTION"] = "EDIT_MODE_INPAINT_INSERTION";
  EditMode2["EDIT_MODE_OUTPAINT"] = "EDIT_MODE_OUTPAINT";
  EditMode2["EDIT_MODE_CONTROLLED_EDITING"] = "EDIT_MODE_CONTROLLED_EDITING";
  EditMode2["EDIT_MODE_STYLE"] = "EDIT_MODE_STYLE";
  EditMode2["EDIT_MODE_BGSWAP"] = "EDIT_MODE_BGSWAP";
  EditMode2["EDIT_MODE_PRODUCT_IMAGE"] = "EDIT_MODE_PRODUCT_IMAGE";
})(EditMode || (EditMode = {}));
var SegmentMode;
(function(SegmentMode2) {
  SegmentMode2["FOREGROUND"] = "FOREGROUND";
  SegmentMode2["BACKGROUND"] = "BACKGROUND";
  SegmentMode2["PROMPT"] = "PROMPT";
  SegmentMode2["SEMANTIC"] = "SEMANTIC";
  SegmentMode2["INTERACTIVE"] = "INTERACTIVE";
})(SegmentMode || (SegmentMode = {}));
var VideoGenerationReferenceType;
(function(VideoGenerationReferenceType2) {
  VideoGenerationReferenceType2["ASSET"] = "ASSET";
  VideoGenerationReferenceType2["STYLE"] = "STYLE";
})(VideoGenerationReferenceType || (VideoGenerationReferenceType = {}));
var VideoGenerationMaskMode;
(function(VideoGenerationMaskMode2) {
  VideoGenerationMaskMode2["INSERT"] = "INSERT";
  VideoGenerationMaskMode2["REMOVE"] = "REMOVE";
  VideoGenerationMaskMode2["REMOVE_STATIC"] = "REMOVE_STATIC";
  VideoGenerationMaskMode2["OUTPAINT"] = "OUTPAINT";
})(VideoGenerationMaskMode || (VideoGenerationMaskMode = {}));
var VideoCompressionQuality;
(function(VideoCompressionQuality2) {
  VideoCompressionQuality2["OPTIMIZED"] = "OPTIMIZED";
  VideoCompressionQuality2["LOSSLESS"] = "LOSSLESS";
})(VideoCompressionQuality || (VideoCompressionQuality = {}));
var TuningMethod;
(function(TuningMethod2) {
  TuningMethod2["SUPERVISED_FINE_TUNING"] = "SUPERVISED_FINE_TUNING";
  TuningMethod2["PREFERENCE_TUNING"] = "PREFERENCE_TUNING";
  TuningMethod2["DISTILLATION"] = "DISTILLATION";
})(TuningMethod || (TuningMethod = {}));
var DocumentState;
(function(DocumentState2) {
  DocumentState2["STATE_UNSPECIFIED"] = "STATE_UNSPECIFIED";
  DocumentState2["STATE_PENDING"] = "STATE_PENDING";
  DocumentState2["STATE_ACTIVE"] = "STATE_ACTIVE";
  DocumentState2["STATE_FAILED"] = "STATE_FAILED";
})(DocumentState || (DocumentState = {}));
var FileState;
(function(FileState2) {
  FileState2["STATE_UNSPECIFIED"] = "STATE_UNSPECIFIED";
  FileState2["PROCESSING"] = "PROCESSING";
  FileState2["ACTIVE"] = "ACTIVE";
  FileState2["FAILED"] = "FAILED";
})(FileState || (FileState = {}));
var FileSource;
(function(FileSource2) {
  FileSource2["SOURCE_UNSPECIFIED"] = "SOURCE_UNSPECIFIED";
  FileSource2["UPLOADED"] = "UPLOADED";
  FileSource2["GENERATED"] = "GENERATED";
  FileSource2["REGISTERED"] = "REGISTERED";
})(FileSource || (FileSource = {}));
var TurnCompleteReason;
(function(TurnCompleteReason2) {
  TurnCompleteReason2["TURN_COMPLETE_REASON_UNSPECIFIED"] = "TURN_COMPLETE_REASON_UNSPECIFIED";
  TurnCompleteReason2["MALFORMED_FUNCTION_CALL"] = "MALFORMED_FUNCTION_CALL";
  TurnCompleteReason2["RESPONSE_REJECTED"] = "RESPONSE_REJECTED";
  TurnCompleteReason2["NEED_MORE_INPUT"] = "NEED_MORE_INPUT";
})(TurnCompleteReason || (TurnCompleteReason = {}));
var MediaModality;
(function(MediaModality2) {
  MediaModality2["MODALITY_UNSPECIFIED"] = "MODALITY_UNSPECIFIED";
  MediaModality2["TEXT"] = "TEXT";
  MediaModality2["IMAGE"] = "IMAGE";
  MediaModality2["VIDEO"] = "VIDEO";
  MediaModality2["AUDIO"] = "AUDIO";
  MediaModality2["DOCUMENT"] = "DOCUMENT";
})(MediaModality || (MediaModality = {}));
var VadSignalType;
(function(VadSignalType2) {
  VadSignalType2["VAD_SIGNAL_TYPE_UNSPECIFIED"] = "VAD_SIGNAL_TYPE_UNSPECIFIED";
  VadSignalType2["VAD_SIGNAL_TYPE_SOS"] = "VAD_SIGNAL_TYPE_SOS";
  VadSignalType2["VAD_SIGNAL_TYPE_EOS"] = "VAD_SIGNAL_TYPE_EOS";
})(VadSignalType || (VadSignalType = {}));
var VoiceActivityType;
(function(VoiceActivityType2) {
  VoiceActivityType2["TYPE_UNSPECIFIED"] = "TYPE_UNSPECIFIED";
  VoiceActivityType2["ACTIVITY_START"] = "ACTIVITY_START";
  VoiceActivityType2["ACTIVITY_END"] = "ACTIVITY_END";
})(VoiceActivityType || (VoiceActivityType = {}));
var StartSensitivity;
(function(StartSensitivity2) {
  StartSensitivity2["START_SENSITIVITY_UNSPECIFIED"] = "START_SENSITIVITY_UNSPECIFIED";
  StartSensitivity2["START_SENSITIVITY_HIGH"] = "START_SENSITIVITY_HIGH";
  StartSensitivity2["START_SENSITIVITY_LOW"] = "START_SENSITIVITY_LOW";
})(StartSensitivity || (StartSensitivity = {}));
var EndSensitivity;
(function(EndSensitivity2) {
  EndSensitivity2["END_SENSITIVITY_UNSPECIFIED"] = "END_SENSITIVITY_UNSPECIFIED";
  EndSensitivity2["END_SENSITIVITY_HIGH"] = "END_SENSITIVITY_HIGH";
  EndSensitivity2["END_SENSITIVITY_LOW"] = "END_SENSITIVITY_LOW";
})(EndSensitivity || (EndSensitivity = {}));
var ActivityHandling;
(function(ActivityHandling2) {
  ActivityHandling2["ACTIVITY_HANDLING_UNSPECIFIED"] = "ACTIVITY_HANDLING_UNSPECIFIED";
  ActivityHandling2["START_OF_ACTIVITY_INTERRUPTS"] = "START_OF_ACTIVITY_INTERRUPTS";
  ActivityHandling2["NO_INTERRUPTION"] = "NO_INTERRUPTION";
})(ActivityHandling || (ActivityHandling = {}));
var TurnCoverage;
(function(TurnCoverage2) {
  TurnCoverage2["TURN_COVERAGE_UNSPECIFIED"] = "TURN_COVERAGE_UNSPECIFIED";
  TurnCoverage2["TURN_INCLUDES_ONLY_ACTIVITY"] = "TURN_INCLUDES_ONLY_ACTIVITY";
  TurnCoverage2["TURN_INCLUDES_ALL_INPUT"] = "TURN_INCLUDES_ALL_INPUT";
})(TurnCoverage || (TurnCoverage = {}));
var Scale;
(function(Scale2) {
  Scale2["SCALE_UNSPECIFIED"] = "SCALE_UNSPECIFIED";
  Scale2["C_MAJOR_A_MINOR"] = "C_MAJOR_A_MINOR";
  Scale2["D_FLAT_MAJOR_B_FLAT_MINOR"] = "D_FLAT_MAJOR_B_FLAT_MINOR";
  Scale2["D_MAJOR_B_MINOR"] = "D_MAJOR_B_MINOR";
  Scale2["E_FLAT_MAJOR_C_MINOR"] = "E_FLAT_MAJOR_C_MINOR";
  Scale2["E_MAJOR_D_FLAT_MINOR"] = "E_MAJOR_D_FLAT_MINOR";
  Scale2["F_MAJOR_D_MINOR"] = "F_MAJOR_D_MINOR";
  Scale2["G_FLAT_MAJOR_E_FLAT_MINOR"] = "G_FLAT_MAJOR_E_FLAT_MINOR";
  Scale2["G_MAJOR_E_MINOR"] = "G_MAJOR_E_MINOR";
  Scale2["A_FLAT_MAJOR_F_MINOR"] = "A_FLAT_MAJOR_F_MINOR";
  Scale2["A_MAJOR_G_FLAT_MINOR"] = "A_MAJOR_G_FLAT_MINOR";
  Scale2["B_FLAT_MAJOR_G_MINOR"] = "B_FLAT_MAJOR_G_MINOR";
  Scale2["B_MAJOR_A_FLAT_MINOR"] = "B_MAJOR_A_FLAT_MINOR";
})(Scale || (Scale = {}));
var MusicGenerationMode;
(function(MusicGenerationMode2) {
  MusicGenerationMode2["MUSIC_GENERATION_MODE_UNSPECIFIED"] = "MUSIC_GENERATION_MODE_UNSPECIFIED";
  MusicGenerationMode2["QUALITY"] = "QUALITY";
  MusicGenerationMode2["DIVERSITY"] = "DIVERSITY";
  MusicGenerationMode2["VOCALIZATION"] = "VOCALIZATION";
})(MusicGenerationMode || (MusicGenerationMode = {}));
var LiveMusicPlaybackControl;
(function(LiveMusicPlaybackControl2) {
  LiveMusicPlaybackControl2["PLAYBACK_CONTROL_UNSPECIFIED"] = "PLAYBACK_CONTROL_UNSPECIFIED";
  LiveMusicPlaybackControl2["PLAY"] = "PLAY";
  LiveMusicPlaybackControl2["PAUSE"] = "PAUSE";
  LiveMusicPlaybackControl2["STOP"] = "STOP";
  LiveMusicPlaybackControl2["RESET_CONTEXT"] = "RESET_CONTEXT";
})(LiveMusicPlaybackControl || (LiveMusicPlaybackControl = {}));
var HttpResponse = class {
  constructor(response) {
    const headers = {};
    for (const pair of response.headers.entries()) {
      headers[pair[0]] = pair[1];
    }
    this.headers = headers;
    this.responseInternal = response;
  }
  json() {
    return this.responseInternal.json();
  }
};
var GenerateContentResponse = class {
  /**
   * Returns the concatenation of all text parts from the first candidate in the response.
   *
   * @remarks
   * If there are multiple candidates in the response, the text from the first
   * one will be returned.
   * If there are non-text parts in the response, the concatenation of all text
   * parts will be returned, and a warning will be logged.
   * If there are thought parts in the response, the concatenation of all text
   * parts excluding the thought parts will be returned.
   *
   * @example
   * ```ts
   * const response = await ai.models.generateContent({
   *   model: 'gemini-2.0-flash',
   *   contents:
   *     'Why is the sky blue?',
   * });
   *
   * console.debug(response.text);
   * ```
   */
  get text() {
    var _a5, _b, _c, _d, _e, _f, _g, _h;
    if (((_d = (_c = (_b = (_a5 = this.candidates) === null || _a5 === void 0 ? void 0 : _a5[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
      return void 0;
    }
    if (this.candidates && this.candidates.length > 1) {
      console.warn("there are multiple candidates in the response, returning text from the first one.");
    }
    let text = "";
    let anyTextPartText = false;
    const nonTextParts = [];
    for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []) {
      for (const [fieldName, fieldValue] of Object.entries(part)) {
        if (fieldName !== "text" && fieldName !== "thought" && fieldName !== "thoughtSignature" && (fieldValue !== null || fieldValue !== void 0)) {
          nonTextParts.push(fieldName);
        }
      }
      if (typeof part.text === "string") {
        if (typeof part.thought === "boolean" && part.thought) {
          continue;
        }
        anyTextPartText = true;
        text += part.text;
      }
    }
    if (nonTextParts.length > 0) {
      console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);
    }
    return anyTextPartText ? text : void 0;
  }
  /**
   * Returns the concatenation of all inline data parts from the first candidate
   * in the response.
   *
   * @remarks
   * If there are multiple candidates in the response, the inline data from the
   * first one will be returned. If there are non-inline data parts in the
   * response, the concatenation of all inline data parts will be returned, and
   * a warning will be logged.
   */
  get data() {
    var _a5, _b, _c, _d, _e, _f, _g, _h;
    if (((_d = (_c = (_b = (_a5 = this.candidates) === null || _a5 === void 0 ? void 0 : _a5[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
      return void 0;
    }
    if (this.candidates && this.candidates.length > 1) {
      console.warn("there are multiple candidates in the response, returning data from the first one.");
    }
    let data = "";
    const nonDataParts = [];
    for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []) {
      for (const [fieldName, fieldValue] of Object.entries(part)) {
        if (fieldName !== "inlineData" && (fieldValue !== null || fieldValue !== void 0)) {
          nonDataParts.push(fieldName);
        }
      }
      if (part.inlineData && typeof part.inlineData.data === "string") {
        data += atob(part.inlineData.data);
      }
    }
    if (nonDataParts.length > 0) {
      console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);
    }
    return data.length > 0 ? btoa(data) : void 0;
  }
  /**
   * Returns the function calls from the first candidate in the response.
   *
   * @remarks
   * If there are multiple candidates in the response, the function calls from
   * the first one will be returned.
   * If there are no function calls in the response, undefined will be returned.
   *
   * @example
   * ```ts
   * const controlLightFunctionDeclaration: FunctionDeclaration = {
   *   name: 'controlLight',
   *   parameters: {
   *   type: Type.OBJECT,
   *   description: 'Set the brightness and color temperature of a room light.',
   *   properties: {
   *     brightness: {
   *       type: Type.NUMBER,
   *       description:
   *         'Light level from 0 to 100. Zero is off and 100 is full brightness.',
   *     },
   *     colorTemperature: {
   *       type: Type.STRING,
   *       description:
   *         'Color temperature of the light fixture which can be `daylight`, `cool` or `warm`.',
   *     },
   *   },
   *   required: ['brightness', 'colorTemperature'],
   *  };
   *  const response = await ai.models.generateContent({
   *     model: 'gemini-2.0-flash',
   *     contents: 'Dim the lights so the room feels cozy and warm.',
   *     config: {
   *       tools: [{functionDeclarations: [controlLightFunctionDeclaration]}],
   *       toolConfig: {
   *         functionCallingConfig: {
   *           mode: FunctionCallingConfigMode.ANY,
   *           allowedFunctionNames: ['controlLight'],
   *         },
   *       },
   *     },
   *   });
   *  console.debug(JSON.stringify(response.functionCalls));
   * ```
   */
  get functionCalls() {
    var _a5, _b, _c, _d, _e, _f, _g, _h;
    if (((_d = (_c = (_b = (_a5 = this.candidates) === null || _a5 === void 0 ? void 0 : _a5[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
      return void 0;
    }
    if (this.candidates && this.candidates.length > 1) {
      console.warn("there are multiple candidates in the response, returning function calls from the first one.");
    }
    const functionCalls = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.functionCall).map((part) => part.functionCall).filter((functionCall) => functionCall !== void 0);
    if ((functionCalls === null || functionCalls === void 0 ? void 0 : functionCalls.length) === 0) {
      return void 0;
    }
    return functionCalls;
  }
  /**
   * Returns the first executable code from the first candidate in the response.
   *
   * @remarks
   * If there are multiple candidates in the response, the executable code from
   * the first one will be returned.
   * If there are no executable code in the response, undefined will be
   * returned.
   *
   * @example
   * ```ts
   * const response = await ai.models.generateContent({
   *   model: 'gemini-2.0-flash',
   *   contents:
   *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'
   *   config: {
   *     tools: [{codeExecution: {}}],
   *   },
   * });
   *
   * console.debug(response.executableCode);
   * ```
   */
  get executableCode() {
    var _a5, _b, _c, _d, _e, _f, _g, _h, _j;
    if (((_d = (_c = (_b = (_a5 = this.candidates) === null || _a5 === void 0 ? void 0 : _a5[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
      return void 0;
    }
    if (this.candidates && this.candidates.length > 1) {
      console.warn("there are multiple candidates in the response, returning executable code from the first one.");
    }
    const executableCode = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.executableCode).map((part) => part.executableCode).filter((executableCode2) => executableCode2 !== void 0);
    if ((executableCode === null || executableCode === void 0 ? void 0 : executableCode.length) === 0) {
      return void 0;
    }
    return (_j = executableCode === null || executableCode === void 0 ? void 0 : executableCode[0]) === null || _j === void 0 ? void 0 : _j.code;
  }
  /**
   * Returns the first code execution result from the first candidate in the response.
   *
   * @remarks
   * If there are multiple candidates in the response, the code execution result from
   * the first one will be returned.
   * If there are no code execution result in the response, undefined will be returned.
   *
   * @example
   * ```ts
   * const response = await ai.models.generateContent({
   *   model: 'gemini-2.0-flash',
   *   contents:
   *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'
   *   config: {
   *     tools: [{codeExecution: {}}],
   *   },
   * });
   *
   * console.debug(response.codeExecutionResult);
   * ```
   */
  get codeExecutionResult() {
    var _a5, _b, _c, _d, _e, _f, _g, _h, _j;
    if (((_d = (_c = (_b = (_a5 = this.candidates) === null || _a5 === void 0 ? void 0 : _a5[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {
      return void 0;
    }
    if (this.candidates && this.candidates.length > 1) {
      console.warn("there are multiple candidates in the response, returning code execution result from the first one.");
    }
    const codeExecutionResult = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.codeExecutionResult).map((part) => part.codeExecutionResult).filter((codeExecutionResult2) => codeExecutionResult2 !== void 0);
    if ((codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult.length) === 0) {
      return void 0;
    }
    return (_j = codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult[0]) === null || _j === void 0 ? void 0 : _j.output;
  }
};
var EmbedContentResponse = class {
};
var GenerateImagesResponse = class {
};
var EditImageResponse = class {
};
var UpscaleImageResponse = class {
};
var RecontextImageResponse = class {
};
var SegmentImageResponse = class {
};
var ListModelsResponse = class {
};
var DeleteModelResponse = class {
};
var CountTokensResponse = class {
};
var ComputeTokensResponse = class {
};
var GenerateVideosOperation = class _GenerateVideosOperation {
  /**
   * Instantiates an Operation of the same type as the one being called with the fields set from the API response.
   * @internal
   */
  _fromAPIResponse({ apiResponse, _isVertexAI }) {
    const operation = new _GenerateVideosOperation();
    let response;
    const op = apiResponse;
    if (_isVertexAI) {
      response = generateVideosOperationFromVertex$1(op);
    } else {
      response = generateVideosOperationFromMldev$1(op);
    }
    Object.assign(operation, response);
    return operation;
  }
};
var ListTuningJobsResponse = class {
};
var CancelTuningJobResponse = class {
};
var DeleteCachedContentResponse = class {
};
var ListCachedContentsResponse = class {
};
var ListDocumentsResponse = class {
};
var ListFileSearchStoresResponse = class {
};
var UploadToFileSearchStoreResumableResponse = class {
};
var ImportFileOperation = class _ImportFileOperation {
  /**
   * Instantiates an Operation of the same type as the one being called with the fields set from the API response.
   * @internal
   */
  _fromAPIResponse({ apiResponse, _isVertexAI }) {
    const operation = new _ImportFileOperation();
    const op = apiResponse;
    const response = importFileOperationFromMldev$1(op);
    Object.assign(operation, response);
    return operation;
  }
};
var ListFilesResponse = class {
};
var CreateFileResponse = class {
};
var DeleteFileResponse = class {
};
var RegisterFilesResponse = class {
};
var ListBatchJobsResponse = class {
};
var LiveServerMessage = class {
  /**
   * Returns the concatenation of all text parts from the server content if present.
   *
   * @remarks
   * If there are non-text parts in the response, the concatenation of all text
   * parts will be returned, and a warning will be logged.
   */
  get text() {
    var _a5, _b, _c;
    let text = "";
    let anyTextPartFound = false;
    const nonTextParts = [];
    for (const part of (_c = (_b = (_a5 = this.serverContent) === null || _a5 === void 0 ? void 0 : _a5.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []) {
      for (const [fieldName, fieldValue] of Object.entries(part)) {
        if (fieldName !== "text" && fieldName !== "thought" && fieldValue !== null) {
          nonTextParts.push(fieldName);
        }
      }
      if (typeof part.text === "string") {
        if (typeof part.thought === "boolean" && part.thought) {
          continue;
        }
        anyTextPartFound = true;
        text += part.text;
      }
    }
    if (nonTextParts.length > 0) {
      console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);
    }
    return anyTextPartFound ? text : void 0;
  }
  /**
   * Returns the concatenation of all inline data parts from the server content if present.
   *
   * @remarks
   * If there are non-inline data parts in the
   * response, the concatenation of all inline data parts will be returned, and
   * a warning will be logged.
   */
  get data() {
    var _a5, _b, _c;
    let data = "";
    const nonDataParts = [];
    for (const part of (_c = (_b = (_a5 = this.serverContent) === null || _a5 === void 0 ? void 0 : _a5.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []) {
      for (const [fieldName, fieldValue] of Object.entries(part)) {
        if (fieldName !== "inlineData" && fieldValue !== null) {
          nonDataParts.push(fieldName);
        }
      }
      if (part.inlineData && typeof part.inlineData.data === "string") {
        data += atob(part.inlineData.data);
      }
    }
    if (nonDataParts.length > 0) {
      console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);
    }
    return data.length > 0 ? btoa(data) : void 0;
  }
};
var LiveMusicServerMessage = class {
  /**
   * Returns the first audio chunk from the server content, if present.
   *
   * @remarks
   * If there are no audio chunks in the response, undefined will be returned.
   */
  get audioChunk() {
    if (this.serverContent && this.serverContent.audioChunks && this.serverContent.audioChunks.length > 0) {
      return this.serverContent.audioChunks[0];
    }
    return void 0;
  }
};
var UploadToFileSearchStoreOperation = class _UploadToFileSearchStoreOperation {
  /**
   * Instantiates an Operation of the same type as the one being called with the fields set from the API response.
   * @internal
   */
  _fromAPIResponse({ apiResponse, _isVertexAI }) {
    const operation = new _UploadToFileSearchStoreOperation();
    const op = apiResponse;
    const response = uploadToFileSearchStoreOperationFromMldev(op);
    Object.assign(operation, response);
    return operation;
  }
};
function tModel(apiClient, model) {
  if (!model || typeof model !== "string") {
    throw new Error("model is required and must be a string");
  }
  if (model.includes("..") || model.includes("?") || model.includes("&")) {
    throw new Error("invalid model parameter");
  }
  if (apiClient.isVertexAI()) {
    if (model.startsWith("publishers/") || model.startsWith("projects/") || model.startsWith("models/")) {
      return model;
    } else if (model.indexOf("/") >= 0) {
      const parts = model.split("/", 2);
      return `publishers/${parts[0]}/models/${parts[1]}`;
    } else {
      return `publishers/google/models/${model}`;
    }
  } else {
    if (model.startsWith("models/") || model.startsWith("tunedModels/")) {
      return model;
    } else {
      return `models/${model}`;
    }
  }
}
function tCachesModel(apiClient, model) {
  const transformedModel = tModel(apiClient, model);
  if (!transformedModel) {
    return "";
  }
  if (transformedModel.startsWith("publishers/") && apiClient.isVertexAI()) {
    return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/${transformedModel}`;
  } else if (transformedModel.startsWith("models/") && apiClient.isVertexAI()) {
    return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/publishers/google/${transformedModel}`;
  } else {
    return transformedModel;
  }
}
function tBlobs(blobs) {
  if (Array.isArray(blobs)) {
    return blobs.map((blob) => tBlob(blob));
  } else {
    return [tBlob(blobs)];
  }
}
function tBlob(blob) {
  if (typeof blob === "object" && blob !== null) {
    return blob;
  }
  throw new Error(`Could not parse input as Blob. Unsupported blob type: ${typeof blob}`);
}
function tImageBlob(blob) {
  const transformedBlob = tBlob(blob);
  if (transformedBlob.mimeType && transformedBlob.mimeType.startsWith("image/")) {
    return transformedBlob;
  }
  throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);
}
function tAudioBlob(blob) {
  const transformedBlob = tBlob(blob);
  if (transformedBlob.mimeType && transformedBlob.mimeType.startsWith("audio/")) {
    return transformedBlob;
  }
  throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);
}
function tPart(origin) {
  if (origin === null || origin === void 0) {
    throw new Error("PartUnion is required");
  }
  if (typeof origin === "object") {
    return origin;
  }
  if (typeof origin === "string") {
    return { text: origin };
  }
  throw new Error(`Unsupported part type: ${typeof origin}`);
}
function tParts(origin) {
  if (origin === null || origin === void 0 || Array.isArray(origin) && origin.length === 0) {
    throw new Error("PartListUnion is required");
  }
  if (Array.isArray(origin)) {
    return origin.map((item) => tPart(item));
  }
  return [tPart(origin)];
}
function _isContent(origin) {
  return origin !== null && origin !== void 0 && typeof origin === "object" && "parts" in origin && Array.isArray(origin.parts);
}
function _isFunctionCallPart(origin) {
  return origin !== null && origin !== void 0 && typeof origin === "object" && "functionCall" in origin;
}
function _isFunctionResponsePart(origin) {
  return origin !== null && origin !== void 0 && typeof origin === "object" && "functionResponse" in origin;
}
function tContent(origin) {
  if (origin === null || origin === void 0) {
    throw new Error("ContentUnion is required");
  }
  if (_isContent(origin)) {
    return origin;
  }
  return {
    role: "user",
    parts: tParts(origin)
  };
}
function tContentsForEmbed(apiClient, origin) {
  if (!origin) {
    return [];
  }
  if (apiClient.isVertexAI() && Array.isArray(origin)) {
    return origin.flatMap((item) => {
      const content = tContent(item);
      if (content.parts && content.parts.length > 0 && content.parts[0].text !== void 0) {
        return [content.parts[0].text];
      }
      return [];
    });
  } else if (apiClient.isVertexAI()) {
    const content = tContent(origin);
    if (content.parts && content.parts.length > 0 && content.parts[0].text !== void 0) {
      return [content.parts[0].text];
    }
    return [];
  }
  if (Array.isArray(origin)) {
    return origin.map((item) => tContent(item));
  }
  return [tContent(origin)];
}
function tContents(origin) {
  if (origin === null || origin === void 0 || Array.isArray(origin) && origin.length === 0) {
    throw new Error("contents are required");
  }
  if (!Array.isArray(origin)) {
    if (_isFunctionCallPart(origin) || _isFunctionResponsePart(origin)) {
      throw new Error("To specify functionCall or functionResponse parts, please wrap them in a Content object, specifying the role for them");
    }
    return [tContent(origin)];
  }
  const result = [];
  const accumulatedParts = [];
  const isContentArray = _isContent(origin[0]);
  for (const item of origin) {
    const isContent = _isContent(item);
    if (isContent != isContentArray) {
      throw new Error("Mixing Content and Parts is not supported, please group the parts into a the appropriate Content objects and specify the roles for them");
    }
    if (isContent) {
      result.push(item);
    } else if (_isFunctionCallPart(item) || _isFunctionResponsePart(item)) {
      throw new Error("To specify functionCall or functionResponse parts, please wrap them, and any other parts, in Content objects as appropriate, specifying the role for them");
    } else {
      accumulatedParts.push(item);
    }
  }
  if (!isContentArray) {
    result.push({ role: "user", parts: tParts(accumulatedParts) });
  }
  return result;
}
function flattenTypeArrayToAnyOf(typeList, resultingSchema) {
  if (typeList.includes("null")) {
    resultingSchema["nullable"] = true;
  }
  const listWithoutNull = typeList.filter((type) => type !== "null");
  if (listWithoutNull.length === 1) {
    resultingSchema["type"] = Object.values(Type).includes(listWithoutNull[0].toUpperCase()) ? listWithoutNull[0].toUpperCase() : Type.TYPE_UNSPECIFIED;
  } else {
    resultingSchema["anyOf"] = [];
    for (const i3 of listWithoutNull) {
      resultingSchema["anyOf"].push({
        "type": Object.values(Type).includes(i3.toUpperCase()) ? i3.toUpperCase() : Type.TYPE_UNSPECIFIED
      });
    }
  }
}
function processJsonSchema(_jsonSchema) {
  const genAISchema = {};
  const schemaFieldNames = ["items"];
  const listSchemaFieldNames = ["anyOf"];
  const dictSchemaFieldNames = ["properties"];
  if (_jsonSchema["type"] && _jsonSchema["anyOf"]) {
    throw new Error("type and anyOf cannot be both populated.");
  }
  const incomingAnyOf = _jsonSchema["anyOf"];
  if (incomingAnyOf != null && incomingAnyOf.length == 2) {
    if (incomingAnyOf[0]["type"] === "null") {
      genAISchema["nullable"] = true;
      _jsonSchema = incomingAnyOf[1];
    } else if (incomingAnyOf[1]["type"] === "null") {
      genAISchema["nullable"] = true;
      _jsonSchema = incomingAnyOf[0];
    }
  }
  if (_jsonSchema["type"] instanceof Array) {
    flattenTypeArrayToAnyOf(_jsonSchema["type"], genAISchema);
  }
  for (const [fieldName, fieldValue] of Object.entries(_jsonSchema)) {
    if (fieldValue == null) {
      continue;
    }
    if (fieldName == "type") {
      if (fieldValue === "null") {
        throw new Error("type: null can not be the only possible type for the field.");
      }
      if (fieldValue instanceof Array) {
        continue;
      }
      genAISchema["type"] = Object.values(Type).includes(fieldValue.toUpperCase()) ? fieldValue.toUpperCase() : Type.TYPE_UNSPECIFIED;
    } else if (schemaFieldNames.includes(fieldName)) {
      genAISchema[fieldName] = processJsonSchema(fieldValue);
    } else if (listSchemaFieldNames.includes(fieldName)) {
      const listSchemaFieldValue = [];
      for (const item of fieldValue) {
        if (item["type"] == "null") {
          genAISchema["nullable"] = true;
          continue;
        }
        listSchemaFieldValue.push(processJsonSchema(item));
      }
      genAISchema[fieldName] = listSchemaFieldValue;
    } else if (dictSchemaFieldNames.includes(fieldName)) {
      const dictSchemaFieldValue = {};
      for (const [key, value] of Object.entries(fieldValue)) {
        dictSchemaFieldValue[key] = processJsonSchema(value);
      }
      genAISchema[fieldName] = dictSchemaFieldValue;
    } else {
      if (fieldName === "additionalProperties") {
        continue;
      }
      genAISchema[fieldName] = fieldValue;
    }
  }
  return genAISchema;
}
function tSchema(schema) {
  return processJsonSchema(schema);
}
function tSpeechConfig(speechConfig) {
  if (typeof speechConfig === "object") {
    return speechConfig;
  } else if (typeof speechConfig === "string") {
    return {
      voiceConfig: {
        prebuiltVoiceConfig: {
          voiceName: speechConfig
        }
      }
    };
  } else {
    throw new Error(`Unsupported speechConfig type: ${typeof speechConfig}`);
  }
}
function tLiveSpeechConfig(speechConfig) {
  if ("multiSpeakerVoiceConfig" in speechConfig) {
    throw new Error("multiSpeakerVoiceConfig is not supported in the live API.");
  }
  return speechConfig;
}
function tTool(tool) {
  if (tool.functionDeclarations) {
    for (const functionDeclaration of tool.functionDeclarations) {
      if (functionDeclaration.parameters) {
        if (!Object.keys(functionDeclaration.parameters).includes("$schema")) {
          functionDeclaration.parameters = processJsonSchema(functionDeclaration.parameters);
        } else {
          if (!functionDeclaration.parametersJsonSchema) {
            functionDeclaration.parametersJsonSchema = functionDeclaration.parameters;
            delete functionDeclaration.parameters;
          }
        }
      }
      if (functionDeclaration.response) {
        if (!Object.keys(functionDeclaration.response).includes("$schema")) {
          functionDeclaration.response = processJsonSchema(functionDeclaration.response);
        } else {
          if (!functionDeclaration.responseJsonSchema) {
            functionDeclaration.responseJsonSchema = functionDeclaration.response;
            delete functionDeclaration.response;
          }
        }
      }
    }
  }
  return tool;
}
function tTools(tools) {
  if (tools === void 0 || tools === null) {
    throw new Error("tools is required");
  }
  if (!Array.isArray(tools)) {
    throw new Error("tools is required and must be an array of Tools");
  }
  const result = [];
  for (const tool of tools) {
    result.push(tool);
  }
  return result;
}
function resourceName(client, resourceName2, resourcePrefix, splitsAfterPrefix = 1) {
  const shouldAppendPrefix = !resourceName2.startsWith(`${resourcePrefix}/`) && resourceName2.split("/").length === splitsAfterPrefix;
  if (client.isVertexAI()) {
    if (resourceName2.startsWith("projects/")) {
      return resourceName2;
    } else if (resourceName2.startsWith("locations/")) {
      return `projects/${client.getProject()}/${resourceName2}`;
    } else if (resourceName2.startsWith(`${resourcePrefix}/`)) {
      return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourceName2}`;
    } else if (shouldAppendPrefix) {
      return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourcePrefix}/${resourceName2}`;
    } else {
      return resourceName2;
    }
  }
  if (shouldAppendPrefix) {
    return `${resourcePrefix}/${resourceName2}`;
  }
  return resourceName2;
}
function tCachedContentName(apiClient, name) {
  if (typeof name !== "string") {
    throw new Error("name must be a string");
  }
  return resourceName(apiClient, name, "cachedContents");
}
function tTuningJobStatus(status) {
  switch (status) {
    case "STATE_UNSPECIFIED":
      return "JOB_STATE_UNSPECIFIED";
    case "CREATING":
      return "JOB_STATE_RUNNING";
    case "ACTIVE":
      return "JOB_STATE_SUCCEEDED";
    case "FAILED":
      return "JOB_STATE_FAILED";
    default:
      return status;
  }
}
function tBytes(fromImageBytes) {
  return tBytes$1(fromImageBytes);
}
function _isFile(origin) {
  return origin !== null && origin !== void 0 && typeof origin === "object" && "name" in origin;
}
function isGeneratedVideo(origin) {
  return origin !== null && origin !== void 0 && typeof origin === "object" && "video" in origin;
}
function isVideo(origin) {
  return origin !== null && origin !== void 0 && typeof origin === "object" && "uri" in origin;
}
function tFileName(fromName) {
  var _a5;
  let name;
  if (_isFile(fromName)) {
    name = fromName.name;
  }
  if (isVideo(fromName)) {
    name = fromName.uri;
    if (name === void 0) {
      return void 0;
    }
  }
  if (isGeneratedVideo(fromName)) {
    name = (_a5 = fromName.video) === null || _a5 === void 0 ? void 0 : _a5.uri;
    if (name === void 0) {
      return void 0;
    }
  }
  if (typeof fromName === "string") {
    name = fromName;
  }
  if (name === void 0) {
    throw new Error("Could not extract file name from the provided input.");
  }
  if (name.startsWith("https://")) {
    const suffix = name.split("files/")[1];
    const match = suffix.match(/[a-z0-9]+/);
    if (match === null) {
      throw new Error(`Could not extract file name from URI ${name}`);
    }
    name = match[0];
  } else if (name.startsWith("files/")) {
    name = name.split("files/")[1];
  }
  return name;
}
function tModelsUrl(apiClient, baseModels) {
  let res;
  if (apiClient.isVertexAI()) {
    res = baseModels ? "publishers/google/models" : "models";
  } else {
    res = baseModels ? "models" : "tunedModels";
  }
  return res;
}
function tExtractModels(response) {
  for (const key of ["models", "tunedModels", "publisherModels"]) {
    if (hasField(response, key)) {
      return response[key];
    }
  }
  return [];
}
function hasField(data, fieldName) {
  return data !== null && typeof data === "object" && fieldName in data;
}
function mcpToGeminiTool(mcpTool, config = {}) {
  const mcpToolSchema = mcpTool;
  const functionDeclaration = {
    name: mcpToolSchema["name"],
    description: mcpToolSchema["description"],
    parametersJsonSchema: mcpToolSchema["inputSchema"]
  };
  if (mcpToolSchema["outputSchema"]) {
    functionDeclaration["responseJsonSchema"] = mcpToolSchema["outputSchema"];
  }
  if (config.behavior) {
    functionDeclaration["behavior"] = config.behavior;
  }
  const geminiTool = {
    functionDeclarations: [
      functionDeclaration
    ]
  };
  return geminiTool;
}
function mcpToolsToGeminiTool(mcpTools, config = {}) {
  const functionDeclarations = [];
  const toolNames = /* @__PURE__ */ new Set();
  for (const mcpTool of mcpTools) {
    const mcpToolName = mcpTool.name;
    if (toolNames.has(mcpToolName)) {
      throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);
    }
    toolNames.add(mcpToolName);
    const geminiTool = mcpToGeminiTool(mcpTool, config);
    if (geminiTool.functionDeclarations) {
      functionDeclarations.push(...geminiTool.functionDeclarations);
    }
  }
  return { functionDeclarations };
}
function tBatchJobSource(client, src) {
  let sourceObj;
  if (typeof src === "string") {
    if (client.isVertexAI()) {
      if (src.startsWith("gs://")) {
        sourceObj = { format: "jsonl", gcsUri: [src] };
      } else if (src.startsWith("bq://")) {
        sourceObj = { format: "bigquery", bigqueryUri: src };
      } else {
        throw new Error(`Unsupported string source for Vertex AI: ${src}`);
      }
    } else {
      if (src.startsWith("files/")) {
        sourceObj = { fileName: src };
      } else {
        throw new Error(`Unsupported string source for Gemini API: ${src}`);
      }
    }
  } else if (Array.isArray(src)) {
    if (client.isVertexAI()) {
      throw new Error("InlinedRequest[] is not supported in Vertex AI.");
    }
    sourceObj = { inlinedRequests: src };
  } else {
    sourceObj = src;
  }
  const vertexSourcesCount = [sourceObj.gcsUri, sourceObj.bigqueryUri].filter(Boolean).length;
  const mldevSourcesCount = [
    sourceObj.inlinedRequests,
    sourceObj.fileName
  ].filter(Boolean).length;
  if (client.isVertexAI()) {
    if (mldevSourcesCount > 0 || vertexSourcesCount !== 1) {
      throw new Error("Exactly one of `gcsUri` or `bigqueryUri` must be set for Vertex AI.");
    }
  } else {
    if (vertexSourcesCount > 0 || mldevSourcesCount !== 1) {
      throw new Error("Exactly one of `inlinedRequests`, `fileName`, must be set for Gemini API.");
    }
  }
  return sourceObj;
}
function tBatchJobDestination(dest) {
  if (typeof dest !== "string") {
    return dest;
  }
  const destString = dest;
  if (destString.startsWith("gs://")) {
    return {
      format: "jsonl",
      gcsUri: destString
    };
  } else if (destString.startsWith("bq://")) {
    return {
      format: "bigquery",
      bigqueryUri: destString
    };
  } else {
    throw new Error(`Unsupported destination: ${destString}`);
  }
}
function tRecvBatchJobDestination(dest) {
  if (typeof dest !== "object" || dest === null) {
    return {};
  }
  const obj = dest;
  const inlineResponsesVal = obj["inlinedResponses"];
  if (typeof inlineResponsesVal !== "object" || inlineResponsesVal === null) {
    return dest;
  }
  const inlineResponsesObj = inlineResponsesVal;
  const responsesArray = inlineResponsesObj["inlinedResponses"];
  if (!Array.isArray(responsesArray) || responsesArray.length === 0) {
    return dest;
  }
  let hasEmbedding = false;
  for (const responseItem of responsesArray) {
    if (typeof responseItem !== "object" || responseItem === null) {
      continue;
    }
    const responseItemObj = responseItem;
    const responseVal = responseItemObj["response"];
    if (typeof responseVal !== "object" || responseVal === null) {
      continue;
    }
    const responseObj = responseVal;
    if (responseObj["embedding"] !== void 0) {
      hasEmbedding = true;
      break;
    }
  }
  if (hasEmbedding) {
    obj["inlinedEmbedContentResponses"] = obj["inlinedResponses"];
    delete obj["inlinedResponses"];
  }
  return dest;
}
function tBatchJobName(apiClient, name) {
  const nameString = name;
  if (!apiClient.isVertexAI()) {
    const mldevPattern = /batches\/[^/]+$/;
    if (mldevPattern.test(nameString)) {
      return nameString.split("/").pop();
    } else {
      throw new Error(`Invalid batch job name: ${nameString}.`);
    }
  }
  const vertexPattern = /^projects\/[^/]+\/locations\/[^/]+\/batchPredictionJobs\/[^/]+$/;
  if (vertexPattern.test(nameString)) {
    return nameString.split("/").pop();
  } else if (/^\d+$/.test(nameString)) {
    return nameString;
  } else {
    throw new Error(`Invalid batch job name: ${nameString}.`);
  }
}
function tJobState(state) {
  const stateString = state;
  if (stateString === "BATCH_STATE_UNSPECIFIED") {
    return "JOB_STATE_UNSPECIFIED";
  } else if (stateString === "BATCH_STATE_PENDING") {
    return "JOB_STATE_PENDING";
  } else if (stateString === "BATCH_STATE_RUNNING") {
    return "JOB_STATE_RUNNING";
  } else if (stateString === "BATCH_STATE_SUCCEEDED") {
    return "JOB_STATE_SUCCEEDED";
  } else if (stateString === "BATCH_STATE_FAILED") {
    return "JOB_STATE_FAILED";
  } else if (stateString === "BATCH_STATE_CANCELLED") {
    return "JOB_STATE_CANCELLED";
  } else if (stateString === "BATCH_STATE_EXPIRED") {
    return "JOB_STATE_EXPIRED";
  } else {
    return stateString;
  }
}
function batchJobDestinationFromMldev(fromObject) {
  const toObject = {};
  const fromFileName = getValueByPath(fromObject, ["responsesFile"]);
  if (fromFileName != null) {
    setValueByPath(toObject, ["fileName"], fromFileName);
  }
  const fromInlinedResponses = getValueByPath(fromObject, [
    "inlinedResponses",
    "inlinedResponses"
  ]);
  if (fromInlinedResponses != null) {
    let transformedList = fromInlinedResponses;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return inlinedResponseFromMldev(item);
      });
    }
    setValueByPath(toObject, ["inlinedResponses"], transformedList);
  }
  const fromInlinedEmbedContentResponses = getValueByPath(fromObject, [
    "inlinedEmbedContentResponses",
    "inlinedResponses"
  ]);
  if (fromInlinedEmbedContentResponses != null) {
    let transformedList = fromInlinedEmbedContentResponses;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["inlinedEmbedContentResponses"], transformedList);
  }
  return toObject;
}
function batchJobDestinationFromVertex(fromObject) {
  const toObject = {};
  const fromFormat = getValueByPath(fromObject, ["predictionsFormat"]);
  if (fromFormat != null) {
    setValueByPath(toObject, ["format"], fromFormat);
  }
  const fromGcsUri = getValueByPath(fromObject, [
    "gcsDestination",
    "outputUriPrefix"
  ]);
  if (fromGcsUri != null) {
    setValueByPath(toObject, ["gcsUri"], fromGcsUri);
  }
  const fromBigqueryUri = getValueByPath(fromObject, [
    "bigqueryDestination",
    "outputUri"
  ]);
  if (fromBigqueryUri != null) {
    setValueByPath(toObject, ["bigqueryUri"], fromBigqueryUri);
  }
  return toObject;
}
function batchJobDestinationToVertex(fromObject) {
  const toObject = {};
  const fromFormat = getValueByPath(fromObject, ["format"]);
  if (fromFormat != null) {
    setValueByPath(toObject, ["predictionsFormat"], fromFormat);
  }
  const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
  if (fromGcsUri != null) {
    setValueByPath(toObject, ["gcsDestination", "outputUriPrefix"], fromGcsUri);
  }
  const fromBigqueryUri = getValueByPath(fromObject, ["bigqueryUri"]);
  if (fromBigqueryUri != null) {
    setValueByPath(toObject, ["bigqueryDestination", "outputUri"], fromBigqueryUri);
  }
  if (getValueByPath(fromObject, ["fileName"]) !== void 0) {
    throw new Error("fileName parameter is not supported in Vertex AI.");
  }
  if (getValueByPath(fromObject, ["inlinedResponses"]) !== void 0) {
    throw new Error("inlinedResponses parameter is not supported in Vertex AI.");
  }
  if (getValueByPath(fromObject, ["inlinedEmbedContentResponses"]) !== void 0) {
    throw new Error("inlinedEmbedContentResponses parameter is not supported in Vertex AI.");
  }
  return toObject;
}
function batchJobFromMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromDisplayName = getValueByPath(fromObject, [
    "metadata",
    "displayName"
  ]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromState = getValueByPath(fromObject, ["metadata", "state"]);
  if (fromState != null) {
    setValueByPath(toObject, ["state"], tJobState(fromState));
  }
  const fromCreateTime = getValueByPath(fromObject, [
    "metadata",
    "createTime"
  ]);
  if (fromCreateTime != null) {
    setValueByPath(toObject, ["createTime"], fromCreateTime);
  }
  const fromEndTime = getValueByPath(fromObject, [
    "metadata",
    "endTime"
  ]);
  if (fromEndTime != null) {
    setValueByPath(toObject, ["endTime"], fromEndTime);
  }
  const fromUpdateTime = getValueByPath(fromObject, [
    "metadata",
    "updateTime"
  ]);
  if (fromUpdateTime != null) {
    setValueByPath(toObject, ["updateTime"], fromUpdateTime);
  }
  const fromModel = getValueByPath(fromObject, ["metadata", "model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["model"], fromModel);
  }
  const fromDest = getValueByPath(fromObject, ["metadata", "output"]);
  if (fromDest != null) {
    setValueByPath(toObject, ["dest"], batchJobDestinationFromMldev(tRecvBatchJobDestination(fromDest)));
  }
  return toObject;
}
function batchJobFromVertex(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromState = getValueByPath(fromObject, ["state"]);
  if (fromState != null) {
    setValueByPath(toObject, ["state"], tJobState(fromState));
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fromError);
  }
  const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
  if (fromCreateTime != null) {
    setValueByPath(toObject, ["createTime"], fromCreateTime);
  }
  const fromStartTime = getValueByPath(fromObject, ["startTime"]);
  if (fromStartTime != null) {
    setValueByPath(toObject, ["startTime"], fromStartTime);
  }
  const fromEndTime = getValueByPath(fromObject, ["endTime"]);
  if (fromEndTime != null) {
    setValueByPath(toObject, ["endTime"], fromEndTime);
  }
  const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
  if (fromUpdateTime != null) {
    setValueByPath(toObject, ["updateTime"], fromUpdateTime);
  }
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["model"], fromModel);
  }
  const fromSrc = getValueByPath(fromObject, ["inputConfig"]);
  if (fromSrc != null) {
    setValueByPath(toObject, ["src"], batchJobSourceFromVertex(fromSrc));
  }
  const fromDest = getValueByPath(fromObject, ["outputConfig"]);
  if (fromDest != null) {
    setValueByPath(toObject, ["dest"], batchJobDestinationFromVertex(tRecvBatchJobDestination(fromDest)));
  }
  const fromCompletionStats = getValueByPath(fromObject, [
    "completionStats"
  ]);
  if (fromCompletionStats != null) {
    setValueByPath(toObject, ["completionStats"], fromCompletionStats);
  }
  return toObject;
}
function batchJobSourceFromVertex(fromObject) {
  const toObject = {};
  const fromFormat = getValueByPath(fromObject, ["instancesFormat"]);
  if (fromFormat != null) {
    setValueByPath(toObject, ["format"], fromFormat);
  }
  const fromGcsUri = getValueByPath(fromObject, ["gcsSource", "uris"]);
  if (fromGcsUri != null) {
    setValueByPath(toObject, ["gcsUri"], fromGcsUri);
  }
  const fromBigqueryUri = getValueByPath(fromObject, [
    "bigquerySource",
    "inputUri"
  ]);
  if (fromBigqueryUri != null) {
    setValueByPath(toObject, ["bigqueryUri"], fromBigqueryUri);
  }
  return toObject;
}
function batchJobSourceToMldev(apiClient, fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["format"]) !== void 0) {
    throw new Error("format parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["gcsUri"]) !== void 0) {
    throw new Error("gcsUri parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["bigqueryUri"]) !== void 0) {
    throw new Error("bigqueryUri parameter is not supported in Gemini API.");
  }
  const fromFileName = getValueByPath(fromObject, ["fileName"]);
  if (fromFileName != null) {
    setValueByPath(toObject, ["fileName"], fromFileName);
  }
  const fromInlinedRequests = getValueByPath(fromObject, [
    "inlinedRequests"
  ]);
  if (fromInlinedRequests != null) {
    let transformedList = fromInlinedRequests;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return inlinedRequestToMldev(apiClient, item);
      });
    }
    setValueByPath(toObject, ["requests", "requests"], transformedList);
  }
  return toObject;
}
function batchJobSourceToVertex(fromObject) {
  const toObject = {};
  const fromFormat = getValueByPath(fromObject, ["format"]);
  if (fromFormat != null) {
    setValueByPath(toObject, ["instancesFormat"], fromFormat);
  }
  const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
  if (fromGcsUri != null) {
    setValueByPath(toObject, ["gcsSource", "uris"], fromGcsUri);
  }
  const fromBigqueryUri = getValueByPath(fromObject, ["bigqueryUri"]);
  if (fromBigqueryUri != null) {
    setValueByPath(toObject, ["bigquerySource", "inputUri"], fromBigqueryUri);
  }
  if (getValueByPath(fromObject, ["fileName"]) !== void 0) {
    throw new Error("fileName parameter is not supported in Vertex AI.");
  }
  if (getValueByPath(fromObject, ["inlinedRequests"]) !== void 0) {
    throw new Error("inlinedRequests parameter is not supported in Vertex AI.");
  }
  return toObject;
}
function blobToMldev$4(fromObject) {
  const toObject = {};
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function cancelBatchJobParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
  }
  return toObject;
}
function cancelBatchJobParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
  }
  return toObject;
}
function candidateFromMldev$1(fromObject) {
  const toObject = {};
  const fromContent = getValueByPath(fromObject, ["content"]);
  if (fromContent != null) {
    setValueByPath(toObject, ["content"], fromContent);
  }
  const fromCitationMetadata = getValueByPath(fromObject, [
    "citationMetadata"
  ]);
  if (fromCitationMetadata != null) {
    setValueByPath(toObject, ["citationMetadata"], citationMetadataFromMldev$1(fromCitationMetadata));
  }
  const fromTokenCount = getValueByPath(fromObject, ["tokenCount"]);
  if (fromTokenCount != null) {
    setValueByPath(toObject, ["tokenCount"], fromTokenCount);
  }
  const fromFinishReason = getValueByPath(fromObject, ["finishReason"]);
  if (fromFinishReason != null) {
    setValueByPath(toObject, ["finishReason"], fromFinishReason);
  }
  const fromAvgLogprobs = getValueByPath(fromObject, ["avgLogprobs"]);
  if (fromAvgLogprobs != null) {
    setValueByPath(toObject, ["avgLogprobs"], fromAvgLogprobs);
  }
  const fromGroundingMetadata = getValueByPath(fromObject, [
    "groundingMetadata"
  ]);
  if (fromGroundingMetadata != null) {
    setValueByPath(toObject, ["groundingMetadata"], fromGroundingMetadata);
  }
  const fromIndex = getValueByPath(fromObject, ["index"]);
  if (fromIndex != null) {
    setValueByPath(toObject, ["index"], fromIndex);
  }
  const fromLogprobsResult = getValueByPath(fromObject, [
    "logprobsResult"
  ]);
  if (fromLogprobsResult != null) {
    setValueByPath(toObject, ["logprobsResult"], fromLogprobsResult);
  }
  const fromSafetyRatings = getValueByPath(fromObject, [
    "safetyRatings"
  ]);
  if (fromSafetyRatings != null) {
    let transformedList = fromSafetyRatings;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["safetyRatings"], transformedList);
  }
  const fromUrlContextMetadata = getValueByPath(fromObject, [
    "urlContextMetadata"
  ]);
  if (fromUrlContextMetadata != null) {
    setValueByPath(toObject, ["urlContextMetadata"], fromUrlContextMetadata);
  }
  return toObject;
}
function citationMetadataFromMldev$1(fromObject) {
  const toObject = {};
  const fromCitations = getValueByPath(fromObject, ["citationSources"]);
  if (fromCitations != null) {
    let transformedList = fromCitations;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["citations"], transformedList);
  }
  return toObject;
}
function contentToMldev$4(fromObject) {
  const toObject = {};
  const fromParts = getValueByPath(fromObject, ["parts"]);
  if (fromParts != null) {
    let transformedList = fromParts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return partToMldev$4(item);
      });
    }
    setValueByPath(toObject, ["parts"], transformedList);
  }
  const fromRole = getValueByPath(fromObject, ["role"]);
  if (fromRole != null) {
    setValueByPath(toObject, ["role"], fromRole);
  }
  return toObject;
}
function createBatchJobConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (parentObject !== void 0 && fromDisplayName != null) {
    setValueByPath(parentObject, ["batch", "displayName"], fromDisplayName);
  }
  if (getValueByPath(fromObject, ["dest"]) !== void 0) {
    throw new Error("dest parameter is not supported in Gemini API.");
  }
  return toObject;
}
function createBatchJobConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (parentObject !== void 0 && fromDisplayName != null) {
    setValueByPath(parentObject, ["displayName"], fromDisplayName);
  }
  const fromDest = getValueByPath(fromObject, ["dest"]);
  if (parentObject !== void 0 && fromDest != null) {
    setValueByPath(parentObject, ["outputConfig"], batchJobDestinationToVertex(tBatchJobDestination(fromDest)));
  }
  return toObject;
}
function createBatchJobParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromSrc = getValueByPath(fromObject, ["src"]);
  if (fromSrc != null) {
    setValueByPath(toObject, ["batch", "inputConfig"], batchJobSourceToMldev(apiClient, tBatchJobSource(apiClient, fromSrc)));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    createBatchJobConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function createBatchJobParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["model"], tModel(apiClient, fromModel));
  }
  const fromSrc = getValueByPath(fromObject, ["src"]);
  if (fromSrc != null) {
    setValueByPath(toObject, ["inputConfig"], batchJobSourceToVertex(tBatchJobSource(apiClient, fromSrc)));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    createBatchJobConfigToVertex(fromConfig, toObject);
  }
  return toObject;
}
function createEmbeddingsBatchJobConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (parentObject !== void 0 && fromDisplayName != null) {
    setValueByPath(parentObject, ["batch", "displayName"], fromDisplayName);
  }
  return toObject;
}
function createEmbeddingsBatchJobParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromSrc = getValueByPath(fromObject, ["src"]);
  if (fromSrc != null) {
    setValueByPath(toObject, ["batch", "inputConfig"], embeddingsBatchJobSourceToMldev(apiClient, fromSrc));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    createEmbeddingsBatchJobConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function deleteBatchJobParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
  }
  return toObject;
}
function deleteBatchJobParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
  }
  return toObject;
}
function deleteResourceJobFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromDone = getValueByPath(fromObject, ["done"]);
  if (fromDone != null) {
    setValueByPath(toObject, ["done"], fromDone);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fromError);
  }
  return toObject;
}
function deleteResourceJobFromVertex(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromDone = getValueByPath(fromObject, ["done"]);
  if (fromDone != null) {
    setValueByPath(toObject, ["done"], fromDone);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fromError);
  }
  return toObject;
}
function embedContentBatchToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (fromContents != null) {
    let transformedList = tContentsForEmbed(apiClient, fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["requests[]", "request", "content"], transformedList);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["_self"], embedContentConfigToMldev$1(fromConfig, toObject));
    moveValueByPath(toObject, { "requests[].*": "requests[].request.*" });
  }
  return toObject;
}
function embedContentConfigToMldev$1(fromObject, parentObject) {
  const toObject = {};
  const fromTaskType = getValueByPath(fromObject, ["taskType"]);
  if (parentObject !== void 0 && fromTaskType != null) {
    setValueByPath(parentObject, ["requests[]", "taskType"], fromTaskType);
  }
  const fromTitle = getValueByPath(fromObject, ["title"]);
  if (parentObject !== void 0 && fromTitle != null) {
    setValueByPath(parentObject, ["requests[]", "title"], fromTitle);
  }
  const fromOutputDimensionality = getValueByPath(fromObject, [
    "outputDimensionality"
  ]);
  if (parentObject !== void 0 && fromOutputDimensionality != null) {
    setValueByPath(parentObject, ["requests[]", "outputDimensionality"], fromOutputDimensionality);
  }
  if (getValueByPath(fromObject, ["mimeType"]) !== void 0) {
    throw new Error("mimeType parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["autoTruncate"]) !== void 0) {
    throw new Error("autoTruncate parameter is not supported in Gemini API.");
  }
  return toObject;
}
function embeddingsBatchJobSourceToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromFileName = getValueByPath(fromObject, ["fileName"]);
  if (fromFileName != null) {
    setValueByPath(toObject, ["file_name"], fromFileName);
  }
  const fromInlinedRequests = getValueByPath(fromObject, [
    "inlinedRequests"
  ]);
  if (fromInlinedRequests != null) {
    setValueByPath(toObject, ["requests"], embedContentBatchToMldev(apiClient, fromInlinedRequests));
  }
  return toObject;
}
function fileDataToMldev$4(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
  if (fromFileUri != null) {
    setValueByPath(toObject, ["fileUri"], fromFileUri);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function functionCallToMldev$4(fromObject) {
  const toObject = {};
  const fromId = getValueByPath(fromObject, ["id"]);
  if (fromId != null) {
    setValueByPath(toObject, ["id"], fromId);
  }
  const fromArgs = getValueByPath(fromObject, ["args"]);
  if (fromArgs != null) {
    setValueByPath(toObject, ["args"], fromArgs);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  if (getValueByPath(fromObject, ["partialArgs"]) !== void 0) {
    throw new Error("partialArgs parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["willContinue"]) !== void 0) {
    throw new Error("willContinue parameter is not supported in Gemini API.");
  }
  return toObject;
}
function functionCallingConfigToMldev$2(fromObject) {
  const toObject = {};
  const fromAllowedFunctionNames = getValueByPath(fromObject, [
    "allowedFunctionNames"
  ]);
  if (fromAllowedFunctionNames != null) {
    setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
  }
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (fromMode != null) {
    setValueByPath(toObject, ["mode"], fromMode);
  }
  if (getValueByPath(fromObject, ["streamFunctionCallArguments"]) !== void 0) {
    throw new Error("streamFunctionCallArguments parameter is not supported in Gemini API.");
  }
  return toObject;
}
function generateContentConfigToMldev$1(apiClient, fromObject, parentObject) {
  const toObject = {};
  const fromSystemInstruction = getValueByPath(fromObject, [
    "systemInstruction"
  ]);
  if (parentObject !== void 0 && fromSystemInstruction != null) {
    setValueByPath(parentObject, ["systemInstruction"], contentToMldev$4(tContent(fromSystemInstruction)));
  }
  const fromTemperature = getValueByPath(fromObject, ["temperature"]);
  if (fromTemperature != null) {
    setValueByPath(toObject, ["temperature"], fromTemperature);
  }
  const fromTopP = getValueByPath(fromObject, ["topP"]);
  if (fromTopP != null) {
    setValueByPath(toObject, ["topP"], fromTopP);
  }
  const fromTopK = getValueByPath(fromObject, ["topK"]);
  if (fromTopK != null) {
    setValueByPath(toObject, ["topK"], fromTopK);
  }
  const fromCandidateCount = getValueByPath(fromObject, [
    "candidateCount"
  ]);
  if (fromCandidateCount != null) {
    setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
  }
  const fromMaxOutputTokens = getValueByPath(fromObject, [
    "maxOutputTokens"
  ]);
  if (fromMaxOutputTokens != null) {
    setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
  }
  const fromStopSequences = getValueByPath(fromObject, [
    "stopSequences"
  ]);
  if (fromStopSequences != null) {
    setValueByPath(toObject, ["stopSequences"], fromStopSequences);
  }
  const fromResponseLogprobs = getValueByPath(fromObject, [
    "responseLogprobs"
  ]);
  if (fromResponseLogprobs != null) {
    setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
  }
  const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
  if (fromLogprobs != null) {
    setValueByPath(toObject, ["logprobs"], fromLogprobs);
  }
  const fromPresencePenalty = getValueByPath(fromObject, [
    "presencePenalty"
  ]);
  if (fromPresencePenalty != null) {
    setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
  }
  const fromFrequencyPenalty = getValueByPath(fromObject, [
    "frequencyPenalty"
  ]);
  if (fromFrequencyPenalty != null) {
    setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (fromSeed != null) {
    setValueByPath(toObject, ["seed"], fromSeed);
  }
  const fromResponseMimeType = getValueByPath(fromObject, [
    "responseMimeType"
  ]);
  if (fromResponseMimeType != null) {
    setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
  }
  const fromResponseSchema = getValueByPath(fromObject, [
    "responseSchema"
  ]);
  if (fromResponseSchema != null) {
    setValueByPath(toObject, ["responseSchema"], tSchema(fromResponseSchema));
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  if (getValueByPath(fromObject, ["routingConfig"]) !== void 0) {
    throw new Error("routingConfig parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["modelSelectionConfig"]) !== void 0) {
    throw new Error("modelSelectionConfig parameter is not supported in Gemini API.");
  }
  const fromSafetySettings = getValueByPath(fromObject, [
    "safetySettings"
  ]);
  if (parentObject !== void 0 && fromSafetySettings != null) {
    let transformedList = fromSafetySettings;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return safetySettingToMldev$1(item);
      });
    }
    setValueByPath(parentObject, ["safetySettings"], transformedList);
  }
  const fromTools = getValueByPath(fromObject, ["tools"]);
  if (parentObject !== void 0 && fromTools != null) {
    let transformedList = tTools(fromTools);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return toolToMldev$4(tTool(item));
      });
    }
    setValueByPath(parentObject, ["tools"], transformedList);
  }
  const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
  if (parentObject !== void 0 && fromToolConfig != null) {
    setValueByPath(parentObject, ["toolConfig"], toolConfigToMldev$2(fromToolConfig));
  }
  if (getValueByPath(fromObject, ["labels"]) !== void 0) {
    throw new Error("labels parameter is not supported in Gemini API.");
  }
  const fromCachedContent = getValueByPath(fromObject, [
    "cachedContent"
  ]);
  if (parentObject !== void 0 && fromCachedContent != null) {
    setValueByPath(parentObject, ["cachedContent"], tCachedContentName(apiClient, fromCachedContent));
  }
  const fromResponseModalities = getValueByPath(fromObject, [
    "responseModalities"
  ]);
  if (fromResponseModalities != null) {
    setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
  }
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (fromMediaResolution != null) {
    setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
  }
  const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
  if (fromSpeechConfig != null) {
    setValueByPath(toObject, ["speechConfig"], tSpeechConfig(fromSpeechConfig));
  }
  if (getValueByPath(fromObject, ["audioTimestamp"]) !== void 0) {
    throw new Error("audioTimestamp parameter is not supported in Gemini API.");
  }
  const fromThinkingConfig = getValueByPath(fromObject, [
    "thinkingConfig"
  ]);
  if (fromThinkingConfig != null) {
    setValueByPath(toObject, ["thinkingConfig"], fromThinkingConfig);
  }
  const fromImageConfig = getValueByPath(fromObject, ["imageConfig"]);
  if (fromImageConfig != null) {
    setValueByPath(toObject, ["imageConfig"], imageConfigToMldev$1(fromImageConfig));
  }
  const fromEnableEnhancedCivicAnswers = getValueByPath(fromObject, [
    "enableEnhancedCivicAnswers"
  ]);
  if (fromEnableEnhancedCivicAnswers != null) {
    setValueByPath(toObject, ["enableEnhancedCivicAnswers"], fromEnableEnhancedCivicAnswers);
  }
  if (getValueByPath(fromObject, ["modelArmorConfig"]) !== void 0) {
    throw new Error("modelArmorConfig parameter is not supported in Gemini API.");
  }
  return toObject;
}
function generateContentResponseFromMldev$1(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromCandidates = getValueByPath(fromObject, ["candidates"]);
  if (fromCandidates != null) {
    let transformedList = fromCandidates;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return candidateFromMldev$1(item);
      });
    }
    setValueByPath(toObject, ["candidates"], transformedList);
  }
  const fromModelVersion = getValueByPath(fromObject, ["modelVersion"]);
  if (fromModelVersion != null) {
    setValueByPath(toObject, ["modelVersion"], fromModelVersion);
  }
  const fromPromptFeedback = getValueByPath(fromObject, [
    "promptFeedback"
  ]);
  if (fromPromptFeedback != null) {
    setValueByPath(toObject, ["promptFeedback"], fromPromptFeedback);
  }
  const fromResponseId = getValueByPath(fromObject, ["responseId"]);
  if (fromResponseId != null) {
    setValueByPath(toObject, ["responseId"], fromResponseId);
  }
  const fromUsageMetadata = getValueByPath(fromObject, [
    "usageMetadata"
  ]);
  if (fromUsageMetadata != null) {
    setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
  }
  return toObject;
}
function getBatchJobParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
  }
  return toObject;
}
function getBatchJobParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tBatchJobName(apiClient, fromName));
  }
  return toObject;
}
function googleMapsToMldev$4(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["authConfig"]) !== void 0) {
    throw new Error("authConfig parameter is not supported in Gemini API.");
  }
  const fromEnableWidget = getValueByPath(fromObject, ["enableWidget"]);
  if (fromEnableWidget != null) {
    setValueByPath(toObject, ["enableWidget"], fromEnableWidget);
  }
  return toObject;
}
function googleSearchToMldev$4(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) {
    throw new Error("excludeDomains parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["blockingConfidence"]) !== void 0) {
    throw new Error("blockingConfidence parameter is not supported in Gemini API.");
  }
  const fromTimeRangeFilter = getValueByPath(fromObject, [
    "timeRangeFilter"
  ]);
  if (fromTimeRangeFilter != null) {
    setValueByPath(toObject, ["timeRangeFilter"], fromTimeRangeFilter);
  }
  return toObject;
}
function imageConfigToMldev$1(fromObject) {
  const toObject = {};
  const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
  if (fromAspectRatio != null) {
    setValueByPath(toObject, ["aspectRatio"], fromAspectRatio);
  }
  const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
  if (fromImageSize != null) {
    setValueByPath(toObject, ["imageSize"], fromImageSize);
  }
  if (getValueByPath(fromObject, ["personGeneration"]) !== void 0) {
    throw new Error("personGeneration parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["outputMimeType"]) !== void 0) {
    throw new Error("outputMimeType parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["outputCompressionQuality"]) !== void 0) {
    throw new Error("outputCompressionQuality parameter is not supported in Gemini API.");
  }
  return toObject;
}
function inlinedRequestToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["request", "model"], tModel(apiClient, fromModel));
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (fromContents != null) {
    let transformedList = tContents(fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return contentToMldev$4(item);
      });
    }
    setValueByPath(toObject, ["request", "contents"], transformedList);
  }
  const fromMetadata = getValueByPath(fromObject, ["metadata"]);
  if (fromMetadata != null) {
    setValueByPath(toObject, ["metadata"], fromMetadata);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["request", "generationConfig"], generateContentConfigToMldev$1(apiClient, fromConfig, getValueByPath(toObject, ["request"], {})));
  }
  return toObject;
}
function inlinedResponseFromMldev(fromObject) {
  const toObject = {};
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], generateContentResponseFromMldev$1(fromResponse));
  }
  const fromMetadata = getValueByPath(fromObject, ["metadata"]);
  if (fromMetadata != null) {
    setValueByPath(toObject, ["metadata"], fromMetadata);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fromError);
  }
  return toObject;
}
function listBatchJobsConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== void 0 && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== void 0 && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  if (getValueByPath(fromObject, ["filter"]) !== void 0) {
    throw new Error("filter parameter is not supported in Gemini API.");
  }
  return toObject;
}
function listBatchJobsConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== void 0 && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== void 0 && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  const fromFilter = getValueByPath(fromObject, ["filter"]);
  if (parentObject !== void 0 && fromFilter != null) {
    setValueByPath(parentObject, ["_query", "filter"], fromFilter);
  }
  return toObject;
}
function listBatchJobsParametersToMldev(fromObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    listBatchJobsConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function listBatchJobsParametersToVertex(fromObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    listBatchJobsConfigToVertex(fromConfig, toObject);
  }
  return toObject;
}
function listBatchJobsResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromBatchJobs = getValueByPath(fromObject, ["operations"]);
  if (fromBatchJobs != null) {
    let transformedList = fromBatchJobs;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return batchJobFromMldev(item);
      });
    }
    setValueByPath(toObject, ["batchJobs"], transformedList);
  }
  return toObject;
}
function listBatchJobsResponseFromVertex(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromBatchJobs = getValueByPath(fromObject, [
    "batchPredictionJobs"
  ]);
  if (fromBatchJobs != null) {
    let transformedList = fromBatchJobs;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return batchJobFromVertex(item);
      });
    }
    setValueByPath(toObject, ["batchJobs"], transformedList);
  }
  return toObject;
}
function partToMldev$4(fromObject) {
  const toObject = {};
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (fromMediaResolution != null) {
    setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
  }
  const fromCodeExecutionResult = getValueByPath(fromObject, [
    "codeExecutionResult"
  ]);
  if (fromCodeExecutionResult != null) {
    setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
  }
  const fromExecutableCode = getValueByPath(fromObject, [
    "executableCode"
  ]);
  if (fromExecutableCode != null) {
    setValueByPath(toObject, ["executableCode"], fromExecutableCode);
  }
  const fromFileData = getValueByPath(fromObject, ["fileData"]);
  if (fromFileData != null) {
    setValueByPath(toObject, ["fileData"], fileDataToMldev$4(fromFileData));
  }
  const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
  if (fromFunctionCall != null) {
    setValueByPath(toObject, ["functionCall"], functionCallToMldev$4(fromFunctionCall));
  }
  const fromFunctionResponse = getValueByPath(fromObject, [
    "functionResponse"
  ]);
  if (fromFunctionResponse != null) {
    setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
  }
  const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
  if (fromInlineData != null) {
    setValueByPath(toObject, ["inlineData"], blobToMldev$4(fromInlineData));
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  const fromThought = getValueByPath(fromObject, ["thought"]);
  if (fromThought != null) {
    setValueByPath(toObject, ["thought"], fromThought);
  }
  const fromThoughtSignature = getValueByPath(fromObject, [
    "thoughtSignature"
  ]);
  if (fromThoughtSignature != null) {
    setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
  }
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
  }
  return toObject;
}
function safetySettingToMldev$1(fromObject) {
  const toObject = {};
  const fromCategory = getValueByPath(fromObject, ["category"]);
  if (fromCategory != null) {
    setValueByPath(toObject, ["category"], fromCategory);
  }
  if (getValueByPath(fromObject, ["method"]) !== void 0) {
    throw new Error("method parameter is not supported in Gemini API.");
  }
  const fromThreshold = getValueByPath(fromObject, ["threshold"]);
  if (fromThreshold != null) {
    setValueByPath(toObject, ["threshold"], fromThreshold);
  }
  return toObject;
}
function toolConfigToMldev$2(fromObject) {
  const toObject = {};
  const fromRetrievalConfig = getValueByPath(fromObject, [
    "retrievalConfig"
  ]);
  if (fromRetrievalConfig != null) {
    setValueByPath(toObject, ["retrievalConfig"], fromRetrievalConfig);
  }
  const fromFunctionCallingConfig = getValueByPath(fromObject, [
    "functionCallingConfig"
  ]);
  if (fromFunctionCallingConfig != null) {
    setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToMldev$2(fromFunctionCallingConfig));
  }
  return toObject;
}
function toolToMldev$4(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
    throw new Error("retrieval parameter is not supported in Gemini API.");
  }
  const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
  if (fromComputerUse != null) {
    setValueByPath(toObject, ["computerUse"], fromComputerUse);
  }
  const fromFileSearch = getValueByPath(fromObject, ["fileSearch"]);
  if (fromFileSearch != null) {
    setValueByPath(toObject, ["fileSearch"], fromFileSearch);
  }
  const fromCodeExecution = getValueByPath(fromObject, [
    "codeExecution"
  ]);
  if (fromCodeExecution != null) {
    setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
  }
  if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
    throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
  }
  const fromFunctionDeclarations = getValueByPath(fromObject, [
    "functionDeclarations"
  ]);
  if (fromFunctionDeclarations != null) {
    let transformedList = fromFunctionDeclarations;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["functionDeclarations"], transformedList);
  }
  const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
  if (fromGoogleMaps != null) {
    setValueByPath(toObject, ["googleMaps"], googleMapsToMldev$4(fromGoogleMaps));
  }
  const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
  if (fromGoogleSearch != null) {
    setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$4(fromGoogleSearch));
  }
  const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
    "googleSearchRetrieval"
  ]);
  if (fromGoogleSearchRetrieval != null) {
    setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
  }
  const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
  if (fromUrlContext != null) {
    setValueByPath(toObject, ["urlContext"], fromUrlContext);
  }
  return toObject;
}
var PagedItem;
(function(PagedItem2) {
  PagedItem2["PAGED_ITEM_BATCH_JOBS"] = "batchJobs";
  PagedItem2["PAGED_ITEM_MODELS"] = "models";
  PagedItem2["PAGED_ITEM_TUNING_JOBS"] = "tuningJobs";
  PagedItem2["PAGED_ITEM_FILES"] = "files";
  PagedItem2["PAGED_ITEM_CACHED_CONTENTS"] = "cachedContents";
  PagedItem2["PAGED_ITEM_FILE_SEARCH_STORES"] = "fileSearchStores";
  PagedItem2["PAGED_ITEM_DOCUMENTS"] = "documents";
})(PagedItem || (PagedItem = {}));
var Pager = class {
  constructor(name, request, response, params) {
    this.pageInternal = [];
    this.paramsInternal = {};
    this.requestInternal = request;
    this.init(name, response, params);
  }
  init(name, response, params) {
    var _a5, _b;
    this.nameInternal = name;
    this.pageInternal = response[this.nameInternal] || [];
    this.sdkHttpResponseInternal = response === null || response === void 0 ? void 0 : response.sdkHttpResponse;
    this.idxInternal = 0;
    let requestParams = { config: {} };
    if (!params || Object.keys(params).length === 0) {
      requestParams = { config: {} };
    } else if (typeof params === "object") {
      requestParams = Object.assign({}, params);
    } else {
      requestParams = params;
    }
    if (requestParams["config"]) {
      requestParams["config"]["pageToken"] = response["nextPageToken"];
    }
    this.paramsInternal = requestParams;
    this.pageInternalSize = (_b = (_a5 = requestParams["config"]) === null || _a5 === void 0 ? void 0 : _a5["pageSize"]) !== null && _b !== void 0 ? _b : this.pageInternal.length;
  }
  initNextPage(response) {
    this.init(this.nameInternal, response, this.paramsInternal);
  }
  /**
   * Returns the current page, which is a list of items.
   *
   * @remarks
   * The first page is retrieved when the pager is created. The returned list of
   * items could be a subset of the entire list.
   */
  get page() {
    return this.pageInternal;
  }
  /**
   * Returns the type of paged item (for example, ``batch_jobs``).
   */
  get name() {
    return this.nameInternal;
  }
  /**
   * Returns the length of the page fetched each time by this pager.
   *
   * @remarks
   * The number of items in the page is less than or equal to the page length.
   */
  get pageSize() {
    return this.pageInternalSize;
  }
  /**
   * Returns the headers of the API response.
   */
  get sdkHttpResponse() {
    return this.sdkHttpResponseInternal;
  }
  /**
   * Returns the parameters when making the API request for the next page.
   *
   * @remarks
   * Parameters contain a set of optional configs that can be
   * used to customize the API request. For example, the `pageToken` parameter
   * contains the token to request the next page.
   */
  get params() {
    return this.paramsInternal;
  }
  /**
   * Returns the total number of items in the current page.
   */
  get pageLength() {
    return this.pageInternal.length;
  }
  /**
   * Returns the item at the given index.
   */
  getItem(index) {
    return this.pageInternal[index];
  }
  /**
   * Returns an async iterator that support iterating through all items
   * retrieved from the API.
   *
   * @remarks
   * The iterator will automatically fetch the next page if there are more items
   * to fetch from the API.
   *
   * @example
   *
   * ```ts
   * const pager = await ai.files.list({config: {pageSize: 10}});
   * for await (const file of pager) {
   *   console.log(file.name);
   * }
   * ```
   */
  [Symbol.asyncIterator]() {
    return {
      next: async () => {
        if (this.idxInternal >= this.pageLength) {
          if (this.hasNextPage()) {
            await this.nextPage();
          } else {
            return { value: void 0, done: true };
          }
        }
        const item = this.getItem(this.idxInternal);
        this.idxInternal += 1;
        return { value: item, done: false };
      },
      return: async () => {
        return { value: void 0, done: true };
      }
    };
  }
  /**
   * Fetches the next page of items. This makes a new API request.
   *
   * @throws {Error} If there are no more pages to fetch.
   *
   * @example
   *
   * ```ts
   * const pager = await ai.files.list({config: {pageSize: 10}});
   * let page = pager.page;
   * while (true) {
   *   for (const file of page) {
   *     console.log(file.name);
   *   }
   *   if (!pager.hasNextPage()) {
   *     break;
   *   }
   *   page = await pager.nextPage();
   * }
   * ```
   */
  async nextPage() {
    if (!this.hasNextPage()) {
      throw new Error("No more pages to fetch.");
    }
    const response = await this.requestInternal(this.params);
    this.initNextPage(response);
    return this.page;
  }
  /**
   * Returns true if there are more pages to fetch from the API.
   */
  hasNextPage() {
    var _a5;
    if (((_a5 = this.params["config"]) === null || _a5 === void 0 ? void 0 : _a5["pageToken"]) !== void 0) {
      return true;
    }
    return false;
  }
};
var Batches4 = class extends BaseModule {
  constructor(apiClient) {
    super();
    this.apiClient = apiClient;
    this.list = async (params = {}) => {
      return new Pager(PagedItem.PAGED_ITEM_BATCH_JOBS, (x3) => this.listInternal(x3), await this.listInternal(params), params);
    };
    this.create = async (params) => {
      if (this.apiClient.isVertexAI()) {
        params.config = this.formatDestination(params.src, params.config);
      }
      return this.createInternal(params);
    };
    this.createEmbeddings = async (params) => {
      console.warn("batches.createEmbeddings() is experimental and may change without notice.");
      if (this.apiClient.isVertexAI()) {
        throw new Error("Vertex AI does not support batches.createEmbeddings.");
      }
      return this.createEmbeddingsInternal(params);
    };
  }
  // Helper function to handle inlined generate content requests
  createInlinedGenerateContentRequest(params) {
    const body = createBatchJobParametersToMldev(
      this.apiClient,
      // Use instance apiClient
      params
    );
    const urlParams = body["_url"];
    const path4 = formatMap("{model}:batchGenerateContent", urlParams);
    const batch = body["batch"];
    const inputConfig = batch["inputConfig"];
    const requestsWrapper = inputConfig["requests"];
    const requests = requestsWrapper["requests"];
    const newRequests = [];
    for (const request of requests) {
      const requestDict = Object.assign({}, request);
      if (requestDict["systemInstruction"]) {
        const systemInstructionValue = requestDict["systemInstruction"];
        delete requestDict["systemInstruction"];
        const requestContent = requestDict["request"];
        requestContent["systemInstruction"] = systemInstructionValue;
        requestDict["request"] = requestContent;
      }
      newRequests.push(requestDict);
    }
    requestsWrapper["requests"] = newRequests;
    delete body["config"];
    delete body["_url"];
    delete body["_query"];
    return { path: path4, body };
  }
  // Helper function to get the first GCS URI
  getGcsUri(src) {
    if (typeof src === "string") {
      return src.startsWith("gs://") ? src : void 0;
    }
    if (!Array.isArray(src) && src.gcsUri && src.gcsUri.length > 0) {
      return src.gcsUri[0];
    }
    return void 0;
  }
  // Helper function to get the BigQuery URI
  getBigqueryUri(src) {
    if (typeof src === "string") {
      return src.startsWith("bq://") ? src : void 0;
    }
    if (!Array.isArray(src)) {
      return src.bigqueryUri;
    }
    return void 0;
  }
  // Function to format the destination configuration for Vertex AI
  formatDestination(src, config) {
    const newConfig = config ? Object.assign({}, config) : {};
    const timestampStr = Date.now().toString();
    if (!newConfig.displayName) {
      newConfig.displayName = `genaiBatchJob_${timestampStr}`;
    }
    if (newConfig.dest === void 0) {
      const gcsUri = this.getGcsUri(src);
      const bigqueryUri = this.getBigqueryUri(src);
      if (gcsUri) {
        if (gcsUri.endsWith(".jsonl")) {
          newConfig.dest = `${gcsUri.slice(0, -6)}/dest`;
        } else {
          newConfig.dest = `${gcsUri}_dest_${timestampStr}`;
        }
      } else if (bigqueryUri) {
        newConfig.dest = `${bigqueryUri}_dest_${timestampStr}`;
      } else {
        throw new Error("Unsupported source for Vertex AI: No GCS or BigQuery URI found.");
      }
    }
    return newConfig;
  }
  /**
   * Internal method to create batch job.
   *
   * @param params - The parameters for create batch job request.
   * @return The created batch job.
   *
   */
  async createInternal(params) {
    var _a5, _b, _c, _d;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = createBatchJobParametersToVertex(this.apiClient, params);
      path4 = formatMap("batchPredictionJobs", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = batchJobFromVertex(apiResponse);
        return resp;
      });
    } else {
      const body = createBatchJobParametersToMldev(this.apiClient, params);
      path4 = formatMap("{model}:batchGenerateContent", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = batchJobFromMldev(apiResponse);
        return resp;
      });
    }
  }
  /**
   * Internal method to create batch job.
   *
   * @param params - The parameters for create batch job request.
   * @return The created batch job.
   *
   */
  async createEmbeddingsInternal(params) {
    var _a5, _b;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      throw new Error("This method is only supported by the Gemini Developer API.");
    } else {
      const body = createEmbeddingsBatchJobParametersToMldev(this.apiClient, params);
      path4 = formatMap("{model}:asyncBatchEmbedContent", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = batchJobFromMldev(apiResponse);
        return resp;
      });
    }
  }
  /**
   * Gets batch job configurations.
   *
   * @param params - The parameters for the get request.
   * @return The batch job.
   *
   * @example
   * ```ts
   * await ai.batches.get({name: '...'}); // The server-generated resource name.
   * ```
   */
  async get(params) {
    var _a5, _b, _c, _d;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = getBatchJobParametersToVertex(this.apiClient, params);
      path4 = formatMap("batchPredictionJobs/{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = batchJobFromVertex(apiResponse);
        return resp;
      });
    } else {
      const body = getBatchJobParametersToMldev(this.apiClient, params);
      path4 = formatMap("batches/{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = batchJobFromMldev(apiResponse);
        return resp;
      });
    }
  }
  /**
   * Cancels a batch job.
   *
   * @param params - The parameters for the cancel request.
   * @return The empty response returned by the API.
   *
   * @example
   * ```ts
   * await ai.batches.cancel({name: '...'}); // The server-generated resource name.
   * ```
   */
  async cancel(params) {
    var _a5, _b, _c, _d;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = cancelBatchJobParametersToVertex(this.apiClient, params);
      path4 = formatMap("batchPredictionJobs/{name}:cancel", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      await this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      });
    } else {
      const body = cancelBatchJobParametersToMldev(this.apiClient, params);
      path4 = formatMap("batches/{name}:cancel", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      await this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      });
    }
  }
  async listInternal(params) {
    var _a5, _b, _c, _d;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = listBatchJobsParametersToVertex(params);
      path4 = formatMap("batchPredictionJobs", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = listBatchJobsResponseFromVertex(apiResponse);
        const typedResp = new ListBatchJobsResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = listBatchJobsParametersToMldev(params);
      path4 = formatMap("batches", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = listBatchJobsResponseFromMldev(apiResponse);
        const typedResp = new ListBatchJobsResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
  /**
   * Deletes a batch job.
   *
   * @param params - The parameters for the delete request.
   * @return The empty response returned by the API.
   *
   * @example
   * ```ts
   * await ai.batches.delete({name: '...'}); // The server-generated resource name.
   * ```
   */
  async delete(params) {
    var _a5, _b, _c, _d;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = deleteBatchJobParametersToVertex(this.apiClient, params);
      path4 = formatMap("batchPredictionJobs/{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "DELETE",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = deleteResourceJobFromVertex(apiResponse);
        return resp;
      });
    } else {
      const body = deleteBatchJobParametersToMldev(this.apiClient, params);
      path4 = formatMap("batches/{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "DELETE",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = deleteResourceJobFromMldev(apiResponse);
        return resp;
      });
    }
  }
};
function blobToMldev$3(fromObject) {
  const toObject = {};
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function contentToMldev$3(fromObject) {
  const toObject = {};
  const fromParts = getValueByPath(fromObject, ["parts"]);
  if (fromParts != null) {
    let transformedList = fromParts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return partToMldev$3(item);
      });
    }
    setValueByPath(toObject, ["parts"], transformedList);
  }
  const fromRole = getValueByPath(fromObject, ["role"]);
  if (fromRole != null) {
    setValueByPath(toObject, ["role"], fromRole);
  }
  return toObject;
}
function createCachedContentConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromTtl = getValueByPath(fromObject, ["ttl"]);
  if (parentObject !== void 0 && fromTtl != null) {
    setValueByPath(parentObject, ["ttl"], fromTtl);
  }
  const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
  if (parentObject !== void 0 && fromExpireTime != null) {
    setValueByPath(parentObject, ["expireTime"], fromExpireTime);
  }
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (parentObject !== void 0 && fromDisplayName != null) {
    setValueByPath(parentObject, ["displayName"], fromDisplayName);
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (parentObject !== void 0 && fromContents != null) {
    let transformedList = tContents(fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return contentToMldev$3(item);
      });
    }
    setValueByPath(parentObject, ["contents"], transformedList);
  }
  const fromSystemInstruction = getValueByPath(fromObject, [
    "systemInstruction"
  ]);
  if (parentObject !== void 0 && fromSystemInstruction != null) {
    setValueByPath(parentObject, ["systemInstruction"], contentToMldev$3(tContent(fromSystemInstruction)));
  }
  const fromTools = getValueByPath(fromObject, ["tools"]);
  if (parentObject !== void 0 && fromTools != null) {
    let transformedList = fromTools;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return toolToMldev$3(item);
      });
    }
    setValueByPath(parentObject, ["tools"], transformedList);
  }
  const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
  if (parentObject !== void 0 && fromToolConfig != null) {
    setValueByPath(parentObject, ["toolConfig"], toolConfigToMldev$1(fromToolConfig));
  }
  if (getValueByPath(fromObject, ["kmsKeyName"]) !== void 0) {
    throw new Error("kmsKeyName parameter is not supported in Gemini API.");
  }
  return toObject;
}
function createCachedContentConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromTtl = getValueByPath(fromObject, ["ttl"]);
  if (parentObject !== void 0 && fromTtl != null) {
    setValueByPath(parentObject, ["ttl"], fromTtl);
  }
  const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
  if (parentObject !== void 0 && fromExpireTime != null) {
    setValueByPath(parentObject, ["expireTime"], fromExpireTime);
  }
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (parentObject !== void 0 && fromDisplayName != null) {
    setValueByPath(parentObject, ["displayName"], fromDisplayName);
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (parentObject !== void 0 && fromContents != null) {
    let transformedList = tContents(fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(parentObject, ["contents"], transformedList);
  }
  const fromSystemInstruction = getValueByPath(fromObject, [
    "systemInstruction"
  ]);
  if (parentObject !== void 0 && fromSystemInstruction != null) {
    setValueByPath(parentObject, ["systemInstruction"], tContent(fromSystemInstruction));
  }
  const fromTools = getValueByPath(fromObject, ["tools"]);
  if (parentObject !== void 0 && fromTools != null) {
    let transformedList = fromTools;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return toolToVertex$2(item);
      });
    }
    setValueByPath(parentObject, ["tools"], transformedList);
  }
  const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
  if (parentObject !== void 0 && fromToolConfig != null) {
    setValueByPath(parentObject, ["toolConfig"], fromToolConfig);
  }
  const fromKmsKeyName = getValueByPath(fromObject, ["kmsKeyName"]);
  if (parentObject !== void 0 && fromKmsKeyName != null) {
    setValueByPath(parentObject, ["encryption_spec", "kmsKeyName"], fromKmsKeyName);
  }
  return toObject;
}
function createCachedContentParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["model"], tCachesModel(apiClient, fromModel));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    createCachedContentConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function createCachedContentParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["model"], tCachesModel(apiClient, fromModel));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    createCachedContentConfigToVertex(fromConfig, toObject);
  }
  return toObject;
}
function deleteCachedContentParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
  }
  return toObject;
}
function deleteCachedContentParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
  }
  return toObject;
}
function deleteCachedContentResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  return toObject;
}
function deleteCachedContentResponseFromVertex(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  return toObject;
}
function fileDataToMldev$3(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
  if (fromFileUri != null) {
    setValueByPath(toObject, ["fileUri"], fromFileUri);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function functionCallToMldev$3(fromObject) {
  const toObject = {};
  const fromId = getValueByPath(fromObject, ["id"]);
  if (fromId != null) {
    setValueByPath(toObject, ["id"], fromId);
  }
  const fromArgs = getValueByPath(fromObject, ["args"]);
  if (fromArgs != null) {
    setValueByPath(toObject, ["args"], fromArgs);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  if (getValueByPath(fromObject, ["partialArgs"]) !== void 0) {
    throw new Error("partialArgs parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["willContinue"]) !== void 0) {
    throw new Error("willContinue parameter is not supported in Gemini API.");
  }
  return toObject;
}
function functionCallingConfigToMldev$1(fromObject) {
  const toObject = {};
  const fromAllowedFunctionNames = getValueByPath(fromObject, [
    "allowedFunctionNames"
  ]);
  if (fromAllowedFunctionNames != null) {
    setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
  }
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (fromMode != null) {
    setValueByPath(toObject, ["mode"], fromMode);
  }
  if (getValueByPath(fromObject, ["streamFunctionCallArguments"]) !== void 0) {
    throw new Error("streamFunctionCallArguments parameter is not supported in Gemini API.");
  }
  return toObject;
}
function functionDeclarationToVertex$2(fromObject) {
  const toObject = {};
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromParameters = getValueByPath(fromObject, ["parameters"]);
  if (fromParameters != null) {
    setValueByPath(toObject, ["parameters"], fromParameters);
  }
  const fromParametersJsonSchema = getValueByPath(fromObject, [
    "parametersJsonSchema"
  ]);
  if (fromParametersJsonSchema != null) {
    setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
  }
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], fromResponse);
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  if (getValueByPath(fromObject, ["behavior"]) !== void 0) {
    throw new Error("behavior parameter is not supported in Vertex AI.");
  }
  return toObject;
}
function getCachedContentParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
  }
  return toObject;
}
function getCachedContentParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
  }
  return toObject;
}
function googleMapsToMldev$3(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["authConfig"]) !== void 0) {
    throw new Error("authConfig parameter is not supported in Gemini API.");
  }
  const fromEnableWidget = getValueByPath(fromObject, ["enableWidget"]);
  if (fromEnableWidget != null) {
    setValueByPath(toObject, ["enableWidget"], fromEnableWidget);
  }
  return toObject;
}
function googleSearchToMldev$3(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) {
    throw new Error("excludeDomains parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["blockingConfidence"]) !== void 0) {
    throw new Error("blockingConfidence parameter is not supported in Gemini API.");
  }
  const fromTimeRangeFilter = getValueByPath(fromObject, [
    "timeRangeFilter"
  ]);
  if (fromTimeRangeFilter != null) {
    setValueByPath(toObject, ["timeRangeFilter"], fromTimeRangeFilter);
  }
  return toObject;
}
function listCachedContentsConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== void 0 && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== void 0 && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  return toObject;
}
function listCachedContentsConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== void 0 && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== void 0 && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  return toObject;
}
function listCachedContentsParametersToMldev(fromObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    listCachedContentsConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function listCachedContentsParametersToVertex(fromObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    listCachedContentsConfigToVertex(fromConfig, toObject);
  }
  return toObject;
}
function listCachedContentsResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromCachedContents = getValueByPath(fromObject, [
    "cachedContents"
  ]);
  if (fromCachedContents != null) {
    let transformedList = fromCachedContents;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["cachedContents"], transformedList);
  }
  return toObject;
}
function listCachedContentsResponseFromVertex(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromCachedContents = getValueByPath(fromObject, [
    "cachedContents"
  ]);
  if (fromCachedContents != null) {
    let transformedList = fromCachedContents;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["cachedContents"], transformedList);
  }
  return toObject;
}
function partToMldev$3(fromObject) {
  const toObject = {};
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (fromMediaResolution != null) {
    setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
  }
  const fromCodeExecutionResult = getValueByPath(fromObject, [
    "codeExecutionResult"
  ]);
  if (fromCodeExecutionResult != null) {
    setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
  }
  const fromExecutableCode = getValueByPath(fromObject, [
    "executableCode"
  ]);
  if (fromExecutableCode != null) {
    setValueByPath(toObject, ["executableCode"], fromExecutableCode);
  }
  const fromFileData = getValueByPath(fromObject, ["fileData"]);
  if (fromFileData != null) {
    setValueByPath(toObject, ["fileData"], fileDataToMldev$3(fromFileData));
  }
  const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
  if (fromFunctionCall != null) {
    setValueByPath(toObject, ["functionCall"], functionCallToMldev$3(fromFunctionCall));
  }
  const fromFunctionResponse = getValueByPath(fromObject, [
    "functionResponse"
  ]);
  if (fromFunctionResponse != null) {
    setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
  }
  const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
  if (fromInlineData != null) {
    setValueByPath(toObject, ["inlineData"], blobToMldev$3(fromInlineData));
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  const fromThought = getValueByPath(fromObject, ["thought"]);
  if (fromThought != null) {
    setValueByPath(toObject, ["thought"], fromThought);
  }
  const fromThoughtSignature = getValueByPath(fromObject, [
    "thoughtSignature"
  ]);
  if (fromThoughtSignature != null) {
    setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
  }
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
  }
  return toObject;
}
function toolConfigToMldev$1(fromObject) {
  const toObject = {};
  const fromRetrievalConfig = getValueByPath(fromObject, [
    "retrievalConfig"
  ]);
  if (fromRetrievalConfig != null) {
    setValueByPath(toObject, ["retrievalConfig"], fromRetrievalConfig);
  }
  const fromFunctionCallingConfig = getValueByPath(fromObject, [
    "functionCallingConfig"
  ]);
  if (fromFunctionCallingConfig != null) {
    setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToMldev$1(fromFunctionCallingConfig));
  }
  return toObject;
}
function toolToMldev$3(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
    throw new Error("retrieval parameter is not supported in Gemini API.");
  }
  const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
  if (fromComputerUse != null) {
    setValueByPath(toObject, ["computerUse"], fromComputerUse);
  }
  const fromFileSearch = getValueByPath(fromObject, ["fileSearch"]);
  if (fromFileSearch != null) {
    setValueByPath(toObject, ["fileSearch"], fromFileSearch);
  }
  const fromCodeExecution = getValueByPath(fromObject, [
    "codeExecution"
  ]);
  if (fromCodeExecution != null) {
    setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
  }
  if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
    throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
  }
  const fromFunctionDeclarations = getValueByPath(fromObject, [
    "functionDeclarations"
  ]);
  if (fromFunctionDeclarations != null) {
    let transformedList = fromFunctionDeclarations;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["functionDeclarations"], transformedList);
  }
  const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
  if (fromGoogleMaps != null) {
    setValueByPath(toObject, ["googleMaps"], googleMapsToMldev$3(fromGoogleMaps));
  }
  const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
  if (fromGoogleSearch != null) {
    setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$3(fromGoogleSearch));
  }
  const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
    "googleSearchRetrieval"
  ]);
  if (fromGoogleSearchRetrieval != null) {
    setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
  }
  const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
  if (fromUrlContext != null) {
    setValueByPath(toObject, ["urlContext"], fromUrlContext);
  }
  return toObject;
}
function toolToVertex$2(fromObject) {
  const toObject = {};
  const fromRetrieval = getValueByPath(fromObject, ["retrieval"]);
  if (fromRetrieval != null) {
    setValueByPath(toObject, ["retrieval"], fromRetrieval);
  }
  const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
  if (fromComputerUse != null) {
    setValueByPath(toObject, ["computerUse"], fromComputerUse);
  }
  if (getValueByPath(fromObject, ["fileSearch"]) !== void 0) {
    throw new Error("fileSearch parameter is not supported in Vertex AI.");
  }
  const fromCodeExecution = getValueByPath(fromObject, [
    "codeExecution"
  ]);
  if (fromCodeExecution != null) {
    setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
  }
  const fromEnterpriseWebSearch = getValueByPath(fromObject, [
    "enterpriseWebSearch"
  ]);
  if (fromEnterpriseWebSearch != null) {
    setValueByPath(toObject, ["enterpriseWebSearch"], fromEnterpriseWebSearch);
  }
  const fromFunctionDeclarations = getValueByPath(fromObject, [
    "functionDeclarations"
  ]);
  if (fromFunctionDeclarations != null) {
    let transformedList = fromFunctionDeclarations;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return functionDeclarationToVertex$2(item);
      });
    }
    setValueByPath(toObject, ["functionDeclarations"], transformedList);
  }
  const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
  if (fromGoogleMaps != null) {
    setValueByPath(toObject, ["googleMaps"], fromGoogleMaps);
  }
  const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
  if (fromGoogleSearch != null) {
    setValueByPath(toObject, ["googleSearch"], fromGoogleSearch);
  }
  const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
    "googleSearchRetrieval"
  ]);
  if (fromGoogleSearchRetrieval != null) {
    setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
  }
  const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
  if (fromUrlContext != null) {
    setValueByPath(toObject, ["urlContext"], fromUrlContext);
  }
  return toObject;
}
function updateCachedContentConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromTtl = getValueByPath(fromObject, ["ttl"]);
  if (parentObject !== void 0 && fromTtl != null) {
    setValueByPath(parentObject, ["ttl"], fromTtl);
  }
  const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
  if (parentObject !== void 0 && fromExpireTime != null) {
    setValueByPath(parentObject, ["expireTime"], fromExpireTime);
  }
  return toObject;
}
function updateCachedContentConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromTtl = getValueByPath(fromObject, ["ttl"]);
  if (parentObject !== void 0 && fromTtl != null) {
    setValueByPath(parentObject, ["ttl"], fromTtl);
  }
  const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
  if (parentObject !== void 0 && fromExpireTime != null) {
    setValueByPath(parentObject, ["expireTime"], fromExpireTime);
  }
  return toObject;
}
function updateCachedContentParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    updateCachedContentConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function updateCachedContentParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], tCachedContentName(apiClient, fromName));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    updateCachedContentConfigToVertex(fromConfig, toObject);
  }
  return toObject;
}
var Caches = class extends BaseModule {
  constructor(apiClient) {
    super();
    this.apiClient = apiClient;
    this.list = async (params = {}) => {
      return new Pager(PagedItem.PAGED_ITEM_CACHED_CONTENTS, (x3) => this.listInternal(x3), await this.listInternal(params), params);
    };
  }
  /**
   * Creates a cached contents resource.
   *
   * @remarks
   * Context caching is only supported for specific models. See [Gemini
   * Developer API reference](https://ai.google.dev/gemini-api/docs/caching?lang=node/context-cac)
   * and [Vertex AI reference](https://cloud.google.com/vertex-ai/generative-ai/docs/context-cache/context-cache-overview#supported_models)
   * for more information.
   *
   * @param params - The parameters for the create request.
   * @return The created cached content.
   *
   * @example
   * ```ts
   * const contents = ...; // Initialize the content to cache.
   * const response = await ai.caches.create({
   *   model: 'gemini-2.0-flash-001',
   *   config: {
   *    'contents': contents,
   *    'displayName': 'test cache',
   *    'systemInstruction': 'What is the sum of the two pdfs?',
   *    'ttl': '86400s',
   *  }
   * });
   * ```
   */
  async create(params) {
    var _a5, _b, _c, _d;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = createCachedContentParametersToVertex(this.apiClient, params);
      path4 = formatMap("cachedContents", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((resp) => {
        return resp;
      });
    } else {
      const body = createCachedContentParametersToMldev(this.apiClient, params);
      path4 = formatMap("cachedContents", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((resp) => {
        return resp;
      });
    }
  }
  /**
   * Gets cached content configurations.
   *
   * @param params - The parameters for the get request.
   * @return The cached content.
   *
   * @example
   * ```ts
   * await ai.caches.get({name: '...'}); // The server-generated resource name.
   * ```
   */
  async get(params) {
    var _a5, _b, _c, _d;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = getCachedContentParametersToVertex(this.apiClient, params);
      path4 = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((resp) => {
        return resp;
      });
    } else {
      const body = getCachedContentParametersToMldev(this.apiClient, params);
      path4 = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((resp) => {
        return resp;
      });
    }
  }
  /**
   * Deletes cached content.
   *
   * @param params - The parameters for the delete request.
   * @return The empty response returned by the API.
   *
   * @example
   * ```ts
   * await ai.caches.delete({name: '...'}); // The server-generated resource name.
   * ```
   */
  async delete(params) {
    var _a5, _b, _c, _d;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = deleteCachedContentParametersToVertex(this.apiClient, params);
      path4 = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "DELETE",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = deleteCachedContentResponseFromVertex(apiResponse);
        const typedResp = new DeleteCachedContentResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = deleteCachedContentParametersToMldev(this.apiClient, params);
      path4 = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "DELETE",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = deleteCachedContentResponseFromMldev(apiResponse);
        const typedResp = new DeleteCachedContentResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
  /**
   * Updates cached content configurations.
   *
   * @param params - The parameters for the update request.
   * @return The updated cached content.
   *
   * @example
   * ```ts
   * const response = await ai.caches.update({
   *   name: '...',  // The server-generated resource name.
   *   config: {'ttl': '7600s'}
   * });
   * ```
   */
  async update(params) {
    var _a5, _b, _c, _d;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = updateCachedContentParametersToVertex(this.apiClient, params);
      path4 = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "PATCH",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((resp) => {
        return resp;
      });
    } else {
      const body = updateCachedContentParametersToMldev(this.apiClient, params);
      path4 = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "PATCH",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((resp) => {
        return resp;
      });
    }
  }
  async listInternal(params) {
    var _a5, _b, _c, _d;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = listCachedContentsParametersToVertex(params);
      path4 = formatMap("cachedContents", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = listCachedContentsResponseFromVertex(apiResponse);
        const typedResp = new ListCachedContentsResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = listCachedContentsParametersToMldev(params);
      path4 = formatMap("cachedContents", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = listCachedContentsResponseFromMldev(apiResponse);
        const typedResp = new ListCachedContentsResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
};
function __rest(s, e3) {
  var t = {};
  for (var p3 in s) if (Object.prototype.hasOwnProperty.call(s, p3) && e3.indexOf(p3) < 0)
    t[p3] = s[p3];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i3 = 0, p3 = Object.getOwnPropertySymbols(s); i3 < p3.length; i3++) {
      if (e3.indexOf(p3[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p3[i3]))
        t[p3[i3]] = s[p3[i3]];
    }
  return t;
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i3 = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i3 >= o.length) o = void 0;
      return { value: o && o[i3++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __await(v3) {
  return this instanceof __await ? (this.v = v3, this) : new __await(v3);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g3 = generator.apply(thisArg, _arguments || []), i3, q = [];
  return i3 = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i3[Symbol.asyncIterator] = function() {
    return this;
  }, i3;
  function awaitReturn(f) {
    return function(v3) {
      return Promise.resolve(v3).then(f, reject);
    };
  }
  function verb(n3, f) {
    if (g3[n3]) {
      i3[n3] = function(v3) {
        return new Promise(function(a, b3) {
          q.push([n3, v3, a, b3]) > 1 || resume(n3, v3);
        });
      };
      if (f) i3[n3] = f(i3[n3]);
    }
  }
  function resume(n3, v3) {
    try {
      step(g3[n3](v3));
    } catch (e3) {
      settle(q[0][3], e3);
    }
  }
  function step(r3) {
    r3.value instanceof __await ? Promise.resolve(r3.value.v).then(fulfill, reject) : settle(q[0][2], r3);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v3) {
    if (f(v3), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i3;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i3 = {}, verb("next"), verb("throw"), verb("return"), i3[Symbol.asyncIterator] = function() {
    return this;
  }, i3);
  function verb(n3) {
    i3[n3] = o[n3] && function(v3) {
      return new Promise(function(resolve, reject) {
        v3 = o[n3](v3), settle(resolve, reject, v3.done, v3.value);
      });
    };
  }
  function settle(resolve, reject, d3, v3) {
    Promise.resolve(v3).then(function(v5) {
      resolve({ value: v5, done: d3 });
    }, reject);
  }
}
function isValidResponse(response) {
  var _a5;
  if (response.candidates == void 0 || response.candidates.length === 0) {
    return false;
  }
  const content = (_a5 = response.candidates[0]) === null || _a5 === void 0 ? void 0 : _a5.content;
  if (content === void 0) {
    return false;
  }
  return isValidContent(content);
}
function isValidContent(content) {
  if (content.parts === void 0 || content.parts.length === 0) {
    return false;
  }
  for (const part of content.parts) {
    if (part === void 0 || Object.keys(part).length === 0) {
      return false;
    }
  }
  return true;
}
function validateHistory(history) {
  if (history.length === 0) {
    return;
  }
  for (const content of history) {
    if (content.role !== "user" && content.role !== "model") {
      throw new Error(`Role must be user or model, but got ${content.role}.`);
    }
  }
}
function extractCuratedHistory(comprehensiveHistory) {
  if (comprehensiveHistory === void 0 || comprehensiveHistory.length === 0) {
    return [];
  }
  const curatedHistory = [];
  const length = comprehensiveHistory.length;
  let i3 = 0;
  while (i3 < length) {
    if (comprehensiveHistory[i3].role === "user") {
      curatedHistory.push(comprehensiveHistory[i3]);
      i3++;
    } else {
      const modelOutput = [];
      let isValid = true;
      while (i3 < length && comprehensiveHistory[i3].role === "model") {
        modelOutput.push(comprehensiveHistory[i3]);
        if (isValid && !isValidContent(comprehensiveHistory[i3])) {
          isValid = false;
        }
        i3++;
      }
      if (isValid) {
        curatedHistory.push(...modelOutput);
      } else {
        curatedHistory.pop();
      }
    }
  }
  return curatedHistory;
}
var Chats = class {
  constructor(modelsModule, apiClient) {
    this.modelsModule = modelsModule;
    this.apiClient = apiClient;
  }
  /**
   * Creates a new chat session.
   *
   * @remarks
   * The config in the params will be used for all requests within the chat
   * session unless overridden by a per-request `config` in
   * @see {@link types.SendMessageParameters#config}.
   *
   * @param params - Parameters for creating a chat session.
   * @returns A new chat session.
   *
   * @example
   * ```ts
   * const chat = ai.chats.create({
   *   model: 'gemini-2.0-flash'
   *   config: {
   *     temperature: 0.5,
   *     maxOutputTokens: 1024,
   *   }
   * });
   * ```
   */
  create(params) {
    return new Chat2(
      this.apiClient,
      this.modelsModule,
      params.model,
      params.config,
      // Deep copy the history to avoid mutating the history outside of the
      // chat session.
      structuredClone(params.history)
    );
  }
};
var Chat2 = class {
  constructor(apiClient, modelsModule, model, config = {}, history = []) {
    this.apiClient = apiClient;
    this.modelsModule = modelsModule;
    this.model = model;
    this.config = config;
    this.history = history;
    this.sendPromise = Promise.resolve();
    validateHistory(history);
  }
  /**
   * Sends a message to the model and returns the response.
   *
   * @remarks
   * This method will wait for the previous message to be processed before
   * sending the next message.
   *
   * @see {@link Chat#sendMessageStream} for streaming method.
   * @param params - parameters for sending messages within a chat session.
   * @returns The model's response.
   *
   * @example
   * ```ts
   * const chat = ai.chats.create({model: 'gemini-2.0-flash'});
   * const response = await chat.sendMessage({
   *   message: 'Why is the sky blue?'
   * });
   * console.log(response.text);
   * ```
   */
  async sendMessage(params) {
    var _a5;
    await this.sendPromise;
    const inputContent = tContent(params.message);
    const responsePromise = this.modelsModule.generateContent({
      model: this.model,
      contents: this.getHistory(true).concat(inputContent),
      config: (_a5 = params.config) !== null && _a5 !== void 0 ? _a5 : this.config
    });
    this.sendPromise = (async () => {
      var _a6, _b, _c;
      const response = await responsePromise;
      const outputContent = (_b = (_a6 = response.candidates) === null || _a6 === void 0 ? void 0 : _a6[0]) === null || _b === void 0 ? void 0 : _b.content;
      const fullAutomaticFunctionCallingHistory = response.automaticFunctionCallingHistory;
      const index = this.getHistory(true).length;
      let automaticFunctionCallingHistory = [];
      if (fullAutomaticFunctionCallingHistory != null) {
        automaticFunctionCallingHistory = (_c = fullAutomaticFunctionCallingHistory.slice(index)) !== null && _c !== void 0 ? _c : [];
      }
      const modelOutput = outputContent ? [outputContent] : [];
      this.recordHistory(inputContent, modelOutput, automaticFunctionCallingHistory);
      return;
    })();
    await this.sendPromise.catch(() => {
      this.sendPromise = Promise.resolve();
    });
    return responsePromise;
  }
  /**
   * Sends a message to the model and returns the response in chunks.
   *
   * @remarks
   * This method will wait for the previous message to be processed before
   * sending the next message.
   *
   * @see {@link Chat#sendMessage} for non-streaming method.
   * @param params - parameters for sending the message.
   * @return The model's response.
   *
   * @example
   * ```ts
   * const chat = ai.chats.create({model: 'gemini-2.0-flash'});
   * const response = await chat.sendMessageStream({
   *   message: 'Why is the sky blue?'
   * });
   * for await (const chunk of response) {
   *   console.log(chunk.text);
   * }
   * ```
   */
  async sendMessageStream(params) {
    var _a5;
    await this.sendPromise;
    const inputContent = tContent(params.message);
    const streamResponse = this.modelsModule.generateContentStream({
      model: this.model,
      contents: this.getHistory(true).concat(inputContent),
      config: (_a5 = params.config) !== null && _a5 !== void 0 ? _a5 : this.config
    });
    this.sendPromise = streamResponse.then(() => void 0).catch(() => void 0);
    const response = await streamResponse;
    const result = this.processStreamResponse(response, inputContent);
    return result;
  }
  /**
   * Returns the chat history.
   *
   * @remarks
   * The history is a list of contents alternating between user and model.
   *
   * There are two types of history:
   * - The `curated history` contains only the valid turns between user and
   * model, which will be included in the subsequent requests sent to the model.
   * - The `comprehensive history` contains all turns, including invalid or
   *   empty model outputs, providing a complete record of the history.
   *
   * The history is updated after receiving the response from the model,
   * for streaming response, it means receiving the last chunk of the response.
   *
   * The `comprehensive history` is returned by default. To get the `curated
   * history`, set the `curated` parameter to `true`.
   *
   * @param curated - whether to return the curated history or the comprehensive
   *     history.
   * @return History contents alternating between user and model for the entire
   *     chat session.
   */
  getHistory(curated = false) {
    const history = curated ? extractCuratedHistory(this.history) : this.history;
    return structuredClone(history);
  }
  processStreamResponse(streamResponse, inputContent) {
    return __asyncGenerator(this, arguments, function* processStreamResponse_1() {
      var _a5, e_1, _b, _c;
      var _d, _e;
      const outputContent = [];
      try {
        for (var _f = true, streamResponse_1 = __asyncValues(streamResponse), streamResponse_1_1; streamResponse_1_1 = yield __await(streamResponse_1.next()), _a5 = streamResponse_1_1.done, !_a5; _f = true) {
          _c = streamResponse_1_1.value;
          _f = false;
          const chunk = _c;
          if (isValidResponse(chunk)) {
            const content = (_e = (_d = chunk.candidates) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e.content;
            if (content !== void 0) {
              outputContent.push(content);
            }
          }
          yield yield __await(chunk);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (!_f && !_a5 && (_b = streamResponse_1.return)) yield __await(_b.call(streamResponse_1));
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      this.recordHistory(inputContent, outputContent);
    });
  }
  recordHistory(userInput, modelOutput, automaticFunctionCallingHistory) {
    let outputContents = [];
    if (modelOutput.length > 0 && modelOutput.every((content) => content.role !== void 0)) {
      outputContents = modelOutput;
    } else {
      outputContents.push({
        role: "model",
        parts: []
      });
    }
    if (automaticFunctionCallingHistory && automaticFunctionCallingHistory.length > 0) {
      this.history.push(...extractCuratedHistory(automaticFunctionCallingHistory));
    } else {
      this.history.push(userInput);
    }
    this.history.push(...outputContents);
  }
};
var ApiError = class _ApiError extends Error {
  constructor(options) {
    super(options.message);
    this.name = "ApiError";
    this.status = options.status;
    Object.setPrototypeOf(this, _ApiError.prototype);
  }
};
function createFileParametersToMldev(fromObject) {
  const toObject = {};
  const fromFile = getValueByPath(fromObject, ["file"]);
  if (fromFile != null) {
    setValueByPath(toObject, ["file"], fromFile);
  }
  return toObject;
}
function createFileResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  return toObject;
}
function deleteFileParametersToMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "file"], tFileName(fromName));
  }
  return toObject;
}
function deleteFileResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  return toObject;
}
function getFileParametersToMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "file"], tFileName(fromName));
  }
  return toObject;
}
function internalRegisterFilesParametersToMldev(fromObject) {
  const toObject = {};
  const fromUris = getValueByPath(fromObject, ["uris"]);
  if (fromUris != null) {
    setValueByPath(toObject, ["uris"], fromUris);
  }
  return toObject;
}
function listFilesConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== void 0 && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== void 0 && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  return toObject;
}
function listFilesParametersToMldev(fromObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    listFilesConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function listFilesResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromFiles = getValueByPath(fromObject, ["files"]);
  if (fromFiles != null) {
    let transformedList = fromFiles;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["files"], transformedList);
  }
  return toObject;
}
function registerFilesResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromFiles = getValueByPath(fromObject, ["files"]);
  if (fromFiles != null) {
    let transformedList = fromFiles;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["files"], transformedList);
  }
  return toObject;
}
var Files5 = class extends BaseModule {
  constructor(apiClient) {
    super();
    this.apiClient = apiClient;
    this.list = async (params = {}) => {
      return new Pager(PagedItem.PAGED_ITEM_FILES, (x3) => this.listInternal(x3), await this.listInternal(params), params);
    };
  }
  /**
   * Uploads a file asynchronously to the Gemini API.
   * This method is not available in Vertex AI.
   * Supported upload sources:
   * - Node.js: File path (string) or Blob object.
   * - Browser: Blob object (e.g., File).
   *
   * @remarks
   * The `mimeType` can be specified in the `config` parameter. If omitted:
   *  - For file path (string) inputs, the `mimeType` will be inferred from the
   *     file extension.
   *  - For Blob object inputs, the `mimeType` will be set to the Blob's `type`
   *     property.
   * Somex eamples for file extension to mimeType mapping:
   * .txt -> text/plain
   * .json -> application/json
   * .jpg  -> image/jpeg
   * .png -> image/png
   * .mp3 -> audio/mpeg
   * .mp4 -> video/mp4
   *
   * This section can contain multiple paragraphs and code examples.
   *
   * @param params - Optional parameters specified in the
   *        `types.UploadFileParameters` interface.
   *         @see {@link types.UploadFileParameters#config} for the optional
   *         config in the parameters.
   * @return A promise that resolves to a `types.File` object.
   * @throws An error if called on a Vertex AI client.
   * @throws An error if the `mimeType` is not provided and can not be inferred,
   * the `mimeType` can be provided in the `params.config` parameter.
   * @throws An error occurs if a suitable upload location cannot be established.
   *
   * @example
   * The following code uploads a file to Gemini API.
   *
   * ```ts
   * const file = await ai.files.upload({file: 'file.txt', config: {
   *   mimeType: 'text/plain',
   * }});
   * console.log(file.name);
   * ```
   */
  async upload(params) {
    if (this.apiClient.isVertexAI()) {
      throw new Error("Vertex AI does not support uploading files. You can share files through a GCS bucket.");
    }
    return this.apiClient.uploadFile(params.file, params.config).then((resp) => {
      return resp;
    });
  }
  /**
   * Downloads a remotely stored file asynchronously to a location specified in
   * the `params` object. This method only works on Node environment, to
   * download files in the browser, use a browser compliant method like an <a>
   * tag.
   *
   * @param params - The parameters for the download request.
   *
   * @example
   * The following code downloads an example file named "files/mehozpxf877d" as
   * "file.txt".
   *
   * ```ts
   * await ai.files.download({file: file.name, downloadPath: 'file.txt'});
   * ```
   */
  async download(params) {
    await this.apiClient.downloadFile(params);
  }
  /**
   * Registers Google Cloud Storage files for use with the API.
   * This method is only available in Node.js environments.
   */
  async registerFiles(params) {
    throw new Error("registerFiles is only supported in Node.js environments.");
  }
  async _registerFiles(params) {
    return this.registerFilesInternal(params);
  }
  async listInternal(params) {
    var _a5, _b;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      throw new Error("This method is only supported by the Gemini Developer API.");
    } else {
      const body = listFilesParametersToMldev(params);
      path4 = formatMap("files", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = listFilesResponseFromMldev(apiResponse);
        const typedResp = new ListFilesResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
  async createInternal(params) {
    var _a5, _b;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      throw new Error("This method is only supported by the Gemini Developer API.");
    } else {
      const body = createFileParametersToMldev(params);
      path4 = formatMap("upload/v1beta/files", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = createFileResponseFromMldev(apiResponse);
        const typedResp = new CreateFileResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
  /**
   * Retrieves the file information from the service.
   *
   * @param params - The parameters for the get request
   * @return The Promise that resolves to the types.File object requested.
   *
   * @example
   * ```ts
   * const config: GetFileParameters = {
   *   name: fileName,
   * };
   * file = await ai.files.get(config);
   * console.log(file.name);
   * ```
   */
  async get(params) {
    var _a5, _b;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      throw new Error("This method is only supported by the Gemini Developer API.");
    } else {
      const body = getFileParametersToMldev(params);
      path4 = formatMap("files/{file}", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((resp) => {
        return resp;
      });
    }
  }
  /**
   * Deletes a remotely stored file.
   *
   * @param params - The parameters for the delete request.
   * @return The DeleteFileResponse, the response for the delete method.
   *
   * @example
   * The following code deletes an example file named "files/mehozpxf877d".
   *
   * ```ts
   * await ai.files.delete({name: file.name});
   * ```
   */
  async delete(params) {
    var _a5, _b;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      throw new Error("This method is only supported by the Gemini Developer API.");
    } else {
      const body = deleteFileParametersToMldev(params);
      path4 = formatMap("files/{file}", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "DELETE",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = deleteFileResponseFromMldev(apiResponse);
        const typedResp = new DeleteFileResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
  async registerFilesInternal(params) {
    var _a5, _b;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      throw new Error("This method is only supported by the Gemini Developer API.");
    } else {
      const body = internalRegisterFilesParametersToMldev(params);
      path4 = formatMap("files:register", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = registerFilesResponseFromMldev(apiResponse);
        const typedResp = new RegisterFilesResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
};
function blobToMldev$2(fromObject) {
  const toObject = {};
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function contentToMldev$2(fromObject) {
  const toObject = {};
  const fromParts = getValueByPath(fromObject, ["parts"]);
  if (fromParts != null) {
    let transformedList = fromParts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return partToMldev$2(item);
      });
    }
    setValueByPath(toObject, ["parts"], transformedList);
  }
  const fromRole = getValueByPath(fromObject, ["role"]);
  if (fromRole != null) {
    setValueByPath(toObject, ["role"], fromRole);
  }
  return toObject;
}
function fileDataToMldev$2(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
  if (fromFileUri != null) {
    setValueByPath(toObject, ["fileUri"], fromFileUri);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function functionCallToMldev$2(fromObject) {
  const toObject = {};
  const fromId = getValueByPath(fromObject, ["id"]);
  if (fromId != null) {
    setValueByPath(toObject, ["id"], fromId);
  }
  const fromArgs = getValueByPath(fromObject, ["args"]);
  if (fromArgs != null) {
    setValueByPath(toObject, ["args"], fromArgs);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  if (getValueByPath(fromObject, ["partialArgs"]) !== void 0) {
    throw new Error("partialArgs parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["willContinue"]) !== void 0) {
    throw new Error("willContinue parameter is not supported in Gemini API.");
  }
  return toObject;
}
function functionDeclarationToVertex$1(fromObject) {
  const toObject = {};
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromParameters = getValueByPath(fromObject, ["parameters"]);
  if (fromParameters != null) {
    setValueByPath(toObject, ["parameters"], fromParameters);
  }
  const fromParametersJsonSchema = getValueByPath(fromObject, [
    "parametersJsonSchema"
  ]);
  if (fromParametersJsonSchema != null) {
    setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
  }
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], fromResponse);
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  if (getValueByPath(fromObject, ["behavior"]) !== void 0) {
    throw new Error("behavior parameter is not supported in Vertex AI.");
  }
  return toObject;
}
function generationConfigToVertex$1(fromObject) {
  const toObject = {};
  const fromModelSelectionConfig = getValueByPath(fromObject, [
    "modelSelectionConfig"
  ]);
  if (fromModelSelectionConfig != null) {
    setValueByPath(toObject, ["modelConfig"], fromModelSelectionConfig);
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  const fromAudioTimestamp = getValueByPath(fromObject, [
    "audioTimestamp"
  ]);
  if (fromAudioTimestamp != null) {
    setValueByPath(toObject, ["audioTimestamp"], fromAudioTimestamp);
  }
  const fromCandidateCount = getValueByPath(fromObject, [
    "candidateCount"
  ]);
  if (fromCandidateCount != null) {
    setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
  }
  const fromEnableAffectiveDialog = getValueByPath(fromObject, [
    "enableAffectiveDialog"
  ]);
  if (fromEnableAffectiveDialog != null) {
    setValueByPath(toObject, ["enableAffectiveDialog"], fromEnableAffectiveDialog);
  }
  const fromFrequencyPenalty = getValueByPath(fromObject, [
    "frequencyPenalty"
  ]);
  if (fromFrequencyPenalty != null) {
    setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
  }
  const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
  if (fromLogprobs != null) {
    setValueByPath(toObject, ["logprobs"], fromLogprobs);
  }
  const fromMaxOutputTokens = getValueByPath(fromObject, [
    "maxOutputTokens"
  ]);
  if (fromMaxOutputTokens != null) {
    setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
  }
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (fromMediaResolution != null) {
    setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
  }
  const fromPresencePenalty = getValueByPath(fromObject, [
    "presencePenalty"
  ]);
  if (fromPresencePenalty != null) {
    setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
  }
  const fromResponseLogprobs = getValueByPath(fromObject, [
    "responseLogprobs"
  ]);
  if (fromResponseLogprobs != null) {
    setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
  }
  const fromResponseMimeType = getValueByPath(fromObject, [
    "responseMimeType"
  ]);
  if (fromResponseMimeType != null) {
    setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
  }
  const fromResponseModalities = getValueByPath(fromObject, [
    "responseModalities"
  ]);
  if (fromResponseModalities != null) {
    setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
  }
  const fromResponseSchema = getValueByPath(fromObject, [
    "responseSchema"
  ]);
  if (fromResponseSchema != null) {
    setValueByPath(toObject, ["responseSchema"], fromResponseSchema);
  }
  const fromRoutingConfig = getValueByPath(fromObject, [
    "routingConfig"
  ]);
  if (fromRoutingConfig != null) {
    setValueByPath(toObject, ["routingConfig"], fromRoutingConfig);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (fromSeed != null) {
    setValueByPath(toObject, ["seed"], fromSeed);
  }
  const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
  if (fromSpeechConfig != null) {
    setValueByPath(toObject, ["speechConfig"], fromSpeechConfig);
  }
  const fromStopSequences = getValueByPath(fromObject, [
    "stopSequences"
  ]);
  if (fromStopSequences != null) {
    setValueByPath(toObject, ["stopSequences"], fromStopSequences);
  }
  const fromTemperature = getValueByPath(fromObject, ["temperature"]);
  if (fromTemperature != null) {
    setValueByPath(toObject, ["temperature"], fromTemperature);
  }
  const fromThinkingConfig = getValueByPath(fromObject, [
    "thinkingConfig"
  ]);
  if (fromThinkingConfig != null) {
    setValueByPath(toObject, ["thinkingConfig"], fromThinkingConfig);
  }
  const fromTopK = getValueByPath(fromObject, ["topK"]);
  if (fromTopK != null) {
    setValueByPath(toObject, ["topK"], fromTopK);
  }
  const fromTopP = getValueByPath(fromObject, ["topP"]);
  if (fromTopP != null) {
    setValueByPath(toObject, ["topP"], fromTopP);
  }
  if (getValueByPath(fromObject, ["enableEnhancedCivicAnswers"]) !== void 0) {
    throw new Error("enableEnhancedCivicAnswers parameter is not supported in Vertex AI.");
  }
  return toObject;
}
function googleMapsToMldev$2(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["authConfig"]) !== void 0) {
    throw new Error("authConfig parameter is not supported in Gemini API.");
  }
  const fromEnableWidget = getValueByPath(fromObject, ["enableWidget"]);
  if (fromEnableWidget != null) {
    setValueByPath(toObject, ["enableWidget"], fromEnableWidget);
  }
  return toObject;
}
function googleSearchToMldev$2(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) {
    throw new Error("excludeDomains parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["blockingConfidence"]) !== void 0) {
    throw new Error("blockingConfidence parameter is not supported in Gemini API.");
  }
  const fromTimeRangeFilter = getValueByPath(fromObject, [
    "timeRangeFilter"
  ]);
  if (fromTimeRangeFilter != null) {
    setValueByPath(toObject, ["timeRangeFilter"], fromTimeRangeFilter);
  }
  return toObject;
}
function liveConnectConfigToMldev$1(fromObject, parentObject) {
  const toObject = {};
  const fromGenerationConfig = getValueByPath(fromObject, [
    "generationConfig"
  ]);
  if (parentObject !== void 0 && fromGenerationConfig != null) {
    setValueByPath(parentObject, ["setup", "generationConfig"], fromGenerationConfig);
  }
  const fromResponseModalities = getValueByPath(fromObject, [
    "responseModalities"
  ]);
  if (parentObject !== void 0 && fromResponseModalities != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "responseModalities"], fromResponseModalities);
  }
  const fromTemperature = getValueByPath(fromObject, ["temperature"]);
  if (parentObject !== void 0 && fromTemperature != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "temperature"], fromTemperature);
  }
  const fromTopP = getValueByPath(fromObject, ["topP"]);
  if (parentObject !== void 0 && fromTopP != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "topP"], fromTopP);
  }
  const fromTopK = getValueByPath(fromObject, ["topK"]);
  if (parentObject !== void 0 && fromTopK != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "topK"], fromTopK);
  }
  const fromMaxOutputTokens = getValueByPath(fromObject, [
    "maxOutputTokens"
  ]);
  if (parentObject !== void 0 && fromMaxOutputTokens != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "maxOutputTokens"], fromMaxOutputTokens);
  }
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (parentObject !== void 0 && fromMediaResolution != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "mediaResolution"], fromMediaResolution);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (parentObject !== void 0 && fromSeed != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "seed"], fromSeed);
  }
  const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
  if (parentObject !== void 0 && fromSpeechConfig != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "speechConfig"], tLiveSpeechConfig(fromSpeechConfig));
  }
  const fromThinkingConfig = getValueByPath(fromObject, [
    "thinkingConfig"
  ]);
  if (parentObject !== void 0 && fromThinkingConfig != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "thinkingConfig"], fromThinkingConfig);
  }
  const fromEnableAffectiveDialog = getValueByPath(fromObject, [
    "enableAffectiveDialog"
  ]);
  if (parentObject !== void 0 && fromEnableAffectiveDialog != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "enableAffectiveDialog"], fromEnableAffectiveDialog);
  }
  const fromSystemInstruction = getValueByPath(fromObject, [
    "systemInstruction"
  ]);
  if (parentObject !== void 0 && fromSystemInstruction != null) {
    setValueByPath(parentObject, ["setup", "systemInstruction"], contentToMldev$2(tContent(fromSystemInstruction)));
  }
  const fromTools = getValueByPath(fromObject, ["tools"]);
  if (parentObject !== void 0 && fromTools != null) {
    let transformedList = tTools(fromTools);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return toolToMldev$2(tTool(item));
      });
    }
    setValueByPath(parentObject, ["setup", "tools"], transformedList);
  }
  const fromSessionResumption = getValueByPath(fromObject, [
    "sessionResumption"
  ]);
  if (parentObject !== void 0 && fromSessionResumption != null) {
    setValueByPath(parentObject, ["setup", "sessionResumption"], sessionResumptionConfigToMldev$1(fromSessionResumption));
  }
  const fromInputAudioTranscription = getValueByPath(fromObject, [
    "inputAudioTranscription"
  ]);
  if (parentObject !== void 0 && fromInputAudioTranscription != null) {
    setValueByPath(parentObject, ["setup", "inputAudioTranscription"], fromInputAudioTranscription);
  }
  const fromOutputAudioTranscription = getValueByPath(fromObject, [
    "outputAudioTranscription"
  ]);
  if (parentObject !== void 0 && fromOutputAudioTranscription != null) {
    setValueByPath(parentObject, ["setup", "outputAudioTranscription"], fromOutputAudioTranscription);
  }
  const fromRealtimeInputConfig = getValueByPath(fromObject, [
    "realtimeInputConfig"
  ]);
  if (parentObject !== void 0 && fromRealtimeInputConfig != null) {
    setValueByPath(parentObject, ["setup", "realtimeInputConfig"], fromRealtimeInputConfig);
  }
  const fromContextWindowCompression = getValueByPath(fromObject, [
    "contextWindowCompression"
  ]);
  if (parentObject !== void 0 && fromContextWindowCompression != null) {
    setValueByPath(parentObject, ["setup", "contextWindowCompression"], fromContextWindowCompression);
  }
  const fromProactivity = getValueByPath(fromObject, ["proactivity"]);
  if (parentObject !== void 0 && fromProactivity != null) {
    setValueByPath(parentObject, ["setup", "proactivity"], fromProactivity);
  }
  if (getValueByPath(fromObject, ["explicitVadSignal"]) !== void 0) {
    throw new Error("explicitVadSignal parameter is not supported in Gemini API.");
  }
  return toObject;
}
function liveConnectConfigToVertex(fromObject, parentObject) {
  const toObject = {};
  const fromGenerationConfig = getValueByPath(fromObject, [
    "generationConfig"
  ]);
  if (parentObject !== void 0 && fromGenerationConfig != null) {
    setValueByPath(parentObject, ["setup", "generationConfig"], generationConfigToVertex$1(fromGenerationConfig));
  }
  const fromResponseModalities = getValueByPath(fromObject, [
    "responseModalities"
  ]);
  if (parentObject !== void 0 && fromResponseModalities != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "responseModalities"], fromResponseModalities);
  }
  const fromTemperature = getValueByPath(fromObject, ["temperature"]);
  if (parentObject !== void 0 && fromTemperature != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "temperature"], fromTemperature);
  }
  const fromTopP = getValueByPath(fromObject, ["topP"]);
  if (parentObject !== void 0 && fromTopP != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "topP"], fromTopP);
  }
  const fromTopK = getValueByPath(fromObject, ["topK"]);
  if (parentObject !== void 0 && fromTopK != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "topK"], fromTopK);
  }
  const fromMaxOutputTokens = getValueByPath(fromObject, [
    "maxOutputTokens"
  ]);
  if (parentObject !== void 0 && fromMaxOutputTokens != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "maxOutputTokens"], fromMaxOutputTokens);
  }
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (parentObject !== void 0 && fromMediaResolution != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "mediaResolution"], fromMediaResolution);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (parentObject !== void 0 && fromSeed != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "seed"], fromSeed);
  }
  const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
  if (parentObject !== void 0 && fromSpeechConfig != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "speechConfig"], tLiveSpeechConfig(fromSpeechConfig));
  }
  const fromThinkingConfig = getValueByPath(fromObject, [
    "thinkingConfig"
  ]);
  if (parentObject !== void 0 && fromThinkingConfig != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "thinkingConfig"], fromThinkingConfig);
  }
  const fromEnableAffectiveDialog = getValueByPath(fromObject, [
    "enableAffectiveDialog"
  ]);
  if (parentObject !== void 0 && fromEnableAffectiveDialog != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "enableAffectiveDialog"], fromEnableAffectiveDialog);
  }
  const fromSystemInstruction = getValueByPath(fromObject, [
    "systemInstruction"
  ]);
  if (parentObject !== void 0 && fromSystemInstruction != null) {
    setValueByPath(parentObject, ["setup", "systemInstruction"], tContent(fromSystemInstruction));
  }
  const fromTools = getValueByPath(fromObject, ["tools"]);
  if (parentObject !== void 0 && fromTools != null) {
    let transformedList = tTools(fromTools);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return toolToVertex$1(tTool(item));
      });
    }
    setValueByPath(parentObject, ["setup", "tools"], transformedList);
  }
  const fromSessionResumption = getValueByPath(fromObject, [
    "sessionResumption"
  ]);
  if (parentObject !== void 0 && fromSessionResumption != null) {
    setValueByPath(parentObject, ["setup", "sessionResumption"], fromSessionResumption);
  }
  const fromInputAudioTranscription = getValueByPath(fromObject, [
    "inputAudioTranscription"
  ]);
  if (parentObject !== void 0 && fromInputAudioTranscription != null) {
    setValueByPath(parentObject, ["setup", "inputAudioTranscription"], fromInputAudioTranscription);
  }
  const fromOutputAudioTranscription = getValueByPath(fromObject, [
    "outputAudioTranscription"
  ]);
  if (parentObject !== void 0 && fromOutputAudioTranscription != null) {
    setValueByPath(parentObject, ["setup", "outputAudioTranscription"], fromOutputAudioTranscription);
  }
  const fromRealtimeInputConfig = getValueByPath(fromObject, [
    "realtimeInputConfig"
  ]);
  if (parentObject !== void 0 && fromRealtimeInputConfig != null) {
    setValueByPath(parentObject, ["setup", "realtimeInputConfig"], fromRealtimeInputConfig);
  }
  const fromContextWindowCompression = getValueByPath(fromObject, [
    "contextWindowCompression"
  ]);
  if (parentObject !== void 0 && fromContextWindowCompression != null) {
    setValueByPath(parentObject, ["setup", "contextWindowCompression"], fromContextWindowCompression);
  }
  const fromProactivity = getValueByPath(fromObject, ["proactivity"]);
  if (parentObject !== void 0 && fromProactivity != null) {
    setValueByPath(parentObject, ["setup", "proactivity"], fromProactivity);
  }
  const fromExplicitVadSignal = getValueByPath(fromObject, [
    "explicitVadSignal"
  ]);
  if (parentObject !== void 0 && fromExplicitVadSignal != null) {
    setValueByPath(parentObject, ["setup", "explicitVadSignal"], fromExplicitVadSignal);
  }
  return toObject;
}
function liveConnectParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["setup", "model"], tModel(apiClient, fromModel));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], liveConnectConfigToMldev$1(fromConfig, toObject));
  }
  return toObject;
}
function liveConnectParametersToVertex(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["setup", "model"], tModel(apiClient, fromModel));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], liveConnectConfigToVertex(fromConfig, toObject));
  }
  return toObject;
}
function liveMusicSetConfigParametersToMldev(fromObject) {
  const toObject = {};
  const fromMusicGenerationConfig = getValueByPath(fromObject, [
    "musicGenerationConfig"
  ]);
  if (fromMusicGenerationConfig != null) {
    setValueByPath(toObject, ["musicGenerationConfig"], fromMusicGenerationConfig);
  }
  return toObject;
}
function liveMusicSetWeightedPromptsParametersToMldev(fromObject) {
  const toObject = {};
  const fromWeightedPrompts = getValueByPath(fromObject, [
    "weightedPrompts"
  ]);
  if (fromWeightedPrompts != null) {
    let transformedList = fromWeightedPrompts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["weightedPrompts"], transformedList);
  }
  return toObject;
}
function liveSendRealtimeInputParametersToMldev(fromObject) {
  const toObject = {};
  const fromMedia = getValueByPath(fromObject, ["media"]);
  if (fromMedia != null) {
    let transformedList = tBlobs(fromMedia);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return blobToMldev$2(item);
      });
    }
    setValueByPath(toObject, ["mediaChunks"], transformedList);
  }
  const fromAudio = getValueByPath(fromObject, ["audio"]);
  if (fromAudio != null) {
    setValueByPath(toObject, ["audio"], blobToMldev$2(tAudioBlob(fromAudio)));
  }
  const fromAudioStreamEnd = getValueByPath(fromObject, [
    "audioStreamEnd"
  ]);
  if (fromAudioStreamEnd != null) {
    setValueByPath(toObject, ["audioStreamEnd"], fromAudioStreamEnd);
  }
  const fromVideo = getValueByPath(fromObject, ["video"]);
  if (fromVideo != null) {
    setValueByPath(toObject, ["video"], blobToMldev$2(tImageBlob(fromVideo)));
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  const fromActivityStart = getValueByPath(fromObject, [
    "activityStart"
  ]);
  if (fromActivityStart != null) {
    setValueByPath(toObject, ["activityStart"], fromActivityStart);
  }
  const fromActivityEnd = getValueByPath(fromObject, ["activityEnd"]);
  if (fromActivityEnd != null) {
    setValueByPath(toObject, ["activityEnd"], fromActivityEnd);
  }
  return toObject;
}
function liveSendRealtimeInputParametersToVertex(fromObject) {
  const toObject = {};
  const fromMedia = getValueByPath(fromObject, ["media"]);
  if (fromMedia != null) {
    let transformedList = tBlobs(fromMedia);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["mediaChunks"], transformedList);
  }
  const fromAudio = getValueByPath(fromObject, ["audio"]);
  if (fromAudio != null) {
    setValueByPath(toObject, ["audio"], tAudioBlob(fromAudio));
  }
  const fromAudioStreamEnd = getValueByPath(fromObject, [
    "audioStreamEnd"
  ]);
  if (fromAudioStreamEnd != null) {
    setValueByPath(toObject, ["audioStreamEnd"], fromAudioStreamEnd);
  }
  const fromVideo = getValueByPath(fromObject, ["video"]);
  if (fromVideo != null) {
    setValueByPath(toObject, ["video"], tImageBlob(fromVideo));
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  const fromActivityStart = getValueByPath(fromObject, [
    "activityStart"
  ]);
  if (fromActivityStart != null) {
    setValueByPath(toObject, ["activityStart"], fromActivityStart);
  }
  const fromActivityEnd = getValueByPath(fromObject, ["activityEnd"]);
  if (fromActivityEnd != null) {
    setValueByPath(toObject, ["activityEnd"], fromActivityEnd);
  }
  return toObject;
}
function liveServerMessageFromVertex(fromObject) {
  const toObject = {};
  const fromSetupComplete = getValueByPath(fromObject, [
    "setupComplete"
  ]);
  if (fromSetupComplete != null) {
    setValueByPath(toObject, ["setupComplete"], fromSetupComplete);
  }
  const fromServerContent = getValueByPath(fromObject, [
    "serverContent"
  ]);
  if (fromServerContent != null) {
    setValueByPath(toObject, ["serverContent"], fromServerContent);
  }
  const fromToolCall = getValueByPath(fromObject, ["toolCall"]);
  if (fromToolCall != null) {
    setValueByPath(toObject, ["toolCall"], fromToolCall);
  }
  const fromToolCallCancellation = getValueByPath(fromObject, [
    "toolCallCancellation"
  ]);
  if (fromToolCallCancellation != null) {
    setValueByPath(toObject, ["toolCallCancellation"], fromToolCallCancellation);
  }
  const fromUsageMetadata = getValueByPath(fromObject, [
    "usageMetadata"
  ]);
  if (fromUsageMetadata != null) {
    setValueByPath(toObject, ["usageMetadata"], usageMetadataFromVertex(fromUsageMetadata));
  }
  const fromGoAway = getValueByPath(fromObject, ["goAway"]);
  if (fromGoAway != null) {
    setValueByPath(toObject, ["goAway"], fromGoAway);
  }
  const fromSessionResumptionUpdate = getValueByPath(fromObject, [
    "sessionResumptionUpdate"
  ]);
  if (fromSessionResumptionUpdate != null) {
    setValueByPath(toObject, ["sessionResumptionUpdate"], fromSessionResumptionUpdate);
  }
  const fromVoiceActivityDetectionSignal = getValueByPath(fromObject, [
    "voiceActivityDetectionSignal"
  ]);
  if (fromVoiceActivityDetectionSignal != null) {
    setValueByPath(toObject, ["voiceActivityDetectionSignal"], fromVoiceActivityDetectionSignal);
  }
  const fromVoiceActivity = getValueByPath(fromObject, [
    "voiceActivity"
  ]);
  if (fromVoiceActivity != null) {
    setValueByPath(toObject, ["voiceActivity"], voiceActivityFromVertex(fromVoiceActivity));
  }
  return toObject;
}
function partToMldev$2(fromObject) {
  const toObject = {};
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (fromMediaResolution != null) {
    setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
  }
  const fromCodeExecutionResult = getValueByPath(fromObject, [
    "codeExecutionResult"
  ]);
  if (fromCodeExecutionResult != null) {
    setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
  }
  const fromExecutableCode = getValueByPath(fromObject, [
    "executableCode"
  ]);
  if (fromExecutableCode != null) {
    setValueByPath(toObject, ["executableCode"], fromExecutableCode);
  }
  const fromFileData = getValueByPath(fromObject, ["fileData"]);
  if (fromFileData != null) {
    setValueByPath(toObject, ["fileData"], fileDataToMldev$2(fromFileData));
  }
  const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
  if (fromFunctionCall != null) {
    setValueByPath(toObject, ["functionCall"], functionCallToMldev$2(fromFunctionCall));
  }
  const fromFunctionResponse = getValueByPath(fromObject, [
    "functionResponse"
  ]);
  if (fromFunctionResponse != null) {
    setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
  }
  const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
  if (fromInlineData != null) {
    setValueByPath(toObject, ["inlineData"], blobToMldev$2(fromInlineData));
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  const fromThought = getValueByPath(fromObject, ["thought"]);
  if (fromThought != null) {
    setValueByPath(toObject, ["thought"], fromThought);
  }
  const fromThoughtSignature = getValueByPath(fromObject, [
    "thoughtSignature"
  ]);
  if (fromThoughtSignature != null) {
    setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
  }
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
  }
  return toObject;
}
function sessionResumptionConfigToMldev$1(fromObject) {
  const toObject = {};
  const fromHandle = getValueByPath(fromObject, ["handle"]);
  if (fromHandle != null) {
    setValueByPath(toObject, ["handle"], fromHandle);
  }
  if (getValueByPath(fromObject, ["transparent"]) !== void 0) {
    throw new Error("transparent parameter is not supported in Gemini API.");
  }
  return toObject;
}
function toolToMldev$2(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
    throw new Error("retrieval parameter is not supported in Gemini API.");
  }
  const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
  if (fromComputerUse != null) {
    setValueByPath(toObject, ["computerUse"], fromComputerUse);
  }
  const fromFileSearch = getValueByPath(fromObject, ["fileSearch"]);
  if (fromFileSearch != null) {
    setValueByPath(toObject, ["fileSearch"], fromFileSearch);
  }
  const fromCodeExecution = getValueByPath(fromObject, [
    "codeExecution"
  ]);
  if (fromCodeExecution != null) {
    setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
  }
  if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
    throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
  }
  const fromFunctionDeclarations = getValueByPath(fromObject, [
    "functionDeclarations"
  ]);
  if (fromFunctionDeclarations != null) {
    let transformedList = fromFunctionDeclarations;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["functionDeclarations"], transformedList);
  }
  const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
  if (fromGoogleMaps != null) {
    setValueByPath(toObject, ["googleMaps"], googleMapsToMldev$2(fromGoogleMaps));
  }
  const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
  if (fromGoogleSearch != null) {
    setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$2(fromGoogleSearch));
  }
  const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
    "googleSearchRetrieval"
  ]);
  if (fromGoogleSearchRetrieval != null) {
    setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
  }
  const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
  if (fromUrlContext != null) {
    setValueByPath(toObject, ["urlContext"], fromUrlContext);
  }
  return toObject;
}
function toolToVertex$1(fromObject) {
  const toObject = {};
  const fromRetrieval = getValueByPath(fromObject, ["retrieval"]);
  if (fromRetrieval != null) {
    setValueByPath(toObject, ["retrieval"], fromRetrieval);
  }
  const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
  if (fromComputerUse != null) {
    setValueByPath(toObject, ["computerUse"], fromComputerUse);
  }
  if (getValueByPath(fromObject, ["fileSearch"]) !== void 0) {
    throw new Error("fileSearch parameter is not supported in Vertex AI.");
  }
  const fromCodeExecution = getValueByPath(fromObject, [
    "codeExecution"
  ]);
  if (fromCodeExecution != null) {
    setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
  }
  const fromEnterpriseWebSearch = getValueByPath(fromObject, [
    "enterpriseWebSearch"
  ]);
  if (fromEnterpriseWebSearch != null) {
    setValueByPath(toObject, ["enterpriseWebSearch"], fromEnterpriseWebSearch);
  }
  const fromFunctionDeclarations = getValueByPath(fromObject, [
    "functionDeclarations"
  ]);
  if (fromFunctionDeclarations != null) {
    let transformedList = fromFunctionDeclarations;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return functionDeclarationToVertex$1(item);
      });
    }
    setValueByPath(toObject, ["functionDeclarations"], transformedList);
  }
  const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
  if (fromGoogleMaps != null) {
    setValueByPath(toObject, ["googleMaps"], fromGoogleMaps);
  }
  const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
  if (fromGoogleSearch != null) {
    setValueByPath(toObject, ["googleSearch"], fromGoogleSearch);
  }
  const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
    "googleSearchRetrieval"
  ]);
  if (fromGoogleSearchRetrieval != null) {
    setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
  }
  const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
  if (fromUrlContext != null) {
    setValueByPath(toObject, ["urlContext"], fromUrlContext);
  }
  return toObject;
}
function usageMetadataFromVertex(fromObject) {
  const toObject = {};
  const fromPromptTokenCount = getValueByPath(fromObject, [
    "promptTokenCount"
  ]);
  if (fromPromptTokenCount != null) {
    setValueByPath(toObject, ["promptTokenCount"], fromPromptTokenCount);
  }
  const fromCachedContentTokenCount = getValueByPath(fromObject, [
    "cachedContentTokenCount"
  ]);
  if (fromCachedContentTokenCount != null) {
    setValueByPath(toObject, ["cachedContentTokenCount"], fromCachedContentTokenCount);
  }
  const fromResponseTokenCount = getValueByPath(fromObject, [
    "candidatesTokenCount"
  ]);
  if (fromResponseTokenCount != null) {
    setValueByPath(toObject, ["responseTokenCount"], fromResponseTokenCount);
  }
  const fromToolUsePromptTokenCount = getValueByPath(fromObject, [
    "toolUsePromptTokenCount"
  ]);
  if (fromToolUsePromptTokenCount != null) {
    setValueByPath(toObject, ["toolUsePromptTokenCount"], fromToolUsePromptTokenCount);
  }
  const fromThoughtsTokenCount = getValueByPath(fromObject, [
    "thoughtsTokenCount"
  ]);
  if (fromThoughtsTokenCount != null) {
    setValueByPath(toObject, ["thoughtsTokenCount"], fromThoughtsTokenCount);
  }
  const fromTotalTokenCount = getValueByPath(fromObject, [
    "totalTokenCount"
  ]);
  if (fromTotalTokenCount != null) {
    setValueByPath(toObject, ["totalTokenCount"], fromTotalTokenCount);
  }
  const fromPromptTokensDetails = getValueByPath(fromObject, [
    "promptTokensDetails"
  ]);
  if (fromPromptTokensDetails != null) {
    let transformedList = fromPromptTokensDetails;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["promptTokensDetails"], transformedList);
  }
  const fromCacheTokensDetails = getValueByPath(fromObject, [
    "cacheTokensDetails"
  ]);
  if (fromCacheTokensDetails != null) {
    let transformedList = fromCacheTokensDetails;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["cacheTokensDetails"], transformedList);
  }
  const fromResponseTokensDetails = getValueByPath(fromObject, [
    "candidatesTokensDetails"
  ]);
  if (fromResponseTokensDetails != null) {
    let transformedList = fromResponseTokensDetails;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["responseTokensDetails"], transformedList);
  }
  const fromToolUsePromptTokensDetails = getValueByPath(fromObject, [
    "toolUsePromptTokensDetails"
  ]);
  if (fromToolUsePromptTokensDetails != null) {
    let transformedList = fromToolUsePromptTokensDetails;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["toolUsePromptTokensDetails"], transformedList);
  }
  const fromTrafficType = getValueByPath(fromObject, ["trafficType"]);
  if (fromTrafficType != null) {
    setValueByPath(toObject, ["trafficType"], fromTrafficType);
  }
  return toObject;
}
function voiceActivityFromVertex(fromObject) {
  const toObject = {};
  const fromVoiceActivityType = getValueByPath(fromObject, ["type"]);
  if (fromVoiceActivityType != null) {
    setValueByPath(toObject, ["voiceActivityType"], fromVoiceActivityType);
  }
  return toObject;
}
function blobToMldev$1(fromObject, _rootObject) {
  const toObject = {};
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function candidateFromMldev(fromObject, rootObject) {
  const toObject = {};
  const fromContent = getValueByPath(fromObject, ["content"]);
  if (fromContent != null) {
    setValueByPath(toObject, ["content"], fromContent);
  }
  const fromCitationMetadata = getValueByPath(fromObject, [
    "citationMetadata"
  ]);
  if (fromCitationMetadata != null) {
    setValueByPath(toObject, ["citationMetadata"], citationMetadataFromMldev(fromCitationMetadata));
  }
  const fromTokenCount = getValueByPath(fromObject, ["tokenCount"]);
  if (fromTokenCount != null) {
    setValueByPath(toObject, ["tokenCount"], fromTokenCount);
  }
  const fromFinishReason = getValueByPath(fromObject, ["finishReason"]);
  if (fromFinishReason != null) {
    setValueByPath(toObject, ["finishReason"], fromFinishReason);
  }
  const fromAvgLogprobs = getValueByPath(fromObject, ["avgLogprobs"]);
  if (fromAvgLogprobs != null) {
    setValueByPath(toObject, ["avgLogprobs"], fromAvgLogprobs);
  }
  const fromGroundingMetadata = getValueByPath(fromObject, [
    "groundingMetadata"
  ]);
  if (fromGroundingMetadata != null) {
    setValueByPath(toObject, ["groundingMetadata"], fromGroundingMetadata);
  }
  const fromIndex = getValueByPath(fromObject, ["index"]);
  if (fromIndex != null) {
    setValueByPath(toObject, ["index"], fromIndex);
  }
  const fromLogprobsResult = getValueByPath(fromObject, [
    "logprobsResult"
  ]);
  if (fromLogprobsResult != null) {
    setValueByPath(toObject, ["logprobsResult"], fromLogprobsResult);
  }
  const fromSafetyRatings = getValueByPath(fromObject, [
    "safetyRatings"
  ]);
  if (fromSafetyRatings != null) {
    let transformedList = fromSafetyRatings;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["safetyRatings"], transformedList);
  }
  const fromUrlContextMetadata = getValueByPath(fromObject, [
    "urlContextMetadata"
  ]);
  if (fromUrlContextMetadata != null) {
    setValueByPath(toObject, ["urlContextMetadata"], fromUrlContextMetadata);
  }
  return toObject;
}
function citationMetadataFromMldev(fromObject, _rootObject) {
  const toObject = {};
  const fromCitations = getValueByPath(fromObject, ["citationSources"]);
  if (fromCitations != null) {
    let transformedList = fromCitations;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["citations"], transformedList);
  }
  return toObject;
}
function computeTokensParametersToVertex(apiClient, fromObject, _rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (fromContents != null) {
    let transformedList = tContents(fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["contents"], transformedList);
  }
  return toObject;
}
function computeTokensResponseFromVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromTokensInfo = getValueByPath(fromObject, ["tokensInfo"]);
  if (fromTokensInfo != null) {
    let transformedList = fromTokensInfo;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["tokensInfo"], transformedList);
  }
  return toObject;
}
function contentEmbeddingFromVertex(fromObject, rootObject) {
  const toObject = {};
  const fromValues = getValueByPath(fromObject, ["values"]);
  if (fromValues != null) {
    setValueByPath(toObject, ["values"], fromValues);
  }
  const fromStatistics = getValueByPath(fromObject, ["statistics"]);
  if (fromStatistics != null) {
    setValueByPath(toObject, ["statistics"], contentEmbeddingStatisticsFromVertex(fromStatistics));
  }
  return toObject;
}
function contentEmbeddingStatisticsFromVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromTruncated = getValueByPath(fromObject, ["truncated"]);
  if (fromTruncated != null) {
    setValueByPath(toObject, ["truncated"], fromTruncated);
  }
  const fromTokenCount = getValueByPath(fromObject, ["token_count"]);
  if (fromTokenCount != null) {
    setValueByPath(toObject, ["tokenCount"], fromTokenCount);
  }
  return toObject;
}
function contentToMldev$1(fromObject, rootObject) {
  const toObject = {};
  const fromParts = getValueByPath(fromObject, ["parts"]);
  if (fromParts != null) {
    let transformedList = fromParts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return partToMldev$1(item);
      });
    }
    setValueByPath(toObject, ["parts"], transformedList);
  }
  const fromRole = getValueByPath(fromObject, ["role"]);
  if (fromRole != null) {
    setValueByPath(toObject, ["role"], fromRole);
  }
  return toObject;
}
function controlReferenceConfigToVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromControlType = getValueByPath(fromObject, ["controlType"]);
  if (fromControlType != null) {
    setValueByPath(toObject, ["controlType"], fromControlType);
  }
  const fromEnableControlImageComputation = getValueByPath(fromObject, [
    "enableControlImageComputation"
  ]);
  if (fromEnableControlImageComputation != null) {
    setValueByPath(toObject, ["computeControl"], fromEnableControlImageComputation);
  }
  return toObject;
}
function countTokensConfigToMldev(fromObject, _rootObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["systemInstruction"]) !== void 0) {
    throw new Error("systemInstruction parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["tools"]) !== void 0) {
    throw new Error("tools parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["generationConfig"]) !== void 0) {
    throw new Error("generationConfig parameter is not supported in Gemini API.");
  }
  return toObject;
}
function countTokensConfigToVertex(fromObject, parentObject, rootObject) {
  const toObject = {};
  const fromSystemInstruction = getValueByPath(fromObject, [
    "systemInstruction"
  ]);
  if (parentObject !== void 0 && fromSystemInstruction != null) {
    setValueByPath(parentObject, ["systemInstruction"], tContent(fromSystemInstruction));
  }
  const fromTools = getValueByPath(fromObject, ["tools"]);
  if (parentObject !== void 0 && fromTools != null) {
    let transformedList = fromTools;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return toolToVertex(item);
      });
    }
    setValueByPath(parentObject, ["tools"], transformedList);
  }
  const fromGenerationConfig = getValueByPath(fromObject, [
    "generationConfig"
  ]);
  if (parentObject !== void 0 && fromGenerationConfig != null) {
    setValueByPath(parentObject, ["generationConfig"], generationConfigToVertex(fromGenerationConfig));
  }
  return toObject;
}
function countTokensParametersToMldev(apiClient, fromObject, rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (fromContents != null) {
    let transformedList = tContents(fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return contentToMldev$1(item);
      });
    }
    setValueByPath(toObject, ["contents"], transformedList);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    countTokensConfigToMldev(fromConfig);
  }
  return toObject;
}
function countTokensParametersToVertex(apiClient, fromObject, rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (fromContents != null) {
    let transformedList = tContents(fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["contents"], transformedList);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    countTokensConfigToVertex(fromConfig, toObject);
  }
  return toObject;
}
function countTokensResponseFromMldev(fromObject, _rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromTotalTokens = getValueByPath(fromObject, ["totalTokens"]);
  if (fromTotalTokens != null) {
    setValueByPath(toObject, ["totalTokens"], fromTotalTokens);
  }
  const fromCachedContentTokenCount = getValueByPath(fromObject, [
    "cachedContentTokenCount"
  ]);
  if (fromCachedContentTokenCount != null) {
    setValueByPath(toObject, ["cachedContentTokenCount"], fromCachedContentTokenCount);
  }
  return toObject;
}
function countTokensResponseFromVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromTotalTokens = getValueByPath(fromObject, ["totalTokens"]);
  if (fromTotalTokens != null) {
    setValueByPath(toObject, ["totalTokens"], fromTotalTokens);
  }
  return toObject;
}
function deleteModelParametersToMldev(apiClient, fromObject, _rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
  }
  return toObject;
}
function deleteModelParametersToVertex(apiClient, fromObject, _rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
  }
  return toObject;
}
function deleteModelResponseFromMldev(fromObject, _rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  return toObject;
}
function deleteModelResponseFromVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  return toObject;
}
function editImageConfigToVertex(fromObject, parentObject, _rootObject) {
  const toObject = {};
  const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
  if (parentObject !== void 0 && fromOutputGcsUri != null) {
    setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
  }
  const fromNegativePrompt = getValueByPath(fromObject, [
    "negativePrompt"
  ]);
  if (parentObject !== void 0 && fromNegativePrompt != null) {
    setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
  }
  const fromNumberOfImages = getValueByPath(fromObject, [
    "numberOfImages"
  ]);
  if (parentObject !== void 0 && fromNumberOfImages != null) {
    setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
  }
  const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
  if (parentObject !== void 0 && fromAspectRatio != null) {
    setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
  }
  const fromGuidanceScale = getValueByPath(fromObject, [
    "guidanceScale"
  ]);
  if (parentObject !== void 0 && fromGuidanceScale != null) {
    setValueByPath(parentObject, ["parameters", "guidanceScale"], fromGuidanceScale);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (parentObject !== void 0 && fromSeed != null) {
    setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
  }
  const fromSafetyFilterLevel = getValueByPath(fromObject, [
    "safetyFilterLevel"
  ]);
  if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
    setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
  }
  const fromPersonGeneration = getValueByPath(fromObject, [
    "personGeneration"
  ]);
  if (parentObject !== void 0 && fromPersonGeneration != null) {
    setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
  }
  const fromIncludeSafetyAttributes = getValueByPath(fromObject, [
    "includeSafetyAttributes"
  ]);
  if (parentObject !== void 0 && fromIncludeSafetyAttributes != null) {
    setValueByPath(parentObject, ["parameters", "includeSafetyAttributes"], fromIncludeSafetyAttributes);
  }
  const fromIncludeRaiReason = getValueByPath(fromObject, [
    "includeRaiReason"
  ]);
  if (parentObject !== void 0 && fromIncludeRaiReason != null) {
    setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
  }
  const fromLanguage = getValueByPath(fromObject, ["language"]);
  if (parentObject !== void 0 && fromLanguage != null) {
    setValueByPath(parentObject, ["parameters", "language"], fromLanguage);
  }
  const fromOutputMimeType = getValueByPath(fromObject, [
    "outputMimeType"
  ]);
  if (parentObject !== void 0 && fromOutputMimeType != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
  }
  const fromOutputCompressionQuality = getValueByPath(fromObject, [
    "outputCompressionQuality"
  ]);
  if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
  }
  const fromAddWatermark = getValueByPath(fromObject, ["addWatermark"]);
  if (parentObject !== void 0 && fromAddWatermark != null) {
    setValueByPath(parentObject, ["parameters", "addWatermark"], fromAddWatermark);
  }
  const fromLabels = getValueByPath(fromObject, ["labels"]);
  if (parentObject !== void 0 && fromLabels != null) {
    setValueByPath(parentObject, ["labels"], fromLabels);
  }
  const fromEditMode = getValueByPath(fromObject, ["editMode"]);
  if (parentObject !== void 0 && fromEditMode != null) {
    setValueByPath(parentObject, ["parameters", "editMode"], fromEditMode);
  }
  const fromBaseSteps = getValueByPath(fromObject, ["baseSteps"]);
  if (parentObject !== void 0 && fromBaseSteps != null) {
    setValueByPath(parentObject, ["parameters", "editConfig", "baseSteps"], fromBaseSteps);
  }
  return toObject;
}
function editImageParametersInternalToVertex(apiClient, fromObject, rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromPrompt = getValueByPath(fromObject, ["prompt"]);
  if (fromPrompt != null) {
    setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
  }
  const fromReferenceImages = getValueByPath(fromObject, [
    "referenceImages"
  ]);
  if (fromReferenceImages != null) {
    let transformedList = fromReferenceImages;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return referenceImageAPIInternalToVertex(item);
      });
    }
    setValueByPath(toObject, ["instances[0]", "referenceImages"], transformedList);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    editImageConfigToVertex(fromConfig, toObject);
  }
  return toObject;
}
function editImageResponseFromVertex(fromObject, rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromGeneratedImages = getValueByPath(fromObject, [
    "predictions"
  ]);
  if (fromGeneratedImages != null) {
    let transformedList = fromGeneratedImages;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return generatedImageFromVertex(item);
      });
    }
    setValueByPath(toObject, ["generatedImages"], transformedList);
  }
  return toObject;
}
function embedContentConfigToMldev(fromObject, parentObject, _rootObject) {
  const toObject = {};
  const fromTaskType = getValueByPath(fromObject, ["taskType"]);
  if (parentObject !== void 0 && fromTaskType != null) {
    setValueByPath(parentObject, ["requests[]", "taskType"], fromTaskType);
  }
  const fromTitle = getValueByPath(fromObject, ["title"]);
  if (parentObject !== void 0 && fromTitle != null) {
    setValueByPath(parentObject, ["requests[]", "title"], fromTitle);
  }
  const fromOutputDimensionality = getValueByPath(fromObject, [
    "outputDimensionality"
  ]);
  if (parentObject !== void 0 && fromOutputDimensionality != null) {
    setValueByPath(parentObject, ["requests[]", "outputDimensionality"], fromOutputDimensionality);
  }
  if (getValueByPath(fromObject, ["mimeType"]) !== void 0) {
    throw new Error("mimeType parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["autoTruncate"]) !== void 0) {
    throw new Error("autoTruncate parameter is not supported in Gemini API.");
  }
  return toObject;
}
function embedContentConfigToVertex(fromObject, parentObject, _rootObject) {
  const toObject = {};
  const fromTaskType = getValueByPath(fromObject, ["taskType"]);
  if (parentObject !== void 0 && fromTaskType != null) {
    setValueByPath(parentObject, ["instances[]", "task_type"], fromTaskType);
  }
  const fromTitle = getValueByPath(fromObject, ["title"]);
  if (parentObject !== void 0 && fromTitle != null) {
    setValueByPath(parentObject, ["instances[]", "title"], fromTitle);
  }
  const fromOutputDimensionality = getValueByPath(fromObject, [
    "outputDimensionality"
  ]);
  if (parentObject !== void 0 && fromOutputDimensionality != null) {
    setValueByPath(parentObject, ["parameters", "outputDimensionality"], fromOutputDimensionality);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (parentObject !== void 0 && fromMimeType != null) {
    setValueByPath(parentObject, ["instances[]", "mimeType"], fromMimeType);
  }
  const fromAutoTruncate = getValueByPath(fromObject, ["autoTruncate"]);
  if (parentObject !== void 0 && fromAutoTruncate != null) {
    setValueByPath(parentObject, ["parameters", "autoTruncate"], fromAutoTruncate);
  }
  return toObject;
}
function embedContentParametersToMldev(apiClient, fromObject, rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (fromContents != null) {
    let transformedList = tContentsForEmbed(apiClient, fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["requests[]", "content"], transformedList);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    embedContentConfigToMldev(fromConfig, toObject);
  }
  const fromModelForEmbedContent = getValueByPath(fromObject, ["model"]);
  if (fromModelForEmbedContent !== void 0) {
    setValueByPath(toObject, ["requests[]", "model"], tModel(apiClient, fromModelForEmbedContent));
  }
  return toObject;
}
function embedContentParametersToVertex(apiClient, fromObject, rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (fromContents != null) {
    let transformedList = tContentsForEmbed(apiClient, fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["instances[]", "content"], transformedList);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    embedContentConfigToVertex(fromConfig, toObject);
  }
  return toObject;
}
function embedContentResponseFromMldev(fromObject, _rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromEmbeddings = getValueByPath(fromObject, ["embeddings"]);
  if (fromEmbeddings != null) {
    let transformedList = fromEmbeddings;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["embeddings"], transformedList);
  }
  const fromMetadata = getValueByPath(fromObject, ["metadata"]);
  if (fromMetadata != null) {
    setValueByPath(toObject, ["metadata"], fromMetadata);
  }
  return toObject;
}
function embedContentResponseFromVertex(fromObject, rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromEmbeddings = getValueByPath(fromObject, [
    "predictions[]",
    "embeddings"
  ]);
  if (fromEmbeddings != null) {
    let transformedList = fromEmbeddings;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return contentEmbeddingFromVertex(item);
      });
    }
    setValueByPath(toObject, ["embeddings"], transformedList);
  }
  const fromMetadata = getValueByPath(fromObject, ["metadata"]);
  if (fromMetadata != null) {
    setValueByPath(toObject, ["metadata"], fromMetadata);
  }
  return toObject;
}
function endpointFromVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["endpoint"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromDeployedModelId = getValueByPath(fromObject, [
    "deployedModelId"
  ]);
  if (fromDeployedModelId != null) {
    setValueByPath(toObject, ["deployedModelId"], fromDeployedModelId);
  }
  return toObject;
}
function fileDataToMldev$1(fromObject, _rootObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
  if (fromFileUri != null) {
    setValueByPath(toObject, ["fileUri"], fromFileUri);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function functionCallToMldev$1(fromObject, _rootObject) {
  const toObject = {};
  const fromId = getValueByPath(fromObject, ["id"]);
  if (fromId != null) {
    setValueByPath(toObject, ["id"], fromId);
  }
  const fromArgs = getValueByPath(fromObject, ["args"]);
  if (fromArgs != null) {
    setValueByPath(toObject, ["args"], fromArgs);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  if (getValueByPath(fromObject, ["partialArgs"]) !== void 0) {
    throw new Error("partialArgs parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["willContinue"]) !== void 0) {
    throw new Error("willContinue parameter is not supported in Gemini API.");
  }
  return toObject;
}
function functionCallingConfigToMldev(fromObject, _rootObject) {
  const toObject = {};
  const fromAllowedFunctionNames = getValueByPath(fromObject, [
    "allowedFunctionNames"
  ]);
  if (fromAllowedFunctionNames != null) {
    setValueByPath(toObject, ["allowedFunctionNames"], fromAllowedFunctionNames);
  }
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (fromMode != null) {
    setValueByPath(toObject, ["mode"], fromMode);
  }
  if (getValueByPath(fromObject, ["streamFunctionCallArguments"]) !== void 0) {
    throw new Error("streamFunctionCallArguments parameter is not supported in Gemini API.");
  }
  return toObject;
}
function functionDeclarationToVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromParameters = getValueByPath(fromObject, ["parameters"]);
  if (fromParameters != null) {
    setValueByPath(toObject, ["parameters"], fromParameters);
  }
  const fromParametersJsonSchema = getValueByPath(fromObject, [
    "parametersJsonSchema"
  ]);
  if (fromParametersJsonSchema != null) {
    setValueByPath(toObject, ["parametersJsonSchema"], fromParametersJsonSchema);
  }
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], fromResponse);
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  if (getValueByPath(fromObject, ["behavior"]) !== void 0) {
    throw new Error("behavior parameter is not supported in Vertex AI.");
  }
  return toObject;
}
function generateContentConfigToMldev(apiClient, fromObject, parentObject, rootObject) {
  const toObject = {};
  const fromSystemInstruction = getValueByPath(fromObject, [
    "systemInstruction"
  ]);
  if (parentObject !== void 0 && fromSystemInstruction != null) {
    setValueByPath(parentObject, ["systemInstruction"], contentToMldev$1(tContent(fromSystemInstruction)));
  }
  const fromTemperature = getValueByPath(fromObject, ["temperature"]);
  if (fromTemperature != null) {
    setValueByPath(toObject, ["temperature"], fromTemperature);
  }
  const fromTopP = getValueByPath(fromObject, ["topP"]);
  if (fromTopP != null) {
    setValueByPath(toObject, ["topP"], fromTopP);
  }
  const fromTopK = getValueByPath(fromObject, ["topK"]);
  if (fromTopK != null) {
    setValueByPath(toObject, ["topK"], fromTopK);
  }
  const fromCandidateCount = getValueByPath(fromObject, [
    "candidateCount"
  ]);
  if (fromCandidateCount != null) {
    setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
  }
  const fromMaxOutputTokens = getValueByPath(fromObject, [
    "maxOutputTokens"
  ]);
  if (fromMaxOutputTokens != null) {
    setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
  }
  const fromStopSequences = getValueByPath(fromObject, [
    "stopSequences"
  ]);
  if (fromStopSequences != null) {
    setValueByPath(toObject, ["stopSequences"], fromStopSequences);
  }
  const fromResponseLogprobs = getValueByPath(fromObject, [
    "responseLogprobs"
  ]);
  if (fromResponseLogprobs != null) {
    setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
  }
  const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
  if (fromLogprobs != null) {
    setValueByPath(toObject, ["logprobs"], fromLogprobs);
  }
  const fromPresencePenalty = getValueByPath(fromObject, [
    "presencePenalty"
  ]);
  if (fromPresencePenalty != null) {
    setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
  }
  const fromFrequencyPenalty = getValueByPath(fromObject, [
    "frequencyPenalty"
  ]);
  if (fromFrequencyPenalty != null) {
    setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (fromSeed != null) {
    setValueByPath(toObject, ["seed"], fromSeed);
  }
  const fromResponseMimeType = getValueByPath(fromObject, [
    "responseMimeType"
  ]);
  if (fromResponseMimeType != null) {
    setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
  }
  const fromResponseSchema = getValueByPath(fromObject, [
    "responseSchema"
  ]);
  if (fromResponseSchema != null) {
    setValueByPath(toObject, ["responseSchema"], tSchema(fromResponseSchema));
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  if (getValueByPath(fromObject, ["routingConfig"]) !== void 0) {
    throw new Error("routingConfig parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["modelSelectionConfig"]) !== void 0) {
    throw new Error("modelSelectionConfig parameter is not supported in Gemini API.");
  }
  const fromSafetySettings = getValueByPath(fromObject, [
    "safetySettings"
  ]);
  if (parentObject !== void 0 && fromSafetySettings != null) {
    let transformedList = fromSafetySettings;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return safetySettingToMldev(item);
      });
    }
    setValueByPath(parentObject, ["safetySettings"], transformedList);
  }
  const fromTools = getValueByPath(fromObject, ["tools"]);
  if (parentObject !== void 0 && fromTools != null) {
    let transformedList = tTools(fromTools);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return toolToMldev$1(tTool(item));
      });
    }
    setValueByPath(parentObject, ["tools"], transformedList);
  }
  const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
  if (parentObject !== void 0 && fromToolConfig != null) {
    setValueByPath(parentObject, ["toolConfig"], toolConfigToMldev(fromToolConfig));
  }
  if (getValueByPath(fromObject, ["labels"]) !== void 0) {
    throw new Error("labels parameter is not supported in Gemini API.");
  }
  const fromCachedContent = getValueByPath(fromObject, [
    "cachedContent"
  ]);
  if (parentObject !== void 0 && fromCachedContent != null) {
    setValueByPath(parentObject, ["cachedContent"], tCachedContentName(apiClient, fromCachedContent));
  }
  const fromResponseModalities = getValueByPath(fromObject, [
    "responseModalities"
  ]);
  if (fromResponseModalities != null) {
    setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
  }
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (fromMediaResolution != null) {
    setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
  }
  const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
  if (fromSpeechConfig != null) {
    setValueByPath(toObject, ["speechConfig"], tSpeechConfig(fromSpeechConfig));
  }
  if (getValueByPath(fromObject, ["audioTimestamp"]) !== void 0) {
    throw new Error("audioTimestamp parameter is not supported in Gemini API.");
  }
  const fromThinkingConfig = getValueByPath(fromObject, [
    "thinkingConfig"
  ]);
  if (fromThinkingConfig != null) {
    setValueByPath(toObject, ["thinkingConfig"], fromThinkingConfig);
  }
  const fromImageConfig = getValueByPath(fromObject, ["imageConfig"]);
  if (fromImageConfig != null) {
    setValueByPath(toObject, ["imageConfig"], imageConfigToMldev(fromImageConfig));
  }
  const fromEnableEnhancedCivicAnswers = getValueByPath(fromObject, [
    "enableEnhancedCivicAnswers"
  ]);
  if (fromEnableEnhancedCivicAnswers != null) {
    setValueByPath(toObject, ["enableEnhancedCivicAnswers"], fromEnableEnhancedCivicAnswers);
  }
  if (getValueByPath(fromObject, ["modelArmorConfig"]) !== void 0) {
    throw new Error("modelArmorConfig parameter is not supported in Gemini API.");
  }
  return toObject;
}
function generateContentConfigToVertex(apiClient, fromObject, parentObject, rootObject) {
  const toObject = {};
  const fromSystemInstruction = getValueByPath(fromObject, [
    "systemInstruction"
  ]);
  if (parentObject !== void 0 && fromSystemInstruction != null) {
    setValueByPath(parentObject, ["systemInstruction"], tContent(fromSystemInstruction));
  }
  const fromTemperature = getValueByPath(fromObject, ["temperature"]);
  if (fromTemperature != null) {
    setValueByPath(toObject, ["temperature"], fromTemperature);
  }
  const fromTopP = getValueByPath(fromObject, ["topP"]);
  if (fromTopP != null) {
    setValueByPath(toObject, ["topP"], fromTopP);
  }
  const fromTopK = getValueByPath(fromObject, ["topK"]);
  if (fromTopK != null) {
    setValueByPath(toObject, ["topK"], fromTopK);
  }
  const fromCandidateCount = getValueByPath(fromObject, [
    "candidateCount"
  ]);
  if (fromCandidateCount != null) {
    setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
  }
  const fromMaxOutputTokens = getValueByPath(fromObject, [
    "maxOutputTokens"
  ]);
  if (fromMaxOutputTokens != null) {
    setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
  }
  const fromStopSequences = getValueByPath(fromObject, [
    "stopSequences"
  ]);
  if (fromStopSequences != null) {
    setValueByPath(toObject, ["stopSequences"], fromStopSequences);
  }
  const fromResponseLogprobs = getValueByPath(fromObject, [
    "responseLogprobs"
  ]);
  if (fromResponseLogprobs != null) {
    setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
  }
  const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
  if (fromLogprobs != null) {
    setValueByPath(toObject, ["logprobs"], fromLogprobs);
  }
  const fromPresencePenalty = getValueByPath(fromObject, [
    "presencePenalty"
  ]);
  if (fromPresencePenalty != null) {
    setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
  }
  const fromFrequencyPenalty = getValueByPath(fromObject, [
    "frequencyPenalty"
  ]);
  if (fromFrequencyPenalty != null) {
    setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (fromSeed != null) {
    setValueByPath(toObject, ["seed"], fromSeed);
  }
  const fromResponseMimeType = getValueByPath(fromObject, [
    "responseMimeType"
  ]);
  if (fromResponseMimeType != null) {
    setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
  }
  const fromResponseSchema = getValueByPath(fromObject, [
    "responseSchema"
  ]);
  if (fromResponseSchema != null) {
    setValueByPath(toObject, ["responseSchema"], tSchema(fromResponseSchema));
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  const fromRoutingConfig = getValueByPath(fromObject, [
    "routingConfig"
  ]);
  if (fromRoutingConfig != null) {
    setValueByPath(toObject, ["routingConfig"], fromRoutingConfig);
  }
  const fromModelSelectionConfig = getValueByPath(fromObject, [
    "modelSelectionConfig"
  ]);
  if (fromModelSelectionConfig != null) {
    setValueByPath(toObject, ["modelConfig"], fromModelSelectionConfig);
  }
  const fromSafetySettings = getValueByPath(fromObject, [
    "safetySettings"
  ]);
  if (parentObject !== void 0 && fromSafetySettings != null) {
    let transformedList = fromSafetySettings;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(parentObject, ["safetySettings"], transformedList);
  }
  const fromTools = getValueByPath(fromObject, ["tools"]);
  if (parentObject !== void 0 && fromTools != null) {
    let transformedList = tTools(fromTools);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return toolToVertex(tTool(item));
      });
    }
    setValueByPath(parentObject, ["tools"], transformedList);
  }
  const fromToolConfig = getValueByPath(fromObject, ["toolConfig"]);
  if (parentObject !== void 0 && fromToolConfig != null) {
    setValueByPath(parentObject, ["toolConfig"], fromToolConfig);
  }
  const fromLabels = getValueByPath(fromObject, ["labels"]);
  if (parentObject !== void 0 && fromLabels != null) {
    setValueByPath(parentObject, ["labels"], fromLabels);
  }
  const fromCachedContent = getValueByPath(fromObject, [
    "cachedContent"
  ]);
  if (parentObject !== void 0 && fromCachedContent != null) {
    setValueByPath(parentObject, ["cachedContent"], tCachedContentName(apiClient, fromCachedContent));
  }
  const fromResponseModalities = getValueByPath(fromObject, [
    "responseModalities"
  ]);
  if (fromResponseModalities != null) {
    setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
  }
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (fromMediaResolution != null) {
    setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
  }
  const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
  if (fromSpeechConfig != null) {
    setValueByPath(toObject, ["speechConfig"], tSpeechConfig(fromSpeechConfig));
  }
  const fromAudioTimestamp = getValueByPath(fromObject, [
    "audioTimestamp"
  ]);
  if (fromAudioTimestamp != null) {
    setValueByPath(toObject, ["audioTimestamp"], fromAudioTimestamp);
  }
  const fromThinkingConfig = getValueByPath(fromObject, [
    "thinkingConfig"
  ]);
  if (fromThinkingConfig != null) {
    setValueByPath(toObject, ["thinkingConfig"], fromThinkingConfig);
  }
  const fromImageConfig = getValueByPath(fromObject, ["imageConfig"]);
  if (fromImageConfig != null) {
    setValueByPath(toObject, ["imageConfig"], imageConfigToVertex(fromImageConfig));
  }
  if (getValueByPath(fromObject, ["enableEnhancedCivicAnswers"]) !== void 0) {
    throw new Error("enableEnhancedCivicAnswers parameter is not supported in Vertex AI.");
  }
  const fromModelArmorConfig = getValueByPath(fromObject, [
    "modelArmorConfig"
  ]);
  if (parentObject !== void 0 && fromModelArmorConfig != null) {
    setValueByPath(parentObject, ["modelArmorConfig"], fromModelArmorConfig);
  }
  return toObject;
}
function generateContentParametersToMldev(apiClient, fromObject, rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (fromContents != null) {
    let transformedList = tContents(fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return contentToMldev$1(item);
      });
    }
    setValueByPath(toObject, ["contents"], transformedList);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["generationConfig"], generateContentConfigToMldev(apiClient, fromConfig, toObject));
  }
  return toObject;
}
function generateContentParametersToVertex(apiClient, fromObject, rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromContents = getValueByPath(fromObject, ["contents"]);
  if (fromContents != null) {
    let transformedList = tContents(fromContents);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["contents"], transformedList);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["generationConfig"], generateContentConfigToVertex(apiClient, fromConfig, toObject));
  }
  return toObject;
}
function generateContentResponseFromMldev(fromObject, rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromCandidates = getValueByPath(fromObject, ["candidates"]);
  if (fromCandidates != null) {
    let transformedList = fromCandidates;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return candidateFromMldev(item);
      });
    }
    setValueByPath(toObject, ["candidates"], transformedList);
  }
  const fromModelVersion = getValueByPath(fromObject, ["modelVersion"]);
  if (fromModelVersion != null) {
    setValueByPath(toObject, ["modelVersion"], fromModelVersion);
  }
  const fromPromptFeedback = getValueByPath(fromObject, [
    "promptFeedback"
  ]);
  if (fromPromptFeedback != null) {
    setValueByPath(toObject, ["promptFeedback"], fromPromptFeedback);
  }
  const fromResponseId = getValueByPath(fromObject, ["responseId"]);
  if (fromResponseId != null) {
    setValueByPath(toObject, ["responseId"], fromResponseId);
  }
  const fromUsageMetadata = getValueByPath(fromObject, [
    "usageMetadata"
  ]);
  if (fromUsageMetadata != null) {
    setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
  }
  return toObject;
}
function generateContentResponseFromVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromCandidates = getValueByPath(fromObject, ["candidates"]);
  if (fromCandidates != null) {
    let transformedList = fromCandidates;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["candidates"], transformedList);
  }
  const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
  if (fromCreateTime != null) {
    setValueByPath(toObject, ["createTime"], fromCreateTime);
  }
  const fromModelVersion = getValueByPath(fromObject, ["modelVersion"]);
  if (fromModelVersion != null) {
    setValueByPath(toObject, ["modelVersion"], fromModelVersion);
  }
  const fromPromptFeedback = getValueByPath(fromObject, [
    "promptFeedback"
  ]);
  if (fromPromptFeedback != null) {
    setValueByPath(toObject, ["promptFeedback"], fromPromptFeedback);
  }
  const fromResponseId = getValueByPath(fromObject, ["responseId"]);
  if (fromResponseId != null) {
    setValueByPath(toObject, ["responseId"], fromResponseId);
  }
  const fromUsageMetadata = getValueByPath(fromObject, [
    "usageMetadata"
  ]);
  if (fromUsageMetadata != null) {
    setValueByPath(toObject, ["usageMetadata"], fromUsageMetadata);
  }
  return toObject;
}
function generateImagesConfigToMldev(fromObject, parentObject, _rootObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["outputGcsUri"]) !== void 0) {
    throw new Error("outputGcsUri parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["negativePrompt"]) !== void 0) {
    throw new Error("negativePrompt parameter is not supported in Gemini API.");
  }
  const fromNumberOfImages = getValueByPath(fromObject, [
    "numberOfImages"
  ]);
  if (parentObject !== void 0 && fromNumberOfImages != null) {
    setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
  }
  const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
  if (parentObject !== void 0 && fromAspectRatio != null) {
    setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
  }
  const fromGuidanceScale = getValueByPath(fromObject, [
    "guidanceScale"
  ]);
  if (parentObject !== void 0 && fromGuidanceScale != null) {
    setValueByPath(parentObject, ["parameters", "guidanceScale"], fromGuidanceScale);
  }
  if (getValueByPath(fromObject, ["seed"]) !== void 0) {
    throw new Error("seed parameter is not supported in Gemini API.");
  }
  const fromSafetyFilterLevel = getValueByPath(fromObject, [
    "safetyFilterLevel"
  ]);
  if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
    setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
  }
  const fromPersonGeneration = getValueByPath(fromObject, [
    "personGeneration"
  ]);
  if (parentObject !== void 0 && fromPersonGeneration != null) {
    setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
  }
  const fromIncludeSafetyAttributes = getValueByPath(fromObject, [
    "includeSafetyAttributes"
  ]);
  if (parentObject !== void 0 && fromIncludeSafetyAttributes != null) {
    setValueByPath(parentObject, ["parameters", "includeSafetyAttributes"], fromIncludeSafetyAttributes);
  }
  const fromIncludeRaiReason = getValueByPath(fromObject, [
    "includeRaiReason"
  ]);
  if (parentObject !== void 0 && fromIncludeRaiReason != null) {
    setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
  }
  const fromLanguage = getValueByPath(fromObject, ["language"]);
  if (parentObject !== void 0 && fromLanguage != null) {
    setValueByPath(parentObject, ["parameters", "language"], fromLanguage);
  }
  const fromOutputMimeType = getValueByPath(fromObject, [
    "outputMimeType"
  ]);
  if (parentObject !== void 0 && fromOutputMimeType != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
  }
  const fromOutputCompressionQuality = getValueByPath(fromObject, [
    "outputCompressionQuality"
  ]);
  if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
  }
  if (getValueByPath(fromObject, ["addWatermark"]) !== void 0) {
    throw new Error("addWatermark parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["labels"]) !== void 0) {
    throw new Error("labels parameter is not supported in Gemini API.");
  }
  const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
  if (parentObject !== void 0 && fromImageSize != null) {
    setValueByPath(parentObject, ["parameters", "sampleImageSize"], fromImageSize);
  }
  if (getValueByPath(fromObject, ["enhancePrompt"]) !== void 0) {
    throw new Error("enhancePrompt parameter is not supported in Gemini API.");
  }
  return toObject;
}
function generateImagesConfigToVertex(fromObject, parentObject, _rootObject) {
  const toObject = {};
  const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
  if (parentObject !== void 0 && fromOutputGcsUri != null) {
    setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
  }
  const fromNegativePrompt = getValueByPath(fromObject, [
    "negativePrompt"
  ]);
  if (parentObject !== void 0 && fromNegativePrompt != null) {
    setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
  }
  const fromNumberOfImages = getValueByPath(fromObject, [
    "numberOfImages"
  ]);
  if (parentObject !== void 0 && fromNumberOfImages != null) {
    setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
  }
  const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
  if (parentObject !== void 0 && fromAspectRatio != null) {
    setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
  }
  const fromGuidanceScale = getValueByPath(fromObject, [
    "guidanceScale"
  ]);
  if (parentObject !== void 0 && fromGuidanceScale != null) {
    setValueByPath(parentObject, ["parameters", "guidanceScale"], fromGuidanceScale);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (parentObject !== void 0 && fromSeed != null) {
    setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
  }
  const fromSafetyFilterLevel = getValueByPath(fromObject, [
    "safetyFilterLevel"
  ]);
  if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
    setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
  }
  const fromPersonGeneration = getValueByPath(fromObject, [
    "personGeneration"
  ]);
  if (parentObject !== void 0 && fromPersonGeneration != null) {
    setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
  }
  const fromIncludeSafetyAttributes = getValueByPath(fromObject, [
    "includeSafetyAttributes"
  ]);
  if (parentObject !== void 0 && fromIncludeSafetyAttributes != null) {
    setValueByPath(parentObject, ["parameters", "includeSafetyAttributes"], fromIncludeSafetyAttributes);
  }
  const fromIncludeRaiReason = getValueByPath(fromObject, [
    "includeRaiReason"
  ]);
  if (parentObject !== void 0 && fromIncludeRaiReason != null) {
    setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
  }
  const fromLanguage = getValueByPath(fromObject, ["language"]);
  if (parentObject !== void 0 && fromLanguage != null) {
    setValueByPath(parentObject, ["parameters", "language"], fromLanguage);
  }
  const fromOutputMimeType = getValueByPath(fromObject, [
    "outputMimeType"
  ]);
  if (parentObject !== void 0 && fromOutputMimeType != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
  }
  const fromOutputCompressionQuality = getValueByPath(fromObject, [
    "outputCompressionQuality"
  ]);
  if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
  }
  const fromAddWatermark = getValueByPath(fromObject, ["addWatermark"]);
  if (parentObject !== void 0 && fromAddWatermark != null) {
    setValueByPath(parentObject, ["parameters", "addWatermark"], fromAddWatermark);
  }
  const fromLabels = getValueByPath(fromObject, ["labels"]);
  if (parentObject !== void 0 && fromLabels != null) {
    setValueByPath(parentObject, ["labels"], fromLabels);
  }
  const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
  if (parentObject !== void 0 && fromImageSize != null) {
    setValueByPath(parentObject, ["parameters", "sampleImageSize"], fromImageSize);
  }
  const fromEnhancePrompt = getValueByPath(fromObject, [
    "enhancePrompt"
  ]);
  if (parentObject !== void 0 && fromEnhancePrompt != null) {
    setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
  }
  return toObject;
}
function generateImagesParametersToMldev(apiClient, fromObject, rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromPrompt = getValueByPath(fromObject, ["prompt"]);
  if (fromPrompt != null) {
    setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    generateImagesConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function generateImagesParametersToVertex(apiClient, fromObject, rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromPrompt = getValueByPath(fromObject, ["prompt"]);
  if (fromPrompt != null) {
    setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    generateImagesConfigToVertex(fromConfig, toObject);
  }
  return toObject;
}
function generateImagesResponseFromMldev(fromObject, rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromGeneratedImages = getValueByPath(fromObject, [
    "predictions"
  ]);
  if (fromGeneratedImages != null) {
    let transformedList = fromGeneratedImages;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return generatedImageFromMldev(item);
      });
    }
    setValueByPath(toObject, ["generatedImages"], transformedList);
  }
  const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [
    "positivePromptSafetyAttributes"
  ]);
  if (fromPositivePromptSafetyAttributes != null) {
    setValueByPath(toObject, ["positivePromptSafetyAttributes"], safetyAttributesFromMldev(fromPositivePromptSafetyAttributes));
  }
  return toObject;
}
function generateImagesResponseFromVertex(fromObject, rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromGeneratedImages = getValueByPath(fromObject, [
    "predictions"
  ]);
  if (fromGeneratedImages != null) {
    let transformedList = fromGeneratedImages;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return generatedImageFromVertex(item);
      });
    }
    setValueByPath(toObject, ["generatedImages"], transformedList);
  }
  const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [
    "positivePromptSafetyAttributes"
  ]);
  if (fromPositivePromptSafetyAttributes != null) {
    setValueByPath(toObject, ["positivePromptSafetyAttributes"], safetyAttributesFromVertex(fromPositivePromptSafetyAttributes));
  }
  return toObject;
}
function generateVideosConfigToMldev(fromObject, parentObject, rootObject) {
  const toObject = {};
  const fromNumberOfVideos = getValueByPath(fromObject, [
    "numberOfVideos"
  ]);
  if (parentObject !== void 0 && fromNumberOfVideos != null) {
    setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfVideos);
  }
  if (getValueByPath(fromObject, ["outputGcsUri"]) !== void 0) {
    throw new Error("outputGcsUri parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["fps"]) !== void 0) {
    throw new Error("fps parameter is not supported in Gemini API.");
  }
  const fromDurationSeconds = getValueByPath(fromObject, [
    "durationSeconds"
  ]);
  if (parentObject !== void 0 && fromDurationSeconds != null) {
    setValueByPath(parentObject, ["parameters", "durationSeconds"], fromDurationSeconds);
  }
  if (getValueByPath(fromObject, ["seed"]) !== void 0) {
    throw new Error("seed parameter is not supported in Gemini API.");
  }
  const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
  if (parentObject !== void 0 && fromAspectRatio != null) {
    setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
  }
  const fromResolution = getValueByPath(fromObject, ["resolution"]);
  if (parentObject !== void 0 && fromResolution != null) {
    setValueByPath(parentObject, ["parameters", "resolution"], fromResolution);
  }
  const fromPersonGeneration = getValueByPath(fromObject, [
    "personGeneration"
  ]);
  if (parentObject !== void 0 && fromPersonGeneration != null) {
    setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
  }
  if (getValueByPath(fromObject, ["pubsubTopic"]) !== void 0) {
    throw new Error("pubsubTopic parameter is not supported in Gemini API.");
  }
  const fromNegativePrompt = getValueByPath(fromObject, [
    "negativePrompt"
  ]);
  if (parentObject !== void 0 && fromNegativePrompt != null) {
    setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
  }
  const fromEnhancePrompt = getValueByPath(fromObject, [
    "enhancePrompt"
  ]);
  if (parentObject !== void 0 && fromEnhancePrompt != null) {
    setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
  }
  if (getValueByPath(fromObject, ["generateAudio"]) !== void 0) {
    throw new Error("generateAudio parameter is not supported in Gemini API.");
  }
  const fromLastFrame = getValueByPath(fromObject, ["lastFrame"]);
  if (parentObject !== void 0 && fromLastFrame != null) {
    setValueByPath(parentObject, ["instances[0]", "lastFrame"], imageToMldev(fromLastFrame));
  }
  const fromReferenceImages = getValueByPath(fromObject, [
    "referenceImages"
  ]);
  if (parentObject !== void 0 && fromReferenceImages != null) {
    let transformedList = fromReferenceImages;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return videoGenerationReferenceImageToMldev(item);
      });
    }
    setValueByPath(parentObject, ["instances[0]", "referenceImages"], transformedList);
  }
  if (getValueByPath(fromObject, ["mask"]) !== void 0) {
    throw new Error("mask parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["compressionQuality"]) !== void 0) {
    throw new Error("compressionQuality parameter is not supported in Gemini API.");
  }
  return toObject;
}
function generateVideosConfigToVertex(fromObject, parentObject, rootObject) {
  const toObject = {};
  const fromNumberOfVideos = getValueByPath(fromObject, [
    "numberOfVideos"
  ]);
  if (parentObject !== void 0 && fromNumberOfVideos != null) {
    setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfVideos);
  }
  const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
  if (parentObject !== void 0 && fromOutputGcsUri != null) {
    setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
  }
  const fromFps = getValueByPath(fromObject, ["fps"]);
  if (parentObject !== void 0 && fromFps != null) {
    setValueByPath(parentObject, ["parameters", "fps"], fromFps);
  }
  const fromDurationSeconds = getValueByPath(fromObject, [
    "durationSeconds"
  ]);
  if (parentObject !== void 0 && fromDurationSeconds != null) {
    setValueByPath(parentObject, ["parameters", "durationSeconds"], fromDurationSeconds);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (parentObject !== void 0 && fromSeed != null) {
    setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
  }
  const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
  if (parentObject !== void 0 && fromAspectRatio != null) {
    setValueByPath(parentObject, ["parameters", "aspectRatio"], fromAspectRatio);
  }
  const fromResolution = getValueByPath(fromObject, ["resolution"]);
  if (parentObject !== void 0 && fromResolution != null) {
    setValueByPath(parentObject, ["parameters", "resolution"], fromResolution);
  }
  const fromPersonGeneration = getValueByPath(fromObject, [
    "personGeneration"
  ]);
  if (parentObject !== void 0 && fromPersonGeneration != null) {
    setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
  }
  const fromPubsubTopic = getValueByPath(fromObject, ["pubsubTopic"]);
  if (parentObject !== void 0 && fromPubsubTopic != null) {
    setValueByPath(parentObject, ["parameters", "pubsubTopic"], fromPubsubTopic);
  }
  const fromNegativePrompt = getValueByPath(fromObject, [
    "negativePrompt"
  ]);
  if (parentObject !== void 0 && fromNegativePrompt != null) {
    setValueByPath(parentObject, ["parameters", "negativePrompt"], fromNegativePrompt);
  }
  const fromEnhancePrompt = getValueByPath(fromObject, [
    "enhancePrompt"
  ]);
  if (parentObject !== void 0 && fromEnhancePrompt != null) {
    setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
  }
  const fromGenerateAudio = getValueByPath(fromObject, [
    "generateAudio"
  ]);
  if (parentObject !== void 0 && fromGenerateAudio != null) {
    setValueByPath(parentObject, ["parameters", "generateAudio"], fromGenerateAudio);
  }
  const fromLastFrame = getValueByPath(fromObject, ["lastFrame"]);
  if (parentObject !== void 0 && fromLastFrame != null) {
    setValueByPath(parentObject, ["instances[0]", "lastFrame"], imageToVertex(fromLastFrame));
  }
  const fromReferenceImages = getValueByPath(fromObject, [
    "referenceImages"
  ]);
  if (parentObject !== void 0 && fromReferenceImages != null) {
    let transformedList = fromReferenceImages;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return videoGenerationReferenceImageToVertex(item);
      });
    }
    setValueByPath(parentObject, ["instances[0]", "referenceImages"], transformedList);
  }
  const fromMask = getValueByPath(fromObject, ["mask"]);
  if (parentObject !== void 0 && fromMask != null) {
    setValueByPath(parentObject, ["instances[0]", "mask"], videoGenerationMaskToVertex(fromMask));
  }
  const fromCompressionQuality = getValueByPath(fromObject, [
    "compressionQuality"
  ]);
  if (parentObject !== void 0 && fromCompressionQuality != null) {
    setValueByPath(parentObject, ["parameters", "compressionQuality"], fromCompressionQuality);
  }
  return toObject;
}
function generateVideosOperationFromMldev(fromObject, rootObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromMetadata = getValueByPath(fromObject, ["metadata"]);
  if (fromMetadata != null) {
    setValueByPath(toObject, ["metadata"], fromMetadata);
  }
  const fromDone = getValueByPath(fromObject, ["done"]);
  if (fromDone != null) {
    setValueByPath(toObject, ["done"], fromDone);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fromError);
  }
  const fromResponse = getValueByPath(fromObject, [
    "response",
    "generateVideoResponse"
  ]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], generateVideosResponseFromMldev(fromResponse));
  }
  return toObject;
}
function generateVideosOperationFromVertex(fromObject, rootObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromMetadata = getValueByPath(fromObject, ["metadata"]);
  if (fromMetadata != null) {
    setValueByPath(toObject, ["metadata"], fromMetadata);
  }
  const fromDone = getValueByPath(fromObject, ["done"]);
  if (fromDone != null) {
    setValueByPath(toObject, ["done"], fromDone);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fromError);
  }
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], generateVideosResponseFromVertex(fromResponse));
  }
  return toObject;
}
function generateVideosParametersToMldev(apiClient, fromObject, rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromPrompt = getValueByPath(fromObject, ["prompt"]);
  if (fromPrompt != null) {
    setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
  }
  const fromImage = getValueByPath(fromObject, ["image"]);
  if (fromImage != null) {
    setValueByPath(toObject, ["instances[0]", "image"], imageToMldev(fromImage));
  }
  const fromVideo = getValueByPath(fromObject, ["video"]);
  if (fromVideo != null) {
    setValueByPath(toObject, ["instances[0]", "video"], videoToMldev(fromVideo));
  }
  const fromSource = getValueByPath(fromObject, ["source"]);
  if (fromSource != null) {
    generateVideosSourceToMldev(fromSource, toObject);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    generateVideosConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function generateVideosParametersToVertex(apiClient, fromObject, rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromPrompt = getValueByPath(fromObject, ["prompt"]);
  if (fromPrompt != null) {
    setValueByPath(toObject, ["instances[0]", "prompt"], fromPrompt);
  }
  const fromImage = getValueByPath(fromObject, ["image"]);
  if (fromImage != null) {
    setValueByPath(toObject, ["instances[0]", "image"], imageToVertex(fromImage));
  }
  const fromVideo = getValueByPath(fromObject, ["video"]);
  if (fromVideo != null) {
    setValueByPath(toObject, ["instances[0]", "video"], videoToVertex(fromVideo));
  }
  const fromSource = getValueByPath(fromObject, ["source"]);
  if (fromSource != null) {
    generateVideosSourceToVertex(fromSource, toObject);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    generateVideosConfigToVertex(fromConfig, toObject);
  }
  return toObject;
}
function generateVideosResponseFromMldev(fromObject, rootObject) {
  const toObject = {};
  const fromGeneratedVideos = getValueByPath(fromObject, [
    "generatedSamples"
  ]);
  if (fromGeneratedVideos != null) {
    let transformedList = fromGeneratedVideos;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return generatedVideoFromMldev(item);
      });
    }
    setValueByPath(toObject, ["generatedVideos"], transformedList);
  }
  const fromRaiMediaFilteredCount = getValueByPath(fromObject, [
    "raiMediaFilteredCount"
  ]);
  if (fromRaiMediaFilteredCount != null) {
    setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
  }
  const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [
    "raiMediaFilteredReasons"
  ]);
  if (fromRaiMediaFilteredReasons != null) {
    setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
  }
  return toObject;
}
function generateVideosResponseFromVertex(fromObject, rootObject) {
  const toObject = {};
  const fromGeneratedVideos = getValueByPath(fromObject, ["videos"]);
  if (fromGeneratedVideos != null) {
    let transformedList = fromGeneratedVideos;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return generatedVideoFromVertex(item);
      });
    }
    setValueByPath(toObject, ["generatedVideos"], transformedList);
  }
  const fromRaiMediaFilteredCount = getValueByPath(fromObject, [
    "raiMediaFilteredCount"
  ]);
  if (fromRaiMediaFilteredCount != null) {
    setValueByPath(toObject, ["raiMediaFilteredCount"], fromRaiMediaFilteredCount);
  }
  const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [
    "raiMediaFilteredReasons"
  ]);
  if (fromRaiMediaFilteredReasons != null) {
    setValueByPath(toObject, ["raiMediaFilteredReasons"], fromRaiMediaFilteredReasons);
  }
  return toObject;
}
function generateVideosSourceToMldev(fromObject, parentObject, rootObject) {
  const toObject = {};
  const fromPrompt = getValueByPath(fromObject, ["prompt"]);
  if (parentObject !== void 0 && fromPrompt != null) {
    setValueByPath(parentObject, ["instances[0]", "prompt"], fromPrompt);
  }
  const fromImage = getValueByPath(fromObject, ["image"]);
  if (parentObject !== void 0 && fromImage != null) {
    setValueByPath(parentObject, ["instances[0]", "image"], imageToMldev(fromImage));
  }
  const fromVideo = getValueByPath(fromObject, ["video"]);
  if (parentObject !== void 0 && fromVideo != null) {
    setValueByPath(parentObject, ["instances[0]", "video"], videoToMldev(fromVideo));
  }
  return toObject;
}
function generateVideosSourceToVertex(fromObject, parentObject, rootObject) {
  const toObject = {};
  const fromPrompt = getValueByPath(fromObject, ["prompt"]);
  if (parentObject !== void 0 && fromPrompt != null) {
    setValueByPath(parentObject, ["instances[0]", "prompt"], fromPrompt);
  }
  const fromImage = getValueByPath(fromObject, ["image"]);
  if (parentObject !== void 0 && fromImage != null) {
    setValueByPath(parentObject, ["instances[0]", "image"], imageToVertex(fromImage));
  }
  const fromVideo = getValueByPath(fromObject, ["video"]);
  if (parentObject !== void 0 && fromVideo != null) {
    setValueByPath(parentObject, ["instances[0]", "video"], videoToVertex(fromVideo));
  }
  return toObject;
}
function generatedImageFromMldev(fromObject, rootObject) {
  const toObject = {};
  const fromImage = getValueByPath(fromObject, ["_self"]);
  if (fromImage != null) {
    setValueByPath(toObject, ["image"], imageFromMldev(fromImage));
  }
  const fromRaiFilteredReason = getValueByPath(fromObject, [
    "raiFilteredReason"
  ]);
  if (fromRaiFilteredReason != null) {
    setValueByPath(toObject, ["raiFilteredReason"], fromRaiFilteredReason);
  }
  const fromSafetyAttributes = getValueByPath(fromObject, ["_self"]);
  if (fromSafetyAttributes != null) {
    setValueByPath(toObject, ["safetyAttributes"], safetyAttributesFromMldev(fromSafetyAttributes));
  }
  return toObject;
}
function generatedImageFromVertex(fromObject, rootObject) {
  const toObject = {};
  const fromImage = getValueByPath(fromObject, ["_self"]);
  if (fromImage != null) {
    setValueByPath(toObject, ["image"], imageFromVertex(fromImage));
  }
  const fromRaiFilteredReason = getValueByPath(fromObject, [
    "raiFilteredReason"
  ]);
  if (fromRaiFilteredReason != null) {
    setValueByPath(toObject, ["raiFilteredReason"], fromRaiFilteredReason);
  }
  const fromSafetyAttributes = getValueByPath(fromObject, ["_self"]);
  if (fromSafetyAttributes != null) {
    setValueByPath(toObject, ["safetyAttributes"], safetyAttributesFromVertex(fromSafetyAttributes));
  }
  const fromEnhancedPrompt = getValueByPath(fromObject, ["prompt"]);
  if (fromEnhancedPrompt != null) {
    setValueByPath(toObject, ["enhancedPrompt"], fromEnhancedPrompt);
  }
  return toObject;
}
function generatedImageMaskFromVertex(fromObject, rootObject) {
  const toObject = {};
  const fromMask = getValueByPath(fromObject, ["_self"]);
  if (fromMask != null) {
    setValueByPath(toObject, ["mask"], imageFromVertex(fromMask));
  }
  const fromLabels = getValueByPath(fromObject, ["labels"]);
  if (fromLabels != null) {
    let transformedList = fromLabels;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["labels"], transformedList);
  }
  return toObject;
}
function generatedVideoFromMldev(fromObject, rootObject) {
  const toObject = {};
  const fromVideo = getValueByPath(fromObject, ["video"]);
  if (fromVideo != null) {
    setValueByPath(toObject, ["video"], videoFromMldev(fromVideo));
  }
  return toObject;
}
function generatedVideoFromVertex(fromObject, rootObject) {
  const toObject = {};
  const fromVideo = getValueByPath(fromObject, ["_self"]);
  if (fromVideo != null) {
    setValueByPath(toObject, ["video"], videoFromVertex(fromVideo));
  }
  return toObject;
}
function generationConfigToVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromModelSelectionConfig = getValueByPath(fromObject, [
    "modelSelectionConfig"
  ]);
  if (fromModelSelectionConfig != null) {
    setValueByPath(toObject, ["modelConfig"], fromModelSelectionConfig);
  }
  const fromResponseJsonSchema = getValueByPath(fromObject, [
    "responseJsonSchema"
  ]);
  if (fromResponseJsonSchema != null) {
    setValueByPath(toObject, ["responseJsonSchema"], fromResponseJsonSchema);
  }
  const fromAudioTimestamp = getValueByPath(fromObject, [
    "audioTimestamp"
  ]);
  if (fromAudioTimestamp != null) {
    setValueByPath(toObject, ["audioTimestamp"], fromAudioTimestamp);
  }
  const fromCandidateCount = getValueByPath(fromObject, [
    "candidateCount"
  ]);
  if (fromCandidateCount != null) {
    setValueByPath(toObject, ["candidateCount"], fromCandidateCount);
  }
  const fromEnableAffectiveDialog = getValueByPath(fromObject, [
    "enableAffectiveDialog"
  ]);
  if (fromEnableAffectiveDialog != null) {
    setValueByPath(toObject, ["enableAffectiveDialog"], fromEnableAffectiveDialog);
  }
  const fromFrequencyPenalty = getValueByPath(fromObject, [
    "frequencyPenalty"
  ]);
  if (fromFrequencyPenalty != null) {
    setValueByPath(toObject, ["frequencyPenalty"], fromFrequencyPenalty);
  }
  const fromLogprobs = getValueByPath(fromObject, ["logprobs"]);
  if (fromLogprobs != null) {
    setValueByPath(toObject, ["logprobs"], fromLogprobs);
  }
  const fromMaxOutputTokens = getValueByPath(fromObject, [
    "maxOutputTokens"
  ]);
  if (fromMaxOutputTokens != null) {
    setValueByPath(toObject, ["maxOutputTokens"], fromMaxOutputTokens);
  }
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (fromMediaResolution != null) {
    setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
  }
  const fromPresencePenalty = getValueByPath(fromObject, [
    "presencePenalty"
  ]);
  if (fromPresencePenalty != null) {
    setValueByPath(toObject, ["presencePenalty"], fromPresencePenalty);
  }
  const fromResponseLogprobs = getValueByPath(fromObject, [
    "responseLogprobs"
  ]);
  if (fromResponseLogprobs != null) {
    setValueByPath(toObject, ["responseLogprobs"], fromResponseLogprobs);
  }
  const fromResponseMimeType = getValueByPath(fromObject, [
    "responseMimeType"
  ]);
  if (fromResponseMimeType != null) {
    setValueByPath(toObject, ["responseMimeType"], fromResponseMimeType);
  }
  const fromResponseModalities = getValueByPath(fromObject, [
    "responseModalities"
  ]);
  if (fromResponseModalities != null) {
    setValueByPath(toObject, ["responseModalities"], fromResponseModalities);
  }
  const fromResponseSchema = getValueByPath(fromObject, [
    "responseSchema"
  ]);
  if (fromResponseSchema != null) {
    setValueByPath(toObject, ["responseSchema"], fromResponseSchema);
  }
  const fromRoutingConfig = getValueByPath(fromObject, [
    "routingConfig"
  ]);
  if (fromRoutingConfig != null) {
    setValueByPath(toObject, ["routingConfig"], fromRoutingConfig);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (fromSeed != null) {
    setValueByPath(toObject, ["seed"], fromSeed);
  }
  const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
  if (fromSpeechConfig != null) {
    setValueByPath(toObject, ["speechConfig"], fromSpeechConfig);
  }
  const fromStopSequences = getValueByPath(fromObject, [
    "stopSequences"
  ]);
  if (fromStopSequences != null) {
    setValueByPath(toObject, ["stopSequences"], fromStopSequences);
  }
  const fromTemperature = getValueByPath(fromObject, ["temperature"]);
  if (fromTemperature != null) {
    setValueByPath(toObject, ["temperature"], fromTemperature);
  }
  const fromThinkingConfig = getValueByPath(fromObject, [
    "thinkingConfig"
  ]);
  if (fromThinkingConfig != null) {
    setValueByPath(toObject, ["thinkingConfig"], fromThinkingConfig);
  }
  const fromTopK = getValueByPath(fromObject, ["topK"]);
  if (fromTopK != null) {
    setValueByPath(toObject, ["topK"], fromTopK);
  }
  const fromTopP = getValueByPath(fromObject, ["topP"]);
  if (fromTopP != null) {
    setValueByPath(toObject, ["topP"], fromTopP);
  }
  if (getValueByPath(fromObject, ["enableEnhancedCivicAnswers"]) !== void 0) {
    throw new Error("enableEnhancedCivicAnswers parameter is not supported in Vertex AI.");
  }
  return toObject;
}
function getModelParametersToMldev(apiClient, fromObject, _rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
  }
  return toObject;
}
function getModelParametersToVertex(apiClient, fromObject, _rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
  }
  return toObject;
}
function googleMapsToMldev$1(fromObject, _rootObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["authConfig"]) !== void 0) {
    throw new Error("authConfig parameter is not supported in Gemini API.");
  }
  const fromEnableWidget = getValueByPath(fromObject, ["enableWidget"]);
  if (fromEnableWidget != null) {
    setValueByPath(toObject, ["enableWidget"], fromEnableWidget);
  }
  return toObject;
}
function googleSearchToMldev$1(fromObject, _rootObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) {
    throw new Error("excludeDomains parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["blockingConfidence"]) !== void 0) {
    throw new Error("blockingConfidence parameter is not supported in Gemini API.");
  }
  const fromTimeRangeFilter = getValueByPath(fromObject, [
    "timeRangeFilter"
  ]);
  if (fromTimeRangeFilter != null) {
    setValueByPath(toObject, ["timeRangeFilter"], fromTimeRangeFilter);
  }
  return toObject;
}
function imageConfigToMldev(fromObject, _rootObject) {
  const toObject = {};
  const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
  if (fromAspectRatio != null) {
    setValueByPath(toObject, ["aspectRatio"], fromAspectRatio);
  }
  const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
  if (fromImageSize != null) {
    setValueByPath(toObject, ["imageSize"], fromImageSize);
  }
  if (getValueByPath(fromObject, ["personGeneration"]) !== void 0) {
    throw new Error("personGeneration parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["outputMimeType"]) !== void 0) {
    throw new Error("outputMimeType parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["outputCompressionQuality"]) !== void 0) {
    throw new Error("outputCompressionQuality parameter is not supported in Gemini API.");
  }
  return toObject;
}
function imageConfigToVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromAspectRatio = getValueByPath(fromObject, ["aspectRatio"]);
  if (fromAspectRatio != null) {
    setValueByPath(toObject, ["aspectRatio"], fromAspectRatio);
  }
  const fromImageSize = getValueByPath(fromObject, ["imageSize"]);
  if (fromImageSize != null) {
    setValueByPath(toObject, ["imageSize"], fromImageSize);
  }
  const fromPersonGeneration = getValueByPath(fromObject, [
    "personGeneration"
  ]);
  if (fromPersonGeneration != null) {
    setValueByPath(toObject, ["personGeneration"], fromPersonGeneration);
  }
  const fromOutputMimeType = getValueByPath(fromObject, [
    "outputMimeType"
  ]);
  if (fromOutputMimeType != null) {
    setValueByPath(toObject, ["imageOutputOptions", "mimeType"], fromOutputMimeType);
  }
  const fromOutputCompressionQuality = getValueByPath(fromObject, [
    "outputCompressionQuality"
  ]);
  if (fromOutputCompressionQuality != null) {
    setValueByPath(toObject, ["imageOutputOptions", "compressionQuality"], fromOutputCompressionQuality);
  }
  return toObject;
}
function imageFromMldev(fromObject, _rootObject) {
  const toObject = {};
  const fromImageBytes = getValueByPath(fromObject, [
    "bytesBase64Encoded"
  ]);
  if (fromImageBytes != null) {
    setValueByPath(toObject, ["imageBytes"], tBytes(fromImageBytes));
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function imageFromVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
  if (fromGcsUri != null) {
    setValueByPath(toObject, ["gcsUri"], fromGcsUri);
  }
  const fromImageBytes = getValueByPath(fromObject, [
    "bytesBase64Encoded"
  ]);
  if (fromImageBytes != null) {
    setValueByPath(toObject, ["imageBytes"], tBytes(fromImageBytes));
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function imageToMldev(fromObject, _rootObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["gcsUri"]) !== void 0) {
    throw new Error("gcsUri parameter is not supported in Gemini API.");
  }
  const fromImageBytes = getValueByPath(fromObject, ["imageBytes"]);
  if (fromImageBytes != null) {
    setValueByPath(toObject, ["bytesBase64Encoded"], tBytes(fromImageBytes));
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function imageToVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
  if (fromGcsUri != null) {
    setValueByPath(toObject, ["gcsUri"], fromGcsUri);
  }
  const fromImageBytes = getValueByPath(fromObject, ["imageBytes"]);
  if (fromImageBytes != null) {
    setValueByPath(toObject, ["bytesBase64Encoded"], tBytes(fromImageBytes));
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function listModelsConfigToMldev(apiClient, fromObject, parentObject, _rootObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== void 0 && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== void 0 && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  const fromFilter = getValueByPath(fromObject, ["filter"]);
  if (parentObject !== void 0 && fromFilter != null) {
    setValueByPath(parentObject, ["_query", "filter"], fromFilter);
  }
  const fromQueryBase = getValueByPath(fromObject, ["queryBase"]);
  if (parentObject !== void 0 && fromQueryBase != null) {
    setValueByPath(parentObject, ["_url", "models_url"], tModelsUrl(apiClient, fromQueryBase));
  }
  return toObject;
}
function listModelsConfigToVertex(apiClient, fromObject, parentObject, _rootObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== void 0 && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== void 0 && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  const fromFilter = getValueByPath(fromObject, ["filter"]);
  if (parentObject !== void 0 && fromFilter != null) {
    setValueByPath(parentObject, ["_query", "filter"], fromFilter);
  }
  const fromQueryBase = getValueByPath(fromObject, ["queryBase"]);
  if (parentObject !== void 0 && fromQueryBase != null) {
    setValueByPath(parentObject, ["_url", "models_url"], tModelsUrl(apiClient, fromQueryBase));
  }
  return toObject;
}
function listModelsParametersToMldev(apiClient, fromObject, rootObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    listModelsConfigToMldev(apiClient, fromConfig, toObject);
  }
  return toObject;
}
function listModelsParametersToVertex(apiClient, fromObject, rootObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    listModelsConfigToVertex(apiClient, fromConfig, toObject);
  }
  return toObject;
}
function listModelsResponseFromMldev(fromObject, rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromModels = getValueByPath(fromObject, ["_self"]);
  if (fromModels != null) {
    let transformedList = tExtractModels(fromModels);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return modelFromMldev(item);
      });
    }
    setValueByPath(toObject, ["models"], transformedList);
  }
  return toObject;
}
function listModelsResponseFromVertex(fromObject, rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromModels = getValueByPath(fromObject, ["_self"]);
  if (fromModels != null) {
    let transformedList = tExtractModels(fromModels);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return modelFromVertex(item);
      });
    }
    setValueByPath(toObject, ["models"], transformedList);
  }
  return toObject;
}
function maskReferenceConfigToVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromMaskMode = getValueByPath(fromObject, ["maskMode"]);
  if (fromMaskMode != null) {
    setValueByPath(toObject, ["maskMode"], fromMaskMode);
  }
  const fromSegmentationClasses = getValueByPath(fromObject, [
    "segmentationClasses"
  ]);
  if (fromSegmentationClasses != null) {
    setValueByPath(toObject, ["maskClasses"], fromSegmentationClasses);
  }
  const fromMaskDilation = getValueByPath(fromObject, ["maskDilation"]);
  if (fromMaskDilation != null) {
    setValueByPath(toObject, ["dilation"], fromMaskDilation);
  }
  return toObject;
}
function modelFromMldev(fromObject, rootObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromVersion = getValueByPath(fromObject, ["version"]);
  if (fromVersion != null) {
    setValueByPath(toObject, ["version"], fromVersion);
  }
  const fromTunedModelInfo = getValueByPath(fromObject, ["_self"]);
  if (fromTunedModelInfo != null) {
    setValueByPath(toObject, ["tunedModelInfo"], tunedModelInfoFromMldev(fromTunedModelInfo));
  }
  const fromInputTokenLimit = getValueByPath(fromObject, [
    "inputTokenLimit"
  ]);
  if (fromInputTokenLimit != null) {
    setValueByPath(toObject, ["inputTokenLimit"], fromInputTokenLimit);
  }
  const fromOutputTokenLimit = getValueByPath(fromObject, [
    "outputTokenLimit"
  ]);
  if (fromOutputTokenLimit != null) {
    setValueByPath(toObject, ["outputTokenLimit"], fromOutputTokenLimit);
  }
  const fromSupportedActions = getValueByPath(fromObject, [
    "supportedGenerationMethods"
  ]);
  if (fromSupportedActions != null) {
    setValueByPath(toObject, ["supportedActions"], fromSupportedActions);
  }
  const fromTemperature = getValueByPath(fromObject, ["temperature"]);
  if (fromTemperature != null) {
    setValueByPath(toObject, ["temperature"], fromTemperature);
  }
  const fromMaxTemperature = getValueByPath(fromObject, [
    "maxTemperature"
  ]);
  if (fromMaxTemperature != null) {
    setValueByPath(toObject, ["maxTemperature"], fromMaxTemperature);
  }
  const fromTopP = getValueByPath(fromObject, ["topP"]);
  if (fromTopP != null) {
    setValueByPath(toObject, ["topP"], fromTopP);
  }
  const fromTopK = getValueByPath(fromObject, ["topK"]);
  if (fromTopK != null) {
    setValueByPath(toObject, ["topK"], fromTopK);
  }
  const fromThinking = getValueByPath(fromObject, ["thinking"]);
  if (fromThinking != null) {
    setValueByPath(toObject, ["thinking"], fromThinking);
  }
  return toObject;
}
function modelFromVertex(fromObject, rootObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (fromDisplayName != null) {
    setValueByPath(toObject, ["displayName"], fromDisplayName);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromVersion = getValueByPath(fromObject, ["versionId"]);
  if (fromVersion != null) {
    setValueByPath(toObject, ["version"], fromVersion);
  }
  const fromEndpoints = getValueByPath(fromObject, ["deployedModels"]);
  if (fromEndpoints != null) {
    let transformedList = fromEndpoints;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return endpointFromVertex(item);
      });
    }
    setValueByPath(toObject, ["endpoints"], transformedList);
  }
  const fromLabels = getValueByPath(fromObject, ["labels"]);
  if (fromLabels != null) {
    setValueByPath(toObject, ["labels"], fromLabels);
  }
  const fromTunedModelInfo = getValueByPath(fromObject, ["_self"]);
  if (fromTunedModelInfo != null) {
    setValueByPath(toObject, ["tunedModelInfo"], tunedModelInfoFromVertex(fromTunedModelInfo));
  }
  const fromDefaultCheckpointId = getValueByPath(fromObject, [
    "defaultCheckpointId"
  ]);
  if (fromDefaultCheckpointId != null) {
    setValueByPath(toObject, ["defaultCheckpointId"], fromDefaultCheckpointId);
  }
  const fromCheckpoints = getValueByPath(fromObject, ["checkpoints"]);
  if (fromCheckpoints != null) {
    let transformedList = fromCheckpoints;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["checkpoints"], transformedList);
  }
  return toObject;
}
function partToMldev$1(fromObject, rootObject) {
  const toObject = {};
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (fromMediaResolution != null) {
    setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
  }
  const fromCodeExecutionResult = getValueByPath(fromObject, [
    "codeExecutionResult"
  ]);
  if (fromCodeExecutionResult != null) {
    setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
  }
  const fromExecutableCode = getValueByPath(fromObject, [
    "executableCode"
  ]);
  if (fromExecutableCode != null) {
    setValueByPath(toObject, ["executableCode"], fromExecutableCode);
  }
  const fromFileData = getValueByPath(fromObject, ["fileData"]);
  if (fromFileData != null) {
    setValueByPath(toObject, ["fileData"], fileDataToMldev$1(fromFileData));
  }
  const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
  if (fromFunctionCall != null) {
    setValueByPath(toObject, ["functionCall"], functionCallToMldev$1(fromFunctionCall));
  }
  const fromFunctionResponse = getValueByPath(fromObject, [
    "functionResponse"
  ]);
  if (fromFunctionResponse != null) {
    setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
  }
  const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
  if (fromInlineData != null) {
    setValueByPath(toObject, ["inlineData"], blobToMldev$1(fromInlineData));
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  const fromThought = getValueByPath(fromObject, ["thought"]);
  if (fromThought != null) {
    setValueByPath(toObject, ["thought"], fromThought);
  }
  const fromThoughtSignature = getValueByPath(fromObject, [
    "thoughtSignature"
  ]);
  if (fromThoughtSignature != null) {
    setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
  }
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
  }
  return toObject;
}
function productImageToVertex(fromObject, rootObject) {
  const toObject = {};
  const fromProductImage = getValueByPath(fromObject, ["productImage"]);
  if (fromProductImage != null) {
    setValueByPath(toObject, ["image"], imageToVertex(fromProductImage));
  }
  return toObject;
}
function recontextImageConfigToVertex(fromObject, parentObject, _rootObject) {
  const toObject = {};
  const fromNumberOfImages = getValueByPath(fromObject, [
    "numberOfImages"
  ]);
  if (parentObject !== void 0 && fromNumberOfImages != null) {
    setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
  }
  const fromBaseSteps = getValueByPath(fromObject, ["baseSteps"]);
  if (parentObject !== void 0 && fromBaseSteps != null) {
    setValueByPath(parentObject, ["parameters", "baseSteps"], fromBaseSteps);
  }
  const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
  if (parentObject !== void 0 && fromOutputGcsUri != null) {
    setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (parentObject !== void 0 && fromSeed != null) {
    setValueByPath(parentObject, ["parameters", "seed"], fromSeed);
  }
  const fromSafetyFilterLevel = getValueByPath(fromObject, [
    "safetyFilterLevel"
  ]);
  if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
    setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
  }
  const fromPersonGeneration = getValueByPath(fromObject, [
    "personGeneration"
  ]);
  if (parentObject !== void 0 && fromPersonGeneration != null) {
    setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
  }
  const fromAddWatermark = getValueByPath(fromObject, ["addWatermark"]);
  if (parentObject !== void 0 && fromAddWatermark != null) {
    setValueByPath(parentObject, ["parameters", "addWatermark"], fromAddWatermark);
  }
  const fromOutputMimeType = getValueByPath(fromObject, [
    "outputMimeType"
  ]);
  if (parentObject !== void 0 && fromOutputMimeType != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
  }
  const fromOutputCompressionQuality = getValueByPath(fromObject, [
    "outputCompressionQuality"
  ]);
  if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
  }
  const fromEnhancePrompt = getValueByPath(fromObject, [
    "enhancePrompt"
  ]);
  if (parentObject !== void 0 && fromEnhancePrompt != null) {
    setValueByPath(parentObject, ["parameters", "enhancePrompt"], fromEnhancePrompt);
  }
  const fromLabels = getValueByPath(fromObject, ["labels"]);
  if (parentObject !== void 0 && fromLabels != null) {
    setValueByPath(parentObject, ["labels"], fromLabels);
  }
  return toObject;
}
function recontextImageParametersToVertex(apiClient, fromObject, rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromSource = getValueByPath(fromObject, ["source"]);
  if (fromSource != null) {
    recontextImageSourceToVertex(fromSource, toObject);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    recontextImageConfigToVertex(fromConfig, toObject);
  }
  return toObject;
}
function recontextImageResponseFromVertex(fromObject, rootObject) {
  const toObject = {};
  const fromGeneratedImages = getValueByPath(fromObject, [
    "predictions"
  ]);
  if (fromGeneratedImages != null) {
    let transformedList = fromGeneratedImages;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return generatedImageFromVertex(item);
      });
    }
    setValueByPath(toObject, ["generatedImages"], transformedList);
  }
  return toObject;
}
function recontextImageSourceToVertex(fromObject, parentObject, rootObject) {
  const toObject = {};
  const fromPrompt = getValueByPath(fromObject, ["prompt"]);
  if (parentObject !== void 0 && fromPrompt != null) {
    setValueByPath(parentObject, ["instances[0]", "prompt"], fromPrompt);
  }
  const fromPersonImage = getValueByPath(fromObject, ["personImage"]);
  if (parentObject !== void 0 && fromPersonImage != null) {
    setValueByPath(parentObject, ["instances[0]", "personImage", "image"], imageToVertex(fromPersonImage));
  }
  const fromProductImages = getValueByPath(fromObject, [
    "productImages"
  ]);
  if (parentObject !== void 0 && fromProductImages != null) {
    let transformedList = fromProductImages;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return productImageToVertex(item);
      });
    }
    setValueByPath(parentObject, ["instances[0]", "productImages"], transformedList);
  }
  return toObject;
}
function referenceImageAPIInternalToVertex(fromObject, rootObject) {
  const toObject = {};
  const fromReferenceImage = getValueByPath(fromObject, [
    "referenceImage"
  ]);
  if (fromReferenceImage != null) {
    setValueByPath(toObject, ["referenceImage"], imageToVertex(fromReferenceImage));
  }
  const fromReferenceId = getValueByPath(fromObject, ["referenceId"]);
  if (fromReferenceId != null) {
    setValueByPath(toObject, ["referenceId"], fromReferenceId);
  }
  const fromReferenceType = getValueByPath(fromObject, [
    "referenceType"
  ]);
  if (fromReferenceType != null) {
    setValueByPath(toObject, ["referenceType"], fromReferenceType);
  }
  const fromMaskImageConfig = getValueByPath(fromObject, [
    "maskImageConfig"
  ]);
  if (fromMaskImageConfig != null) {
    setValueByPath(toObject, ["maskImageConfig"], maskReferenceConfigToVertex(fromMaskImageConfig));
  }
  const fromControlImageConfig = getValueByPath(fromObject, [
    "controlImageConfig"
  ]);
  if (fromControlImageConfig != null) {
    setValueByPath(toObject, ["controlImageConfig"], controlReferenceConfigToVertex(fromControlImageConfig));
  }
  const fromStyleImageConfig = getValueByPath(fromObject, [
    "styleImageConfig"
  ]);
  if (fromStyleImageConfig != null) {
    setValueByPath(toObject, ["styleImageConfig"], fromStyleImageConfig);
  }
  const fromSubjectImageConfig = getValueByPath(fromObject, [
    "subjectImageConfig"
  ]);
  if (fromSubjectImageConfig != null) {
    setValueByPath(toObject, ["subjectImageConfig"], fromSubjectImageConfig);
  }
  return toObject;
}
function safetyAttributesFromMldev(fromObject, _rootObject) {
  const toObject = {};
  const fromCategories = getValueByPath(fromObject, [
    "safetyAttributes",
    "categories"
  ]);
  if (fromCategories != null) {
    setValueByPath(toObject, ["categories"], fromCategories);
  }
  const fromScores = getValueByPath(fromObject, [
    "safetyAttributes",
    "scores"
  ]);
  if (fromScores != null) {
    setValueByPath(toObject, ["scores"], fromScores);
  }
  const fromContentType = getValueByPath(fromObject, ["contentType"]);
  if (fromContentType != null) {
    setValueByPath(toObject, ["contentType"], fromContentType);
  }
  return toObject;
}
function safetyAttributesFromVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromCategories = getValueByPath(fromObject, [
    "safetyAttributes",
    "categories"
  ]);
  if (fromCategories != null) {
    setValueByPath(toObject, ["categories"], fromCategories);
  }
  const fromScores = getValueByPath(fromObject, [
    "safetyAttributes",
    "scores"
  ]);
  if (fromScores != null) {
    setValueByPath(toObject, ["scores"], fromScores);
  }
  const fromContentType = getValueByPath(fromObject, ["contentType"]);
  if (fromContentType != null) {
    setValueByPath(toObject, ["contentType"], fromContentType);
  }
  return toObject;
}
function safetySettingToMldev(fromObject, _rootObject) {
  const toObject = {};
  const fromCategory = getValueByPath(fromObject, ["category"]);
  if (fromCategory != null) {
    setValueByPath(toObject, ["category"], fromCategory);
  }
  if (getValueByPath(fromObject, ["method"]) !== void 0) {
    throw new Error("method parameter is not supported in Gemini API.");
  }
  const fromThreshold = getValueByPath(fromObject, ["threshold"]);
  if (fromThreshold != null) {
    setValueByPath(toObject, ["threshold"], fromThreshold);
  }
  return toObject;
}
function scribbleImageToVertex(fromObject, rootObject) {
  const toObject = {};
  const fromImage = getValueByPath(fromObject, ["image"]);
  if (fromImage != null) {
    setValueByPath(toObject, ["image"], imageToVertex(fromImage));
  }
  return toObject;
}
function segmentImageConfigToVertex(fromObject, parentObject, _rootObject) {
  const toObject = {};
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (parentObject !== void 0 && fromMode != null) {
    setValueByPath(parentObject, ["parameters", "mode"], fromMode);
  }
  const fromMaxPredictions = getValueByPath(fromObject, [
    "maxPredictions"
  ]);
  if (parentObject !== void 0 && fromMaxPredictions != null) {
    setValueByPath(parentObject, ["parameters", "maxPredictions"], fromMaxPredictions);
  }
  const fromConfidenceThreshold = getValueByPath(fromObject, [
    "confidenceThreshold"
  ]);
  if (parentObject !== void 0 && fromConfidenceThreshold != null) {
    setValueByPath(parentObject, ["parameters", "confidenceThreshold"], fromConfidenceThreshold);
  }
  const fromMaskDilation = getValueByPath(fromObject, ["maskDilation"]);
  if (parentObject !== void 0 && fromMaskDilation != null) {
    setValueByPath(parentObject, ["parameters", "maskDilation"], fromMaskDilation);
  }
  const fromBinaryColorThreshold = getValueByPath(fromObject, [
    "binaryColorThreshold"
  ]);
  if (parentObject !== void 0 && fromBinaryColorThreshold != null) {
    setValueByPath(parentObject, ["parameters", "binaryColorThreshold"], fromBinaryColorThreshold);
  }
  const fromLabels = getValueByPath(fromObject, ["labels"]);
  if (parentObject !== void 0 && fromLabels != null) {
    setValueByPath(parentObject, ["labels"], fromLabels);
  }
  return toObject;
}
function segmentImageParametersToVertex(apiClient, fromObject, rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromSource = getValueByPath(fromObject, ["source"]);
  if (fromSource != null) {
    segmentImageSourceToVertex(fromSource, toObject);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    segmentImageConfigToVertex(fromConfig, toObject);
  }
  return toObject;
}
function segmentImageResponseFromVertex(fromObject, rootObject) {
  const toObject = {};
  const fromGeneratedMasks = getValueByPath(fromObject, ["predictions"]);
  if (fromGeneratedMasks != null) {
    let transformedList = fromGeneratedMasks;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return generatedImageMaskFromVertex(item);
      });
    }
    setValueByPath(toObject, ["generatedMasks"], transformedList);
  }
  return toObject;
}
function segmentImageSourceToVertex(fromObject, parentObject, rootObject) {
  const toObject = {};
  const fromPrompt = getValueByPath(fromObject, ["prompt"]);
  if (parentObject !== void 0 && fromPrompt != null) {
    setValueByPath(parentObject, ["instances[0]", "prompt"], fromPrompt);
  }
  const fromImage = getValueByPath(fromObject, ["image"]);
  if (parentObject !== void 0 && fromImage != null) {
    setValueByPath(parentObject, ["instances[0]", "image"], imageToVertex(fromImage));
  }
  const fromScribbleImage = getValueByPath(fromObject, [
    "scribbleImage"
  ]);
  if (parentObject !== void 0 && fromScribbleImage != null) {
    setValueByPath(parentObject, ["instances[0]", "scribble"], scribbleImageToVertex(fromScribbleImage));
  }
  return toObject;
}
function toolConfigToMldev(fromObject, rootObject) {
  const toObject = {};
  const fromRetrievalConfig = getValueByPath(fromObject, [
    "retrievalConfig"
  ]);
  if (fromRetrievalConfig != null) {
    setValueByPath(toObject, ["retrievalConfig"], fromRetrievalConfig);
  }
  const fromFunctionCallingConfig = getValueByPath(fromObject, [
    "functionCallingConfig"
  ]);
  if (fromFunctionCallingConfig != null) {
    setValueByPath(toObject, ["functionCallingConfig"], functionCallingConfigToMldev(fromFunctionCallingConfig));
  }
  return toObject;
}
function toolToMldev$1(fromObject, rootObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
    throw new Error("retrieval parameter is not supported in Gemini API.");
  }
  const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
  if (fromComputerUse != null) {
    setValueByPath(toObject, ["computerUse"], fromComputerUse);
  }
  const fromFileSearch = getValueByPath(fromObject, ["fileSearch"]);
  if (fromFileSearch != null) {
    setValueByPath(toObject, ["fileSearch"], fromFileSearch);
  }
  const fromCodeExecution = getValueByPath(fromObject, [
    "codeExecution"
  ]);
  if (fromCodeExecution != null) {
    setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
  }
  if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
    throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
  }
  const fromFunctionDeclarations = getValueByPath(fromObject, [
    "functionDeclarations"
  ]);
  if (fromFunctionDeclarations != null) {
    let transformedList = fromFunctionDeclarations;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["functionDeclarations"], transformedList);
  }
  const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
  if (fromGoogleMaps != null) {
    setValueByPath(toObject, ["googleMaps"], googleMapsToMldev$1(fromGoogleMaps));
  }
  const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
  if (fromGoogleSearch != null) {
    setValueByPath(toObject, ["googleSearch"], googleSearchToMldev$1(fromGoogleSearch));
  }
  const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
    "googleSearchRetrieval"
  ]);
  if (fromGoogleSearchRetrieval != null) {
    setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
  }
  const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
  if (fromUrlContext != null) {
    setValueByPath(toObject, ["urlContext"], fromUrlContext);
  }
  return toObject;
}
function toolToVertex(fromObject, rootObject) {
  const toObject = {};
  const fromRetrieval = getValueByPath(fromObject, ["retrieval"]);
  if (fromRetrieval != null) {
    setValueByPath(toObject, ["retrieval"], fromRetrieval);
  }
  const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
  if (fromComputerUse != null) {
    setValueByPath(toObject, ["computerUse"], fromComputerUse);
  }
  if (getValueByPath(fromObject, ["fileSearch"]) !== void 0) {
    throw new Error("fileSearch parameter is not supported in Vertex AI.");
  }
  const fromCodeExecution = getValueByPath(fromObject, [
    "codeExecution"
  ]);
  if (fromCodeExecution != null) {
    setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
  }
  const fromEnterpriseWebSearch = getValueByPath(fromObject, [
    "enterpriseWebSearch"
  ]);
  if (fromEnterpriseWebSearch != null) {
    setValueByPath(toObject, ["enterpriseWebSearch"], fromEnterpriseWebSearch);
  }
  const fromFunctionDeclarations = getValueByPath(fromObject, [
    "functionDeclarations"
  ]);
  if (fromFunctionDeclarations != null) {
    let transformedList = fromFunctionDeclarations;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return functionDeclarationToVertex(item);
      });
    }
    setValueByPath(toObject, ["functionDeclarations"], transformedList);
  }
  const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
  if (fromGoogleMaps != null) {
    setValueByPath(toObject, ["googleMaps"], fromGoogleMaps);
  }
  const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
  if (fromGoogleSearch != null) {
    setValueByPath(toObject, ["googleSearch"], fromGoogleSearch);
  }
  const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
    "googleSearchRetrieval"
  ]);
  if (fromGoogleSearchRetrieval != null) {
    setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
  }
  const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
  if (fromUrlContext != null) {
    setValueByPath(toObject, ["urlContext"], fromUrlContext);
  }
  return toObject;
}
function tunedModelInfoFromMldev(fromObject, _rootObject) {
  const toObject = {};
  const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
  if (fromBaseModel != null) {
    setValueByPath(toObject, ["baseModel"], fromBaseModel);
  }
  const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
  if (fromCreateTime != null) {
    setValueByPath(toObject, ["createTime"], fromCreateTime);
  }
  const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
  if (fromUpdateTime != null) {
    setValueByPath(toObject, ["updateTime"], fromUpdateTime);
  }
  return toObject;
}
function tunedModelInfoFromVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromBaseModel = getValueByPath(fromObject, [
    "labels",
    "google-vertex-llm-tuning-base-model-id"
  ]);
  if (fromBaseModel != null) {
    setValueByPath(toObject, ["baseModel"], fromBaseModel);
  }
  const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
  if (fromCreateTime != null) {
    setValueByPath(toObject, ["createTime"], fromCreateTime);
  }
  const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
  if (fromUpdateTime != null) {
    setValueByPath(toObject, ["updateTime"], fromUpdateTime);
  }
  return toObject;
}
function updateModelConfigToMldev(fromObject, parentObject, _rootObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (parentObject !== void 0 && fromDisplayName != null) {
    setValueByPath(parentObject, ["displayName"], fromDisplayName);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (parentObject !== void 0 && fromDescription != null) {
    setValueByPath(parentObject, ["description"], fromDescription);
  }
  const fromDefaultCheckpointId = getValueByPath(fromObject, [
    "defaultCheckpointId"
  ]);
  if (parentObject !== void 0 && fromDefaultCheckpointId != null) {
    setValueByPath(parentObject, ["defaultCheckpointId"], fromDefaultCheckpointId);
  }
  return toObject;
}
function updateModelConfigToVertex(fromObject, parentObject, _rootObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (parentObject !== void 0 && fromDisplayName != null) {
    setValueByPath(parentObject, ["displayName"], fromDisplayName);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (parentObject !== void 0 && fromDescription != null) {
    setValueByPath(parentObject, ["description"], fromDescription);
  }
  const fromDefaultCheckpointId = getValueByPath(fromObject, [
    "defaultCheckpointId"
  ]);
  if (parentObject !== void 0 && fromDefaultCheckpointId != null) {
    setValueByPath(parentObject, ["defaultCheckpointId"], fromDefaultCheckpointId);
  }
  return toObject;
}
function updateModelParametersToMldev(apiClient, fromObject, rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "name"], tModel(apiClient, fromModel));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    updateModelConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function updateModelParametersToVertex(apiClient, fromObject, rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    updateModelConfigToVertex(fromConfig, toObject);
  }
  return toObject;
}
function upscaleImageAPIConfigInternalToVertex(fromObject, parentObject, _rootObject) {
  const toObject = {};
  const fromOutputGcsUri = getValueByPath(fromObject, ["outputGcsUri"]);
  if (parentObject !== void 0 && fromOutputGcsUri != null) {
    setValueByPath(parentObject, ["parameters", "storageUri"], fromOutputGcsUri);
  }
  const fromSafetyFilterLevel = getValueByPath(fromObject, [
    "safetyFilterLevel"
  ]);
  if (parentObject !== void 0 && fromSafetyFilterLevel != null) {
    setValueByPath(parentObject, ["parameters", "safetySetting"], fromSafetyFilterLevel);
  }
  const fromPersonGeneration = getValueByPath(fromObject, [
    "personGeneration"
  ]);
  if (parentObject !== void 0 && fromPersonGeneration != null) {
    setValueByPath(parentObject, ["parameters", "personGeneration"], fromPersonGeneration);
  }
  const fromIncludeRaiReason = getValueByPath(fromObject, [
    "includeRaiReason"
  ]);
  if (parentObject !== void 0 && fromIncludeRaiReason != null) {
    setValueByPath(parentObject, ["parameters", "includeRaiReason"], fromIncludeRaiReason);
  }
  const fromOutputMimeType = getValueByPath(fromObject, [
    "outputMimeType"
  ]);
  if (parentObject !== void 0 && fromOutputMimeType != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "mimeType"], fromOutputMimeType);
  }
  const fromOutputCompressionQuality = getValueByPath(fromObject, [
    "outputCompressionQuality"
  ]);
  if (parentObject !== void 0 && fromOutputCompressionQuality != null) {
    setValueByPath(parentObject, ["parameters", "outputOptions", "compressionQuality"], fromOutputCompressionQuality);
  }
  const fromEnhanceInputImage = getValueByPath(fromObject, [
    "enhanceInputImage"
  ]);
  if (parentObject !== void 0 && fromEnhanceInputImage != null) {
    setValueByPath(parentObject, ["parameters", "upscaleConfig", "enhanceInputImage"], fromEnhanceInputImage);
  }
  const fromImagePreservationFactor = getValueByPath(fromObject, [
    "imagePreservationFactor"
  ]);
  if (parentObject !== void 0 && fromImagePreservationFactor != null) {
    setValueByPath(parentObject, ["parameters", "upscaleConfig", "imagePreservationFactor"], fromImagePreservationFactor);
  }
  const fromLabels = getValueByPath(fromObject, ["labels"]);
  if (parentObject !== void 0 && fromLabels != null) {
    setValueByPath(parentObject, ["labels"], fromLabels);
  }
  const fromNumberOfImages = getValueByPath(fromObject, [
    "numberOfImages"
  ]);
  if (parentObject !== void 0 && fromNumberOfImages != null) {
    setValueByPath(parentObject, ["parameters", "sampleCount"], fromNumberOfImages);
  }
  const fromMode = getValueByPath(fromObject, ["mode"]);
  if (parentObject !== void 0 && fromMode != null) {
    setValueByPath(parentObject, ["parameters", "mode"], fromMode);
  }
  return toObject;
}
function upscaleImageAPIParametersInternalToVertex(apiClient, fromObject, rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["_url", "model"], tModel(apiClient, fromModel));
  }
  const fromImage = getValueByPath(fromObject, ["image"]);
  if (fromImage != null) {
    setValueByPath(toObject, ["instances[0]", "image"], imageToVertex(fromImage));
  }
  const fromUpscaleFactor = getValueByPath(fromObject, [
    "upscaleFactor"
  ]);
  if (fromUpscaleFactor != null) {
    setValueByPath(toObject, ["parameters", "upscaleConfig", "upscaleFactor"], fromUpscaleFactor);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    upscaleImageAPIConfigInternalToVertex(fromConfig, toObject);
  }
  return toObject;
}
function upscaleImageResponseFromVertex(fromObject, rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromGeneratedImages = getValueByPath(fromObject, [
    "predictions"
  ]);
  if (fromGeneratedImages != null) {
    let transformedList = fromGeneratedImages;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return generatedImageFromVertex(item);
      });
    }
    setValueByPath(toObject, ["generatedImages"], transformedList);
  }
  return toObject;
}
function videoFromMldev(fromObject, _rootObject) {
  const toObject = {};
  const fromUri = getValueByPath(fromObject, ["uri"]);
  if (fromUri != null) {
    setValueByPath(toObject, ["uri"], fromUri);
  }
  const fromVideoBytes = getValueByPath(fromObject, ["encodedVideo"]);
  if (fromVideoBytes != null) {
    setValueByPath(toObject, ["videoBytes"], tBytes(fromVideoBytes));
  }
  const fromMimeType = getValueByPath(fromObject, ["encoding"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function videoFromVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromUri = getValueByPath(fromObject, ["gcsUri"]);
  if (fromUri != null) {
    setValueByPath(toObject, ["uri"], fromUri);
  }
  const fromVideoBytes = getValueByPath(fromObject, [
    "bytesBase64Encoded"
  ]);
  if (fromVideoBytes != null) {
    setValueByPath(toObject, ["videoBytes"], tBytes(fromVideoBytes));
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function videoGenerationMaskToVertex(fromObject, rootObject) {
  const toObject = {};
  const fromImage = getValueByPath(fromObject, ["image"]);
  if (fromImage != null) {
    setValueByPath(toObject, ["_self"], imageToVertex(fromImage));
  }
  const fromMaskMode = getValueByPath(fromObject, ["maskMode"]);
  if (fromMaskMode != null) {
    setValueByPath(toObject, ["maskMode"], fromMaskMode);
  }
  return toObject;
}
function videoGenerationReferenceImageToMldev(fromObject, rootObject) {
  const toObject = {};
  const fromImage = getValueByPath(fromObject, ["image"]);
  if (fromImage != null) {
    setValueByPath(toObject, ["image"], imageToMldev(fromImage));
  }
  const fromReferenceType = getValueByPath(fromObject, [
    "referenceType"
  ]);
  if (fromReferenceType != null) {
    setValueByPath(toObject, ["referenceType"], fromReferenceType);
  }
  return toObject;
}
function videoGenerationReferenceImageToVertex(fromObject, rootObject) {
  const toObject = {};
  const fromImage = getValueByPath(fromObject, ["image"]);
  if (fromImage != null) {
    setValueByPath(toObject, ["image"], imageToVertex(fromImage));
  }
  const fromReferenceType = getValueByPath(fromObject, [
    "referenceType"
  ]);
  if (fromReferenceType != null) {
    setValueByPath(toObject, ["referenceType"], fromReferenceType);
  }
  return toObject;
}
function videoToMldev(fromObject, _rootObject) {
  const toObject = {};
  const fromUri = getValueByPath(fromObject, ["uri"]);
  if (fromUri != null) {
    setValueByPath(toObject, ["uri"], fromUri);
  }
  const fromVideoBytes = getValueByPath(fromObject, ["videoBytes"]);
  if (fromVideoBytes != null) {
    setValueByPath(toObject, ["encodedVideo"], tBytes(fromVideoBytes));
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["encoding"], fromMimeType);
  }
  return toObject;
}
function videoToVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromUri = getValueByPath(fromObject, ["uri"]);
  if (fromUri != null) {
    setValueByPath(toObject, ["gcsUri"], fromUri);
  }
  const fromVideoBytes = getValueByPath(fromObject, ["videoBytes"]);
  if (fromVideoBytes != null) {
    setValueByPath(toObject, ["bytesBase64Encoded"], tBytes(fromVideoBytes));
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function createFileSearchStoreConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (parentObject !== void 0 && fromDisplayName != null) {
    setValueByPath(parentObject, ["displayName"], fromDisplayName);
  }
  return toObject;
}
function createFileSearchStoreParametersToMldev(fromObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    createFileSearchStoreConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function deleteFileSearchStoreConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromForce = getValueByPath(fromObject, ["force"]);
  if (parentObject !== void 0 && fromForce != null) {
    setValueByPath(parentObject, ["_query", "force"], fromForce);
  }
  return toObject;
}
function deleteFileSearchStoreParametersToMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], fromName);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    deleteFileSearchStoreConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function getFileSearchStoreParametersToMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], fromName);
  }
  return toObject;
}
function importFileConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromCustomMetadata = getValueByPath(fromObject, [
    "customMetadata"
  ]);
  if (parentObject !== void 0 && fromCustomMetadata != null) {
    let transformedList = fromCustomMetadata;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(parentObject, ["customMetadata"], transformedList);
  }
  const fromChunkingConfig = getValueByPath(fromObject, [
    "chunkingConfig"
  ]);
  if (parentObject !== void 0 && fromChunkingConfig != null) {
    setValueByPath(parentObject, ["chunkingConfig"], fromChunkingConfig);
  }
  return toObject;
}
function importFileOperationFromMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromMetadata = getValueByPath(fromObject, ["metadata"]);
  if (fromMetadata != null) {
    setValueByPath(toObject, ["metadata"], fromMetadata);
  }
  const fromDone = getValueByPath(fromObject, ["done"]);
  if (fromDone != null) {
    setValueByPath(toObject, ["done"], fromDone);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fromError);
  }
  const fromResponse = getValueByPath(fromObject, ["response"]);
  if (fromResponse != null) {
    setValueByPath(toObject, ["response"], importFileResponseFromMldev(fromResponse));
  }
  return toObject;
}
function importFileParametersToMldev(fromObject) {
  const toObject = {};
  const fromFileSearchStoreName = getValueByPath(fromObject, [
    "fileSearchStoreName"
  ]);
  if (fromFileSearchStoreName != null) {
    setValueByPath(toObject, ["_url", "file_search_store_name"], fromFileSearchStoreName);
  }
  const fromFileName = getValueByPath(fromObject, ["fileName"]);
  if (fromFileName != null) {
    setValueByPath(toObject, ["fileName"], fromFileName);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    importFileConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function importFileResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromParent = getValueByPath(fromObject, ["parent"]);
  if (fromParent != null) {
    setValueByPath(toObject, ["parent"], fromParent);
  }
  const fromDocumentName = getValueByPath(fromObject, ["documentName"]);
  if (fromDocumentName != null) {
    setValueByPath(toObject, ["documentName"], fromDocumentName);
  }
  return toObject;
}
function listFileSearchStoresConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== void 0 && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== void 0 && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  return toObject;
}
function listFileSearchStoresParametersToMldev(fromObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    listFileSearchStoresConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function listFileSearchStoresResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromFileSearchStores = getValueByPath(fromObject, [
    "fileSearchStores"
  ]);
  if (fromFileSearchStores != null) {
    let transformedList = fromFileSearchStores;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["fileSearchStores"], transformedList);
  }
  return toObject;
}
function uploadToFileSearchStoreConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (parentObject !== void 0 && fromMimeType != null) {
    setValueByPath(parentObject, ["mimeType"], fromMimeType);
  }
  const fromDisplayName = getValueByPath(fromObject, ["displayName"]);
  if (parentObject !== void 0 && fromDisplayName != null) {
    setValueByPath(parentObject, ["displayName"], fromDisplayName);
  }
  const fromCustomMetadata = getValueByPath(fromObject, [
    "customMetadata"
  ]);
  if (parentObject !== void 0 && fromCustomMetadata != null) {
    let transformedList = fromCustomMetadata;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(parentObject, ["customMetadata"], transformedList);
  }
  const fromChunkingConfig = getValueByPath(fromObject, [
    "chunkingConfig"
  ]);
  if (parentObject !== void 0 && fromChunkingConfig != null) {
    setValueByPath(parentObject, ["chunkingConfig"], fromChunkingConfig);
  }
  return toObject;
}
function uploadToFileSearchStoreParametersToMldev(fromObject) {
  const toObject = {};
  const fromFileSearchStoreName = getValueByPath(fromObject, [
    "fileSearchStoreName"
  ]);
  if (fromFileSearchStoreName != null) {
    setValueByPath(toObject, ["_url", "file_search_store_name"], fromFileSearchStoreName);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    uploadToFileSearchStoreConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function uploadToFileSearchStoreResumableResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  return toObject;
}
var CONTENT_TYPE_HEADER = "Content-Type";
var SERVER_TIMEOUT_HEADER = "X-Server-Timeout";
var USER_AGENT_HEADER = "User-Agent";
var GOOGLE_API_CLIENT_HEADER = "x-goog-api-client";
var SDK_VERSION = "1.40.0";
var LIBRARY_LABEL = `google-genai-sdk/${SDK_VERSION}`;
var VERTEX_AI_API_DEFAULT_VERSION = "v1beta1";
var GOOGLE_AI_API_DEFAULT_VERSION = "v1beta";
var ApiClient = class {
  constructor(opts) {
    var _a5, _b, _c;
    this.clientOptions = Object.assign({}, opts);
    this.customBaseUrl = (_a5 = opts.httpOptions) === null || _a5 === void 0 ? void 0 : _a5.baseUrl;
    if (this.clientOptions.vertexai) {
      if (this.clientOptions.project && this.clientOptions.location) {
        this.clientOptions.apiKey = void 0;
      } else if (this.clientOptions.apiKey) {
        this.clientOptions.project = void 0;
        this.clientOptions.location = void 0;
      }
    }
    const initHttpOptions = {};
    if (this.clientOptions.vertexai) {
      if (!this.clientOptions.location && !this.clientOptions.apiKey && !this.customBaseUrl) {
        this.clientOptions.location = "global";
      }
      const hasSufficientAuth = this.clientOptions.project && this.clientOptions.location || this.clientOptions.apiKey;
      if (!hasSufficientAuth && !this.customBaseUrl) {
        throw new Error("Authentication is not set up. Please provide either a project and location, or an API key, or a custom base URL.");
      }
      const hasConstructorAuth = opts.project && opts.location || !!opts.apiKey;
      if (this.customBaseUrl && !hasConstructorAuth) {
        initHttpOptions.baseUrl = this.customBaseUrl;
        this.clientOptions.project = void 0;
        this.clientOptions.location = void 0;
      } else if (this.clientOptions.apiKey || this.clientOptions.location === "global") {
        initHttpOptions.baseUrl = "https://aiplatform.googleapis.com/";
      } else if (this.clientOptions.project && this.clientOptions.location) {
        initHttpOptions.baseUrl = `https://${this.clientOptions.location}-aiplatform.googleapis.com/`;
      }
      initHttpOptions.apiVersion = (_b = this.clientOptions.apiVersion) !== null && _b !== void 0 ? _b : VERTEX_AI_API_DEFAULT_VERSION;
    } else {
      if (!this.clientOptions.apiKey) {
        throw new ApiError({
          message: "API key must be set when using the Gemini API.",
          status: 403
        });
      }
      initHttpOptions.apiVersion = (_c = this.clientOptions.apiVersion) !== null && _c !== void 0 ? _c : GOOGLE_AI_API_DEFAULT_VERSION;
      initHttpOptions.baseUrl = `https://generativelanguage.googleapis.com/`;
    }
    initHttpOptions.headers = this.getDefaultHeaders();
    this.clientOptions.httpOptions = initHttpOptions;
    if (opts.httpOptions) {
      this.clientOptions.httpOptions = this.patchHttpOptions(initHttpOptions, opts.httpOptions);
    }
  }
  isVertexAI() {
    var _a5;
    return (_a5 = this.clientOptions.vertexai) !== null && _a5 !== void 0 ? _a5 : false;
  }
  getProject() {
    return this.clientOptions.project;
  }
  getLocation() {
    return this.clientOptions.location;
  }
  getCustomBaseUrl() {
    return this.customBaseUrl;
  }
  async getAuthHeaders() {
    const headers = new Headers();
    await this.clientOptions.auth.addAuthHeaders(headers);
    return headers;
  }
  getApiVersion() {
    if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.apiVersion !== void 0) {
      return this.clientOptions.httpOptions.apiVersion;
    }
    throw new Error("API version is not set.");
  }
  getBaseUrl() {
    if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.baseUrl !== void 0) {
      return this.clientOptions.httpOptions.baseUrl;
    }
    throw new Error("Base URL is not set.");
  }
  getRequestUrl() {
    return this.getRequestUrlInternal(this.clientOptions.httpOptions);
  }
  getHeaders() {
    if (this.clientOptions.httpOptions && this.clientOptions.httpOptions.headers !== void 0) {
      return this.clientOptions.httpOptions.headers;
    } else {
      throw new Error("Headers are not set.");
    }
  }
  getRequestUrlInternal(httpOptions) {
    if (!httpOptions || httpOptions.baseUrl === void 0 || httpOptions.apiVersion === void 0) {
      throw new Error("HTTP options are not correctly set.");
    }
    const baseUrl = httpOptions.baseUrl.endsWith("/") ? httpOptions.baseUrl.slice(0, -1) : httpOptions.baseUrl;
    const urlElement = [baseUrl];
    if (httpOptions.apiVersion && httpOptions.apiVersion !== "") {
      urlElement.push(httpOptions.apiVersion);
    }
    return urlElement.join("/");
  }
  getBaseResourcePath() {
    return `projects/${this.clientOptions.project}/locations/${this.clientOptions.location}`;
  }
  getApiKey() {
    return this.clientOptions.apiKey;
  }
  getWebsocketBaseUrl() {
    const baseUrl = this.getBaseUrl();
    const urlParts = new URL(baseUrl);
    urlParts.protocol = urlParts.protocol == "http:" ? "ws" : "wss";
    return urlParts.toString();
  }
  setBaseUrl(url) {
    if (this.clientOptions.httpOptions) {
      this.clientOptions.httpOptions.baseUrl = url;
    } else {
      throw new Error("HTTP options are not correctly set.");
    }
  }
  constructUrl(path4, httpOptions, prependProjectLocation) {
    const urlElement = [this.getRequestUrlInternal(httpOptions)];
    if (prependProjectLocation) {
      urlElement.push(this.getBaseResourcePath());
    }
    if (path4 !== "") {
      urlElement.push(path4);
    }
    const url = new URL(`${urlElement.join("/")}`);
    return url;
  }
  shouldPrependVertexProjectPath(request, httpOptions) {
    if (httpOptions.baseUrl && httpOptions.baseUrlResourceScope === ResourceScope.COLLECTION) {
      return false;
    }
    if (this.clientOptions.apiKey) {
      return false;
    }
    if (!this.clientOptions.vertexai) {
      return false;
    }
    if (request.path.startsWith("projects/")) {
      return false;
    }
    if (request.httpMethod === "GET" && request.path.startsWith("publishers/google/models")) {
      return false;
    }
    return true;
  }
  async request(request) {
    let patchedHttpOptions = this.clientOptions.httpOptions;
    if (request.httpOptions) {
      patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);
    }
    const prependProjectLocation = this.shouldPrependVertexProjectPath(request, patchedHttpOptions);
    const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);
    if (request.queryParams) {
      for (const [key, value] of Object.entries(request.queryParams)) {
        url.searchParams.append(key, String(value));
      }
    }
    let requestInit = {};
    if (request.httpMethod === "GET") {
      if (request.body && request.body !== "{}") {
        throw new Error("Request body should be empty for GET request, but got non empty request body");
      }
    } else {
      requestInit.body = request.body;
    }
    requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, url.toString(), request.abortSignal);
    return this.unaryApiCall(url, requestInit, request.httpMethod);
  }
  patchHttpOptions(baseHttpOptions, requestHttpOptions) {
    const patchedHttpOptions = JSON.parse(JSON.stringify(baseHttpOptions));
    for (const [key, value] of Object.entries(requestHttpOptions)) {
      if (typeof value === "object") {
        patchedHttpOptions[key] = Object.assign(Object.assign({}, patchedHttpOptions[key]), value);
      } else if (value !== void 0) {
        patchedHttpOptions[key] = value;
      }
    }
    return patchedHttpOptions;
  }
  async requestStream(request) {
    let patchedHttpOptions = this.clientOptions.httpOptions;
    if (request.httpOptions) {
      patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);
    }
    const prependProjectLocation = this.shouldPrependVertexProjectPath(request, patchedHttpOptions);
    const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);
    if (!url.searchParams.has("alt") || url.searchParams.get("alt") !== "sse") {
      url.searchParams.set("alt", "sse");
    }
    let requestInit = {};
    requestInit.body = request.body;
    requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, url.toString(), request.abortSignal);
    return this.streamApiCall(url, requestInit, request.httpMethod);
  }
  async includeExtraHttpOptionsToRequestInit(requestInit, httpOptions, url, abortSignal) {
    if (httpOptions && httpOptions.timeout || abortSignal) {
      const abortController = new AbortController();
      const signal = abortController.signal;
      if (httpOptions.timeout && (httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.timeout) > 0) {
        const timeoutHandle = setTimeout(() => abortController.abort(), httpOptions.timeout);
        if (timeoutHandle && typeof timeoutHandle.unref === "function") {
          timeoutHandle.unref();
        }
      }
      if (abortSignal) {
        abortSignal.addEventListener("abort", () => {
          abortController.abort();
        });
      }
      requestInit.signal = signal;
    }
    if (httpOptions && httpOptions.extraBody !== null) {
      includeExtraBodyToRequestInit(requestInit, httpOptions.extraBody);
    }
    requestInit.headers = await this.getHeadersInternal(httpOptions, url);
    return requestInit;
  }
  async unaryApiCall(url, requestInit, httpMethod) {
    return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), { method: httpMethod })).then(async (response) => {
      await throwErrorIfNotOK(response);
      return new HttpResponse(response);
    }).catch((e3) => {
      if (e3 instanceof Error) {
        throw e3;
      } else {
        throw new Error(JSON.stringify(e3));
      }
    });
  }
  async streamApiCall(url, requestInit, httpMethod) {
    return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), { method: httpMethod })).then(async (response) => {
      await throwErrorIfNotOK(response);
      return this.processStreamResponse(response);
    }).catch((e3) => {
      if (e3 instanceof Error) {
        throw e3;
      } else {
        throw new Error(JSON.stringify(e3));
      }
    });
  }
  processStreamResponse(response) {
    return __asyncGenerator(this, arguments, function* processStreamResponse_1() {
      var _a5;
      const reader = (_a5 = response === null || response === void 0 ? void 0 : response.body) === null || _a5 === void 0 ? void 0 : _a5.getReader();
      const decoder = new TextDecoder("utf-8");
      if (!reader) {
        throw new Error("Response body is empty");
      }
      try {
        let buffer = "";
        const dataPrefix = "data:";
        const delimiters = ["\n\n", "\r\r", "\r\n\r\n"];
        while (true) {
          const { done, value } = yield __await(reader.read());
          if (done) {
            if (buffer.trim().length > 0) {
              throw new Error("Incomplete JSON segment at the end");
            }
            break;
          }
          const chunkString = decoder.decode(value, { stream: true });
          try {
            const chunkJson = JSON.parse(chunkString);
            if ("error" in chunkJson) {
              const errorJson = JSON.parse(JSON.stringify(chunkJson["error"]));
              const status = errorJson["status"];
              const code = errorJson["code"];
              const errorMessage = `got status: ${status}. ${JSON.stringify(chunkJson)}`;
              if (code >= 400 && code < 600) {
                const apiError = new ApiError({
                  message: errorMessage,
                  status: code
                });
                throw apiError;
              }
            }
          } catch (e3) {
            const error = e3;
            if (error.name === "ApiError") {
              throw e3;
            }
          }
          buffer += chunkString;
          let delimiterIndex = -1;
          let delimiterLength = 0;
          while (true) {
            delimiterIndex = -1;
            delimiterLength = 0;
            for (const delimiter of delimiters) {
              const index = buffer.indexOf(delimiter);
              if (index !== -1 && (delimiterIndex === -1 || index < delimiterIndex)) {
                delimiterIndex = index;
                delimiterLength = delimiter.length;
              }
            }
            if (delimiterIndex === -1) {
              break;
            }
            const eventString = buffer.substring(0, delimiterIndex);
            buffer = buffer.substring(delimiterIndex + delimiterLength);
            const trimmedEvent = eventString.trim();
            if (trimmedEvent.startsWith(dataPrefix)) {
              const processedChunkString = trimmedEvent.substring(dataPrefix.length).trim();
              try {
                const partialResponse = new Response(processedChunkString, {
                  headers: response === null || response === void 0 ? void 0 : response.headers,
                  status: response === null || response === void 0 ? void 0 : response.status,
                  statusText: response === null || response === void 0 ? void 0 : response.statusText
                });
                yield yield __await(new HttpResponse(partialResponse));
              } catch (e3) {
                throw new Error(`exception parsing stream chunk ${processedChunkString}. ${e3}`);
              }
            }
          }
        }
      } finally {
        reader.releaseLock();
      }
    });
  }
  async apiCall(url, requestInit) {
    return fetch(url, requestInit).catch((e3) => {
      throw new Error(`exception ${e3} sending request`);
    });
  }
  getDefaultHeaders() {
    const headers = {};
    const versionHeaderValue = LIBRARY_LABEL + " " + this.clientOptions.userAgentExtra;
    headers[USER_AGENT_HEADER] = versionHeaderValue;
    headers[GOOGLE_API_CLIENT_HEADER] = versionHeaderValue;
    headers[CONTENT_TYPE_HEADER] = "application/json";
    return headers;
  }
  async getHeadersInternal(httpOptions, url) {
    const headers = new Headers();
    if (httpOptions && httpOptions.headers) {
      for (const [key, value] of Object.entries(httpOptions.headers)) {
        headers.append(key, value);
      }
      if (httpOptions.timeout && httpOptions.timeout > 0) {
        headers.append(SERVER_TIMEOUT_HEADER, String(Math.ceil(httpOptions.timeout / 1e3)));
      }
    }
    await this.clientOptions.auth.addAuthHeaders(headers, url);
    return headers;
  }
  getFileName(file) {
    var _a5;
    let fileName = "";
    if (typeof file === "string") {
      fileName = file.replace(/[/\\]+$/, "");
      fileName = (_a5 = fileName.split(/[/\\]/).pop()) !== null && _a5 !== void 0 ? _a5 : "";
    }
    return fileName;
  }
  /**
   * Uploads a file asynchronously using Gemini API only, this is not supported
   * in Vertex AI.
   *
   * @param file The string path to the file to be uploaded or a Blob object.
   * @param config Optional parameters specified in the `UploadFileConfig`
   *     interface. @see {@link types.UploadFileConfig}
   * @return A promise that resolves to a `File` object.
   * @throws An error if called on a Vertex AI client.
   * @throws An error if the `mimeType` is not provided and can not be inferred,
   */
  async uploadFile(file, config) {
    var _a5;
    const fileToUpload = {};
    if (config != null) {
      fileToUpload.mimeType = config.mimeType;
      fileToUpload.name = config.name;
      fileToUpload.displayName = config.displayName;
    }
    if (fileToUpload.name && !fileToUpload.name.startsWith("files/")) {
      fileToUpload.name = `files/${fileToUpload.name}`;
    }
    const uploader = this.clientOptions.uploader;
    const fileStat = await uploader.stat(file);
    fileToUpload.sizeBytes = String(fileStat.size);
    const mimeType = (_a5 = config === null || config === void 0 ? void 0 : config.mimeType) !== null && _a5 !== void 0 ? _a5 : fileStat.type;
    if (mimeType === void 0 || mimeType === "") {
      throw new Error("Can not determine mimeType. Please provide mimeType in the config.");
    }
    fileToUpload.mimeType = mimeType;
    const body = {
      file: fileToUpload
    };
    const fileName = this.getFileName(file);
    const path4 = formatMap("upload/v1beta/files", body["_url"]);
    const uploadUrl = await this.fetchUploadUrl(path4, fileToUpload.sizeBytes, fileToUpload.mimeType, fileName, body, config === null || config === void 0 ? void 0 : config.httpOptions);
    return uploader.upload(file, uploadUrl, this);
  }
  /**
   * Uploads a file to a given file search store asynchronously using Gemini API only, this is not supported
   * in Vertex AI.
   *
   * @param fileSearchStoreName The name of the file search store to upload the file to.
   * @param file The string path to the file to be uploaded or a Blob object.
   * @param config Optional parameters specified in the `UploadFileConfig`
   *     interface. @see {@link UploadFileConfig}
   * @return A promise that resolves to a `File` object.
   * @throws An error if called on a Vertex AI client.
   * @throws An error if the `mimeType` is not provided and can not be inferred,
   */
  async uploadFileToFileSearchStore(fileSearchStoreName, file, config) {
    var _a5;
    const uploader = this.clientOptions.uploader;
    const fileStat = await uploader.stat(file);
    const sizeBytes = String(fileStat.size);
    const mimeType = (_a5 = config === null || config === void 0 ? void 0 : config.mimeType) !== null && _a5 !== void 0 ? _a5 : fileStat.type;
    if (mimeType === void 0 || mimeType === "") {
      throw new Error("Can not determine mimeType. Please provide mimeType in the config.");
    }
    const path4 = `upload/v1beta/${fileSearchStoreName}:uploadToFileSearchStore`;
    const fileName = this.getFileName(file);
    const body = {};
    if (config != null) {
      uploadToFileSearchStoreConfigToMldev(config, body);
    }
    const uploadUrl = await this.fetchUploadUrl(path4, sizeBytes, mimeType, fileName, body, config === null || config === void 0 ? void 0 : config.httpOptions);
    return uploader.uploadToFileSearchStore(file, uploadUrl, this);
  }
  /**
   * Downloads a file asynchronously to the specified path.
   *
   * @params params - The parameters for the download request, see {@link
   * types.DownloadFileParameters}
   */
  async downloadFile(params) {
    const downloader = this.clientOptions.downloader;
    await downloader.download(params, this);
  }
  async fetchUploadUrl(path4, sizeBytes, mimeType, fileName, body, configHttpOptions) {
    var _a5;
    let httpOptions = {};
    if (configHttpOptions) {
      httpOptions = configHttpOptions;
    } else {
      httpOptions = {
        apiVersion: "",
        // api-version is set in the path.
        headers: Object.assign({ "Content-Type": "application/json", "X-Goog-Upload-Protocol": "resumable", "X-Goog-Upload-Command": "start", "X-Goog-Upload-Header-Content-Length": `${sizeBytes}`, "X-Goog-Upload-Header-Content-Type": `${mimeType}` }, fileName ? { "X-Goog-Upload-File-Name": fileName } : {})
      };
    }
    const httpResponse = await this.request({
      path: path4,
      body: JSON.stringify(body),
      httpMethod: "POST",
      httpOptions
    });
    if (!httpResponse || !(httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers)) {
      throw new Error("Server did not return an HttpResponse or the returned HttpResponse did not have headers.");
    }
    const uploadUrl = (_a5 = httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers) === null || _a5 === void 0 ? void 0 : _a5["x-goog-upload-url"];
    if (uploadUrl === void 0) {
      throw new Error("Failed to get upload url. Server did not return the x-google-upload-url in the headers");
    }
    return uploadUrl;
  }
};
async function throwErrorIfNotOK(response) {
  var _a5;
  if (response === void 0) {
    throw new Error("response is undefined");
  }
  if (!response.ok) {
    const status = response.status;
    let errorBody;
    if ((_a5 = response.headers.get("content-type")) === null || _a5 === void 0 ? void 0 : _a5.includes("application/json")) {
      errorBody = await response.json();
    } else {
      errorBody = {
        error: {
          message: await response.text(),
          code: response.status,
          status: response.statusText
        }
      };
    }
    const errorMessage = JSON.stringify(errorBody);
    if (status >= 400 && status < 600) {
      const apiError = new ApiError({
        message: errorMessage,
        status
      });
      throw apiError;
    }
    throw new Error(errorMessage);
  }
}
function includeExtraBodyToRequestInit(requestInit, extraBody) {
  if (!extraBody || Object.keys(extraBody).length === 0) {
    return;
  }
  if (requestInit.body instanceof Blob) {
    console.warn("includeExtraBodyToRequestInit: extraBody provided but current request body is a Blob. extraBody will be ignored as merging is not supported for Blob bodies.");
    return;
  }
  let currentBodyObject = {};
  if (typeof requestInit.body === "string" && requestInit.body.length > 0) {
    try {
      const parsedBody = JSON.parse(requestInit.body);
      if (typeof parsedBody === "object" && parsedBody !== null && !Array.isArray(parsedBody)) {
        currentBodyObject = parsedBody;
      } else {
        console.warn("includeExtraBodyToRequestInit: Original request body is valid JSON but not a non-array object. Skip applying extraBody to the request body.");
        return;
      }
    } catch (e3) {
      console.warn("includeExtraBodyToRequestInit: Original request body is not valid JSON. Skip applying extraBody to the request body.");
      return;
    }
  }
  function deepMerge(target, source) {
    const output = Object.assign({}, target);
    for (const key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        const sourceValue = source[key];
        const targetValue = output[key];
        if (sourceValue && typeof sourceValue === "object" && !Array.isArray(sourceValue) && targetValue && typeof targetValue === "object" && !Array.isArray(targetValue)) {
          output[key] = deepMerge(targetValue, sourceValue);
        } else {
          if (targetValue && sourceValue && typeof targetValue !== typeof sourceValue) {
            console.warn(`includeExtraBodyToRequestInit:deepMerge: Type mismatch for key "${key}". Original type: ${typeof targetValue}, New type: ${typeof sourceValue}. Overwriting.`);
          }
          output[key] = sourceValue;
        }
      }
    }
    return output;
  }
  const mergedBody = deepMerge(currentBodyObject, extraBody);
  requestInit.body = JSON.stringify(mergedBody);
}
var MCP_LABEL = "mcp_used/unknown";
var hasMcpToolUsageFromMcpToTool = false;
function hasMcpToolUsage(tools) {
  for (const tool of tools) {
    if (isMcpCallableTool(tool)) {
      return true;
    }
    if (typeof tool === "object" && "inputSchema" in tool) {
      return true;
    }
  }
  return hasMcpToolUsageFromMcpToTool;
}
function setMcpUsageHeader(headers) {
  var _a5;
  const existingHeader = (_a5 = headers[GOOGLE_API_CLIENT_HEADER]) !== null && _a5 !== void 0 ? _a5 : "";
  headers[GOOGLE_API_CLIENT_HEADER] = (existingHeader + ` ${MCP_LABEL}`).trimStart();
}
function isMcpCallableTool(object) {
  return object !== null && typeof object === "object" && object instanceof McpCallableTool;
}
function listAllTools(mcpClient_1) {
  return __asyncGenerator(this, arguments, function* listAllTools_1(mcpClient, maxTools = 100) {
    let cursor = void 0;
    let numTools = 0;
    while (numTools < maxTools) {
      const t = yield __await(mcpClient.listTools({ cursor }));
      for (const tool of t.tools) {
        yield yield __await(tool);
        numTools++;
      }
      if (!t.nextCursor) {
        break;
      }
      cursor = t.nextCursor;
    }
  });
}
var McpCallableTool = class _McpCallableTool {
  constructor(mcpClients = [], config) {
    this.mcpTools = [];
    this.functionNameToMcpClient = {};
    this.mcpClients = mcpClients;
    this.config = config;
  }
  /**
   * Creates a McpCallableTool.
   */
  static create(mcpClients, config) {
    return new _McpCallableTool(mcpClients, config);
  }
  /**
   * Validates the function names are not duplicate and initialize the function
   * name to MCP client mapping.
   *
   * @throws {Error} if the MCP tools from the MCP clients have duplicate tool
   *     names.
   */
  async initialize() {
    var _a5, e_1, _b, _c;
    if (this.mcpTools.length > 0) {
      return;
    }
    const functionMap = {};
    const mcpTools = [];
    for (const mcpClient of this.mcpClients) {
      try {
        for (var _d = true, _e = (e_1 = void 0, __asyncValues(listAllTools(mcpClient))), _f; _f = await _e.next(), _a5 = _f.done, !_a5; _d = true) {
          _c = _f.value;
          _d = false;
          const mcpTool = _c;
          mcpTools.push(mcpTool);
          const mcpToolName = mcpTool.name;
          if (functionMap[mcpToolName]) {
            throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);
          }
          functionMap[mcpToolName] = mcpClient;
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (!_d && !_a5 && (_b = _e.return)) await _b.call(_e);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
    }
    this.mcpTools = mcpTools;
    this.functionNameToMcpClient = functionMap;
  }
  async tool() {
    await this.initialize();
    return mcpToolsToGeminiTool(this.mcpTools, this.config);
  }
  async callTool(functionCalls) {
    await this.initialize();
    const functionCallResponseParts = [];
    for (const functionCall of functionCalls) {
      if (functionCall.name in this.functionNameToMcpClient) {
        const mcpClient = this.functionNameToMcpClient[functionCall.name];
        let requestOptions = void 0;
        if (this.config.timeout) {
          requestOptions = {
            timeout: this.config.timeout
          };
        }
        const callToolResponse = await mcpClient.callTool(
          {
            name: functionCall.name,
            arguments: functionCall.args
          },
          // Set the result schema to undefined to allow MCP to rely on the
          // default schema.
          void 0,
          requestOptions
        );
        functionCallResponseParts.push({
          functionResponse: {
            name: functionCall.name,
            response: callToolResponse.isError ? { error: callToolResponse } : callToolResponse
          }
        });
      }
    }
    return functionCallResponseParts;
  }
};
async function handleWebSocketMessage$1(apiClient, onmessage, event) {
  const serverMessage = new LiveMusicServerMessage();
  let data;
  if (event.data instanceof Blob) {
    data = JSON.parse(await event.data.text());
  } else {
    data = JSON.parse(event.data);
  }
  Object.assign(serverMessage, data);
  onmessage(serverMessage);
}
var LiveMusic = class {
  constructor(apiClient, auth, webSocketFactory) {
    this.apiClient = apiClient;
    this.auth = auth;
    this.webSocketFactory = webSocketFactory;
  }
  /**
       Establishes a connection to the specified model and returns a
       LiveMusicSession object representing that connection.
  
       @experimental
  
       @remarks
  
       @param params - The parameters for establishing a connection to the model.
       @return A live session.
  
       @example
       ```ts
       let model = 'models/lyria-realtime-exp';
       const session = await ai.live.music.connect({
         model: model,
         callbacks: {
           onmessage: (e: MessageEvent) => {
             console.log('Received message from the server: %s\n', debug(e.data));
           },
           onerror: (e: ErrorEvent) => {
             console.log('Error occurred: %s\n', debug(e.error));
           },
           onclose: (e: CloseEvent) => {
             console.log('Connection closed.');
           },
         },
       });
       ```
      */
  async connect(params) {
    var _a5, _b;
    if (this.apiClient.isVertexAI()) {
      throw new Error("Live music is not supported for Vertex AI.");
    }
    console.warn("Live music generation is experimental and may change in future versions.");
    const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();
    const apiVersion = this.apiClient.getApiVersion();
    const headers = mapToHeaders$1(this.apiClient.getDefaultHeaders());
    const apiKey = this.apiClient.getApiKey();
    const url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.BidiGenerateMusic?key=${apiKey}`;
    let onopenResolve = () => {
    };
    const onopenPromise = new Promise((resolve) => {
      onopenResolve = resolve;
    });
    const callbacks = params.callbacks;
    const onopenAwaitedCallback = function() {
      onopenResolve({});
    };
    const apiClient = this.apiClient;
    const websocketCallbacks = {
      onopen: onopenAwaitedCallback,
      onmessage: (event) => {
        void handleWebSocketMessage$1(apiClient, callbacks.onmessage, event);
      },
      onerror: (_a5 = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a5 !== void 0 ? _a5 : function(e3) {
      },
      onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function(e3) {
      }
    };
    const conn = this.webSocketFactory.create(url, headersToMap$1(headers), websocketCallbacks);
    conn.connect();
    await onopenPromise;
    const model = tModel(this.apiClient, params.model);
    const setup = { model };
    const clientMessage = { setup };
    conn.send(JSON.stringify(clientMessage));
    return new LiveMusicSession(conn, this.apiClient);
  }
};
var LiveMusicSession = class {
  constructor(conn, apiClient) {
    this.conn = conn;
    this.apiClient = apiClient;
  }
  /**
      Sets inputs to steer music generation. Updates the session's current
      weighted prompts.
  
      @param params - Contains one property, `weightedPrompts`.
  
        - `weightedPrompts` to send to the model; weights are normalized to
          sum to 1.0.
  
      @experimental
     */
  async setWeightedPrompts(params) {
    if (!params.weightedPrompts || Object.keys(params.weightedPrompts).length === 0) {
      throw new Error("Weighted prompts must be set and contain at least one entry.");
    }
    const clientContent = liveMusicSetWeightedPromptsParametersToMldev(params);
    this.conn.send(JSON.stringify({ clientContent }));
  }
  /**
      Sets a configuration to the model. Updates the session's current
      music generation config.
  
      @param params - Contains one property, `musicGenerationConfig`.
  
        - `musicGenerationConfig` to set in the model. Passing an empty or
      undefined config to the model will reset the config to defaults.
  
      @experimental
     */
  async setMusicGenerationConfig(params) {
    if (!params.musicGenerationConfig) {
      params.musicGenerationConfig = {};
    }
    const setConfigParameters = liveMusicSetConfigParametersToMldev(params);
    this.conn.send(JSON.stringify(setConfigParameters));
  }
  sendPlaybackControl(playbackControl) {
    const clientMessage = { playbackControl };
    this.conn.send(JSON.stringify(clientMessage));
  }
  /**
   * Start the music stream.
   *
   * @experimental
   */
  play() {
    this.sendPlaybackControl(LiveMusicPlaybackControl.PLAY);
  }
  /**
   * Temporarily halt the music stream. Use `play` to resume from the current
   * position.
   *
   * @experimental
   */
  pause() {
    this.sendPlaybackControl(LiveMusicPlaybackControl.PAUSE);
  }
  /**
   * Stop the music stream and reset the state. Retains the current prompts
   * and config.
   *
   * @experimental
   */
  stop() {
    this.sendPlaybackControl(LiveMusicPlaybackControl.STOP);
  }
  /**
   * Resets the context of the music generation without stopping it.
   * Retains the current prompts and config.
   *
   * @experimental
   */
  resetContext() {
    this.sendPlaybackControl(LiveMusicPlaybackControl.RESET_CONTEXT);
  }
  /**
       Terminates the WebSocket connection.
  
       @experimental
     */
  close() {
    this.conn.close();
  }
};
function headersToMap$1(headers) {
  const headerMap = {};
  headers.forEach((value, key) => {
    headerMap[key] = value;
  });
  return headerMap;
}
function mapToHeaders$1(map) {
  const headers = new Headers();
  for (const [key, value] of Object.entries(map)) {
    headers.append(key, value);
  }
  return headers;
}
var FUNCTION_RESPONSE_REQUIRES_ID = "FunctionResponse request must have an `id` field from the response of a ToolCall.FunctionalCalls in Google AI.";
async function handleWebSocketMessage(apiClient, onmessage, event) {
  const serverMessage = new LiveServerMessage();
  let jsonData;
  if (event.data instanceof Blob) {
    jsonData = await event.data.text();
  } else if (event.data instanceof ArrayBuffer) {
    jsonData = new TextDecoder().decode(event.data);
  } else {
    jsonData = event.data;
  }
  const data = JSON.parse(jsonData);
  if (apiClient.isVertexAI()) {
    const resp = liveServerMessageFromVertex(data);
    Object.assign(serverMessage, resp);
  } else {
    const resp = data;
    Object.assign(serverMessage, resp);
  }
  onmessage(serverMessage);
}
var Live = class {
  constructor(apiClient, auth, webSocketFactory) {
    this.apiClient = apiClient;
    this.auth = auth;
    this.webSocketFactory = webSocketFactory;
    this.music = new LiveMusic(this.apiClient, this.auth, this.webSocketFactory);
  }
  /**
       Establishes a connection to the specified model with the given
       configuration and returns a Session object representing that connection.
  
       @experimental Built-in MCP support is an experimental feature, may change in
       future versions.
  
       @remarks
  
       @param params - The parameters for establishing a connection to the model.
       @return A live session.
  
       @example
       ```ts
       let model: string;
       if (GOOGLE_GENAI_USE_VERTEXAI) {
         model = 'gemini-2.0-flash-live-preview-04-09';
       } else {
         model = 'gemini-live-2.5-flash-preview';
       }
       const session = await ai.live.connect({
         model: model,
         config: {
           responseModalities: [Modality.AUDIO],
         },
         callbacks: {
           onopen: () => {
             console.log('Connected to the socket.');
           },
           onmessage: (e: MessageEvent) => {
             console.log('Received message from the server: %s\n', debug(e.data));
           },
           onerror: (e: ErrorEvent) => {
             console.log('Error occurred: %s\n', debug(e.error));
           },
           onclose: (e: CloseEvent) => {
             console.log('Connection closed.');
           },
         },
       });
       ```
      */
  async connect(params) {
    var _a5, _b, _c, _d, _e, _f;
    if (params.config && params.config.httpOptions) {
      throw new Error("The Live module does not support httpOptions at request-level in LiveConnectConfig yet. Please use the client-level httpOptions configuration instead.");
    }
    const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();
    const apiVersion = this.apiClient.getApiVersion();
    let url;
    const clientHeaders = this.apiClient.getHeaders();
    if (params.config && params.config.tools && hasMcpToolUsage(params.config.tools)) {
      setMcpUsageHeader(clientHeaders);
    }
    const headers = mapToHeaders(clientHeaders);
    if (this.apiClient.isVertexAI()) {
      const project = this.apiClient.getProject();
      const location = this.apiClient.getLocation();
      const apiKey = this.apiClient.getApiKey();
      const hasStandardAuth = !!project && !!location || !!apiKey;
      if (this.apiClient.getCustomBaseUrl() && !hasStandardAuth) {
        url = websocketBaseUrl;
      } else {
        url = `${websocketBaseUrl}/ws/google.cloud.aiplatform.${apiVersion}.LlmBidiService/BidiGenerateContent`;
        await this.auth.addAuthHeaders(headers, url);
      }
    } else {
      const apiKey = this.apiClient.getApiKey();
      let method = "BidiGenerateContent";
      let keyName = "key";
      if (apiKey === null || apiKey === void 0 ? void 0 : apiKey.startsWith("auth_tokens/")) {
        console.warn("Warning: Ephemeral token support is experimental and may change in future versions.");
        if (apiVersion !== "v1alpha") {
          console.warn("Warning: The SDK's ephemeral token support is in v1alpha only. Please use const ai = new GoogleGenAI({apiKey: token.name, httpOptions: { apiVersion: 'v1alpha' }}); before session connection.");
        }
        method = "BidiGenerateContentConstrained";
        keyName = "access_token";
      }
      url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.${method}?${keyName}=${apiKey}`;
    }
    let onopenResolve = () => {
    };
    const onopenPromise = new Promise((resolve) => {
      onopenResolve = resolve;
    });
    const callbacks = params.callbacks;
    const onopenAwaitedCallback = function() {
      var _a6;
      (_a6 = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onopen) === null || _a6 === void 0 ? void 0 : _a6.call(callbacks);
      onopenResolve({});
    };
    const apiClient = this.apiClient;
    const websocketCallbacks = {
      onopen: onopenAwaitedCallback,
      onmessage: (event) => {
        void handleWebSocketMessage(apiClient, callbacks.onmessage, event);
      },
      onerror: (_a5 = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a5 !== void 0 ? _a5 : function(e3) {
      },
      onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function(e3) {
      }
    };
    const conn = this.webSocketFactory.create(url, headersToMap(headers), websocketCallbacks);
    conn.connect();
    await onopenPromise;
    let transformedModel = tModel(this.apiClient, params.model);
    if (this.apiClient.isVertexAI() && transformedModel.startsWith("publishers/")) {
      const project = this.apiClient.getProject();
      const location = this.apiClient.getLocation();
      if (project && location) {
        transformedModel = `projects/${project}/locations/${location}/` + transformedModel;
      }
    }
    let clientMessage = {};
    if (this.apiClient.isVertexAI() && ((_c = params.config) === null || _c === void 0 ? void 0 : _c.responseModalities) === void 0) {
      if (params.config === void 0) {
        params.config = { responseModalities: [Modality.AUDIO] };
      } else {
        params.config.responseModalities = [Modality.AUDIO];
      }
    }
    if ((_d = params.config) === null || _d === void 0 ? void 0 : _d.generationConfig) {
      console.warn("Setting `LiveConnectConfig.generation_config` is deprecated, please set the fields on `LiveConnectConfig` directly. This will become an error in a future version (not before Q3 2025).");
    }
    const inputTools = (_f = (_e = params.config) === null || _e === void 0 ? void 0 : _e.tools) !== null && _f !== void 0 ? _f : [];
    const convertedTools = [];
    for (const tool of inputTools) {
      if (this.isCallableTool(tool)) {
        const callableTool = tool;
        convertedTools.push(await callableTool.tool());
      } else {
        convertedTools.push(tool);
      }
    }
    if (convertedTools.length > 0) {
      params.config.tools = convertedTools;
    }
    const liveConnectParameters = {
      model: transformedModel,
      config: params.config,
      callbacks: params.callbacks
    };
    if (this.apiClient.isVertexAI()) {
      clientMessage = liveConnectParametersToVertex(this.apiClient, liveConnectParameters);
    } else {
      clientMessage = liveConnectParametersToMldev(this.apiClient, liveConnectParameters);
    }
    delete clientMessage["config"];
    conn.send(JSON.stringify(clientMessage));
    return new Session(conn, this.apiClient);
  }
  // TODO: b/416041229 - Abstract this method to a common place.
  isCallableTool(tool) {
    return "callTool" in tool && typeof tool.callTool === "function";
  }
};
var defaultLiveSendClientContentParamerters = {
  turnComplete: true
};
var Session = class {
  constructor(conn, apiClient) {
    this.conn = conn;
    this.apiClient = apiClient;
  }
  tLiveClientContent(apiClient, params) {
    if (params.turns !== null && params.turns !== void 0) {
      let contents = [];
      try {
        contents = tContents(params.turns);
        if (!apiClient.isVertexAI()) {
          contents = contents.map((item) => contentToMldev$1(item));
        }
      } catch (_a5) {
        throw new Error(`Failed to parse client content "turns", type: '${typeof params.turns}'`);
      }
      return {
        clientContent: { turns: contents, turnComplete: params.turnComplete }
      };
    }
    return {
      clientContent: { turnComplete: params.turnComplete }
    };
  }
  tLiveClienttToolResponse(apiClient, params) {
    let functionResponses = [];
    if (params.functionResponses == null) {
      throw new Error("functionResponses is required.");
    }
    if (!Array.isArray(params.functionResponses)) {
      functionResponses = [params.functionResponses];
    } else {
      functionResponses = params.functionResponses;
    }
    if (functionResponses.length === 0) {
      throw new Error("functionResponses is required.");
    }
    for (const functionResponse of functionResponses) {
      if (typeof functionResponse !== "object" || functionResponse === null || !("name" in functionResponse) || !("response" in functionResponse)) {
        throw new Error(`Could not parse function response, type '${typeof functionResponse}'.`);
      }
      if (!apiClient.isVertexAI() && !("id" in functionResponse)) {
        throw new Error(FUNCTION_RESPONSE_REQUIRES_ID);
      }
    }
    const clientMessage = {
      toolResponse: { functionResponses }
    };
    return clientMessage;
  }
  /**
      Send a message over the established connection.
  
      @param params - Contains two **optional** properties, `turns` and
          `turnComplete`.
  
        - `turns` will be converted to a `Content[]`
        - `turnComplete: true` [default] indicates that you are done sending
          content and expect a response. If `turnComplete: false`, the server
          will wait for additional messages before starting generation.
  
      @experimental
  
      @remarks
      There are two ways to send messages to the live API:
      `sendClientContent` and `sendRealtimeInput`.
  
      `sendClientContent` messages are added to the model context **in order**.
      Having a conversation using `sendClientContent` messages is roughly
      equivalent to using the `Chat.sendMessageStream`, except that the state of
      the `chat` history is stored on the API server instead of locally.
  
      Because of `sendClientContent`'s order guarantee, the model cannot respons
      as quickly to `sendClientContent` messages as to `sendRealtimeInput`
      messages. This makes the biggest difference when sending objects that have
      significant preprocessing time (typically images).
  
      The `sendClientContent` message sends a `Content[]`
      which has more options than the `Blob` sent by `sendRealtimeInput`.
  
      So the main use-cases for `sendClientContent` over `sendRealtimeInput` are:
  
      - Sending anything that can't be represented as a `Blob` (text,
      `sendClientContent({turns="Hello?"}`)).
      - Managing turns when not using audio input and voice activity detection.
        (`sendClientContent({turnComplete:true})` or the short form
      `sendClientContent()`)
      - Prefilling a conversation context
        ```
        sendClientContent({
            turns: [
              Content({role:user, parts:...}),
              Content({role:user, parts:...}),
              ...
            ]
        })
        ```
      @experimental
     */
  sendClientContent(params) {
    params = Object.assign(Object.assign({}, defaultLiveSendClientContentParamerters), params);
    const clientMessage = this.tLiveClientContent(this.apiClient, params);
    this.conn.send(JSON.stringify(clientMessage));
  }
  /**
      Send a realtime message over the established connection.
  
      @param params - Contains one property, `media`.
  
        - `media` will be converted to a `Blob`
  
      @experimental
  
      @remarks
      Use `sendRealtimeInput` for realtime audio chunks and video frames (images).
  
      With `sendRealtimeInput` the api will respond to audio automatically
      based on voice activity detection (VAD).
  
      `sendRealtimeInput` is optimized for responsivness at the expense of
      deterministic ordering guarantees. Audio and video tokens are to the
      context when they become available.
  
      Note: The Call signature expects a `Blob` object, but only a subset
      of audio and image mimetypes are allowed.
     */
  sendRealtimeInput(params) {
    let clientMessage = {};
    if (this.apiClient.isVertexAI()) {
      clientMessage = {
        "realtimeInput": liveSendRealtimeInputParametersToVertex(params)
      };
    } else {
      clientMessage = {
        "realtimeInput": liveSendRealtimeInputParametersToMldev(params)
      };
    }
    this.conn.send(JSON.stringify(clientMessage));
  }
  /**
      Send a function response message over the established connection.
  
      @param params - Contains property `functionResponses`.
  
        - `functionResponses` will be converted to a `functionResponses[]`
  
      @remarks
      Use `sendFunctionResponse` to reply to `LiveServerToolCall` from the server.
  
      Use {@link types.LiveConnectConfig#tools} to configure the callable functions.
  
      @experimental
     */
  sendToolResponse(params) {
    if (params.functionResponses == null) {
      throw new Error("Tool response parameters are required.");
    }
    const clientMessage = this.tLiveClienttToolResponse(this.apiClient, params);
    this.conn.send(JSON.stringify(clientMessage));
  }
  /**
       Terminates the WebSocket connection.
  
       @experimental
  
       @example
       ```ts
       let model: string;
       if (GOOGLE_GENAI_USE_VERTEXAI) {
         model = 'gemini-2.0-flash-live-preview-04-09';
       } else {
         model = 'gemini-live-2.5-flash-preview';
       }
       const session = await ai.live.connect({
         model: model,
         config: {
           responseModalities: [Modality.AUDIO],
         }
       });
  
       session.close();
       ```
     */
  close() {
    this.conn.close();
  }
};
function headersToMap(headers) {
  const headerMap = {};
  headers.forEach((value, key) => {
    headerMap[key] = value;
  });
  return headerMap;
}
function mapToHeaders(map) {
  const headers = new Headers();
  for (const [key, value] of Object.entries(map)) {
    headers.append(key, value);
  }
  return headers;
}
var DEFAULT_MAX_REMOTE_CALLS = 10;
function shouldDisableAfc(config) {
  var _a5, _b, _c;
  if ((_a5 = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a5 === void 0 ? void 0 : _a5.disable) {
    return true;
  }
  let callableToolsPresent = false;
  for (const tool of (_b = config === null || config === void 0 ? void 0 : config.tools) !== null && _b !== void 0 ? _b : []) {
    if (isCallableTool(tool)) {
      callableToolsPresent = true;
      break;
    }
  }
  if (!callableToolsPresent) {
    return true;
  }
  const maxCalls = (_c = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _c === void 0 ? void 0 : _c.maximumRemoteCalls;
  if (maxCalls && (maxCalls < 0 || !Number.isInteger(maxCalls)) || maxCalls == 0) {
    console.warn("Invalid maximumRemoteCalls value provided for automatic function calling. Disabled automatic function calling. Please provide a valid integer value greater than 0. maximumRemoteCalls provided:", maxCalls);
    return true;
  }
  return false;
}
function isCallableTool(tool) {
  return "callTool" in tool && typeof tool.callTool === "function";
}
function hasCallableTools(params) {
  var _a5, _b, _c;
  return (_c = (_b = (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.tools) === null || _b === void 0 ? void 0 : _b.some((tool) => isCallableTool(tool))) !== null && _c !== void 0 ? _c : false;
}
function findAfcIncompatibleToolIndexes(params) {
  var _a5;
  const afcIncompatibleToolIndexes = [];
  if (!((_a5 = params === null || params === void 0 ? void 0 : params.config) === null || _a5 === void 0 ? void 0 : _a5.tools)) {
    return afcIncompatibleToolIndexes;
  }
  params.config.tools.forEach((tool, index) => {
    if (isCallableTool(tool)) {
      return;
    }
    const geminiTool = tool;
    if (geminiTool.functionDeclarations && geminiTool.functionDeclarations.length > 0) {
      afcIncompatibleToolIndexes.push(index);
    }
  });
  return afcIncompatibleToolIndexes;
}
function shouldAppendAfcHistory(config) {
  var _a5;
  return !((_a5 = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a5 === void 0 ? void 0 : _a5.ignoreCallHistory);
}
var Models4 = class extends BaseModule {
  constructor(apiClient) {
    super();
    this.apiClient = apiClient;
    this.generateContent = async (params) => {
      var _a5, _b, _c, _d, _e;
      const transformedParams = await this.processParamsMaybeAddMcpUsage(params);
      this.maybeMoveToResponseJsonSchem(params);
      if (!hasCallableTools(params) || shouldDisableAfc(params.config)) {
        return await this.generateContentInternal(transformedParams);
      }
      const incompatibleToolIndexes = findAfcIncompatibleToolIndexes(params);
      if (incompatibleToolIndexes.length > 0) {
        const formattedIndexes = incompatibleToolIndexes.map((index) => `tools[${index}]`).join(", ");
        throw new Error(`Automatic function calling with CallableTools (or MCP objects) and basic FunctionDeclarations is not yet supported. Incompatible tools found at ${formattedIndexes}.`);
      }
      let response;
      let functionResponseContent;
      const automaticFunctionCallingHistory = tContents(transformedParams.contents);
      const maxRemoteCalls = (_c = (_b = (_a5 = transformedParams.config) === null || _a5 === void 0 ? void 0 : _a5.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;
      let remoteCalls = 0;
      while (remoteCalls < maxRemoteCalls) {
        response = await this.generateContentInternal(transformedParams);
        if (!response.functionCalls || response.functionCalls.length === 0) {
          break;
        }
        const responseContent = response.candidates[0].content;
        const functionResponseParts = [];
        for (const tool of (_e = (_d = params.config) === null || _d === void 0 ? void 0 : _d.tools) !== null && _e !== void 0 ? _e : []) {
          if (isCallableTool(tool)) {
            const callableTool = tool;
            const parts = await callableTool.callTool(response.functionCalls);
            functionResponseParts.push(...parts);
          }
        }
        remoteCalls++;
        functionResponseContent = {
          role: "user",
          parts: functionResponseParts
        };
        transformedParams.contents = tContents(transformedParams.contents);
        transformedParams.contents.push(responseContent);
        transformedParams.contents.push(functionResponseContent);
        if (shouldAppendAfcHistory(transformedParams.config)) {
          automaticFunctionCallingHistory.push(responseContent);
          automaticFunctionCallingHistory.push(functionResponseContent);
        }
      }
      if (shouldAppendAfcHistory(transformedParams.config)) {
        response.automaticFunctionCallingHistory = automaticFunctionCallingHistory;
      }
      return response;
    };
    this.generateContentStream = async (params) => {
      var _a5, _b, _c, _d, _e;
      this.maybeMoveToResponseJsonSchem(params);
      if (shouldDisableAfc(params.config)) {
        const transformedParams = await this.processParamsMaybeAddMcpUsage(params);
        return await this.generateContentStreamInternal(transformedParams);
      }
      const incompatibleToolIndexes = findAfcIncompatibleToolIndexes(params);
      if (incompatibleToolIndexes.length > 0) {
        const formattedIndexes = incompatibleToolIndexes.map((index) => `tools[${index}]`).join(", ");
        throw new Error(`Incompatible tools found at ${formattedIndexes}. Automatic function calling with CallableTools (or MCP objects) and basic FunctionDeclarations" is not yet supported.`);
      }
      const streamFunctionCall = (_c = (_b = (_a5 = params === null || params === void 0 ? void 0 : params.config) === null || _a5 === void 0 ? void 0 : _a5.toolConfig) === null || _b === void 0 ? void 0 : _b.functionCallingConfig) === null || _c === void 0 ? void 0 : _c.streamFunctionCallArguments;
      const disableAfc = (_e = (_d = params === null || params === void 0 ? void 0 : params.config) === null || _d === void 0 ? void 0 : _d.automaticFunctionCalling) === null || _e === void 0 ? void 0 : _e.disable;
      if (streamFunctionCall && !disableAfc) {
        throw new Error("Running in streaming mode with 'streamFunctionCallArguments' enabled, this feature is not compatible with automatic function calling (AFC). Please set 'config.automaticFunctionCalling.disable' to true to disable AFC or leave 'config.toolConfig.functionCallingConfig.streamFunctionCallArguments' to be undefined or set to false to disable streaming function call arguments feature.");
      }
      return await this.processAfcStream(params);
    };
    this.generateImages = async (params) => {
      return await this.generateImagesInternal(params).then((apiResponse) => {
        var _a5;
        let positivePromptSafetyAttributes;
        const generatedImages = [];
        if (apiResponse === null || apiResponse === void 0 ? void 0 : apiResponse.generatedImages) {
          for (const generatedImage of apiResponse.generatedImages) {
            if (generatedImage && (generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) && ((_a5 = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) === null || _a5 === void 0 ? void 0 : _a5.contentType) === "Positive Prompt") {
              positivePromptSafetyAttributes = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes;
            } else {
              generatedImages.push(generatedImage);
            }
          }
        }
        let response;
        if (positivePromptSafetyAttributes) {
          response = {
            generatedImages,
            positivePromptSafetyAttributes,
            sdkHttpResponse: apiResponse.sdkHttpResponse
          };
        } else {
          response = {
            generatedImages,
            sdkHttpResponse: apiResponse.sdkHttpResponse
          };
        }
        return response;
      });
    };
    this.list = async (params) => {
      var _a5;
      const defaultConfig = {
        queryBase: true
      };
      const actualConfig = Object.assign(Object.assign({}, defaultConfig), params === null || params === void 0 ? void 0 : params.config);
      const actualParams = {
        config: actualConfig
      };
      if (this.apiClient.isVertexAI()) {
        if (!actualParams.config.queryBase) {
          if ((_a5 = actualParams.config) === null || _a5 === void 0 ? void 0 : _a5.filter) {
            throw new Error("Filtering tuned models list for Vertex AI is not currently supported");
          } else {
            actualParams.config.filter = "labels.tune-type:*";
          }
        }
      }
      return new Pager(PagedItem.PAGED_ITEM_MODELS, (x3) => this.listInternal(x3), await this.listInternal(actualParams), actualParams);
    };
    this.editImage = async (params) => {
      const paramsInternal = {
        model: params.model,
        prompt: params.prompt,
        referenceImages: [],
        config: params.config
      };
      if (params.referenceImages) {
        if (params.referenceImages) {
          paramsInternal.referenceImages = params.referenceImages.map((img) => img.toReferenceImageAPI());
        }
      }
      return await this.editImageInternal(paramsInternal);
    };
    this.upscaleImage = async (params) => {
      let apiConfig = {
        numberOfImages: 1,
        mode: "upscale"
      };
      if (params.config) {
        apiConfig = Object.assign(Object.assign({}, apiConfig), params.config);
      }
      const apiParams = {
        model: params.model,
        image: params.image,
        upscaleFactor: params.upscaleFactor,
        config: apiConfig
      };
      return await this.upscaleImageInternal(apiParams);
    };
    this.generateVideos = async (params) => {
      var _a5, _b, _c, _d, _e, _f;
      if ((params.prompt || params.image || params.video) && params.source) {
        throw new Error("Source and prompt/image/video are mutually exclusive. Please only use source.");
      }
      if (!this.apiClient.isVertexAI()) {
        if (((_a5 = params.video) === null || _a5 === void 0 ? void 0 : _a5.uri) && ((_b = params.video) === null || _b === void 0 ? void 0 : _b.videoBytes)) {
          params.video = {
            uri: params.video.uri,
            mimeType: params.video.mimeType
          };
        } else if (((_d = (_c = params.source) === null || _c === void 0 ? void 0 : _c.video) === null || _d === void 0 ? void 0 : _d.uri) && ((_f = (_e = params.source) === null || _e === void 0 ? void 0 : _e.video) === null || _f === void 0 ? void 0 : _f.videoBytes)) {
          params.source.video = {
            uri: params.source.video.uri,
            mimeType: params.source.video.mimeType
          };
        }
      }
      return await this.generateVideosInternal(params);
    };
  }
  /**
   * This logic is needed for GenerateContentConfig only.
   * Previously we made GenerateContentConfig.responseSchema field to accept
   * unknown. Since v1.9.0, we switch to use backend JSON schema support.
   * To maintain backward compatibility, we move the data that was treated as
   * JSON schema from the responseSchema field to the responseJsonSchema field.
   */
  maybeMoveToResponseJsonSchem(params) {
    if (params.config && params.config.responseSchema) {
      if (!params.config.responseJsonSchema) {
        if (Object.keys(params.config.responseSchema).includes("$schema")) {
          params.config.responseJsonSchema = params.config.responseSchema;
          delete params.config.responseSchema;
        }
      }
    }
    return;
  }
  /**
   * Transforms the CallableTools in the parameters to be simply Tools, it
   * copies the params into a new object and replaces the tools, it does not
   * modify the original params. Also sets the MCP usage header if there are
   * MCP tools in the parameters.
   */
  async processParamsMaybeAddMcpUsage(params) {
    var _a5, _b, _c;
    const tools = (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.tools;
    if (!tools) {
      return params;
    }
    const transformedTools = await Promise.all(tools.map(async (tool) => {
      if (isCallableTool(tool)) {
        const callableTool = tool;
        return await callableTool.tool();
      }
      return tool;
    }));
    const newParams = {
      model: params.model,
      contents: params.contents,
      config: Object.assign(Object.assign({}, params.config), { tools: transformedTools })
    };
    newParams.config.tools = transformedTools;
    if (params.config && params.config.tools && hasMcpToolUsage(params.config.tools)) {
      const headers = (_c = (_b = params.config.httpOptions) === null || _b === void 0 ? void 0 : _b.headers) !== null && _c !== void 0 ? _c : {};
      let newHeaders = Object.assign({}, headers);
      if (Object.keys(newHeaders).length === 0) {
        newHeaders = this.apiClient.getDefaultHeaders();
      }
      setMcpUsageHeader(newHeaders);
      newParams.config.httpOptions = Object.assign(Object.assign({}, params.config.httpOptions), { headers: newHeaders });
    }
    return newParams;
  }
  async initAfcToolsMap(params) {
    var _a5, _b, _c;
    const afcTools = /* @__PURE__ */ new Map();
    for (const tool of (_b = (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.tools) !== null && _b !== void 0 ? _b : []) {
      if (isCallableTool(tool)) {
        const callableTool = tool;
        const toolDeclaration = await callableTool.tool();
        for (const declaration of (_c = toolDeclaration.functionDeclarations) !== null && _c !== void 0 ? _c : []) {
          if (!declaration.name) {
            throw new Error("Function declaration name is required.");
          }
          if (afcTools.has(declaration.name)) {
            throw new Error(`Duplicate tool declaration name: ${declaration.name}`);
          }
          afcTools.set(declaration.name, callableTool);
        }
      }
    }
    return afcTools;
  }
  async processAfcStream(params) {
    var _a5, _b, _c;
    const maxRemoteCalls = (_c = (_b = (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;
    let wereFunctionsCalled = false;
    let remoteCallCount = 0;
    const afcToolsMap = await this.initAfcToolsMap(params);
    return (function(models2, afcTools, params2) {
      return __asyncGenerator(this, arguments, function* () {
        var _a6, e_1, _b2, _c2;
        var _d, _e;
        while (remoteCallCount < maxRemoteCalls) {
          if (wereFunctionsCalled) {
            remoteCallCount++;
            wereFunctionsCalled = false;
          }
          const transformedParams = yield __await(models2.processParamsMaybeAddMcpUsage(params2));
          const response = yield __await(models2.generateContentStreamInternal(transformedParams));
          const functionResponses = [];
          const responseContents = [];
          try {
            for (var _f = true, response_1 = (e_1 = void 0, __asyncValues(response)), response_1_1; response_1_1 = yield __await(response_1.next()), _a6 = response_1_1.done, !_a6; _f = true) {
              _c2 = response_1_1.value;
              _f = false;
              const chunk = _c2;
              yield yield __await(chunk);
              if (chunk.candidates && ((_d = chunk.candidates[0]) === null || _d === void 0 ? void 0 : _d.content)) {
                responseContents.push(chunk.candidates[0].content);
                for (const part of (_e = chunk.candidates[0].content.parts) !== null && _e !== void 0 ? _e : []) {
                  if (remoteCallCount < maxRemoteCalls && part.functionCall) {
                    if (!part.functionCall.name) {
                      throw new Error("Function call name was not returned by the model.");
                    }
                    if (!afcTools.has(part.functionCall.name)) {
                      throw new Error(`Automatic function calling was requested, but not all the tools the model used implement the CallableTool interface. Available tools: ${afcTools.keys()}, mising tool: ${part.functionCall.name}`);
                    } else {
                      const responseParts = yield __await(afcTools.get(part.functionCall.name).callTool([part.functionCall]));
                      functionResponses.push(...responseParts);
                    }
                  }
                }
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (!_f && !_a6 && (_b2 = response_1.return)) yield __await(_b2.call(response_1));
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          if (functionResponses.length > 0) {
            wereFunctionsCalled = true;
            const typedResponseChunk = new GenerateContentResponse();
            typedResponseChunk.candidates = [
              {
                content: {
                  role: "user",
                  parts: functionResponses
                }
              }
            ];
            yield yield __await(typedResponseChunk);
            const newContents = [];
            newContents.push(...responseContents);
            newContents.push({
              role: "user",
              parts: functionResponses
            });
            const updatedContents = tContents(params2.contents).concat(newContents);
            params2.contents = updatedContents;
          } else {
            break;
          }
        }
      });
    })(this, afcToolsMap, params);
  }
  async generateContentInternal(params) {
    var _a5, _b, _c, _d;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = generateContentParametersToVertex(this.apiClient, params);
      path4 = formatMap("{model}:generateContent", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = generateContentResponseFromVertex(apiResponse);
        const typedResp = new GenerateContentResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = generateContentParametersToMldev(this.apiClient, params);
      path4 = formatMap("{model}:generateContent", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = generateContentResponseFromMldev(apiResponse);
        const typedResp = new GenerateContentResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
  async generateContentStreamInternal(params) {
    var _a5, _b, _c, _d;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = generateContentParametersToVertex(this.apiClient, params);
      path4 = formatMap("{model}:streamGenerateContent?alt=sse", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      const apiClient = this.apiClient;
      response = apiClient.requestStream({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      });
      return response.then(function(apiResponse) {
        return __asyncGenerator(this, arguments, function* () {
          var _a6, e_2, _b2, _c2;
          try {
            for (var _d2 = true, apiResponse_1 = __asyncValues(apiResponse), apiResponse_1_1; apiResponse_1_1 = yield __await(apiResponse_1.next()), _a6 = apiResponse_1_1.done, !_a6; _d2 = true) {
              _c2 = apiResponse_1_1.value;
              _d2 = false;
              const chunk = _c2;
              const resp = generateContentResponseFromVertex(yield __await(chunk.json()), params);
              resp["sdkHttpResponse"] = {
                headers: chunk.headers
              };
              const typedResp = new GenerateContentResponse();
              Object.assign(typedResp, resp);
              yield yield __await(typedResp);
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (!_d2 && !_a6 && (_b2 = apiResponse_1.return)) yield __await(_b2.call(apiResponse_1));
            } finally {
              if (e_2) throw e_2.error;
            }
          }
        });
      });
    } else {
      const body = generateContentParametersToMldev(this.apiClient, params);
      path4 = formatMap("{model}:streamGenerateContent?alt=sse", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      const apiClient = this.apiClient;
      response = apiClient.requestStream({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      });
      return response.then(function(apiResponse) {
        return __asyncGenerator(this, arguments, function* () {
          var _a6, e_3, _b2, _c2;
          try {
            for (var _d2 = true, apiResponse_2 = __asyncValues(apiResponse), apiResponse_2_1; apiResponse_2_1 = yield __await(apiResponse_2.next()), _a6 = apiResponse_2_1.done, !_a6; _d2 = true) {
              _c2 = apiResponse_2_1.value;
              _d2 = false;
              const chunk = _c2;
              const resp = generateContentResponseFromMldev(yield __await(chunk.json()), params);
              resp["sdkHttpResponse"] = {
                headers: chunk.headers
              };
              const typedResp = new GenerateContentResponse();
              Object.assign(typedResp, resp);
              yield yield __await(typedResp);
            }
          } catch (e_3_1) {
            e_3 = { error: e_3_1 };
          } finally {
            try {
              if (!_d2 && !_a6 && (_b2 = apiResponse_2.return)) yield __await(_b2.call(apiResponse_2));
            } finally {
              if (e_3) throw e_3.error;
            }
          }
        });
      });
    }
  }
  /**
   * Calculates embeddings for the given contents. Only text is supported.
   *
   * @param params - The parameters for embedding contents.
   * @return The response from the API.
   *
   * @example
   * ```ts
   * const response = await ai.models.embedContent({
   *  model: 'text-embedding-004',
   *  contents: [
   *    'What is your name?',
   *    'What is your favorite color?',
   *  ],
   *  config: {
   *    outputDimensionality: 64,
   *  },
   * });
   * console.log(response);
   * ```
   */
  async embedContent(params) {
    var _a5, _b, _c, _d;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = embedContentParametersToVertex(this.apiClient, params);
      path4 = formatMap("{model}:predict", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = embedContentResponseFromVertex(apiResponse);
        const typedResp = new EmbedContentResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = embedContentParametersToMldev(this.apiClient, params);
      path4 = formatMap("{model}:batchEmbedContents", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = embedContentResponseFromMldev(apiResponse);
        const typedResp = new EmbedContentResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
  /**
   * Private method for generating images.
   */
  async generateImagesInternal(params) {
    var _a5, _b, _c, _d;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = generateImagesParametersToVertex(this.apiClient, params);
      path4 = formatMap("{model}:predict", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = generateImagesResponseFromVertex(apiResponse);
        const typedResp = new GenerateImagesResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = generateImagesParametersToMldev(this.apiClient, params);
      path4 = formatMap("{model}:predict", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = generateImagesResponseFromMldev(apiResponse);
        const typedResp = new GenerateImagesResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
  /**
   * Private method for editing an image.
   */
  async editImageInternal(params) {
    var _a5, _b;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = editImageParametersInternalToVertex(this.apiClient, params);
      path4 = formatMap("{model}:predict", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = editImageResponseFromVertex(apiResponse);
        const typedResp = new EditImageResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      throw new Error("This method is only supported by the Vertex AI.");
    }
  }
  /**
   * Private method for upscaling an image.
   */
  async upscaleImageInternal(params) {
    var _a5, _b;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = upscaleImageAPIParametersInternalToVertex(this.apiClient, params);
      path4 = formatMap("{model}:predict", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = upscaleImageResponseFromVertex(apiResponse);
        const typedResp = new UpscaleImageResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      throw new Error("This method is only supported by the Vertex AI.");
    }
  }
  /**
   * Recontextualizes an image.
   *
   * There are two types of recontextualization currently supported:
   * 1) Imagen Product Recontext - Generate images of products in new scenes
   *    and contexts.
   * 2) Virtual Try-On: Generate images of persons modeling fashion products.
   *
   * @param params - The parameters for recontextualizing an image.
   * @return The response from the API.
   *
   * @example
   * ```ts
   * const response1 = await ai.models.recontextImage({
   *  model: 'imagen-product-recontext-preview-06-30',
   *  source: {
   *    prompt: 'In a modern kitchen setting.',
   *    productImages: [productImage],
   *  },
   *  config: {
   *    numberOfImages: 1,
   *  },
   * });
   * console.log(response1?.generatedImages?.[0]?.image?.imageBytes);
   *
   * const response2 = await ai.models.recontextImage({
   *  model: 'virtual-try-on-001',
   *  source: {
   *    personImage: personImage,
   *    productImages: [productImage],
   *  },
   *  config: {
   *    numberOfImages: 1,
   *  },
   * });
   * console.log(response2?.generatedImages?.[0]?.image?.imageBytes);
   * ```
   */
  async recontextImage(params) {
    var _a5, _b;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = recontextImageParametersToVertex(this.apiClient, params);
      path4 = formatMap("{model}:predict", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = recontextImageResponseFromVertex(apiResponse);
        const typedResp = new RecontextImageResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      throw new Error("This method is only supported by the Vertex AI.");
    }
  }
  /**
   * Segments an image, creating a mask of a specified area.
   *
   * @param params - The parameters for segmenting an image.
   * @return The response from the API.
   *
   * @example
   * ```ts
   * const response = await ai.models.segmentImage({
   *  model: 'image-segmentation-001',
   *  source: {
   *    image: image,
   *  },
   *  config: {
   *    mode: 'foreground',
   *  },
   * });
   * console.log(response?.generatedMasks?.[0]?.mask?.imageBytes);
   * ```
   */
  async segmentImage(params) {
    var _a5, _b;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = segmentImageParametersToVertex(this.apiClient, params);
      path4 = formatMap("{model}:predict", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = segmentImageResponseFromVertex(apiResponse);
        const typedResp = new SegmentImageResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      throw new Error("This method is only supported by the Vertex AI.");
    }
  }
  /**
   * Fetches information about a model by name.
   *
   * @example
   * ```ts
   * const modelInfo = await ai.models.get({model: 'gemini-2.0-flash'});
   * ```
   */
  async get(params) {
    var _a5, _b, _c, _d;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = getModelParametersToVertex(this.apiClient, params);
      path4 = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = modelFromVertex(apiResponse);
        return resp;
      });
    } else {
      const body = getModelParametersToMldev(this.apiClient, params);
      path4 = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = modelFromMldev(apiResponse);
        return resp;
      });
    }
  }
  async listInternal(params) {
    var _a5, _b, _c, _d;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = listModelsParametersToVertex(this.apiClient, params);
      path4 = formatMap("{models_url}", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = listModelsResponseFromVertex(apiResponse);
        const typedResp = new ListModelsResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = listModelsParametersToMldev(this.apiClient, params);
      path4 = formatMap("{models_url}", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = listModelsResponseFromMldev(apiResponse);
        const typedResp = new ListModelsResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
  /**
   * Updates a tuned model by its name.
   *
   * @param params - The parameters for updating the model.
   * @return The response from the API.
   *
   * @example
   * ```ts
   * const response = await ai.models.update({
   *   model: 'tuned-model-name',
   *   config: {
   *     displayName: 'New display name',
   *     description: 'New description',
   *   },
   * });
   * ```
   */
  async update(params) {
    var _a5, _b, _c, _d;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = updateModelParametersToVertex(this.apiClient, params);
      path4 = formatMap("{model}", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "PATCH",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = modelFromVertex(apiResponse);
        return resp;
      });
    } else {
      const body = updateModelParametersToMldev(this.apiClient, params);
      path4 = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "PATCH",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = modelFromMldev(apiResponse);
        return resp;
      });
    }
  }
  /**
   * Deletes a tuned model by its name.
   *
   * @param params - The parameters for deleting the model.
   * @return The response from the API.
   *
   * @example
   * ```ts
   * const response = await ai.models.delete({model: 'tuned-model-name'});
   * ```
   */
  async delete(params) {
    var _a5, _b, _c, _d;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = deleteModelParametersToVertex(this.apiClient, params);
      path4 = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "DELETE",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = deleteModelResponseFromVertex(apiResponse);
        const typedResp = new DeleteModelResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = deleteModelParametersToMldev(this.apiClient, params);
      path4 = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "DELETE",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = deleteModelResponseFromMldev(apiResponse);
        const typedResp = new DeleteModelResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
  /**
   * Counts the number of tokens in the given contents. Multimodal input is
   * supported for Gemini models.
   *
   * @param params - The parameters for counting tokens.
   * @return The response from the API.
   *
   * @example
   * ```ts
   * const response = await ai.models.countTokens({
   *  model: 'gemini-2.0-flash',
   *  contents: 'The quick brown fox jumps over the lazy dog.'
   * });
   * console.log(response);
   * ```
   */
  async countTokens(params) {
    var _a5, _b, _c, _d;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = countTokensParametersToVertex(this.apiClient, params);
      path4 = formatMap("{model}:countTokens", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = countTokensResponseFromVertex(apiResponse);
        const typedResp = new CountTokensResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = countTokensParametersToMldev(this.apiClient, params);
      path4 = formatMap("{model}:countTokens", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = countTokensResponseFromMldev(apiResponse);
        const typedResp = new CountTokensResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
  /**
   * Given a list of contents, returns a corresponding TokensInfo containing
   * the list of tokens and list of token ids.
   *
   * This method is not supported by the Gemini Developer API.
   *
   * @param params - The parameters for computing tokens.
   * @return The response from the API.
   *
   * @example
   * ```ts
   * const response = await ai.models.computeTokens({
   *  model: 'gemini-2.0-flash',
   *  contents: 'What is your name?'
   * });
   * console.log(response);
   * ```
   */
  async computeTokens(params) {
    var _a5, _b;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = computeTokensParametersToVertex(this.apiClient, params);
      path4 = formatMap("{model}:computeTokens", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = computeTokensResponseFromVertex(apiResponse);
        const typedResp = new ComputeTokensResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      throw new Error("This method is only supported by the Vertex AI.");
    }
  }
  /**
   * Private method for generating videos.
   */
  async generateVideosInternal(params) {
    var _a5, _b, _c, _d;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = generateVideosParametersToVertex(this.apiClient, params);
      path4 = formatMap("{model}:predictLongRunning", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = generateVideosOperationFromVertex(apiResponse);
        const typedResp = new GenerateVideosOperation();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = generateVideosParametersToMldev(this.apiClient, params);
      path4 = formatMap("{model}:predictLongRunning", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = generateVideosOperationFromMldev(apiResponse);
        const typedResp = new GenerateVideosOperation();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
};
var Operations = class extends BaseModule {
  constructor(apiClient) {
    super();
    this.apiClient = apiClient;
  }
  /**
   * Gets the status of a long-running operation.
   *
   * @param parameters The parameters for the get operation request.
   * @return The updated Operation object, with the latest status or result.
   */
  async getVideosOperation(parameters) {
    const operation = parameters.operation;
    const config = parameters.config;
    if (operation.name === void 0 || operation.name === "") {
      throw new Error("Operation name is required.");
    }
    if (this.apiClient.isVertexAI()) {
      const resourceName2 = operation.name.split("/operations/")[0];
      let httpOptions = void 0;
      if (config && "httpOptions" in config) {
        httpOptions = config.httpOptions;
      }
      const rawOperation = await this.fetchPredictVideosOperationInternal({
        operationName: operation.name,
        resourceName: resourceName2,
        config: { httpOptions }
      });
      return operation._fromAPIResponse({
        apiResponse: rawOperation,
        _isVertexAI: true
      });
    } else {
      const rawOperation = await this.getVideosOperationInternal({
        operationName: operation.name,
        config
      });
      return operation._fromAPIResponse({
        apiResponse: rawOperation,
        _isVertexAI: false
      });
    }
  }
  /**
   * Gets the status of a long-running operation.
   *
   * @param parameters The parameters for the get operation request.
   * @return The updated Operation object, with the latest status or result.
   */
  async get(parameters) {
    const operation = parameters.operation;
    const config = parameters.config;
    if (operation.name === void 0 || operation.name === "") {
      throw new Error("Operation name is required.");
    }
    if (this.apiClient.isVertexAI()) {
      const resourceName2 = operation.name.split("/operations/")[0];
      let httpOptions = void 0;
      if (config && "httpOptions" in config) {
        httpOptions = config.httpOptions;
      }
      const rawOperation = await this.fetchPredictVideosOperationInternal({
        operationName: operation.name,
        resourceName: resourceName2,
        config: { httpOptions }
      });
      return operation._fromAPIResponse({
        apiResponse: rawOperation,
        _isVertexAI: true
      });
    } else {
      const rawOperation = await this.getVideosOperationInternal({
        operationName: operation.name,
        config
      });
      return operation._fromAPIResponse({
        apiResponse: rawOperation,
        _isVertexAI: false
      });
    }
  }
  async getVideosOperationInternal(params) {
    var _a5, _b, _c, _d;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = getOperationParametersToVertex(params);
      path4 = formatMap("{operationName}", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response;
    } else {
      const body = getOperationParametersToMldev(params);
      path4 = formatMap("{operationName}", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response;
    }
  }
  async fetchPredictVideosOperationInternal(params) {
    var _a5, _b;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = fetchPredictOperationParametersToVertex(params);
      path4 = formatMap("{resourceName}:fetchPredictOperation", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response;
    } else {
      throw new Error("This method is only supported by the Vertex AI.");
    }
  }
};
function blobToMldev(fromObject) {
  const toObject = {};
  const fromData = getValueByPath(fromObject, ["data"]);
  if (fromData != null) {
    setValueByPath(toObject, ["data"], fromData);
  }
  if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function contentToMldev(fromObject) {
  const toObject = {};
  const fromParts = getValueByPath(fromObject, ["parts"]);
  if (fromParts != null) {
    let transformedList = fromParts;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return partToMldev(item);
      });
    }
    setValueByPath(toObject, ["parts"], transformedList);
  }
  const fromRole = getValueByPath(fromObject, ["role"]);
  if (fromRole != null) {
    setValueByPath(toObject, ["role"], fromRole);
  }
  return toObject;
}
function createAuthTokenConfigToMldev(apiClient, fromObject, parentObject) {
  const toObject = {};
  const fromExpireTime = getValueByPath(fromObject, ["expireTime"]);
  if (parentObject !== void 0 && fromExpireTime != null) {
    setValueByPath(parentObject, ["expireTime"], fromExpireTime);
  }
  const fromNewSessionExpireTime = getValueByPath(fromObject, [
    "newSessionExpireTime"
  ]);
  if (parentObject !== void 0 && fromNewSessionExpireTime != null) {
    setValueByPath(parentObject, ["newSessionExpireTime"], fromNewSessionExpireTime);
  }
  const fromUses = getValueByPath(fromObject, ["uses"]);
  if (parentObject !== void 0 && fromUses != null) {
    setValueByPath(parentObject, ["uses"], fromUses);
  }
  const fromLiveConnectConstraints = getValueByPath(fromObject, [
    "liveConnectConstraints"
  ]);
  if (parentObject !== void 0 && fromLiveConnectConstraints != null) {
    setValueByPath(parentObject, ["bidiGenerateContentSetup"], liveConnectConstraintsToMldev(apiClient, fromLiveConnectConstraints));
  }
  const fromLockAdditionalFields = getValueByPath(fromObject, [
    "lockAdditionalFields"
  ]);
  if (parentObject !== void 0 && fromLockAdditionalFields != null) {
    setValueByPath(parentObject, ["fieldMask"], fromLockAdditionalFields);
  }
  return toObject;
}
function createAuthTokenParametersToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], createAuthTokenConfigToMldev(apiClient, fromConfig, toObject));
  }
  return toObject;
}
function fileDataToMldev(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["displayName"]) !== void 0) {
    throw new Error("displayName parameter is not supported in Gemini API.");
  }
  const fromFileUri = getValueByPath(fromObject, ["fileUri"]);
  if (fromFileUri != null) {
    setValueByPath(toObject, ["fileUri"], fromFileUri);
  }
  const fromMimeType = getValueByPath(fromObject, ["mimeType"]);
  if (fromMimeType != null) {
    setValueByPath(toObject, ["mimeType"], fromMimeType);
  }
  return toObject;
}
function functionCallToMldev(fromObject) {
  const toObject = {};
  const fromId = getValueByPath(fromObject, ["id"]);
  if (fromId != null) {
    setValueByPath(toObject, ["id"], fromId);
  }
  const fromArgs = getValueByPath(fromObject, ["args"]);
  if (fromArgs != null) {
    setValueByPath(toObject, ["args"], fromArgs);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  if (getValueByPath(fromObject, ["partialArgs"]) !== void 0) {
    throw new Error("partialArgs parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["willContinue"]) !== void 0) {
    throw new Error("willContinue parameter is not supported in Gemini API.");
  }
  return toObject;
}
function googleMapsToMldev(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["authConfig"]) !== void 0) {
    throw new Error("authConfig parameter is not supported in Gemini API.");
  }
  const fromEnableWidget = getValueByPath(fromObject, ["enableWidget"]);
  if (fromEnableWidget != null) {
    setValueByPath(toObject, ["enableWidget"], fromEnableWidget);
  }
  return toObject;
}
function googleSearchToMldev(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["excludeDomains"]) !== void 0) {
    throw new Error("excludeDomains parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["blockingConfidence"]) !== void 0) {
    throw new Error("blockingConfidence parameter is not supported in Gemini API.");
  }
  const fromTimeRangeFilter = getValueByPath(fromObject, [
    "timeRangeFilter"
  ]);
  if (fromTimeRangeFilter != null) {
    setValueByPath(toObject, ["timeRangeFilter"], fromTimeRangeFilter);
  }
  return toObject;
}
function liveConnectConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromGenerationConfig = getValueByPath(fromObject, [
    "generationConfig"
  ]);
  if (parentObject !== void 0 && fromGenerationConfig != null) {
    setValueByPath(parentObject, ["setup", "generationConfig"], fromGenerationConfig);
  }
  const fromResponseModalities = getValueByPath(fromObject, [
    "responseModalities"
  ]);
  if (parentObject !== void 0 && fromResponseModalities != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "responseModalities"], fromResponseModalities);
  }
  const fromTemperature = getValueByPath(fromObject, ["temperature"]);
  if (parentObject !== void 0 && fromTemperature != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "temperature"], fromTemperature);
  }
  const fromTopP = getValueByPath(fromObject, ["topP"]);
  if (parentObject !== void 0 && fromTopP != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "topP"], fromTopP);
  }
  const fromTopK = getValueByPath(fromObject, ["topK"]);
  if (parentObject !== void 0 && fromTopK != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "topK"], fromTopK);
  }
  const fromMaxOutputTokens = getValueByPath(fromObject, [
    "maxOutputTokens"
  ]);
  if (parentObject !== void 0 && fromMaxOutputTokens != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "maxOutputTokens"], fromMaxOutputTokens);
  }
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (parentObject !== void 0 && fromMediaResolution != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "mediaResolution"], fromMediaResolution);
  }
  const fromSeed = getValueByPath(fromObject, ["seed"]);
  if (parentObject !== void 0 && fromSeed != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "seed"], fromSeed);
  }
  const fromSpeechConfig = getValueByPath(fromObject, ["speechConfig"]);
  if (parentObject !== void 0 && fromSpeechConfig != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "speechConfig"], tLiveSpeechConfig(fromSpeechConfig));
  }
  const fromThinkingConfig = getValueByPath(fromObject, [
    "thinkingConfig"
  ]);
  if (parentObject !== void 0 && fromThinkingConfig != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "thinkingConfig"], fromThinkingConfig);
  }
  const fromEnableAffectiveDialog = getValueByPath(fromObject, [
    "enableAffectiveDialog"
  ]);
  if (parentObject !== void 0 && fromEnableAffectiveDialog != null) {
    setValueByPath(parentObject, ["setup", "generationConfig", "enableAffectiveDialog"], fromEnableAffectiveDialog);
  }
  const fromSystemInstruction = getValueByPath(fromObject, [
    "systemInstruction"
  ]);
  if (parentObject !== void 0 && fromSystemInstruction != null) {
    setValueByPath(parentObject, ["setup", "systemInstruction"], contentToMldev(tContent(fromSystemInstruction)));
  }
  const fromTools = getValueByPath(fromObject, ["tools"]);
  if (parentObject !== void 0 && fromTools != null) {
    let transformedList = tTools(fromTools);
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return toolToMldev(tTool(item));
      });
    }
    setValueByPath(parentObject, ["setup", "tools"], transformedList);
  }
  const fromSessionResumption = getValueByPath(fromObject, [
    "sessionResumption"
  ]);
  if (parentObject !== void 0 && fromSessionResumption != null) {
    setValueByPath(parentObject, ["setup", "sessionResumption"], sessionResumptionConfigToMldev(fromSessionResumption));
  }
  const fromInputAudioTranscription = getValueByPath(fromObject, [
    "inputAudioTranscription"
  ]);
  if (parentObject !== void 0 && fromInputAudioTranscription != null) {
    setValueByPath(parentObject, ["setup", "inputAudioTranscription"], fromInputAudioTranscription);
  }
  const fromOutputAudioTranscription = getValueByPath(fromObject, [
    "outputAudioTranscription"
  ]);
  if (parentObject !== void 0 && fromOutputAudioTranscription != null) {
    setValueByPath(parentObject, ["setup", "outputAudioTranscription"], fromOutputAudioTranscription);
  }
  const fromRealtimeInputConfig = getValueByPath(fromObject, [
    "realtimeInputConfig"
  ]);
  if (parentObject !== void 0 && fromRealtimeInputConfig != null) {
    setValueByPath(parentObject, ["setup", "realtimeInputConfig"], fromRealtimeInputConfig);
  }
  const fromContextWindowCompression = getValueByPath(fromObject, [
    "contextWindowCompression"
  ]);
  if (parentObject !== void 0 && fromContextWindowCompression != null) {
    setValueByPath(parentObject, ["setup", "contextWindowCompression"], fromContextWindowCompression);
  }
  const fromProactivity = getValueByPath(fromObject, ["proactivity"]);
  if (parentObject !== void 0 && fromProactivity != null) {
    setValueByPath(parentObject, ["setup", "proactivity"], fromProactivity);
  }
  if (getValueByPath(fromObject, ["explicitVadSignal"]) !== void 0) {
    throw new Error("explicitVadSignal parameter is not supported in Gemini API.");
  }
  return toObject;
}
function liveConnectConstraintsToMldev(apiClient, fromObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["model"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["setup", "model"], tModel(apiClient, fromModel));
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    setValueByPath(toObject, ["config"], liveConnectConfigToMldev(fromConfig, toObject));
  }
  return toObject;
}
function partToMldev(fromObject) {
  const toObject = {};
  const fromMediaResolution = getValueByPath(fromObject, [
    "mediaResolution"
  ]);
  if (fromMediaResolution != null) {
    setValueByPath(toObject, ["mediaResolution"], fromMediaResolution);
  }
  const fromCodeExecutionResult = getValueByPath(fromObject, [
    "codeExecutionResult"
  ]);
  if (fromCodeExecutionResult != null) {
    setValueByPath(toObject, ["codeExecutionResult"], fromCodeExecutionResult);
  }
  const fromExecutableCode = getValueByPath(fromObject, [
    "executableCode"
  ]);
  if (fromExecutableCode != null) {
    setValueByPath(toObject, ["executableCode"], fromExecutableCode);
  }
  const fromFileData = getValueByPath(fromObject, ["fileData"]);
  if (fromFileData != null) {
    setValueByPath(toObject, ["fileData"], fileDataToMldev(fromFileData));
  }
  const fromFunctionCall = getValueByPath(fromObject, ["functionCall"]);
  if (fromFunctionCall != null) {
    setValueByPath(toObject, ["functionCall"], functionCallToMldev(fromFunctionCall));
  }
  const fromFunctionResponse = getValueByPath(fromObject, [
    "functionResponse"
  ]);
  if (fromFunctionResponse != null) {
    setValueByPath(toObject, ["functionResponse"], fromFunctionResponse);
  }
  const fromInlineData = getValueByPath(fromObject, ["inlineData"]);
  if (fromInlineData != null) {
    setValueByPath(toObject, ["inlineData"], blobToMldev(fromInlineData));
  }
  const fromText = getValueByPath(fromObject, ["text"]);
  if (fromText != null) {
    setValueByPath(toObject, ["text"], fromText);
  }
  const fromThought = getValueByPath(fromObject, ["thought"]);
  if (fromThought != null) {
    setValueByPath(toObject, ["thought"], fromThought);
  }
  const fromThoughtSignature = getValueByPath(fromObject, [
    "thoughtSignature"
  ]);
  if (fromThoughtSignature != null) {
    setValueByPath(toObject, ["thoughtSignature"], fromThoughtSignature);
  }
  const fromVideoMetadata = getValueByPath(fromObject, [
    "videoMetadata"
  ]);
  if (fromVideoMetadata != null) {
    setValueByPath(toObject, ["videoMetadata"], fromVideoMetadata);
  }
  return toObject;
}
function sessionResumptionConfigToMldev(fromObject) {
  const toObject = {};
  const fromHandle = getValueByPath(fromObject, ["handle"]);
  if (fromHandle != null) {
    setValueByPath(toObject, ["handle"], fromHandle);
  }
  if (getValueByPath(fromObject, ["transparent"]) !== void 0) {
    throw new Error("transparent parameter is not supported in Gemini API.");
  }
  return toObject;
}
function toolToMldev(fromObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["retrieval"]) !== void 0) {
    throw new Error("retrieval parameter is not supported in Gemini API.");
  }
  const fromComputerUse = getValueByPath(fromObject, ["computerUse"]);
  if (fromComputerUse != null) {
    setValueByPath(toObject, ["computerUse"], fromComputerUse);
  }
  const fromFileSearch = getValueByPath(fromObject, ["fileSearch"]);
  if (fromFileSearch != null) {
    setValueByPath(toObject, ["fileSearch"], fromFileSearch);
  }
  const fromCodeExecution = getValueByPath(fromObject, [
    "codeExecution"
  ]);
  if (fromCodeExecution != null) {
    setValueByPath(toObject, ["codeExecution"], fromCodeExecution);
  }
  if (getValueByPath(fromObject, ["enterpriseWebSearch"]) !== void 0) {
    throw new Error("enterpriseWebSearch parameter is not supported in Gemini API.");
  }
  const fromFunctionDeclarations = getValueByPath(fromObject, [
    "functionDeclarations"
  ]);
  if (fromFunctionDeclarations != null) {
    let transformedList = fromFunctionDeclarations;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["functionDeclarations"], transformedList);
  }
  const fromGoogleMaps = getValueByPath(fromObject, ["googleMaps"]);
  if (fromGoogleMaps != null) {
    setValueByPath(toObject, ["googleMaps"], googleMapsToMldev(fromGoogleMaps));
  }
  const fromGoogleSearch = getValueByPath(fromObject, ["googleSearch"]);
  if (fromGoogleSearch != null) {
    setValueByPath(toObject, ["googleSearch"], googleSearchToMldev(fromGoogleSearch));
  }
  const fromGoogleSearchRetrieval = getValueByPath(fromObject, [
    "googleSearchRetrieval"
  ]);
  if (fromGoogleSearchRetrieval != null) {
    setValueByPath(toObject, ["googleSearchRetrieval"], fromGoogleSearchRetrieval);
  }
  const fromUrlContext = getValueByPath(fromObject, ["urlContext"]);
  if (fromUrlContext != null) {
    setValueByPath(toObject, ["urlContext"], fromUrlContext);
  }
  return toObject;
}
function getFieldMasks(setup) {
  const fields = [];
  for (const key in setup) {
    if (Object.prototype.hasOwnProperty.call(setup, key)) {
      const value = setup[key];
      if (typeof value === "object" && value != null && Object.keys(value).length > 0) {
        const field = Object.keys(value).map((kk) => `${key}.${kk}`);
        fields.push(...field);
      } else {
        fields.push(key);
      }
    }
  }
  return fields.join(",");
}
function convertBidiSetupToTokenSetup(requestDict, config) {
  let setupForMaskGeneration = null;
  const bidiGenerateContentSetupValue = requestDict["bidiGenerateContentSetup"];
  if (typeof bidiGenerateContentSetupValue === "object" && bidiGenerateContentSetupValue !== null && "setup" in bidiGenerateContentSetupValue) {
    const innerSetup = bidiGenerateContentSetupValue.setup;
    if (typeof innerSetup === "object" && innerSetup !== null) {
      requestDict["bidiGenerateContentSetup"] = innerSetup;
      setupForMaskGeneration = innerSetup;
    } else {
      delete requestDict["bidiGenerateContentSetup"];
    }
  } else if (bidiGenerateContentSetupValue !== void 0) {
    delete requestDict["bidiGenerateContentSetup"];
  }
  const preExistingFieldMask = requestDict["fieldMask"];
  if (setupForMaskGeneration) {
    const generatedMaskFromBidi = getFieldMasks(setupForMaskGeneration);
    if (Array.isArray(config === null || config === void 0 ? void 0 : config.lockAdditionalFields) && (config === null || config === void 0 ? void 0 : config.lockAdditionalFields.length) === 0) {
      if (generatedMaskFromBidi) {
        requestDict["fieldMask"] = generatedMaskFromBidi;
      } else {
        delete requestDict["fieldMask"];
      }
    } else if ((config === null || config === void 0 ? void 0 : config.lockAdditionalFields) && config.lockAdditionalFields.length > 0 && preExistingFieldMask !== null && Array.isArray(preExistingFieldMask) && preExistingFieldMask.length > 0) {
      const generationConfigFields = [
        "temperature",
        "topK",
        "topP",
        "maxOutputTokens",
        "responseModalities",
        "seed",
        "speechConfig"
      ];
      let mappedFieldsFromPreExisting = [];
      if (preExistingFieldMask.length > 0) {
        mappedFieldsFromPreExisting = preExistingFieldMask.map((field) => {
          if (generationConfigFields.includes(field)) {
            return `generationConfig.${field}`;
          }
          return field;
        });
      }
      const finalMaskParts = [];
      if (generatedMaskFromBidi) {
        finalMaskParts.push(generatedMaskFromBidi);
      }
      if (mappedFieldsFromPreExisting.length > 0) {
        finalMaskParts.push(...mappedFieldsFromPreExisting);
      }
      if (finalMaskParts.length > 0) {
        requestDict["fieldMask"] = finalMaskParts.join(",");
      } else {
        delete requestDict["fieldMask"];
      }
    } else {
      delete requestDict["fieldMask"];
    }
  } else {
    if (preExistingFieldMask !== null && Array.isArray(preExistingFieldMask) && preExistingFieldMask.length > 0) {
      requestDict["fieldMask"] = preExistingFieldMask.join(",");
    } else {
      delete requestDict["fieldMask"];
    }
  }
  return requestDict;
}
var Tokens = class extends BaseModule {
  constructor(apiClient) {
    super();
    this.apiClient = apiClient;
  }
  /**
   * Creates an ephemeral auth token resource.
   *
   * @experimental
   *
   * @remarks
   * Ephemeral auth tokens is only supported in the Gemini Developer API.
   * It can be used for the session connection to the Live constrained API.
   * Support in v1alpha only.
   *
   * @param params - The parameters for the create request.
   * @return The created auth token.
   *
   * @example
   * ```ts
   * const ai = new GoogleGenAI({
   *     apiKey: token.name,
   *     httpOptions: { apiVersion: 'v1alpha' }  // Support in v1alpha only.
   * });
   *
   * // Case 1: If LiveEphemeralParameters is unset, unlock LiveConnectConfig
   * // when using the token in Live API sessions. Each session connection can
   * // use a different configuration.
   * const config: CreateAuthTokenConfig = {
   *     uses: 3,
   *     expireTime: '2025-05-01T00:00:00Z',
   * }
   * const token = await ai.tokens.create(config);
   *
   * // Case 2: If LiveEphemeralParameters is set, lock all fields in
   * // LiveConnectConfig when using the token in Live API sessions. For
   * // example, changing `outputAudioTranscription` in the Live API
   * // connection will be ignored by the API.
   * const config: CreateAuthTokenConfig =
   *     uses: 3,
   *     expireTime: '2025-05-01T00:00:00Z',
   *     LiveEphemeralParameters: {
   *        model: 'gemini-2.0-flash-001',
   *        config: {
   *           'responseModalities': ['AUDIO'],
   *           'systemInstruction': 'Always answer in English.',
   *        }
   *     }
   * }
   * const token = await ai.tokens.create(config);
   *
   * // Case 3: If LiveEphemeralParameters is set and lockAdditionalFields is
   * // set, lock LiveConnectConfig with set and additional fields (e.g.
   * // responseModalities, systemInstruction, temperature in this example) when
   * // using the token in Live API sessions.
   * const config: CreateAuthTokenConfig =
   *     uses: 3,
   *     expireTime: '2025-05-01T00:00:00Z',
   *     LiveEphemeralParameters: {
   *        model: 'gemini-2.0-flash-001',
   *        config: {
   *           'responseModalities': ['AUDIO'],
   *           'systemInstruction': 'Always answer in English.',
   *        }
   *     },
   *     lockAdditionalFields: ['temperature'],
   * }
   * const token = await ai.tokens.create(config);
   *
   * // Case 4: If LiveEphemeralParameters is set and lockAdditionalFields is
   * // empty array, lock LiveConnectConfig with set fields (e.g.
   * // responseModalities, systemInstruction in this example) when using the
   * // token in Live API sessions.
   * const config: CreateAuthTokenConfig =
   *     uses: 3,
   *     expireTime: '2025-05-01T00:00:00Z',
   *     LiveEphemeralParameters: {
   *        model: 'gemini-2.0-flash-001',
   *        config: {
   *           'responseModalities': ['AUDIO'],
   *           'systemInstruction': 'Always answer in English.',
   *        }
   *     },
   *     lockAdditionalFields: [],
   * }
   * const token = await ai.tokens.create(config);
   * ```
   */
  async create(params) {
    var _a5, _b;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      throw new Error("The client.tokens.create method is only supported by the Gemini Developer API.");
    } else {
      const body = createAuthTokenParametersToMldev(this.apiClient, params);
      path4 = formatMap("auth_tokens", body["_url"]);
      queryParams = body["_query"];
      delete body["config"];
      delete body["_url"];
      delete body["_query"];
      const transformedBody = convertBidiSetupToTokenSetup(body, params.config);
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(transformedBody),
        httpMethod: "POST",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((resp) => {
        return resp;
      });
    }
  }
};
function deleteDocumentConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromForce = getValueByPath(fromObject, ["force"]);
  if (parentObject !== void 0 && fromForce != null) {
    setValueByPath(parentObject, ["_query", "force"], fromForce);
  }
  return toObject;
}
function deleteDocumentParametersToMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], fromName);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    deleteDocumentConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function getDocumentParametersToMldev(fromObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], fromName);
  }
  return toObject;
}
function listDocumentsConfigToMldev(fromObject, parentObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== void 0 && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== void 0 && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  return toObject;
}
function listDocumentsParametersToMldev(fromObject) {
  const toObject = {};
  const fromParent = getValueByPath(fromObject, ["parent"]);
  if (fromParent != null) {
    setValueByPath(toObject, ["_url", "parent"], fromParent);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    listDocumentsConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function listDocumentsResponseFromMldev(fromObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromDocuments = getValueByPath(fromObject, ["documents"]);
  if (fromDocuments != null) {
    let transformedList = fromDocuments;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["documents"], transformedList);
  }
  return toObject;
}
var Documents = class extends BaseModule {
  constructor(apiClient) {
    super();
    this.apiClient = apiClient;
    this.list = async (params) => {
      return new Pager(PagedItem.PAGED_ITEM_DOCUMENTS, (x3) => this.listInternal({ parent: params.parent, config: x3.config }), await this.listInternal(params), params);
    };
  }
  /**
   * Gets a Document.
   *
   * @param params - The parameters for getting a document.
   * @return Document.
   */
  async get(params) {
    var _a5, _b;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      throw new Error("This method is only supported by the Gemini Developer API.");
    } else {
      const body = getDocumentParametersToMldev(params);
      path4 = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((resp) => {
        return resp;
      });
    }
  }
  /**
   * Deletes a Document.
   *
   * @param params - The parameters for deleting a document.
   */
  async delete(params) {
    var _a5, _b;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      throw new Error("This method is only supported by the Gemini Developer API.");
    } else {
      const body = deleteDocumentParametersToMldev(params);
      path4 = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      await this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "DELETE",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      });
    }
  }
  async listInternal(params) {
    var _a5, _b;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      throw new Error("This method is only supported by the Gemini Developer API.");
    } else {
      const body = listDocumentsParametersToMldev(params);
      path4 = formatMap("{parent}/documents", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = listDocumentsResponseFromMldev(apiResponse);
        const typedResp = new ListDocumentsResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
};
var FileSearchStores = class extends BaseModule {
  constructor(apiClient, documents = new Documents(apiClient)) {
    super();
    this.apiClient = apiClient;
    this.documents = documents;
    this.list = async (params = {}) => {
      return new Pager(PagedItem.PAGED_ITEM_FILE_SEARCH_STORES, (x3) => this.listInternal(x3), await this.listInternal(params), params);
    };
  }
  /**
   * Uploads a file asynchronously to a given File Search Store.
   * This method is not available in Vertex AI.
   * Supported upload sources:
   * - Node.js: File path (string) or Blob object.
   * - Browser: Blob object (e.g., File).
   *
   * @remarks
   * The `mimeType` can be specified in the `config` parameter. If omitted:
   *  - For file path (string) inputs, the `mimeType` will be inferred from the
   *     file extension.
   *  - For Blob object inputs, the `mimeType` will be set to the Blob's `type`
   *     property.
   *
   * This section can contain multiple paragraphs and code examples.
   *
   * @param params - Optional parameters specified in the
   *        `types.UploadToFileSearchStoreParameters` interface.
   *         @see {@link types.UploadToFileSearchStoreParameters#config} for the optional
   *         config in the parameters.
   * @return A promise that resolves to a long running operation.
   * @throws An error if called on a Vertex AI client.
   * @throws An error if the `mimeType` is not provided and can not be inferred,
   * the `mimeType` can be provided in the `params.config` parameter.
   * @throws An error occurs if a suitable upload location cannot be established.
   *
   * @example
   * The following code uploads a file to a given file search store.
   *
   * ```ts
   * const operation = await ai.fileSearchStores.upload({fileSearchStoreName: 'fileSearchStores/foo-bar', file: 'file.txt', config: {
   *   mimeType: 'text/plain',
   * }});
   * console.log(operation.name);
   * ```
   */
  async uploadToFileSearchStore(params) {
    if (this.apiClient.isVertexAI()) {
      throw new Error("Vertex AI does not support uploading files to a file search store.");
    }
    return this.apiClient.uploadFileToFileSearchStore(params.fileSearchStoreName, params.file, params.config);
  }
  /**
   * Creates a File Search Store.
   *
   * @param params - The parameters for creating a File Search Store.
   * @return FileSearchStore.
   */
  async create(params) {
    var _a5, _b;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      throw new Error("This method is only supported by the Gemini Developer API.");
    } else {
      const body = createFileSearchStoreParametersToMldev(params);
      path4 = formatMap("fileSearchStores", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((resp) => {
        return resp;
      });
    }
  }
  /**
   * Gets a File Search Store.
   *
   * @param params - The parameters for getting a File Search Store.
   * @return FileSearchStore.
   */
  async get(params) {
    var _a5, _b;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      throw new Error("This method is only supported by the Gemini Developer API.");
    } else {
      const body = getFileSearchStoreParametersToMldev(params);
      path4 = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((resp) => {
        return resp;
      });
    }
  }
  /**
   * Deletes a File Search Store.
   *
   * @param params - The parameters for deleting a File Search Store.
   */
  async delete(params) {
    var _a5, _b;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      throw new Error("This method is only supported by the Gemini Developer API.");
    } else {
      const body = deleteFileSearchStoreParametersToMldev(params);
      path4 = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      await this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "DELETE",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      });
    }
  }
  async listInternal(params) {
    var _a5, _b;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      throw new Error("This method is only supported by the Gemini Developer API.");
    } else {
      const body = listFileSearchStoresParametersToMldev(params);
      path4 = formatMap("fileSearchStores", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = listFileSearchStoresResponseFromMldev(apiResponse);
        const typedResp = new ListFileSearchStoresResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
  async uploadToFileSearchStoreInternal(params) {
    var _a5, _b;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      throw new Error("This method is only supported by the Gemini Developer API.");
    } else {
      const body = uploadToFileSearchStoreParametersToMldev(params);
      path4 = formatMap("upload/v1beta/{file_search_store_name}:uploadToFileSearchStore", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = uploadToFileSearchStoreResumableResponseFromMldev(apiResponse);
        const typedResp = new UploadToFileSearchStoreResumableResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
  /**
   * Imports a File from File Service to a FileSearchStore.
   *
   * This is a long-running operation, see aip.dev/151
   *
   * @param params - The parameters for importing a file to a file search store.
   * @return ImportFileOperation.
   */
  async importFile(params) {
    var _a5, _b;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      throw new Error("This method is only supported by the Gemini Developer API.");
    } else {
      const body = importFileParametersToMldev(params);
      path4 = formatMap("{file_search_store_name}:importFile", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json();
      });
      return response.then((apiResponse) => {
        const resp = importFileOperationFromMldev(apiResponse);
        const typedResp = new ImportFileOperation();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
};
var uuid4Internal = function() {
  const { crypto: crypto2 } = globalThis;
  if (crypto2 === null || crypto2 === void 0 ? void 0 : crypto2.randomUUID) {
    uuid4Internal = crypto2.randomUUID.bind(crypto2);
    return crypto2.randomUUID();
  }
  const u8 = new Uint8Array(1);
  const randomByte = crypto2 ? () => crypto2.getRandomValues(u8)[0] : () => Math.random() * 255 & 255;
  return "10000000-1000-4000-8000-100000000000".replace(/[018]/g, (c) => (+c ^ randomByte() & 15 >> +c / 4).toString(16));
};
var uuid43 = () => uuid4Internal();
function isAbortError3(err) {
  return typeof err === "object" && err !== null && // Spec-compliant fetch implementations
  ("name" in err && err.name === "AbortError" || // Expo fetch
  "message" in err && String(err.message).includes("FetchRequestCanceledException"));
}
var castToError3 = (err) => {
  if (err instanceof Error)
    return err;
  if (typeof err === "object" && err !== null) {
    try {
      if (Object.prototype.toString.call(err) === "[object Error]") {
        const error = new Error(err.message, err.cause ? { cause: err.cause } : {});
        if (err.stack)
          error.stack = err.stack;
        if (err.cause && !error.cause)
          error.cause = err.cause;
        if (err.name)
          error.name = err.name;
        return error;
      }
    } catch (_a5) {
    }
    try {
      return new Error(JSON.stringify(err));
    } catch (_b) {
    }
  }
  return new Error(err);
};
var GeminiNextGenAPIClientError = class extends Error {
};
var APIError3 = class _APIError extends GeminiNextGenAPIClientError {
  constructor(status, error, message, headers) {
    super(`${_APIError.makeMessage(status, error, message)}`);
    this.status = status;
    this.headers = headers;
    this.error = error;
  }
  static makeMessage(status, error, message) {
    const msg = (error === null || error === void 0 ? void 0 : error.message) ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
    if (status && msg) {
      return `${status} ${msg}`;
    }
    if (status) {
      return `${status} status code (no body)`;
    }
    if (msg) {
      return msg;
    }
    return "(no status code or body)";
  }
  static generate(status, errorResponse, message, headers) {
    if (!status || !headers) {
      return new APIConnectionError3({ message, cause: castToError3(errorResponse) });
    }
    const error = errorResponse;
    if (status === 400) {
      return new BadRequestError3(status, error, message, headers);
    }
    if (status === 401) {
      return new AuthenticationError3(status, error, message, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError3(status, error, message, headers);
    }
    if (status === 404) {
      return new NotFoundError3(status, error, message, headers);
    }
    if (status === 409) {
      return new ConflictError3(status, error, message, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError3(status, error, message, headers);
    }
    if (status === 429) {
      return new RateLimitError3(status, error, message, headers);
    }
    if (status >= 500) {
      return new InternalServerError3(status, error, message, headers);
    }
    return new _APIError(status, error, message, headers);
  }
};
var APIUserAbortError3 = class extends APIError3 {
  constructor({ message } = {}) {
    super(void 0, void 0, message || "Request was aborted.", void 0);
  }
};
var APIConnectionError3 = class extends APIError3 {
  constructor({ message, cause }) {
    super(void 0, void 0, message || "Connection error.", void 0);
    if (cause)
      this.cause = cause;
  }
};
var APIConnectionTimeoutError3 = class extends APIConnectionError3 {
  constructor({ message } = {}) {
    super({ message: message !== null && message !== void 0 ? message : "Request timed out." });
  }
};
var BadRequestError3 = class extends APIError3 {
};
var AuthenticationError3 = class extends APIError3 {
};
var PermissionDeniedError3 = class extends APIError3 {
};
var NotFoundError3 = class extends APIError3 {
};
var ConflictError3 = class extends APIError3 {
};
var UnprocessableEntityError3 = class extends APIError3 {
};
var RateLimitError3 = class extends APIError3 {
};
var InternalServerError3 = class extends APIError3 {
};
var startsWithSchemeRegexp3 = /^[a-z][a-z0-9+.-]*:/i;
var isAbsoluteURL3 = (url) => {
  return startsWithSchemeRegexp3.test(url);
};
var isArrayInternal = (val) => (isArrayInternal = Array.isArray, isArrayInternal(val));
var isArray3 = isArrayInternal;
var isReadonlyArrayInternal = isArray3;
var isReadonlyArray3 = isReadonlyArrayInternal;
function isEmptyObj3(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn3(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
var validatePositiveInteger3 = (name, n3) => {
  if (typeof n3 !== "number" || !Number.isInteger(n3)) {
    throw new GeminiNextGenAPIClientError(`${name} must be an integer`);
  }
  if (n3 < 0) {
    throw new GeminiNextGenAPIClientError(`${name} must be a positive integer`);
  }
  return n3;
};
var safeJSON3 = (text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return void 0;
  }
};
var sleep$1 = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
var VERSION3 = "0.0.1";
function getDetectedPlatform3() {
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return "deno";
  }
  if (typeof EdgeRuntime !== "undefined") {
    return "edge";
  }
  if (Object.prototype.toString.call(typeof globalThis.process !== "undefined" ? globalThis.process : 0) === "[object process]") {
    return "node";
  }
  return "unknown";
}
var getPlatformProperties3 = () => {
  var _a5, _b, _c, _d, _e;
  const detectedPlatform = getDetectedPlatform3();
  if (detectedPlatform === "deno") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION3,
      "X-Stainless-OS": normalizePlatform3(Deno.build.os),
      "X-Stainless-Arch": normalizeArch3(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : (_b = (_a5 = Deno.version) === null || _a5 === void 0 ? void 0 : _a5.deno) !== null && _b !== void 0 ? _b : "unknown"
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION3,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": globalThis.process.version
    };
  }
  if (detectedPlatform === "node") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION3,
      "X-Stainless-OS": normalizePlatform3((_c = globalThis.process.platform) !== null && _c !== void 0 ? _c : "unknown"),
      "X-Stainless-Arch": normalizeArch3((_d = globalThis.process.arch) !== null && _d !== void 0 ? _d : "unknown"),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": (_e = globalThis.process.version) !== null && _e !== void 0 ? _e : "unknown"
    };
  }
  const browserInfo = getBrowserInfo3();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION3,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION3,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function getBrowserInfo3() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
var normalizeArch3 = (arch) => {
  if (arch === "x32")
    return "x32";
  if (arch === "x86_64" || arch === "x64")
    return "x64";
  if (arch === "arm")
    return "arm";
  if (arch === "aarch64" || arch === "arm64")
    return "arm64";
  if (arch)
    return `other:${arch}`;
  return "unknown";
};
var normalizePlatform3 = (platform) => {
  platform = platform.toLowerCase();
  if (platform.includes("ios"))
    return "iOS";
  if (platform === "android")
    return "Android";
  if (platform === "darwin")
    return "MacOS";
  if (platform === "win32")
    return "Windows";
  if (platform === "freebsd")
    return "FreeBSD";
  if (platform === "openbsd")
    return "OpenBSD";
  if (platform === "linux")
    return "Linux";
  if (platform)
    return `Other:${platform}`;
  return "Unknown";
};
var _platformHeaders3;
var getPlatformHeaders3 = () => {
  return _platformHeaders3 !== null && _platformHeaders3 !== void 0 ? _platformHeaders3 : _platformHeaders3 = getPlatformProperties3();
};
function getDefaultFetch3() {
  if (typeof fetch !== "undefined") {
    return fetch;
  }
  throw new Error("`fetch` is not defined as a global; Either pass `fetch` to the client, `new GeminiNextGenAPIClient({ fetch })` or polyfill the global, `globalThis.fetch = fetch`");
}
function makeReadableStream3(...args) {
  const ReadableStream2 = globalThis.ReadableStream;
  if (typeof ReadableStream2 === "undefined") {
    throw new Error("`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`");
  }
  return new ReadableStream2(...args);
}
function ReadableStreamFrom3(iterable) {
  let iter = Symbol.asyncIterator in iterable ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();
  return makeReadableStream3({
    start() {
    },
    async pull(controller) {
      const { done, value } = await iter.next();
      if (done) {
        controller.close();
      } else {
        controller.enqueue(value);
      }
    },
    async cancel() {
      var _a5;
      await ((_a5 = iter.return) === null || _a5 === void 0 ? void 0 : _a5.call(iter));
    }
  });
}
function ReadableStreamToAsyncIterable3(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result === null || result === void 0 ? void 0 : result.done)
          reader.releaseLock();
        return result;
      } catch (e3) {
        reader.releaseLock();
        throw e3;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
async function CancelReadableStream3(stream) {
  var _a5, _b;
  if (stream === null || typeof stream !== "object")
    return;
  if (stream[Symbol.asyncIterator]) {
    await ((_b = (_a5 = stream[Symbol.asyncIterator]()).return) === null || _b === void 0 ? void 0 : _b.call(_a5));
    return;
  }
  const reader = stream.getReader();
  const cancelPromise = reader.cancel();
  reader.releaseLock();
  await cancelPromise;
}
var FallbackEncoder3 = ({ headers, body }) => {
  return {
    bodyHeaders: {
      "content-type": "application/json"
    },
    body: JSON.stringify(body)
  };
};
var checkFileSupport3 = () => {
  var _a5;
  if (typeof File === "undefined") {
    const { process: process2 } = globalThis;
    const isOldNode = typeof ((_a5 = process2 === null || process2 === void 0 ? void 0 : process2.versions) === null || _a5 === void 0 ? void 0 : _a5.node) === "string" && parseInt(process2.versions.node.split(".")) < 20;
    throw new Error("`File` is not defined as a global, which is required for file uploads." + (isOldNode ? " Update to Node 20 LTS or newer, or set `globalThis.File` to `import('node:buffer').File`." : ""));
  }
};
function makeFile3(fileBits, fileName, options) {
  checkFileSupport3();
  return new File(fileBits, fileName !== null && fileName !== void 0 ? fileName : "unknown_file", options);
}
function getName3(value) {
  return (typeof value === "object" && value !== null && ("name" in value && value.name && String(value.name) || "url" in value && value.url && String(value.url) || "filename" in value && value.filename && String(value.filename) || "path" in value && value.path && String(value.path)) || "").split(/[\\/]/).pop() || void 0;
}
var isAsyncIterable3 = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
var isBlobLike3 = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
var isFileLike3 = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike3(value);
var isResponseLike3 = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
async function toFile3(value, name, options) {
  checkFileSupport3();
  value = await value;
  if (isFileLike3(value)) {
    if (value instanceof File) {
      return value;
    }
    return makeFile3([await value.arrayBuffer()], value.name);
  }
  if (isResponseLike3(value)) {
    const blob = await value.blob();
    name || (name = new URL(value.url).pathname.split(/[\\/]/).pop());
    return makeFile3(await getBytes3(blob), name, options);
  }
  const parts = await getBytes3(value);
  name || (name = getName3(value));
  if (!(options === null || options === void 0 ? void 0 : options.type)) {
    const type = parts.find((part) => typeof part === "object" && "type" in part && part.type);
    if (typeof type === "string") {
      options = Object.assign(Object.assign({}, options), { type });
    }
  }
  return makeFile3(parts, name, options);
}
async function getBytes3(value) {
  var _a5, e_1, _b, _c;
  var _d;
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
  value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike3(value)) {
    parts.push(value instanceof Blob ? value : await value.arrayBuffer());
  } else if (isAsyncIterable3(value)) {
    try {
      for (var _e = true, value_1 = __asyncValues(value), value_1_1; value_1_1 = await value_1.next(), _a5 = value_1_1.done, !_a5; _e = true) {
        _c = value_1_1.value;
        _e = false;
        const chunk = _c;
        parts.push(...await getBytes3(chunk));
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (!_e && !_a5 && (_b = value_1.return)) await _b.call(value_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
  } else {
    const constructor = (_d = value === null || value === void 0 ? void 0 : value.constructor) === null || _d === void 0 ? void 0 : _d.name;
    throw new Error(`Unexpected data type: ${typeof value}${constructor ? `; constructor: ${constructor}` : ""}${propsForError3(value)}`);
  }
  return parts;
}
function propsForError3(value) {
  if (typeof value !== "object" || value === null)
    return "";
  const props = Object.getOwnPropertyNames(value);
  return `; props: [${props.map((p3) => `"${p3}"`).join(", ")}]`;
}
var APIResource3 = class {
  constructor(client) {
    this._client = client;
  }
};
APIResource3._key = [];
function encodeURIPath3(str2) {
  return str2.replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]+/g, encodeURIComponent);
}
var EMPTY3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.create(null));
var createPathTagFunction3 = (pathEncoder = encodeURIPath3) => (function path4(statics, ...params) {
  if (statics.length === 1)
    return statics[0];
  let postPath = false;
  const invalidSegments = [];
  const path5 = statics.reduce((previousValue, currentValue, index) => {
    var _a5, _b, _c;
    if (/[?#]/.test(currentValue)) {
      postPath = true;
    }
    const value = params[index];
    let encoded = (postPath ? encodeURIComponent : pathEncoder)("" + value);
    if (index !== params.length && (value == null || typeof value === "object" && // handle values from other realms
    value.toString === ((_c = Object.getPrototypeOf((_b = Object.getPrototypeOf((_a5 = value.hasOwnProperty) !== null && _a5 !== void 0 ? _a5 : EMPTY3)) !== null && _b !== void 0 ? _b : EMPTY3)) === null || _c === void 0 ? void 0 : _c.toString))) {
      encoded = value + "";
      invalidSegments.push({
        start: previousValue.length + currentValue.length,
        length: encoded.length,
        error: `Value of type ${Object.prototype.toString.call(value).slice(8, -1)} is not a valid path parameter`
      });
    }
    return previousValue + currentValue + (index === params.length ? "" : encoded);
  }, "");
  const pathOnly = path5.split(/[?#]/, 1)[0];
  const invalidSegmentPattern = /(?<=^|\/)(?:\.|%2e){1,2}(?=\/|$)/gi;
  let match;
  while ((match = invalidSegmentPattern.exec(pathOnly)) !== null) {
    invalidSegments.push({
      start: match.index,
      length: match[0].length,
      error: `Value "${match[0]}" can't be safely passed as a path parameter`
    });
  }
  invalidSegments.sort((a, b3) => a.start - b3.start);
  if (invalidSegments.length > 0) {
    let lastEnd = 0;
    const underline = invalidSegments.reduce((acc, segment) => {
      const spaces = " ".repeat(segment.start - lastEnd);
      const arrows = "^".repeat(segment.length);
      lastEnd = segment.start + segment.length;
      return acc + spaces + arrows;
    }, "");
    throw new GeminiNextGenAPIClientError(`Path parameters result in path with invalid segments:
${invalidSegments.map((e3) => e3.error).join("\n")}
${path5}
${underline}`);
  }
  return path5;
});
var path3 = /* @__PURE__ */ createPathTagFunction3(encodeURIPath3);
var BaseInteractions = class extends APIResource3 {
  create(params, options) {
    var _a5;
    const { api_version = this._client.apiVersion } = params, body = __rest(params, ["api_version"]);
    if ("model" in body && "agent_config" in body) {
      throw new GeminiNextGenAPIClientError(`Invalid request: specified \`model\` and \`agent_config\`. If specifying \`model\`, use \`generation_config\`.`);
    }
    if ("agent" in body && "generation_config" in body) {
      throw new GeminiNextGenAPIClientError(`Invalid request: specified \`agent\` and \`generation_config\`. If specifying \`agent\`, use \`agent_config\`.`);
    }
    return this._client.post(path3`/${api_version}/interactions`, Object.assign(Object.assign({ body }, options), { stream: (_a5 = params.stream) !== null && _a5 !== void 0 ? _a5 : false }));
  }
  /**
   * Deletes the interaction by id.
   *
   * @example
   * ```ts
   * const interaction = await client.interactions.delete('id', {
   *   api_version: 'api_version',
   * });
   * ```
   */
  delete(id, params = {}, options) {
    const { api_version = this._client.apiVersion } = params !== null && params !== void 0 ? params : {};
    return this._client.delete(path3`/${api_version}/interactions/${id}`, options);
  }
  /**
   * Cancels an interaction by id. This only applies to background interactions that are still running.
   *
   * @example
   * ```ts
   * const interaction = await client.interactions.cancel('id', {
   *   api_version: 'api_version',
   * });
   * ```
   */
  cancel(id, params = {}, options) {
    const { api_version = this._client.apiVersion } = params !== null && params !== void 0 ? params : {};
    return this._client.post(path3`/${api_version}/interactions/${id}/cancel`, options);
  }
  get(id, params = {}, options) {
    var _a5;
    const _b = params !== null && params !== void 0 ? params : {}, { api_version = this._client.apiVersion } = _b, query = __rest(_b, ["api_version"]);
    return this._client.get(path3`/${api_version}/interactions/${id}`, Object.assign(Object.assign({ query }, options), { stream: (_a5 = params === null || params === void 0 ? void 0 : params.stream) !== null && _a5 !== void 0 ? _a5 : false }));
  }
};
BaseInteractions._key = Object.freeze(["interactions"]);
var Interactions = class extends BaseInteractions {
};
function concatBytes3(buffers) {
  let length = 0;
  for (const buffer of buffers) {
    length += buffer.length;
  }
  const output = new Uint8Array(length);
  let index = 0;
  for (const buffer of buffers) {
    output.set(buffer, index);
    index += buffer.length;
  }
  return output;
}
var encodeUTF8_3;
function encodeUTF83(str2) {
  let encoder;
  return (encodeUTF8_3 !== null && encodeUTF8_3 !== void 0 ? encodeUTF8_3 : (encoder = new globalThis.TextEncoder(), encodeUTF8_3 = encoder.encode.bind(encoder)))(str2);
}
var decodeUTF8_3;
function decodeUTF83(bytes) {
  let decoder;
  return (decodeUTF8_3 !== null && decodeUTF8_3 !== void 0 ? decodeUTF8_3 : (decoder = new globalThis.TextDecoder(), decodeUTF8_3 = decoder.decode.bind(decoder)))(bytes);
}
var LineDecoder3 = class {
  constructor() {
    this.buffer = new Uint8Array();
    this.carriageReturnIndex = null;
  }
  decode(chunk) {
    if (chunk == null) {
      return [];
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? encodeUTF83(chunk) : chunk;
    this.buffer = concatBytes3([this.buffer, binaryChunk]);
    const lines = [];
    let patternIndex;
    while ((patternIndex = findNewlineIndex3(this.buffer, this.carriageReturnIndex)) != null) {
      if (patternIndex.carriage && this.carriageReturnIndex == null) {
        this.carriageReturnIndex = patternIndex.index;
        continue;
      }
      if (this.carriageReturnIndex != null && (patternIndex.index !== this.carriageReturnIndex + 1 || patternIndex.carriage)) {
        lines.push(decodeUTF83(this.buffer.subarray(0, this.carriageReturnIndex - 1)));
        this.buffer = this.buffer.subarray(this.carriageReturnIndex);
        this.carriageReturnIndex = null;
        continue;
      }
      const endIndex = this.carriageReturnIndex !== null ? patternIndex.preceding - 1 : patternIndex.preceding;
      const line = decodeUTF83(this.buffer.subarray(0, endIndex));
      lines.push(line);
      this.buffer = this.buffer.subarray(patternIndex.index);
      this.carriageReturnIndex = null;
    }
    return lines;
  }
  flush() {
    if (!this.buffer.length) {
      return [];
    }
    return this.decode("\n");
  }
};
LineDecoder3.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r"]);
LineDecoder3.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
function findNewlineIndex3(buffer, startIndex) {
  const newline = 10;
  const carriage = 13;
  for (let i3 = startIndex !== null && startIndex !== void 0 ? startIndex : 0; i3 < buffer.length; i3++) {
    if (buffer[i3] === newline) {
      return { preceding: i3, index: i3 + 1, carriage: false };
    }
    if (buffer[i3] === carriage) {
      return { preceding: i3, index: i3 + 1, carriage: true };
    }
  }
  return null;
}
function findDoubleNewlineIndex3(buffer) {
  const newline = 10;
  const carriage = 13;
  for (let i3 = 0; i3 < buffer.length - 1; i3++) {
    if (buffer[i3] === newline && buffer[i3 + 1] === newline) {
      return i3 + 2;
    }
    if (buffer[i3] === carriage && buffer[i3 + 1] === carriage) {
      return i3 + 2;
    }
    if (buffer[i3] === carriage && buffer[i3 + 1] === newline && i3 + 3 < buffer.length && buffer[i3 + 2] === carriage && buffer[i3 + 3] === newline) {
      return i3 + 4;
    }
  }
  return -1;
}
var levelNumbers3 = {
  off: 0,
  error: 200,
  warn: 300,
  info: 400,
  debug: 500
};
var parseLogLevel3 = (maybeLevel, sourceName, client) => {
  if (!maybeLevel) {
    return void 0;
  }
  if (hasOwn3(levelNumbers3, maybeLevel)) {
    return maybeLevel;
  }
  loggerFor3(client).warn(`${sourceName} was set to ${JSON.stringify(maybeLevel)}, expected one of ${JSON.stringify(Object.keys(levelNumbers3))}`);
  return void 0;
};
function noop3() {
}
function makeLogFn3(fnLevel, logger, logLevel) {
  if (!logger || levelNumbers3[fnLevel] > levelNumbers3[logLevel]) {
    return noop3;
  } else {
    return logger[fnLevel].bind(logger);
  }
}
var noopLogger3 = {
  error: noop3,
  warn: noop3,
  info: noop3,
  debug: noop3
};
var cachedLoggers3 = /* @__PURE__ */ new WeakMap();
function loggerFor3(client) {
  var _a5;
  const logger = client.logger;
  const logLevel = (_a5 = client.logLevel) !== null && _a5 !== void 0 ? _a5 : "off";
  if (!logger) {
    return noopLogger3;
  }
  const cachedLogger = cachedLoggers3.get(logger);
  if (cachedLogger && cachedLogger[0] === logLevel) {
    return cachedLogger[1];
  }
  const levelLogger = {
    error: makeLogFn3("error", logger, logLevel),
    warn: makeLogFn3("warn", logger, logLevel),
    info: makeLogFn3("info", logger, logLevel),
    debug: makeLogFn3("debug", logger, logLevel)
  };
  cachedLoggers3.set(logger, [logLevel, levelLogger]);
  return levelLogger;
}
var formatRequestDetails3 = (details) => {
  if (details.options) {
    details.options = Object.assign({}, details.options);
    delete details.options["headers"];
  }
  if (details.headers) {
    details.headers = Object.fromEntries((details.headers instanceof Headers ? [...details.headers] : Object.entries(details.headers)).map(([name, value]) => [
      name,
      name.toLowerCase() === "x-goog-api-key" || name.toLowerCase() === "authorization" || name.toLowerCase() === "cookie" || name.toLowerCase() === "set-cookie" ? "***" : value
    ]));
  }
  if ("retryOfRequestLogID" in details) {
    if (details.retryOfRequestLogID) {
      details.retryOf = details.retryOfRequestLogID;
    }
    delete details.retryOfRequestLogID;
  }
  return details;
};
var Stream3 = class _Stream {
  constructor(iterator, controller, client) {
    this.iterator = iterator;
    this.controller = controller;
    this.client = client;
  }
  static fromSSEResponse(response, controller, client) {
    let consumed = false;
    const logger = client ? loggerFor3(client) : console;
    function iterator() {
      return __asyncGenerator(this, arguments, function* iterator_1() {
        var _a5, e_1, _b, _c;
        if (consumed) {
          throw new GeminiNextGenAPIClientError("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
        }
        consumed = true;
        let done = false;
        try {
          try {
            for (var _d = true, _e = __asyncValues(_iterSSEMessages3(response, controller)), _f; _f = yield __await(_e.next()), _a5 = _f.done, !_a5; _d = true) {
              _c = _f.value;
              _d = false;
              const sse = _c;
              if (done)
                continue;
              if (sse.data.startsWith("[DONE]")) {
                done = true;
                continue;
              } else {
                try {
                  yield yield __await(JSON.parse(sse.data));
                } catch (e3) {
                  logger.error(`Could not parse message into JSON:`, sse.data);
                  logger.error(`From chunk:`, sse.raw);
                  throw e3;
                }
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (!_d && !_a5 && (_b = _e.return)) yield __await(_b.call(_e));
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          done = true;
        } catch (e3) {
          if (isAbortError3(e3))
            return yield __await(void 0);
          throw e3;
        } finally {
          if (!done)
            controller.abort();
        }
      });
    }
    return new _Stream(iterator, controller, client);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(readableStream, controller, client) {
    let consumed = false;
    function iterLines() {
      return __asyncGenerator(this, arguments, function* iterLines_1() {
        var _a5, e_2, _b, _c;
        const lineDecoder = new LineDecoder3();
        const iter = ReadableStreamToAsyncIterable3(readableStream);
        try {
          for (var _d = true, iter_1 = __asyncValues(iter), iter_1_1; iter_1_1 = yield __await(iter_1.next()), _a5 = iter_1_1.done, !_a5; _d = true) {
            _c = iter_1_1.value;
            _d = false;
            const chunk = _c;
            for (const line of lineDecoder.decode(chunk)) {
              yield yield __await(line);
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (!_d && !_a5 && (_b = iter_1.return)) yield __await(_b.call(iter_1));
          } finally {
            if (e_2) throw e_2.error;
          }
        }
        for (const line of lineDecoder.flush()) {
          yield yield __await(line);
        }
      });
    }
    function iterator() {
      return __asyncGenerator(this, arguments, function* iterator_2() {
        var _a5, e_3, _b, _c;
        if (consumed) {
          throw new GeminiNextGenAPIClientError("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
        }
        consumed = true;
        let done = false;
        try {
          try {
            for (var _d = true, _e = __asyncValues(iterLines()), _f; _f = yield __await(_e.next()), _a5 = _f.done, !_a5; _d = true) {
              _c = _f.value;
              _d = false;
              const line = _c;
              if (done)
                continue;
              if (line)
                yield yield __await(JSON.parse(line));
            }
          } catch (e_3_1) {
            e_3 = { error: e_3_1 };
          } finally {
            try {
              if (!_d && !_a5 && (_b = _e.return)) yield __await(_b.call(_e));
            } finally {
              if (e_3) throw e_3.error;
            }
          }
          done = true;
        } catch (e3) {
          if (isAbortError3(e3))
            return yield __await(void 0);
          throw e3;
        } finally {
          if (!done)
            controller.abort();
        }
      });
    }
    return new _Stream(iterator, controller, client);
  }
  [Symbol.asyncIterator]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const left = [];
    const right = [];
    const iterator = this.iterator();
    const teeIterator = (queue) => {
      return {
        next: () => {
          if (queue.length === 0) {
            const result = iterator.next();
            left.push(result);
            right.push(result);
          }
          return queue.shift();
        }
      };
    };
    return [
      new _Stream(() => teeIterator(left), this.controller, this.client),
      new _Stream(() => teeIterator(right), this.controller, this.client)
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const self2 = this;
    let iter;
    return makeReadableStream3({
      async start() {
        iter = self2[Symbol.asyncIterator]();
      },
      async pull(ctrl) {
        try {
          const { value, done } = await iter.next();
          if (done)
            return ctrl.close();
          const bytes = encodeUTF83(JSON.stringify(value) + "\n");
          ctrl.enqueue(bytes);
        } catch (err) {
          ctrl.error(err);
        }
      },
      async cancel() {
        var _a5;
        await ((_a5 = iter.return) === null || _a5 === void 0 ? void 0 : _a5.call(iter));
      }
    });
  }
};
function _iterSSEMessages3(response, controller) {
  return __asyncGenerator(this, arguments, function* _iterSSEMessages_1() {
    var _a5, e_4, _b, _c;
    if (!response.body) {
      controller.abort();
      if (typeof globalThis.navigator !== "undefined" && globalThis.navigator.product === "ReactNative") {
        throw new GeminiNextGenAPIClientError(`The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api`);
      }
      throw new GeminiNextGenAPIClientError(`Attempted to iterate over a response with no body`);
    }
    const sseDecoder = new SSEDecoder3();
    const lineDecoder = new LineDecoder3();
    const iter = ReadableStreamToAsyncIterable3(response.body);
    try {
      for (var _d = true, _e = __asyncValues(iterSSEChunks3(iter)), _f; _f = yield __await(_e.next()), _a5 = _f.done, !_a5; _d = true) {
        _c = _f.value;
        _d = false;
        const sseChunk = _c;
        for (const line of lineDecoder.decode(sseChunk)) {
          const sse = sseDecoder.decode(line);
          if (sse)
            yield yield __await(sse);
        }
      }
    } catch (e_4_1) {
      e_4 = { error: e_4_1 };
    } finally {
      try {
        if (!_d && !_a5 && (_b = _e.return)) yield __await(_b.call(_e));
      } finally {
        if (e_4) throw e_4.error;
      }
    }
    for (const line of lineDecoder.flush()) {
      const sse = sseDecoder.decode(line);
      if (sse)
        yield yield __await(sse);
    }
  });
}
function iterSSEChunks3(iterator) {
  return __asyncGenerator(this, arguments, function* iterSSEChunks_1() {
    var _a5, e_5, _b, _c;
    let data = new Uint8Array();
    try {
      for (var _d = true, iterator_3 = __asyncValues(iterator), iterator_3_1; iterator_3_1 = yield __await(iterator_3.next()), _a5 = iterator_3_1.done, !_a5; _d = true) {
        _c = iterator_3_1.value;
        _d = false;
        const chunk = _c;
        if (chunk == null) {
          continue;
        }
        const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? encodeUTF83(chunk) : chunk;
        let newData = new Uint8Array(data.length + binaryChunk.length);
        newData.set(data);
        newData.set(binaryChunk, data.length);
        data = newData;
        let patternIndex;
        while ((patternIndex = findDoubleNewlineIndex3(data)) !== -1) {
          yield yield __await(data.slice(0, patternIndex));
          data = data.slice(patternIndex);
        }
      }
    } catch (e_5_1) {
      e_5 = { error: e_5_1 };
    } finally {
      try {
        if (!_d && !_a5 && (_b = iterator_3.return)) yield __await(_b.call(iterator_3));
      } finally {
        if (e_5) throw e_5.error;
      }
    }
    if (data.length > 0) {
      yield yield __await(data);
    }
  });
}
var SSEDecoder3 = class {
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length)
        return null;
      const sse = {
        event: this.event,
        data: this.data.join("\n"),
        raw: this.chunks
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _, value] = partition3(line, ":");
    if (value.startsWith(" ")) {
      value = value.substring(1);
    }
    if (fieldname === "event") {
      this.event = value;
    } else if (fieldname === "data") {
      this.data.push(value);
    }
    return null;
  }
};
function partition3(str2, delimiter) {
  const index = str2.indexOf(delimiter);
  if (index !== -1) {
    return [str2.substring(0, index), delimiter, str2.substring(index + delimiter.length)];
  }
  return [str2, "", ""];
}
async function defaultParseResponse3(client, props) {
  const { response, requestLogID, retryOfRequestLogID, startTime } = props;
  const body = await (async () => {
    var _a5;
    if (props.options.stream) {
      loggerFor3(client).debug("response", response.status, response.url, response.headers, response.body);
      if (props.options.__streamClass) {
        return props.options.__streamClass.fromSSEResponse(response, props.controller, client);
      }
      return Stream3.fromSSEResponse(response, props.controller, client);
    }
    if (response.status === 204) {
      return null;
    }
    if (props.options.__binaryResponse) {
      return response;
    }
    const contentType = response.headers.get("content-type");
    const mediaType = (_a5 = contentType === null || contentType === void 0 ? void 0 : contentType.split(";")[0]) === null || _a5 === void 0 ? void 0 : _a5.trim();
    const isJSON = (mediaType === null || mediaType === void 0 ? void 0 : mediaType.includes("application/json")) || (mediaType === null || mediaType === void 0 ? void 0 : mediaType.endsWith("+json"));
    if (isJSON) {
      const contentLength = response.headers.get("content-length");
      if (contentLength === "0") {
        return void 0;
      }
      const json = await response.json();
      return json;
    }
    const text = await response.text();
    return text;
  })();
  loggerFor3(client).debug(`[${requestLogID}] response parsed`, formatRequestDetails3({
    retryOfRequestLogID,
    url: response.url,
    status: response.status,
    body,
    durationMs: Date.now() - startTime
  }));
  return body;
}
var APIPromise3 = class _APIPromise extends Promise {
  constructor(client, responsePromise, parseResponse2 = defaultParseResponse3) {
    super((resolve) => {
      resolve(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse2;
    this.client = client;
  }
  _thenUnwrap(transform) {
    return new _APIPromise(this.client, this.responsePromise, async (client, props) => transform(await this.parseResponse(client, props), props));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
   * to your `tsconfig.json`.
   */
  asResponse() {
    return this.responsePromise.then((p3) => p3.response);
  }
  /**
   * Gets the parsed response data and the raw `Response` instance.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
   * to your `tsconfig.json`.
   */
  async withResponse() {
    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
    return { data, response };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then((data) => this.parseResponse(this.client, data));
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
};
var brand_privateNullableHeaders3 = /* @__PURE__ */ Symbol("brand.privateNullableHeaders");
function* iterateHeaders3(headers) {
  if (!headers)
    return;
  if (brand_privateNullableHeaders3 in headers) {
    const { values, nulls } = headers;
    yield* values.entries();
    for (const name of nulls) {
      yield [name, null];
    }
    return;
  }
  let shouldClear = false;
  let iter;
  if (headers instanceof Headers) {
    iter = headers.entries();
  } else if (isReadonlyArray3(headers)) {
    iter = headers;
  } else {
    shouldClear = true;
    iter = Object.entries(headers !== null && headers !== void 0 ? headers : {});
  }
  for (let row of iter) {
    const name = row[0];
    if (typeof name !== "string")
      throw new TypeError("expected header name to be a string");
    const values = isReadonlyArray3(row[1]) ? row[1] : [row[1]];
    let didClear = false;
    for (const value of values) {
      if (value === void 0)
        continue;
      if (shouldClear && !didClear) {
        didClear = true;
        yield [name, null];
      }
      yield [name, value];
    }
  }
}
var buildHeaders3 = (newHeaders) => {
  const targetHeaders = new Headers();
  const nullHeaders = /* @__PURE__ */ new Set();
  for (const headers of newHeaders) {
    const seenHeaders = /* @__PURE__ */ new Set();
    for (const [name, value] of iterateHeaders3(headers)) {
      const lowerName = name.toLowerCase();
      if (!seenHeaders.has(lowerName)) {
        targetHeaders.delete(name);
        seenHeaders.add(lowerName);
      }
      if (value === null) {
        targetHeaders.delete(name);
        nullHeaders.add(lowerName);
      } else {
        targetHeaders.append(name, value);
        nullHeaders.delete(lowerName);
      }
    }
  }
  return { [brand_privateNullableHeaders3]: true, values: targetHeaders, nulls: nullHeaders };
};
var readEnv3 = (env) => {
  var _a5, _b, _c, _d, _e, _f;
  if (typeof globalThis.process !== "undefined") {
    return (_c = (_b = (_a5 = globalThis.process.env) === null || _a5 === void 0 ? void 0 : _a5[env]) === null || _b === void 0 ? void 0 : _b.trim()) !== null && _c !== void 0 ? _c : void 0;
  }
  if (typeof globalThis.Deno !== "undefined") {
    return (_f = (_e = (_d = globalThis.Deno.env) === null || _d === void 0 ? void 0 : _d.get) === null || _e === void 0 ? void 0 : _e.call(_d, env)) === null || _f === void 0 ? void 0 : _f.trim();
  }
  return void 0;
};
var _a4;
var BaseGeminiNextGenAPIClient = class _BaseGeminiNextGenAPIClient {
  /**
   * API Client for interfacing with the Gemini Next Gen API API.
   *
   * @param {string | null | undefined} [opts.apiKey=process.env['GEMINI_API_KEY'] ?? null]
   * @param {string | undefined} [opts.apiVersion=v1beta]
   * @param {string} [opts.baseURL=process.env['GEMINI_NEXT_GEN_API_BASE_URL'] ?? https://generativelanguage.googleapis.com] - Override the default base URL for the API.
   * @param {number} [opts.timeout=1 minute] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {MergedRequestInit} [opts.fetchOptions] - Additional `RequestInit` options to be passed to `fetch` calls.
   * @param {Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {HeadersLike} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Record<string, string | undefined>} opts.defaultQuery - Default query parameters to include with every request to the API.
   */
  constructor(_b) {
    var _c, _d, _e, _f, _g, _h, _j;
    var { baseURL = readEnv3("GEMINI_NEXT_GEN_API_BASE_URL"), apiKey = (_c = readEnv3("GEMINI_API_KEY")) !== null && _c !== void 0 ? _c : null, apiVersion = "v1beta" } = _b, opts = __rest(_b, ["baseURL", "apiKey", "apiVersion"]);
    const options = Object.assign(Object.assign({
      apiKey,
      apiVersion
    }, opts), { baseURL: baseURL || `https://generativelanguage.googleapis.com` });
    this.baseURL = options.baseURL;
    this.timeout = (_d = options.timeout) !== null && _d !== void 0 ? _d : _BaseGeminiNextGenAPIClient.DEFAULT_TIMEOUT;
    this.logger = (_e = options.logger) !== null && _e !== void 0 ? _e : console;
    const defaultLogLevel = "warn";
    this.logLevel = defaultLogLevel;
    this.logLevel = (_g = (_f = parseLogLevel3(options.logLevel, "ClientOptions.logLevel", this)) !== null && _f !== void 0 ? _f : parseLogLevel3(readEnv3("GEMINI_NEXT_GEN_API_LOG"), "process.env['GEMINI_NEXT_GEN_API_LOG']", this)) !== null && _g !== void 0 ? _g : defaultLogLevel;
    this.fetchOptions = options.fetchOptions;
    this.maxRetries = (_h = options.maxRetries) !== null && _h !== void 0 ? _h : 2;
    this.fetch = (_j = options.fetch) !== null && _j !== void 0 ? _j : getDefaultFetch3();
    this.encoder = FallbackEncoder3;
    this._options = options;
    this.apiKey = apiKey;
    this.apiVersion = apiVersion;
    this.clientAdapter = options.clientAdapter;
  }
  /**
   * Create a new client instance re-using the same options given to the current client with optional overriding.
   */
  withOptions(options) {
    const client = new this.constructor(Object.assign(Object.assign(Object.assign({}, this._options), { baseURL: this.baseURL, maxRetries: this.maxRetries, timeout: this.timeout, logger: this.logger, logLevel: this.logLevel, fetch: this.fetch, fetchOptions: this.fetchOptions, apiKey: this.apiKey, apiVersion: this.apiVersion }), options));
    return client;
  }
  /**
   * Check whether the base URL is set to its default.
   */
  baseURLOverridden() {
    return this.baseURL !== "https://generativelanguage.googleapis.com";
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  validateHeaders({ values, nulls }) {
    if (values.has("authorization") || values.has("x-goog-api-key")) {
      return;
    }
    if (this.apiKey && values.get("x-goog-api-key")) {
      return;
    }
    if (nulls.has("x-goog-api-key")) {
      return;
    }
    throw new Error('Could not resolve authentication method. Expected the apiKey to be set. Or for the "x-goog-api-key" headers to be explicitly omitted');
  }
  async authHeaders(opts) {
    const existingHeaders = buildHeaders3([opts.headers]);
    if (existingHeaders.values.has("authorization") || existingHeaders.values.has("x-goog-api-key")) {
      return void 0;
    }
    if (this.apiKey) {
      return buildHeaders3([{ "x-goog-api-key": this.apiKey }]);
    }
    if (this.clientAdapter.isVertexAI()) {
      return buildHeaders3([await this.clientAdapter.getAuthHeaders()]);
    }
    return void 0;
  }
  /**
   * Basic re-implementation of `qs.stringify` for primitive types.
   */
  stringifyQuery(query) {
    return Object.entries(query).filter(([_, value]) => typeof value !== "undefined").map(([key, value]) => {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
      }
      if (value === null) {
        return `${encodeURIComponent(key)}=`;
      }
      throw new GeminiNextGenAPIClientError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
    }).join("&");
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION3}`;
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid43()}`;
  }
  makeStatusError(status, error, message, headers) {
    return APIError3.generate(status, error, message, headers);
  }
  buildURL(path4, query, defaultBaseURL) {
    const baseURL = !this.baseURLOverridden() && defaultBaseURL || this.baseURL;
    const url = isAbsoluteURL3(path4) ? new URL(path4) : new URL(baseURL + (baseURL.endsWith("/") && path4.startsWith("/") ? path4.slice(1) : path4));
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj3(defaultQuery)) {
      query = Object.assign(Object.assign({}, defaultQuery), query);
    }
    if (typeof query === "object" && query && !Array.isArray(query)) {
      url.search = this.stringifyQuery(query);
    }
    return url.toString();
  }
  /**
     * Used as a callback for mutating the given `FinalRequestOptions` object.
  
     */
  async prepareOptions(options) {
    if (this.clientAdapter && this.clientAdapter.isVertexAI() && !options.path.startsWith(`/${this.apiVersion}/projects/`)) {
      const oldPath = options.path.slice(this.apiVersion.length + 1);
      options.path = `/${this.apiVersion}/projects/${this.clientAdapter.getProject()}/locations/${this.clientAdapter.getLocation()}${oldPath}`;
    }
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(request, { url, options }) {
  }
  get(path4, opts) {
    return this.methodRequest("get", path4, opts);
  }
  post(path4, opts) {
    return this.methodRequest("post", path4, opts);
  }
  patch(path4, opts) {
    return this.methodRequest("patch", path4, opts);
  }
  put(path4, opts) {
    return this.methodRequest("put", path4, opts);
  }
  delete(path4, opts) {
    return this.methodRequest("delete", path4, opts);
  }
  methodRequest(method, path4, opts) {
    return this.request(Promise.resolve(opts).then((opts2) => {
      return Object.assign({ method, path: path4 }, opts2);
    }));
  }
  request(options, remainingRetries = null) {
    return new APIPromise3(this, this.makeRequest(options, remainingRetries, void 0));
  }
  async makeRequest(optionsInput, retriesRemaining, retryOfRequestLogID) {
    var _b, _c, _d;
    const options = await optionsInput;
    const maxRetries = (_b = options.maxRetries) !== null && _b !== void 0 ? _b : this.maxRetries;
    if (retriesRemaining == null) {
      retriesRemaining = maxRetries;
    }
    await this.prepareOptions(options);
    const { req, url, timeout } = await this.buildRequest(options, {
      retryCount: maxRetries - retriesRemaining
    });
    await this.prepareRequest(req, { url, options });
    const requestLogID = "log_" + (Math.random() * (1 << 24) | 0).toString(16).padStart(6, "0");
    const retryLogStr = retryOfRequestLogID === void 0 ? "" : `, retryOf: ${retryOfRequestLogID}`;
    const startTime = Date.now();
    loggerFor3(this).debug(`[${requestLogID}] sending request`, formatRequestDetails3({
      retryOfRequestLogID,
      method: options.method,
      url,
      options,
      headers: req.headers
    }));
    if ((_c = options.signal) === null || _c === void 0 ? void 0 : _c.aborted) {
      throw new APIUserAbortError3();
    }
    const controller = new AbortController();
    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError3);
    const headersTime = Date.now();
    if (response instanceof globalThis.Error) {
      const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;
      if ((_d = options.signal) === null || _d === void 0 ? void 0 : _d.aborted) {
        throw new APIUserAbortError3();
      }
      const isTimeout = isAbortError3(response) || /timed? ?out/i.test(String(response) + ("cause" in response ? String(response.cause) : ""));
      if (retriesRemaining) {
        loggerFor3(this).info(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} - ${retryMessage}`);
        loggerFor3(this).debug(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} (${retryMessage})`, formatRequestDetails3({
          retryOfRequestLogID,
          url,
          durationMs: headersTime - startTime,
          message: response.message
        }));
        return this.retryRequest(options, retriesRemaining, retryOfRequestLogID !== null && retryOfRequestLogID !== void 0 ? retryOfRequestLogID : requestLogID);
      }
      loggerFor3(this).info(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} - error; no more retries left`);
      loggerFor3(this).debug(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} (error; no more retries left)`, formatRequestDetails3({
        retryOfRequestLogID,
        url,
        durationMs: headersTime - startTime,
        message: response.message
      }));
      if (isTimeout) {
        throw new APIConnectionTimeoutError3();
      }
      throw new APIConnectionError3({ cause: response });
    }
    const responseInfo = `[${requestLogID}${retryLogStr}] ${req.method} ${url} ${response.ok ? "succeeded" : "failed"} with status ${response.status} in ${headersTime - startTime}ms`;
    if (!response.ok) {
      const shouldRetry = await this.shouldRetry(response);
      if (retriesRemaining && shouldRetry) {
        const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
        await CancelReadableStream3(response.body);
        loggerFor3(this).info(`${responseInfo} - ${retryMessage2}`);
        loggerFor3(this).debug(`[${requestLogID}] response error (${retryMessage2})`, formatRequestDetails3({
          retryOfRequestLogID,
          url: response.url,
          status: response.status,
          headers: response.headers,
          durationMs: headersTime - startTime
        }));
        return this.retryRequest(options, retriesRemaining, retryOfRequestLogID !== null && retryOfRequestLogID !== void 0 ? retryOfRequestLogID : requestLogID, response.headers);
      }
      const retryMessage = shouldRetry ? `error; no more retries left` : `error; not retryable`;
      loggerFor3(this).info(`${responseInfo} - ${retryMessage}`);
      const errText = await response.text().catch((err2) => castToError3(err2).message);
      const errJSON = safeJSON3(errText);
      const errMessage = errJSON ? void 0 : errText;
      loggerFor3(this).debug(`[${requestLogID}] response error (${retryMessage})`, formatRequestDetails3({
        retryOfRequestLogID,
        url: response.url,
        status: response.status,
        headers: response.headers,
        message: errMessage,
        durationMs: Date.now() - startTime
      }));
      const err = this.makeStatusError(response.status, errJSON, errMessage, response.headers);
      throw err;
    }
    loggerFor3(this).info(responseInfo);
    loggerFor3(this).debug(`[${requestLogID}] response start`, formatRequestDetails3({
      retryOfRequestLogID,
      url: response.url,
      status: response.status,
      headers: response.headers,
      durationMs: headersTime - startTime
    }));
    return { response, options, controller, requestLogID, retryOfRequestLogID, startTime };
  }
  async fetchWithTimeout(url, init, ms, controller) {
    const _b = init || {}, { signal, method } = _b, options = __rest(_b, ["signal", "method"]);
    const abort = controller.abort.bind(controller);
    if (signal)
      signal.addEventListener("abort", abort, { once: true });
    const timeout = setTimeout(abort, ms);
    const isReadableBody = globalThis.ReadableStream && options.body instanceof globalThis.ReadableStream || typeof options.body === "object" && options.body !== null && Symbol.asyncIterator in options.body;
    const fetchOptions = Object.assign(Object.assign(Object.assign({ signal: controller.signal }, isReadableBody ? { duplex: "half" } : {}), { method: "GET" }), options);
    if (method) {
      fetchOptions.method = method.toUpperCase();
    }
    try {
      return await this.fetch.call(void 0, url, fetchOptions);
    } finally {
      clearTimeout(timeout);
    }
  }
  async shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true")
      return true;
    if (shouldRetryHeader === "false")
      return false;
    if (response.status === 408)
      return true;
    if (response.status === 409)
      return true;
    if (response.status === 429)
      return true;
    if (response.status >= 500)
      return true;
    return false;
  }
  async retryRequest(options, retriesRemaining, requestLogID, responseHeaders) {
    var _b;
    let timeoutMillis;
    const retryAfterMillisHeader = responseHeaders === null || responseHeaders === void 0 ? void 0 : responseHeaders.get("retry-after-ms");
    if (retryAfterMillisHeader) {
      const timeoutMs = parseFloat(retryAfterMillisHeader);
      if (!Number.isNaN(timeoutMs)) {
        timeoutMillis = timeoutMs;
      }
    }
    const retryAfterHeader = responseHeaders === null || responseHeaders === void 0 ? void 0 : responseHeaders.get("retry-after");
    if (retryAfterHeader && !timeoutMillis) {
      const timeoutSeconds = parseFloat(retryAfterHeader);
      if (!Number.isNaN(timeoutSeconds)) {
        timeoutMillis = timeoutSeconds * 1e3;
      } else {
        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
      }
    }
    if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
      const maxRetries = (_b = options.maxRetries) !== null && _b !== void 0 ? _b : this.maxRetries;
      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
    }
    await sleep$1(timeoutMillis);
    return this.makeRequest(options, retriesRemaining - 1, requestLogID);
  }
  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 8;
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
    const jitter = 1 - Math.random() * 0.25;
    return sleepSeconds * jitter * 1e3;
  }
  async buildRequest(inputOptions, { retryCount = 0 } = {}) {
    var _b, _c, _d;
    const options = Object.assign({}, inputOptions);
    const { method, path: path4, query, defaultBaseURL } = options;
    const url = this.buildURL(path4, query, defaultBaseURL);
    if ("timeout" in options)
      validatePositiveInteger3("timeout", options.timeout);
    options.timeout = (_b = options.timeout) !== null && _b !== void 0 ? _b : this.timeout;
    const { bodyHeaders, body } = this.buildBody({ options });
    const reqHeaders = await this.buildHeaders({ options: inputOptions, method, bodyHeaders, retryCount });
    const req = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ method, headers: reqHeaders }, options.signal && { signal: options.signal }), globalThis.ReadableStream && body instanceof globalThis.ReadableStream && { duplex: "half" }), body && { body }), (_c = this.fetchOptions) !== null && _c !== void 0 ? _c : {}), (_d = options.fetchOptions) !== null && _d !== void 0 ? _d : {});
    return { req, url, timeout: options.timeout };
  }
  async buildHeaders({ options, method, bodyHeaders, retryCount }) {
    let idempotencyHeaders = {};
    if (this.idempotencyHeader && method !== "get") {
      if (!options.idempotencyKey)
        options.idempotencyKey = this.defaultIdempotencyKey();
      idempotencyHeaders[this.idempotencyHeader] = options.idempotencyKey;
    }
    const authHeaders = await this.authHeaders(options);
    let headers = buildHeaders3([
      idempotencyHeaders,
      Object.assign(Object.assign({ Accept: "application/json", "User-Agent": this.getUserAgent(), "X-Stainless-Retry-Count": String(retryCount) }, options.timeout ? { "X-Stainless-Timeout": String(Math.trunc(options.timeout / 1e3)) } : {}), getPlatformHeaders3()),
      this._options.defaultHeaders,
      bodyHeaders,
      options.headers,
      authHeaders
    ]);
    this.validateHeaders(headers);
    return headers.values;
  }
  buildBody({ options: { body, headers: rawHeaders } }) {
    if (!body) {
      return { bodyHeaders: void 0, body: void 0 };
    }
    const headers = buildHeaders3([rawHeaders]);
    if (
      // Pass raw type verbatim
      ArrayBuffer.isView(body) || body instanceof ArrayBuffer || body instanceof DataView || typeof body === "string" && // Preserve legacy string encoding behavior for now
      headers.values.has("content-type") || // `Blob` is superset of `File`
      globalThis.Blob && body instanceof globalThis.Blob || // `FormData` -> `multipart/form-data`
      body instanceof FormData || // `URLSearchParams` -> `application/x-www-form-urlencoded`
      body instanceof URLSearchParams || // Send chunked stream (each chunk has own `length`)
      globalThis.ReadableStream && body instanceof globalThis.ReadableStream
    ) {
      return { bodyHeaders: void 0, body };
    } else if (typeof body === "object" && (Symbol.asyncIterator in body || Symbol.iterator in body && "next" in body && typeof body.next === "function")) {
      return { bodyHeaders: void 0, body: ReadableStreamFrom3(body) };
    } else {
      return this.encoder({ body, headers });
    }
  }
};
BaseGeminiNextGenAPIClient.DEFAULT_TIMEOUT = 6e4;
var GeminiNextGenAPIClient = class extends BaseGeminiNextGenAPIClient {
  constructor() {
    super(...arguments);
    this.interactions = new Interactions(this);
  }
};
_a4 = GeminiNextGenAPIClient;
GeminiNextGenAPIClient.GeminiNextGenAPIClient = _a4;
GeminiNextGenAPIClient.GeminiNextGenAPIClientError = GeminiNextGenAPIClientError;
GeminiNextGenAPIClient.APIError = APIError3;
GeminiNextGenAPIClient.APIConnectionError = APIConnectionError3;
GeminiNextGenAPIClient.APIConnectionTimeoutError = APIConnectionTimeoutError3;
GeminiNextGenAPIClient.APIUserAbortError = APIUserAbortError3;
GeminiNextGenAPIClient.NotFoundError = NotFoundError3;
GeminiNextGenAPIClient.ConflictError = ConflictError3;
GeminiNextGenAPIClient.RateLimitError = RateLimitError3;
GeminiNextGenAPIClient.BadRequestError = BadRequestError3;
GeminiNextGenAPIClient.AuthenticationError = AuthenticationError3;
GeminiNextGenAPIClient.InternalServerError = InternalServerError3;
GeminiNextGenAPIClient.PermissionDeniedError = PermissionDeniedError3;
GeminiNextGenAPIClient.UnprocessableEntityError = UnprocessableEntityError3;
GeminiNextGenAPIClient.toFile = toFile3;
GeminiNextGenAPIClient.Interactions = Interactions;
function cancelTuningJobParametersToMldev(fromObject, _rootObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], fromName);
  }
  return toObject;
}
function cancelTuningJobParametersToVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], fromName);
  }
  return toObject;
}
function cancelTuningJobResponseFromMldev(fromObject, _rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  return toObject;
}
function cancelTuningJobResponseFromVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  return toObject;
}
function createTuningJobConfigToMldev(fromObject, parentObject, _rootObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["validationDataset"]) !== void 0) {
    throw new Error("validationDataset parameter is not supported in Gemini API.");
  }
  const fromTunedModelDisplayName = getValueByPath(fromObject, [
    "tunedModelDisplayName"
  ]);
  if (parentObject !== void 0 && fromTunedModelDisplayName != null) {
    setValueByPath(parentObject, ["displayName"], fromTunedModelDisplayName);
  }
  if (getValueByPath(fromObject, ["description"]) !== void 0) {
    throw new Error("description parameter is not supported in Gemini API.");
  }
  const fromEpochCount = getValueByPath(fromObject, ["epochCount"]);
  if (parentObject !== void 0 && fromEpochCount != null) {
    setValueByPath(parentObject, ["tuningTask", "hyperparameters", "epochCount"], fromEpochCount);
  }
  const fromLearningRateMultiplier = getValueByPath(fromObject, [
    "learningRateMultiplier"
  ]);
  if (fromLearningRateMultiplier != null) {
    setValueByPath(toObject, ["tuningTask", "hyperparameters", "learningRateMultiplier"], fromLearningRateMultiplier);
  }
  if (getValueByPath(fromObject, ["exportLastCheckpointOnly"]) !== void 0) {
    throw new Error("exportLastCheckpointOnly parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["preTunedModelCheckpointId"]) !== void 0) {
    throw new Error("preTunedModelCheckpointId parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["adapterSize"]) !== void 0) {
    throw new Error("adapterSize parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["tuningMode"]) !== void 0) {
    throw new Error("tuningMode parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["customBaseModel"]) !== void 0) {
    throw new Error("customBaseModel parameter is not supported in Gemini API.");
  }
  const fromBatchSize = getValueByPath(fromObject, ["batchSize"]);
  if (parentObject !== void 0 && fromBatchSize != null) {
    setValueByPath(parentObject, ["tuningTask", "hyperparameters", "batchSize"], fromBatchSize);
  }
  const fromLearningRate = getValueByPath(fromObject, ["learningRate"]);
  if (parentObject !== void 0 && fromLearningRate != null) {
    setValueByPath(parentObject, ["tuningTask", "hyperparameters", "learningRate"], fromLearningRate);
  }
  if (getValueByPath(fromObject, ["labels"]) !== void 0) {
    throw new Error("labels parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["beta"]) !== void 0) {
    throw new Error("beta parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["baseTeacherModel"]) !== void 0) {
    throw new Error("baseTeacherModel parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["tunedTeacherModelSource"]) !== void 0) {
    throw new Error("tunedTeacherModelSource parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["sftLossWeightMultiplier"]) !== void 0) {
    throw new Error("sftLossWeightMultiplier parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["outputUri"]) !== void 0) {
    throw new Error("outputUri parameter is not supported in Gemini API.");
  }
  return toObject;
}
function createTuningJobConfigToVertex(fromObject, parentObject, rootObject) {
  const toObject = {};
  let discriminatorValidationDataset = getValueByPath(rootObject, [
    "config",
    "method"
  ]);
  if (discriminatorValidationDataset === void 0) {
    discriminatorValidationDataset = "SUPERVISED_FINE_TUNING";
  }
  if (discriminatorValidationDataset === "SUPERVISED_FINE_TUNING") {
    const fromValidationDataset = getValueByPath(fromObject, [
      "validationDataset"
    ]);
    if (parentObject !== void 0 && fromValidationDataset != null) {
      setValueByPath(parentObject, ["supervisedTuningSpec"], tuningValidationDatasetToVertex(fromValidationDataset));
    }
  } else if (discriminatorValidationDataset === "PREFERENCE_TUNING") {
    const fromValidationDataset = getValueByPath(fromObject, [
      "validationDataset"
    ]);
    if (parentObject !== void 0 && fromValidationDataset != null) {
      setValueByPath(parentObject, ["preferenceOptimizationSpec"], tuningValidationDatasetToVertex(fromValidationDataset));
    }
  } else if (discriminatorValidationDataset === "DISTILLATION") {
    const fromValidationDataset = getValueByPath(fromObject, [
      "validationDataset"
    ]);
    if (parentObject !== void 0 && fromValidationDataset != null) {
      setValueByPath(parentObject, ["distillationSpec"], tuningValidationDatasetToVertex(fromValidationDataset));
    }
  }
  const fromTunedModelDisplayName = getValueByPath(fromObject, [
    "tunedModelDisplayName"
  ]);
  if (parentObject !== void 0 && fromTunedModelDisplayName != null) {
    setValueByPath(parentObject, ["tunedModelDisplayName"], fromTunedModelDisplayName);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (parentObject !== void 0 && fromDescription != null) {
    setValueByPath(parentObject, ["description"], fromDescription);
  }
  let discriminatorEpochCount = getValueByPath(rootObject, [
    "config",
    "method"
  ]);
  if (discriminatorEpochCount === void 0) {
    discriminatorEpochCount = "SUPERVISED_FINE_TUNING";
  }
  if (discriminatorEpochCount === "SUPERVISED_FINE_TUNING") {
    const fromEpochCount = getValueByPath(fromObject, ["epochCount"]);
    if (parentObject !== void 0 && fromEpochCount != null) {
      setValueByPath(parentObject, ["supervisedTuningSpec", "hyperParameters", "epochCount"], fromEpochCount);
    }
  } else if (discriminatorEpochCount === "PREFERENCE_TUNING") {
    const fromEpochCount = getValueByPath(fromObject, ["epochCount"]);
    if (parentObject !== void 0 && fromEpochCount != null) {
      setValueByPath(parentObject, ["preferenceOptimizationSpec", "hyperParameters", "epochCount"], fromEpochCount);
    }
  } else if (discriminatorEpochCount === "DISTILLATION") {
    const fromEpochCount = getValueByPath(fromObject, ["epochCount"]);
    if (parentObject !== void 0 && fromEpochCount != null) {
      setValueByPath(parentObject, ["distillationSpec", "hyperParameters", "epochCount"], fromEpochCount);
    }
  }
  let discriminatorLearningRateMultiplier = getValueByPath(rootObject, [
    "config",
    "method"
  ]);
  if (discriminatorLearningRateMultiplier === void 0) {
    discriminatorLearningRateMultiplier = "SUPERVISED_FINE_TUNING";
  }
  if (discriminatorLearningRateMultiplier === "SUPERVISED_FINE_TUNING") {
    const fromLearningRateMultiplier = getValueByPath(fromObject, [
      "learningRateMultiplier"
    ]);
    if (parentObject !== void 0 && fromLearningRateMultiplier != null) {
      setValueByPath(parentObject, ["supervisedTuningSpec", "hyperParameters", "learningRateMultiplier"], fromLearningRateMultiplier);
    }
  } else if (discriminatorLearningRateMultiplier === "PREFERENCE_TUNING") {
    const fromLearningRateMultiplier = getValueByPath(fromObject, [
      "learningRateMultiplier"
    ]);
    if (parentObject !== void 0 && fromLearningRateMultiplier != null) {
      setValueByPath(parentObject, [
        "preferenceOptimizationSpec",
        "hyperParameters",
        "learningRateMultiplier"
      ], fromLearningRateMultiplier);
    }
  } else if (discriminatorLearningRateMultiplier === "DISTILLATION") {
    const fromLearningRateMultiplier = getValueByPath(fromObject, [
      "learningRateMultiplier"
    ]);
    if (parentObject !== void 0 && fromLearningRateMultiplier != null) {
      setValueByPath(parentObject, ["distillationSpec", "hyperParameters", "learningRateMultiplier"], fromLearningRateMultiplier);
    }
  }
  let discriminatorExportLastCheckpointOnly = getValueByPath(rootObject, ["config", "method"]);
  if (discriminatorExportLastCheckpointOnly === void 0) {
    discriminatorExportLastCheckpointOnly = "SUPERVISED_FINE_TUNING";
  }
  if (discriminatorExportLastCheckpointOnly === "SUPERVISED_FINE_TUNING") {
    const fromExportLastCheckpointOnly = getValueByPath(fromObject, [
      "exportLastCheckpointOnly"
    ]);
    if (parentObject !== void 0 && fromExportLastCheckpointOnly != null) {
      setValueByPath(parentObject, ["supervisedTuningSpec", "exportLastCheckpointOnly"], fromExportLastCheckpointOnly);
    }
  } else if (discriminatorExportLastCheckpointOnly === "PREFERENCE_TUNING") {
    const fromExportLastCheckpointOnly = getValueByPath(fromObject, [
      "exportLastCheckpointOnly"
    ]);
    if (parentObject !== void 0 && fromExportLastCheckpointOnly != null) {
      setValueByPath(parentObject, ["preferenceOptimizationSpec", "exportLastCheckpointOnly"], fromExportLastCheckpointOnly);
    }
  } else if (discriminatorExportLastCheckpointOnly === "DISTILLATION") {
    const fromExportLastCheckpointOnly = getValueByPath(fromObject, [
      "exportLastCheckpointOnly"
    ]);
    if (parentObject !== void 0 && fromExportLastCheckpointOnly != null) {
      setValueByPath(parentObject, ["distillationSpec", "exportLastCheckpointOnly"], fromExportLastCheckpointOnly);
    }
  }
  let discriminatorAdapterSize = getValueByPath(rootObject, [
    "config",
    "method"
  ]);
  if (discriminatorAdapterSize === void 0) {
    discriminatorAdapterSize = "SUPERVISED_FINE_TUNING";
  }
  if (discriminatorAdapterSize === "SUPERVISED_FINE_TUNING") {
    const fromAdapterSize = getValueByPath(fromObject, ["adapterSize"]);
    if (parentObject !== void 0 && fromAdapterSize != null) {
      setValueByPath(parentObject, ["supervisedTuningSpec", "hyperParameters", "adapterSize"], fromAdapterSize);
    }
  } else if (discriminatorAdapterSize === "PREFERENCE_TUNING") {
    const fromAdapterSize = getValueByPath(fromObject, ["adapterSize"]);
    if (parentObject !== void 0 && fromAdapterSize != null) {
      setValueByPath(parentObject, ["preferenceOptimizationSpec", "hyperParameters", "adapterSize"], fromAdapterSize);
    }
  } else if (discriminatorAdapterSize === "DISTILLATION") {
    const fromAdapterSize = getValueByPath(fromObject, ["adapterSize"]);
    if (parentObject !== void 0 && fromAdapterSize != null) {
      setValueByPath(parentObject, ["distillationSpec", "hyperParameters", "adapterSize"], fromAdapterSize);
    }
  }
  let discriminatorTuningMode = getValueByPath(rootObject, [
    "config",
    "method"
  ]);
  if (discriminatorTuningMode === void 0) {
    discriminatorTuningMode = "SUPERVISED_FINE_TUNING";
  }
  if (discriminatorTuningMode === "SUPERVISED_FINE_TUNING") {
    const fromTuningMode = getValueByPath(fromObject, ["tuningMode"]);
    if (parentObject !== void 0 && fromTuningMode != null) {
      setValueByPath(parentObject, ["supervisedTuningSpec", "tuningMode"], fromTuningMode);
    }
  }
  const fromCustomBaseModel = getValueByPath(fromObject, [
    "customBaseModel"
  ]);
  if (parentObject !== void 0 && fromCustomBaseModel != null) {
    setValueByPath(parentObject, ["customBaseModel"], fromCustomBaseModel);
  }
  let discriminatorBatchSize = getValueByPath(rootObject, [
    "config",
    "method"
  ]);
  if (discriminatorBatchSize === void 0) {
    discriminatorBatchSize = "SUPERVISED_FINE_TUNING";
  }
  if (discriminatorBatchSize === "SUPERVISED_FINE_TUNING") {
    const fromBatchSize = getValueByPath(fromObject, ["batchSize"]);
    if (parentObject !== void 0 && fromBatchSize != null) {
      setValueByPath(parentObject, ["supervisedTuningSpec", "hyperParameters", "batchSize"], fromBatchSize);
    }
  }
  let discriminatorLearningRate = getValueByPath(rootObject, [
    "config",
    "method"
  ]);
  if (discriminatorLearningRate === void 0) {
    discriminatorLearningRate = "SUPERVISED_FINE_TUNING";
  }
  if (discriminatorLearningRate === "SUPERVISED_FINE_TUNING") {
    const fromLearningRate = getValueByPath(fromObject, [
      "learningRate"
    ]);
    if (parentObject !== void 0 && fromLearningRate != null) {
      setValueByPath(parentObject, ["supervisedTuningSpec", "hyperParameters", "learningRate"], fromLearningRate);
    }
  }
  const fromLabels = getValueByPath(fromObject, ["labels"]);
  if (parentObject !== void 0 && fromLabels != null) {
    setValueByPath(parentObject, ["labels"], fromLabels);
  }
  const fromBeta = getValueByPath(fromObject, ["beta"]);
  if (parentObject !== void 0 && fromBeta != null) {
    setValueByPath(parentObject, ["preferenceOptimizationSpec", "hyperParameters", "beta"], fromBeta);
  }
  const fromBaseTeacherModel = getValueByPath(fromObject, [
    "baseTeacherModel"
  ]);
  if (parentObject !== void 0 && fromBaseTeacherModel != null) {
    setValueByPath(parentObject, ["distillationSpec", "baseTeacherModel"], fromBaseTeacherModel);
  }
  const fromTunedTeacherModelSource = getValueByPath(fromObject, [
    "tunedTeacherModelSource"
  ]);
  if (parentObject !== void 0 && fromTunedTeacherModelSource != null) {
    setValueByPath(parentObject, ["distillationSpec", "tunedTeacherModelSource"], fromTunedTeacherModelSource);
  }
  const fromSftLossWeightMultiplier = getValueByPath(fromObject, [
    "sftLossWeightMultiplier"
  ]);
  if (parentObject !== void 0 && fromSftLossWeightMultiplier != null) {
    setValueByPath(parentObject, ["distillationSpec", "hyperParameters", "sftLossWeightMultiplier"], fromSftLossWeightMultiplier);
  }
  const fromOutputUri = getValueByPath(fromObject, ["outputUri"]);
  if (parentObject !== void 0 && fromOutputUri != null) {
    setValueByPath(parentObject, ["outputUri"], fromOutputUri);
  }
  return toObject;
}
function createTuningJobParametersPrivateToMldev(fromObject, rootObject) {
  const toObject = {};
  const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
  if (fromBaseModel != null) {
    setValueByPath(toObject, ["baseModel"], fromBaseModel);
  }
  const fromPreTunedModel = getValueByPath(fromObject, [
    "preTunedModel"
  ]);
  if (fromPreTunedModel != null) {
    setValueByPath(toObject, ["preTunedModel"], fromPreTunedModel);
  }
  const fromTrainingDataset = getValueByPath(fromObject, [
    "trainingDataset"
  ]);
  if (fromTrainingDataset != null) {
    tuningDatasetToMldev(fromTrainingDataset);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    createTuningJobConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function createTuningJobParametersPrivateToVertex(fromObject, rootObject) {
  const toObject = {};
  const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
  if (fromBaseModel != null) {
    setValueByPath(toObject, ["baseModel"], fromBaseModel);
  }
  const fromPreTunedModel = getValueByPath(fromObject, [
    "preTunedModel"
  ]);
  if (fromPreTunedModel != null) {
    setValueByPath(toObject, ["preTunedModel"], fromPreTunedModel);
  }
  const fromTrainingDataset = getValueByPath(fromObject, [
    "trainingDataset"
  ]);
  if (fromTrainingDataset != null) {
    tuningDatasetToVertex(fromTrainingDataset, toObject, rootObject);
  }
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    createTuningJobConfigToVertex(fromConfig, toObject, rootObject);
  }
  return toObject;
}
function getTuningJobParametersToMldev(fromObject, _rootObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], fromName);
  }
  return toObject;
}
function getTuningJobParametersToVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["_url", "name"], fromName);
  }
  return toObject;
}
function listTuningJobsConfigToMldev(fromObject, parentObject, _rootObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== void 0 && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== void 0 && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  const fromFilter = getValueByPath(fromObject, ["filter"]);
  if (parentObject !== void 0 && fromFilter != null) {
    setValueByPath(parentObject, ["_query", "filter"], fromFilter);
  }
  return toObject;
}
function listTuningJobsConfigToVertex(fromObject, parentObject, _rootObject) {
  const toObject = {};
  const fromPageSize = getValueByPath(fromObject, ["pageSize"]);
  if (parentObject !== void 0 && fromPageSize != null) {
    setValueByPath(parentObject, ["_query", "pageSize"], fromPageSize);
  }
  const fromPageToken = getValueByPath(fromObject, ["pageToken"]);
  if (parentObject !== void 0 && fromPageToken != null) {
    setValueByPath(parentObject, ["_query", "pageToken"], fromPageToken);
  }
  const fromFilter = getValueByPath(fromObject, ["filter"]);
  if (parentObject !== void 0 && fromFilter != null) {
    setValueByPath(parentObject, ["_query", "filter"], fromFilter);
  }
  return toObject;
}
function listTuningJobsParametersToMldev(fromObject, rootObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    listTuningJobsConfigToMldev(fromConfig, toObject);
  }
  return toObject;
}
function listTuningJobsParametersToVertex(fromObject, rootObject) {
  const toObject = {};
  const fromConfig = getValueByPath(fromObject, ["config"]);
  if (fromConfig != null) {
    listTuningJobsConfigToVertex(fromConfig, toObject);
  }
  return toObject;
}
function listTuningJobsResponseFromMldev(fromObject, rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromTuningJobs = getValueByPath(fromObject, ["tunedModels"]);
  if (fromTuningJobs != null) {
    let transformedList = fromTuningJobs;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return tuningJobFromMldev(item);
      });
    }
    setValueByPath(toObject, ["tuningJobs"], transformedList);
  }
  return toObject;
}
function listTuningJobsResponseFromVertex(fromObject, rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromNextPageToken = getValueByPath(fromObject, [
    "nextPageToken"
  ]);
  if (fromNextPageToken != null) {
    setValueByPath(toObject, ["nextPageToken"], fromNextPageToken);
  }
  const fromTuningJobs = getValueByPath(fromObject, ["tuningJobs"]);
  if (fromTuningJobs != null) {
    let transformedList = fromTuningJobs;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return tuningJobFromVertex(item);
      });
    }
    setValueByPath(toObject, ["tuningJobs"], transformedList);
  }
  return toObject;
}
function tunedModelFromMldev(fromObject, _rootObject) {
  const toObject = {};
  const fromModel = getValueByPath(fromObject, ["name"]);
  if (fromModel != null) {
    setValueByPath(toObject, ["model"], fromModel);
  }
  const fromEndpoint = getValueByPath(fromObject, ["name"]);
  if (fromEndpoint != null) {
    setValueByPath(toObject, ["endpoint"], fromEndpoint);
  }
  return toObject;
}
function tuningDatasetToMldev(fromObject, _rootObject) {
  const toObject = {};
  if (getValueByPath(fromObject, ["gcsUri"]) !== void 0) {
    throw new Error("gcsUri parameter is not supported in Gemini API.");
  }
  if (getValueByPath(fromObject, ["vertexDatasetResource"]) !== void 0) {
    throw new Error("vertexDatasetResource parameter is not supported in Gemini API.");
  }
  const fromExamples = getValueByPath(fromObject, ["examples"]);
  if (fromExamples != null) {
    let transformedList = fromExamples;
    if (Array.isArray(transformedList)) {
      transformedList = transformedList.map((item) => {
        return item;
      });
    }
    setValueByPath(toObject, ["examples", "examples"], transformedList);
  }
  return toObject;
}
function tuningDatasetToVertex(fromObject, parentObject, rootObject) {
  const toObject = {};
  let discriminatorGcsUri = getValueByPath(rootObject, [
    "config",
    "method"
  ]);
  if (discriminatorGcsUri === void 0) {
    discriminatorGcsUri = "SUPERVISED_FINE_TUNING";
  }
  if (discriminatorGcsUri === "SUPERVISED_FINE_TUNING") {
    const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
    if (parentObject !== void 0 && fromGcsUri != null) {
      setValueByPath(parentObject, ["supervisedTuningSpec", "trainingDatasetUri"], fromGcsUri);
    }
  } else if (discriminatorGcsUri === "PREFERENCE_TUNING") {
    const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
    if (parentObject !== void 0 && fromGcsUri != null) {
      setValueByPath(parentObject, ["preferenceOptimizationSpec", "trainingDatasetUri"], fromGcsUri);
    }
  } else if (discriminatorGcsUri === "DISTILLATION") {
    const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
    if (parentObject !== void 0 && fromGcsUri != null) {
      setValueByPath(parentObject, ["distillationSpec", "promptDatasetUri"], fromGcsUri);
    }
  }
  let discriminatorVertexDatasetResource = getValueByPath(rootObject, [
    "config",
    "method"
  ]);
  if (discriminatorVertexDatasetResource === void 0) {
    discriminatorVertexDatasetResource = "SUPERVISED_FINE_TUNING";
  }
  if (discriminatorVertexDatasetResource === "SUPERVISED_FINE_TUNING") {
    const fromVertexDatasetResource = getValueByPath(fromObject, [
      "vertexDatasetResource"
    ]);
    if (parentObject !== void 0 && fromVertexDatasetResource != null) {
      setValueByPath(parentObject, ["supervisedTuningSpec", "trainingDatasetUri"], fromVertexDatasetResource);
    }
  } else if (discriminatorVertexDatasetResource === "PREFERENCE_TUNING") {
    const fromVertexDatasetResource = getValueByPath(fromObject, [
      "vertexDatasetResource"
    ]);
    if (parentObject !== void 0 && fromVertexDatasetResource != null) {
      setValueByPath(parentObject, ["preferenceOptimizationSpec", "trainingDatasetUri"], fromVertexDatasetResource);
    }
  } else if (discriminatorVertexDatasetResource === "DISTILLATION") {
    const fromVertexDatasetResource = getValueByPath(fromObject, [
      "vertexDatasetResource"
    ]);
    if (parentObject !== void 0 && fromVertexDatasetResource != null) {
      setValueByPath(parentObject, ["distillationSpec", "promptDatasetUri"], fromVertexDatasetResource);
    }
  }
  if (getValueByPath(fromObject, ["examples"]) !== void 0) {
    throw new Error("examples parameter is not supported in Vertex AI.");
  }
  return toObject;
}
function tuningJobFromMldev(fromObject, rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromState = getValueByPath(fromObject, ["state"]);
  if (fromState != null) {
    setValueByPath(toObject, ["state"], tTuningJobStatus(fromState));
  }
  const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
  if (fromCreateTime != null) {
    setValueByPath(toObject, ["createTime"], fromCreateTime);
  }
  const fromStartTime = getValueByPath(fromObject, [
    "tuningTask",
    "startTime"
  ]);
  if (fromStartTime != null) {
    setValueByPath(toObject, ["startTime"], fromStartTime);
  }
  const fromEndTime = getValueByPath(fromObject, [
    "tuningTask",
    "completeTime"
  ]);
  if (fromEndTime != null) {
    setValueByPath(toObject, ["endTime"], fromEndTime);
  }
  const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
  if (fromUpdateTime != null) {
    setValueByPath(toObject, ["updateTime"], fromUpdateTime);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
  if (fromBaseModel != null) {
    setValueByPath(toObject, ["baseModel"], fromBaseModel);
  }
  const fromTunedModel = getValueByPath(fromObject, ["_self"]);
  if (fromTunedModel != null) {
    setValueByPath(toObject, ["tunedModel"], tunedModelFromMldev(fromTunedModel));
  }
  return toObject;
}
function tuningJobFromVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromState = getValueByPath(fromObject, ["state"]);
  if (fromState != null) {
    setValueByPath(toObject, ["state"], tTuningJobStatus(fromState));
  }
  const fromCreateTime = getValueByPath(fromObject, ["createTime"]);
  if (fromCreateTime != null) {
    setValueByPath(toObject, ["createTime"], fromCreateTime);
  }
  const fromStartTime = getValueByPath(fromObject, ["startTime"]);
  if (fromStartTime != null) {
    setValueByPath(toObject, ["startTime"], fromStartTime);
  }
  const fromEndTime = getValueByPath(fromObject, ["endTime"]);
  if (fromEndTime != null) {
    setValueByPath(toObject, ["endTime"], fromEndTime);
  }
  const fromUpdateTime = getValueByPath(fromObject, ["updateTime"]);
  if (fromUpdateTime != null) {
    setValueByPath(toObject, ["updateTime"], fromUpdateTime);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fromError);
  }
  const fromDescription = getValueByPath(fromObject, ["description"]);
  if (fromDescription != null) {
    setValueByPath(toObject, ["description"], fromDescription);
  }
  const fromBaseModel = getValueByPath(fromObject, ["baseModel"]);
  if (fromBaseModel != null) {
    setValueByPath(toObject, ["baseModel"], fromBaseModel);
  }
  const fromTunedModel = getValueByPath(fromObject, ["tunedModel"]);
  if (fromTunedModel != null) {
    setValueByPath(toObject, ["tunedModel"], fromTunedModel);
  }
  const fromPreTunedModel = getValueByPath(fromObject, [
    "preTunedModel"
  ]);
  if (fromPreTunedModel != null) {
    setValueByPath(toObject, ["preTunedModel"], fromPreTunedModel);
  }
  const fromSupervisedTuningSpec = getValueByPath(fromObject, [
    "supervisedTuningSpec"
  ]);
  if (fromSupervisedTuningSpec != null) {
    setValueByPath(toObject, ["supervisedTuningSpec"], fromSupervisedTuningSpec);
  }
  const fromPreferenceOptimizationSpec = getValueByPath(fromObject, [
    "preferenceOptimizationSpec"
  ]);
  if (fromPreferenceOptimizationSpec != null) {
    setValueByPath(toObject, ["preferenceOptimizationSpec"], fromPreferenceOptimizationSpec);
  }
  const fromDistillationSpec = getValueByPath(fromObject, [
    "distillationSpec"
  ]);
  if (fromDistillationSpec != null) {
    setValueByPath(toObject, ["distillationSpec"], fromDistillationSpec);
  }
  const fromTuningDataStats = getValueByPath(fromObject, [
    "tuningDataStats"
  ]);
  if (fromTuningDataStats != null) {
    setValueByPath(toObject, ["tuningDataStats"], fromTuningDataStats);
  }
  const fromEncryptionSpec = getValueByPath(fromObject, [
    "encryptionSpec"
  ]);
  if (fromEncryptionSpec != null) {
    setValueByPath(toObject, ["encryptionSpec"], fromEncryptionSpec);
  }
  const fromPartnerModelTuningSpec = getValueByPath(fromObject, [
    "partnerModelTuningSpec"
  ]);
  if (fromPartnerModelTuningSpec != null) {
    setValueByPath(toObject, ["partnerModelTuningSpec"], fromPartnerModelTuningSpec);
  }
  const fromCustomBaseModel = getValueByPath(fromObject, [
    "customBaseModel"
  ]);
  if (fromCustomBaseModel != null) {
    setValueByPath(toObject, ["customBaseModel"], fromCustomBaseModel);
  }
  const fromExperiment = getValueByPath(fromObject, ["experiment"]);
  if (fromExperiment != null) {
    setValueByPath(toObject, ["experiment"], fromExperiment);
  }
  const fromLabels = getValueByPath(fromObject, ["labels"]);
  if (fromLabels != null) {
    setValueByPath(toObject, ["labels"], fromLabels);
  }
  const fromOutputUri = getValueByPath(fromObject, ["outputUri"]);
  if (fromOutputUri != null) {
    setValueByPath(toObject, ["outputUri"], fromOutputUri);
  }
  const fromPipelineJob = getValueByPath(fromObject, ["pipelineJob"]);
  if (fromPipelineJob != null) {
    setValueByPath(toObject, ["pipelineJob"], fromPipelineJob);
  }
  const fromServiceAccount = getValueByPath(fromObject, [
    "serviceAccount"
  ]);
  if (fromServiceAccount != null) {
    setValueByPath(toObject, ["serviceAccount"], fromServiceAccount);
  }
  const fromTunedModelDisplayName = getValueByPath(fromObject, [
    "tunedModelDisplayName"
  ]);
  if (fromTunedModelDisplayName != null) {
    setValueByPath(toObject, ["tunedModelDisplayName"], fromTunedModelDisplayName);
  }
  const fromVeoTuningSpec = getValueByPath(fromObject, [
    "veoTuningSpec"
  ]);
  if (fromVeoTuningSpec != null) {
    setValueByPath(toObject, ["veoTuningSpec"], fromVeoTuningSpec);
  }
  return toObject;
}
function tuningOperationFromMldev(fromObject, _rootObject) {
  const toObject = {};
  const fromSdkHttpResponse = getValueByPath(fromObject, [
    "sdkHttpResponse"
  ]);
  if (fromSdkHttpResponse != null) {
    setValueByPath(toObject, ["sdkHttpResponse"], fromSdkHttpResponse);
  }
  const fromName = getValueByPath(fromObject, ["name"]);
  if (fromName != null) {
    setValueByPath(toObject, ["name"], fromName);
  }
  const fromMetadata = getValueByPath(fromObject, ["metadata"]);
  if (fromMetadata != null) {
    setValueByPath(toObject, ["metadata"], fromMetadata);
  }
  const fromDone = getValueByPath(fromObject, ["done"]);
  if (fromDone != null) {
    setValueByPath(toObject, ["done"], fromDone);
  }
  const fromError = getValueByPath(fromObject, ["error"]);
  if (fromError != null) {
    setValueByPath(toObject, ["error"], fromError);
  }
  return toObject;
}
function tuningValidationDatasetToVertex(fromObject, _rootObject) {
  const toObject = {};
  const fromGcsUri = getValueByPath(fromObject, ["gcsUri"]);
  if (fromGcsUri != null) {
    setValueByPath(toObject, ["validationDatasetUri"], fromGcsUri);
  }
  const fromVertexDatasetResource = getValueByPath(fromObject, [
    "vertexDatasetResource"
  ]);
  if (fromVertexDatasetResource != null) {
    setValueByPath(toObject, ["validationDatasetUri"], fromVertexDatasetResource);
  }
  return toObject;
}
var Tunings = class extends BaseModule {
  constructor(apiClient) {
    super();
    this.apiClient = apiClient;
    this.list = async (params = {}) => {
      return new Pager(PagedItem.PAGED_ITEM_TUNING_JOBS, (x3) => this.listInternal(x3), await this.listInternal(params), params);
    };
    this.get = async (params) => {
      return await this.getInternal(params);
    };
    this.tune = async (params) => {
      var _a5;
      if (this.apiClient.isVertexAI()) {
        if (params.baseModel.startsWith("projects/")) {
          const preTunedModel = {
            tunedModelName: params.baseModel
          };
          if ((_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.preTunedModelCheckpointId) {
            preTunedModel.checkpointId = params.config.preTunedModelCheckpointId;
          }
          const paramsPrivate = Object.assign(Object.assign({}, params), { preTunedModel });
          paramsPrivate.baseModel = void 0;
          return await this.tuneInternal(paramsPrivate);
        } else {
          const paramsPrivate = Object.assign({}, params);
          return await this.tuneInternal(paramsPrivate);
        }
      } else {
        const paramsPrivate = Object.assign({}, params);
        const operation = await this.tuneMldevInternal(paramsPrivate);
        let tunedModelName = "";
        if (operation["metadata"] !== void 0 && operation["metadata"]["tunedModel"] !== void 0) {
          tunedModelName = operation["metadata"]["tunedModel"];
        } else if (operation["name"] !== void 0 && operation["name"].includes("/operations/")) {
          tunedModelName = operation["name"].split("/operations/")[0];
        }
        const tuningJob = {
          name: tunedModelName,
          state: JobState.JOB_STATE_QUEUED
        };
        return tuningJob;
      }
    };
  }
  async getInternal(params) {
    var _a5, _b, _c, _d;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = getTuningJobParametersToVertex(params);
      path4 = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = tuningJobFromVertex(apiResponse);
        return resp;
      });
    } else {
      const body = getTuningJobParametersToMldev(params);
      path4 = formatMap("{name}", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = tuningJobFromMldev(apiResponse);
        return resp;
      });
    }
  }
  async listInternal(params) {
    var _a5, _b, _c, _d;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = listTuningJobsParametersToVertex(params);
      path4 = formatMap("tuningJobs", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = listTuningJobsResponseFromVertex(apiResponse);
        const typedResp = new ListTuningJobsResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = listTuningJobsParametersToMldev(params);
      path4 = formatMap("tunedModels", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "GET",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = listTuningJobsResponseFromMldev(apiResponse);
        const typedResp = new ListTuningJobsResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
  /**
   * Cancels a tuning job.
   *
   * @param params - The parameters for the cancel request.
   * @return The empty response returned by the API.
   *
   * @example
   * ```ts
   * await ai.tunings.cancel({name: '...'}); // The server-generated resource name.
   * ```
   */
  async cancel(params) {
    var _a5, _b, _c, _d;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = cancelTuningJobParametersToVertex(params);
      path4 = formatMap("{name}:cancel", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = cancelTuningJobResponseFromVertex(apiResponse);
        const typedResp = new CancelTuningJobResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = cancelTuningJobParametersToMldev(params);
      path4 = formatMap("{name}:cancel", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,
        abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = cancelTuningJobResponseFromMldev(apiResponse);
        const typedResp = new CancelTuningJobResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }
  async tuneInternal(params) {
    var _a5, _b;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      const body = createTuningJobParametersPrivateToVertex(params, params);
      path4 = formatMap("tuningJobs", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = tuningJobFromVertex(apiResponse);
        return resp;
      });
    } else {
      throw new Error("This method is only supported by the Vertex AI.");
    }
  }
  async tuneMldevInternal(params) {
    var _a5, _b;
    let response;
    let path4 = "";
    let queryParams = {};
    if (this.apiClient.isVertexAI()) {
      throw new Error("This method is only supported by the Gemini Developer API.");
    } else {
      const body = createTuningJobParametersPrivateToMldev(params);
      path4 = formatMap("tunedModels", body["_url"]);
      queryParams = body["_query"];
      delete body["_url"];
      delete body["_query"];
      response = this.apiClient.request({
        path: path4,
        queryParams,
        body: JSON.stringify(body),
        httpMethod: "POST",
        httpOptions: (_a5 = params.config) === null || _a5 === void 0 ? void 0 : _a5.httpOptions,
        abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal
      }).then((httpResponse) => {
        return httpResponse.json().then((jsonResponse) => {
          const response2 = jsonResponse;
          response2.sdkHttpResponse = {
            headers: httpResponse.headers
          };
          return response2;
        });
      });
      return response.then((apiResponse) => {
        const resp = tuningOperationFromMldev(apiResponse);
        return resp;
      });
    }
  }
};
var BrowserDownloader = class {
  async download(_params, _apiClient) {
    throw new Error("Download to file is not supported in the browser, please use a browser compliant download like an <a> tag.");
  }
};
var MAX_CHUNK_SIZE = 1024 * 1024 * 8;
var MAX_RETRY_COUNT = 3;
var INITIAL_RETRY_DELAY_MS = 1e3;
var DELAY_MULTIPLIER = 2;
var X_GOOG_UPLOAD_STATUS_HEADER_FIELD = "x-goog-upload-status";
async function uploadBlob(file, uploadUrl, apiClient) {
  var _a5;
  const response = await uploadBlobInternal(file, uploadUrl, apiClient);
  const responseJson = await (response === null || response === void 0 ? void 0 : response.json());
  if (((_a5 = response === null || response === void 0 ? void 0 : response.headers) === null || _a5 === void 0 ? void 0 : _a5[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== "final") {
    throw new Error("Failed to upload file: Upload status is not finalized.");
  }
  return responseJson["file"];
}
async function uploadBlobToFileSearchStore(file, uploadUrl, apiClient) {
  var _a5;
  const response = await uploadBlobInternal(file, uploadUrl, apiClient);
  const responseJson = await (response === null || response === void 0 ? void 0 : response.json());
  if (((_a5 = response === null || response === void 0 ? void 0 : response.headers) === null || _a5 === void 0 ? void 0 : _a5[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== "final") {
    throw new Error("Failed to upload file: Upload status is not finalized.");
  }
  const resp = uploadToFileSearchStoreOperationFromMldev(responseJson);
  const typedResp = new UploadToFileSearchStoreOperation();
  Object.assign(typedResp, resp);
  return typedResp;
}
async function uploadBlobInternal(file, uploadUrl, apiClient) {
  var _a5, _b;
  let fileSize = 0;
  let offset = 0;
  let response = new HttpResponse(new Response());
  let uploadCommand = "upload";
  fileSize = file.size;
  while (offset < fileSize) {
    const chunkSize = Math.min(MAX_CHUNK_SIZE, fileSize - offset);
    const chunk = file.slice(offset, offset + chunkSize);
    if (offset + chunkSize >= fileSize) {
      uploadCommand += ", finalize";
    }
    let retryCount = 0;
    let currentDelayMs = INITIAL_RETRY_DELAY_MS;
    while (retryCount < MAX_RETRY_COUNT) {
      response = await apiClient.request({
        path: "",
        body: chunk,
        httpMethod: "POST",
        httpOptions: {
          apiVersion: "",
          baseUrl: uploadUrl,
          headers: {
            "X-Goog-Upload-Command": uploadCommand,
            "X-Goog-Upload-Offset": String(offset),
            "Content-Length": String(chunkSize)
          }
        }
      });
      if ((_a5 = response === null || response === void 0 ? void 0 : response.headers) === null || _a5 === void 0 ? void 0 : _a5[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) {
        break;
      }
      retryCount++;
      await sleep3(currentDelayMs);
      currentDelayMs = currentDelayMs * DELAY_MULTIPLIER;
    }
    offset += chunkSize;
    if (((_b = response === null || response === void 0 ? void 0 : response.headers) === null || _b === void 0 ? void 0 : _b[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== "active") {
      break;
    }
    if (fileSize <= offset) {
      throw new Error("All content has been uploaded, but the upload status is not finalized.");
    }
  }
  return response;
}
async function getBlobStat(file) {
  const fileStat = { size: file.size, type: file.type };
  return fileStat;
}
function sleep3(ms) {
  return new Promise((resolvePromise) => setTimeout(resolvePromise, ms));
}
var BrowserUploader = class {
  async upload(file, uploadUrl, apiClient) {
    if (typeof file === "string") {
      throw new Error("File path is not supported in browser uploader.");
    }
    return await uploadBlob(file, uploadUrl, apiClient);
  }
  async uploadToFileSearchStore(file, uploadUrl, apiClient) {
    if (typeof file === "string") {
      throw new Error("File path is not supported in browser uploader.");
    }
    return await uploadBlobToFileSearchStore(file, uploadUrl, apiClient);
  }
  async stat(file) {
    if (typeof file === "string") {
      throw new Error("File path is not supported in browser uploader.");
    } else {
      return await getBlobStat(file);
    }
  }
};
var BrowserWebSocketFactory = class {
  create(url, headers, callbacks) {
    return new BrowserWebSocket(url, headers, callbacks);
  }
};
var BrowserWebSocket = class {
  constructor(url, headers, callbacks) {
    this.url = url;
    this.headers = headers;
    this.callbacks = callbacks;
  }
  connect() {
    this.ws = new WebSocket(this.url);
    this.ws.onopen = this.callbacks.onopen;
    this.ws.onerror = this.callbacks.onerror;
    this.ws.onclose = this.callbacks.onclose;
    this.ws.onmessage = this.callbacks.onmessage;
  }
  send(message) {
    if (this.ws === void 0) {
      throw new Error("WebSocket is not connected");
    }
    this.ws.send(message);
  }
  close() {
    if (this.ws === void 0) {
      throw new Error("WebSocket is not connected");
    }
    this.ws.close();
  }
};
var GOOGLE_API_KEY_HEADER = "x-goog-api-key";
var WebAuth = class {
  constructor(apiKey) {
    this.apiKey = apiKey;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  async addAuthHeaders(headers, url) {
    if (headers.get(GOOGLE_API_KEY_HEADER) !== null) {
      return;
    }
    if (this.apiKey.startsWith("auth_tokens/")) {
      throw new Error("Ephemeral tokens are only supported by the live API.");
    }
    if (!this.apiKey) {
      throw new Error("API key is missing. Please provide a valid API key.");
    }
    headers.append(GOOGLE_API_KEY_HEADER, this.apiKey);
  }
};
var LANGUAGE_LABEL_PREFIX = "gl-node/";
var GoogleGenAI = class {
  get interactions() {
    if (this._interactions !== void 0) {
      return this._interactions;
    }
    console.warn("GoogleGenAI.interactions: Interactions usage is experimental and may change in future versions.");
    const httpOpts = this.httpOptions;
    if (httpOpts === null || httpOpts === void 0 ? void 0 : httpOpts.extraBody) {
      console.warn("GoogleGenAI.interactions: Client level httpOptions.extraBody is not supported by the interactions client and will be ignored.");
    }
    const nextGenClient = new GeminiNextGenAPIClient({
      baseURL: this.apiClient.getBaseUrl(),
      apiKey: this.apiKey,
      apiVersion: this.apiClient.getApiVersion(),
      clientAdapter: this.apiClient,
      defaultHeaders: this.apiClient.getDefaultHeaders(),
      timeout: httpOpts === null || httpOpts === void 0 ? void 0 : httpOpts.timeout
    });
    this._interactions = nextGenClient.interactions;
    return this._interactions;
  }
  constructor(options) {
    var _a5;
    if (options.apiKey == null) {
      throw new Error("An API Key must be set when running in a browser");
    }
    if (options.project || options.location) {
      throw new Error("Vertex AI project based authentication is not supported on browser runtimes. Please do not provide a project or location.");
    }
    this.vertexai = (_a5 = options.vertexai) !== null && _a5 !== void 0 ? _a5 : false;
    this.apiKey = options.apiKey;
    const baseUrl = getBaseUrl(
      options.httpOptions,
      options.vertexai,
      /*vertexBaseUrlFromEnv*/
      void 0,
      /*geminiBaseUrlFromEnv*/
      void 0
    );
    if (baseUrl) {
      if (options.httpOptions) {
        options.httpOptions.baseUrl = baseUrl;
      } else {
        options.httpOptions = { baseUrl };
      }
    }
    this.apiVersion = options.apiVersion;
    this.httpOptions = options.httpOptions;
    const auth = new WebAuth(this.apiKey);
    this.apiClient = new ApiClient({
      auth,
      apiVersion: this.apiVersion,
      apiKey: this.apiKey,
      vertexai: this.vertexai,
      httpOptions: this.httpOptions,
      userAgentExtra: LANGUAGE_LABEL_PREFIX + "web",
      uploader: new BrowserUploader(),
      downloader: new BrowserDownloader()
    });
    this.models = new Models4(this.apiClient);
    this.live = new Live(this.apiClient, auth, new BrowserWebSocketFactory());
    this.batches = new Batches4(this.apiClient);
    this.chats = new Chats(this.models, this.apiClient);
    this.caches = new Caches(this.apiClient);
    this.files = new Files5(this.apiClient);
    this.operations = new Operations(this.apiClient);
    this.authTokens = new Tokens(this.apiClient);
    this.tunings = new Tunings(this.apiClient);
    this.fileSearchStores = new FileSearchStores(this.apiClient);
  }
};

// src/utils/utils.ts
var events = require("events");
var _origSetMaxListeners = events.setMaxListeners;
if (_origSetMaxListeners) {
  events.setMaxListeners = function(n3, ...eventTargets) {
    try {
      return _origSetMaxListeners(n3, ...eventTargets);
    } catch (e3) {
    }
  };
}
function getGpt4AllPath(plugin) {
  const platform = plugin.os.platform();
  const homedir = plugin.os.homedir();
  if (platform === "win32") {
    return `${homedir}\\AppData\\Local\\nomic.ai\\GPT4All`;
  } else if (platform === "linux") {
    return `${homedir}/gpt4all`;
  } else {
    return `${homedir}/Library/Application Support/nomic.ai/GPT4All`;
  }
}
function upperCaseFirst(input) {
  if (input.length === 0) return input;
  return input.charAt(0).toUpperCase() + input.slice(1);
}
async function messageGPT4AllServer(params, url) {
  const request = {
    url: `http://localhost:4891${url}`,
    method: "POST",
    body: JSON.stringify({
      model: params.model,
      messages: params.messages,
      max_tokens: params.tokens,
      temperature: params.temperature
    })
  };
  const response = await (0, import_obsidian3.requestUrl)(request).then((res) => res.json);
  return response.choices[0].message;
}
async function getApiKeyValidity(providerKeyPair) {
  try {
    const { key, provider } = providerKeyPair;
    if (provider === openAI) {
      const openaiClient = new OpenAI({
        apiKey: key,
        dangerouslyAllowBrowser: true
      });
      await openaiClient.models.list();
      return { provider, valid: true };
    } else if (provider === claude) {
      const client = new Anthropic({
        apiKey: key,
        dangerouslyAllowBrowser: true
      });
      await client.messages.create({
        model: claudeSonnetJuneModel,
        max_tokens: 1,
        messages: [{ role: "user", content: "Reply 'a'" }]
      });
      return { provider, valid: true };
    } else if (provider === gemini) {
      const client = new GoogleGenAI({ apiKey: key });
      await client.models.generateContent({
        model: geminiModel,
        contents: "Reply 'a'",
        config: {
          candidateCount: 1,
          maxOutputTokens: 1
        }
      });
      return { provider, valid: true };
    }
  } catch (error) {
    if (error.status === 401) {
      console.error(`Invalid API key for ${providerKeyPair.provider}.`);
      SingletonNotice.show(
        `Invalid API key for ${upperCaseFirst(
          providerKeyPair.provider
        )}.`
      );
    } else {
      console.log("An error occurred:", error.message);
    }
    return false;
  }
}
async function geminiMessage(params, Gemini_API_KEY) {
  const { model, topP, messages: messages2, tokens, temperature } = params;
  const client = new GoogleGenAI({ apiKey: Gemini_API_KEY });
  const contents = messages2.map((message) => {
    const role = message.role === "user" ? "user" : "model";
    return {
      role,
      parts: [{ text: message.content }]
    };
  });
  const stream = await client.models.generateContentStream({
    model,
    contents,
    config: {
      candidateCount: 1,
      maxOutputTokens: tokens,
      temperature,
      topP: topP != null ? topP : void 0
    }
  });
  return stream;
}
function resolveNodePath() {
  const fs = require("fs");
  const homedir = require("os").homedir();
  const candidates = [];
  const nvmDir = `${homedir}/.nvm/versions/node`;
  try {
    if (fs.existsSync(nvmDir)) {
      const versions = fs.readdirSync(nvmDir).sort().reverse();
      if (versions.length > 0) {
        candidates.push(`${nvmDir}/${versions[0]}/bin/node`);
      }
    }
  } catch (e3) {
  }
  candidates.push(
    `${homedir}/.volta/bin/node`,
    // volta
    `${homedir}/.local/share/fnm/aliases/default/bin/node`,
    // fnm
    `${homedir}/.asdf/shims/node`,
    // asdf
    `${homedir}/.local/bin/node`,
    "/usr/local/bin/node",
    "/usr/bin/node",
    "/snap/bin/node"
  );
  for (const candidate of candidates) {
    try {
      if (fs.existsSync(candidate)) {
        return candidate;
      }
    } catch (e3) {
    }
  }
  console.warn("[Claude Code] Could not find node binary, falling back to 'node'");
  return "node";
}
async function claudeCodeMessage(prompt, oauthToken, linearWorkspaces, cwd, pluginDir, sessionId) {
  await ensureSDKInstalled(pluginDir);
  const path4 = require("path");
  const { spawn } = require("child_process");
  const cliPath = path4.join(
    pluginDir,
    "node_modules",
    "@anthropic-ai",
    "claude-agent-sdk",
    "cli.js"
  );
  const nodePath = resolveNodePath();
  const mcpServers = {};
  const allowedTools = [];
  for (const ws of linearWorkspaces) {
    if (!ws.apiKey) continue;
    const key = ws.name ? `linear-${ws.name.toLowerCase().replace(/[^a-z0-9]+/g, "-")}` : "linear";
    mcpServers[key] = {
      type: "http",
      url: "https://mcp.linear.app/mcp",
      headers: { Authorization: `Bearer ${ws.apiKey}` }
    };
    allowedTools.push(`mcp__${key}__*`);
  }
  const result = s_({
    prompt,
    options: {
      pathToClaudeCodeExecutable: cliPath,
      ...sessionId ? { resume: sessionId } : {},
      spawnClaudeCodeProcess: (options) => {
        const cmd = options.command === "node" ? nodePath : options.command;
        return spawn(cmd, options.args, {
          cwd: options.cwd,
          env: options.env,
          stdio: ["pipe", "pipe", "pipe"]
        });
      },
      ...Object.keys(mcpServers).length > 0 ? { mcpServers, allowedTools } : {},
      permissionMode: "acceptEdits",
      cwd,
      env: {
        ...process.env,
        CLAUDE_CODE_OAUTH_TOKEN: oauthToken
      }
    }
  });
  return result;
}
async function claudeMessage(params, Claude_API_KEY) {
  const client = new Anthropic({
    apiKey: Claude_API_KEY,
    dangerouslyAllowBrowser: true
  });
  const { model, messages: messages2, tokens, temperature } = params;
  const stream = client.messages.stream({
    model,
    messages: messages2,
    max_tokens: tokens,
    temperature,
    stream: true
  });
  return stream;
}
async function openAIMessage(params, OpenAI_API_Key, endpoint, endpointType) {
  var _a5;
  const openai = new OpenAI({
    apiKey: OpenAI_API_Key,
    dangerouslyAllowBrowser: true
  });
  if (endpointType === chat) {
    const { model, messages: messages2, tokens, temperature } = params;
    const stream = await openai.chat.completions.create(
      {
        model,
        messages: messages2,
        max_tokens: tokens,
        temperature,
        stream: true
      },
      { path: endpoint }
    );
    return stream;
  }
  if (endpointType === "images") {
    const {
      prompt,
      model,
      quality,
      size,
      style,
      numberOfImages
    } = params;
    const image = await openai.images.generate({
      model,
      prompt,
      size,
      quality,
      n: numberOfImages,
      style
    });
    let imageURLs = [];
    (_a5 = image.data) == null ? void 0 : _a5.map((image2) => {
      return imageURLs.push(image2.url);
    });
    return imageURLs;
  }
}
async function assistantsMessage(OpenAI_API_Key, messages2, assistant_id) {
  const openai = new OpenAI({
    apiKey: OpenAI_API_Key,
    dangerouslyAllowBrowser: true
  });
  const thread = await openai.beta.threads.create({
    messages: messages2
  });
  const stream = openai.beta.threads.runs.stream(thread.id, {
    assistant_id
  });
  return stream;
}
function getViewInfo(plugin, viewType) {
  if (viewType === "modal") {
    return {
      assistant: plugin.settings.modalSettings.assistant,
      assistantId: plugin.settings.modalSettings.assistantId,
      imageSettings: plugin.settings.modalSettings.imageSettings,
      chatSettings: plugin.settings.modalSettings.chatSettings,
      model: plugin.settings.modalSettings.model,
      modelName: plugin.settings.modalSettings.modelName,
      modelType: plugin.settings.modalSettings.modelType,
      historyIndex: plugin.settings.modalSettings.historyIndex,
      modelEndpoint: plugin.settings.modalSettings.modelEndpoint,
      endpointURL: plugin.settings.modalSettings.endpointURL,
      contextSettings: plugin.settings.modalSettings.contextSettings
    };
  }
  if (viewType === "widget") {
    return {
      assistant: plugin.settings.widgetSettings.assistant,
      assistantId: plugin.settings.widgetSettings.assistantId,
      imageSettings: plugin.settings.widgetSettings.imageSettings,
      chatSettings: plugin.settings.widgetSettings.chatSettings,
      model: plugin.settings.widgetSettings.model,
      modelName: plugin.settings.widgetSettings.modelName,
      modelType: plugin.settings.widgetSettings.modelType,
      historyIndex: plugin.settings.widgetSettings.historyIndex,
      modelEndpoint: plugin.settings.widgetSettings.modelEndpoint,
      endpointURL: plugin.settings.widgetSettings.endpointURL,
      contextSettings: plugin.settings.widgetSettings.contextSettings
    };
  }
  if (viewType === "floating-action-button") {
    return {
      assistant: plugin.settings.fabSettings.assistant,
      assistantId: plugin.settings.fabSettings.assistantId,
      imageSettings: plugin.settings.fabSettings.imageSettings,
      chatSettings: plugin.settings.fabSettings.chatSettings,
      model: plugin.settings.fabSettings.model,
      modelName: plugin.settings.fabSettings.modelName,
      modelType: plugin.settings.fabSettings.modelType,
      historyIndex: plugin.settings.fabSettings.historyIndex,
      modelEndpoint: plugin.settings.fabSettings.modelEndpoint,
      endpointURL: plugin.settings.fabSettings.endpointURL,
      contextSettings: plugin.settings.fabSettings.contextSettings
    };
  }
  return {
    assistant: false,
    assistantId: "",
    imageSettings: {
      numberOfImages: 0,
      response_format: "url",
      size: "1024x1024",
      style: "natural",
      quality: "standard"
    },
    chatSettings: { maxTokens: 0, temperature: 0 },
    model: "",
    modelName: "",
    modelType: "",
    historyIndex: -1,
    modelEndpoint: "",
    endpointURL: "",
    contextSettings: {
      includeActiveFile: false,
      includeSelection: false,
      selectedFiles: [],
      maxContextTokensPercent: 0
    }
  };
}
function changeDefaultModel(model, plugin) {
  plugin.settings.defaultModel = model;
  const modelName = modelNames[model];
  plugin.settings.modalSettings.model = model;
  plugin.settings.modalSettings.modelName = modelName;
  plugin.settings.modalSettings.modelType = models[modelName].type;
  plugin.settings.modalSettings.endpointURL = models[modelName].url;
  plugin.settings.modalSettings.modelEndpoint = models[modelName].endpoint;
  plugin.settings.widgetSettings.model = model;
  plugin.settings.widgetSettings.modelName = modelName;
  plugin.settings.widgetSettings.modelType = models[modelName].type;
  plugin.settings.widgetSettings.endpointURL = models[modelName].url;
  plugin.settings.widgetSettings.modelEndpoint = models[modelName].endpoint;
  plugin.saveSettings();
}
function setHistoryIndex(plugin, viewType, length) {
  const settings = {
    modal: "modalSettings",
    widget: "widgetSettings",
    "floating-action-button": "fabSettings"
  };
  const settingType = settings[viewType];
  if (!length) {
    plugin.settings[settingType].historyIndex = -1;
    plugin.saveSettings();
    return;
  }
  plugin.settings[settingType].historyIndex = length - 1;
  plugin.saveSettings();
}
function setView(plugin, viewType) {
  plugin.settings.currentView = viewType;
  plugin.saveSettings();
}
function getSettingType(viewType) {
  const settings = {
    modal: "modalSettings",
    widget: "widgetSettings",
    "floating-action-button": "fabSettings"
  };
  const settingType = settings[viewType];
  return settingType;
}
async function createAssistant(assistantObj, OpenAI_API_Key) {
  const openai = new OpenAI({
    apiKey: OpenAI_API_Key,
    dangerouslyAllowBrowser: true
  });
  const assistant2 = await openai.beta.assistants.create(assistantObj);
  return assistant2;
}
function getAssistant(plugin, assistant_id) {
  return plugin.settings.assistants.find(
    (assistant2) => assistant2.id === assistant_id
  );
}
async function listAssistants(OpenAI_API_Key) {
  const openai = new OpenAI({
    apiKey: OpenAI_API_Key,
    dangerouslyAllowBrowser: true
  });
  const myAssistants = await openai.beta.assistants.list();
  return myAssistants.data;
}
async function generateAssistantsList(settings) {
  const assisitantsFromOpenAI = await listAssistants(settings.openAIAPIKey);
  const processedAssisitants = assisitantsFromOpenAI.map(
    (assistant2) => ({
      ...assistant2,
      modelType: assistant2
    })
  );
  settings.assistants = processedAssisitants;
}
async function deleteAssistant(OpenAI_API_Key, assistant_id) {
  const openai = new OpenAI({
    apiKey: OpenAI_API_Key,
    dangerouslyAllowBrowser: true
  });
  await openai.beta.assistants.delete(assistant_id);
}
async function listVectors(OpenAI_API_Key) {
  const openai = new OpenAI({
    apiKey: OpenAI_API_Key,
    dangerouslyAllowBrowser: true
  });
  const vectorStores = await openai.vectorStores.list();
  return vectorStores.data;
}
async function deleteVector(OpenAI_API_Key, vector_id) {
  const openai = new OpenAI({
    apiKey: OpenAI_API_Key,
    dangerouslyAllowBrowser: true
  });
  await openai.vectorStores.delete(vector_id);
}
async function createVectorAndUpdate(files, assistant2, OpenAI_API_Key, fileSystem) {
  const openai = new OpenAI({
    apiKey: OpenAI_API_Key,
    dangerouslyAllowBrowser: true
  });
  const file_ids = await Promise.all(
    files.map(async (filePath) => {
      const stream = await fileSystem.createReadStream(filePath);
      const reader = stream.getReader();
      const chunks = [];
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        chunks.push(value);
      }
      const fileContent = new Uint8Array(chunks.flat());
      const fileToUpload = await toFile(
        new Blob([fileContent]),
        filePath
      );
      const file = await openai.files.create({
        file: fileToUpload,
        purpose: "assistants"
      });
      return file.id;
    })
  );
  let vectorStore = await openai.vectorStores.create({
    name: "Assistant Files"
  });
  await openai.vectorStores.fileBatches.create(vectorStore.id, {
    file_ids
  });
  await openai.beta.assistants.update(assistant2.id, {
    tool_resources: { file_search: { vector_store_ids: [vectorStore.id] } }
  });
  return vectorStore.id;
}

// src/Plugin/Components/AssistantsContainer.ts
var AssistantsContainer = class {
  constructor(plugin, viewType) {
    this.plugin = plugin;
    this.viewType = viewType;
  }
  validateFields(fields) {
    const invalidFields = [];
    for (const [fieldName, value] of Object.entries(fields)) {
      if (!value) {
        invalidFields.push(fieldName);
      }
    }
    return invalidFields;
  }
  async generateAssistantsContainer(parentContainer) {
    new import_obsidian4.Setting(parentContainer).setName("Assistants options").setDesc("What do you want to do?").addDropdown((dropdown) => {
      dropdown.addOption("", "---Assistant options---");
      dropdown.addOption("asst_create", "Create an assistant");
      dropdown.addOption("asst_update", "Update an assistant");
      dropdown.addOption("asst_delete", "Delete an assistant");
      dropdown.addOption("", "---Vector storage options---");
      dropdown.addOption("vect_create", "Create vector storage");
      dropdown.addOption("vect_update", "Update vector storage");
      dropdown.addOption("vect_delete", "Delete vector storage");
      dropdown.onChange((change) => {
        this.resetContainer(parentContainer);
        switch (change) {
          case "asst_create":
            this.createAssistant(parentContainer);
            return;
          case "asst_update":
            this.updateAssistant(parentContainer);
            return;
          case "asst_delete":
            this.deleteAssistant(parentContainer);
            return;
          case "vect_create":
            this.createVector(parentContainer);
            return;
          case "vect_update":
            this.updateVector(parentContainer);
            return;
          case "vect_delete":
            this.deleteVector(parentContainer);
            return;
        }
      });
    });
  }
  // NOTE -> for both the create assistant flow we should dump the this.createAssistant name & other fields
  // after a successful submission event.
  createAssistant(parentContainer) {
    const file_ids = this.createSearch(
      parentContainer,
      assistant,
      true
    );
    this.filesSetting = file_ids;
    file_ids.settingEl.setAttr("style", "display:none");
    const buttonDiv = parentContainer.createDiv();
    buttonDiv.addClass(
      "llm-flex",
      "assistants-create-button-div",
      "setting-item"
    );
    const submitButton = new import_obsidian4.ButtonComponent(buttonDiv);
    submitButton.buttonEl.addClass("mod-cta", "llm-assistants-button");
    submitButton.buttonEl.textContent = "Create assistant";
    submitButton.onClick(async (e3) => {
      var _a5, _b;
      const requiredFields = {
        "Name": this.createAssistantName,
        "Model": this.createAssistantModel
      };
      const invalidFields = this.validateFields(requiredFields);
      if (invalidFields.length > 0) {
        SingletonNotice.show(`Please fill out the following fields: ${invalidFields.join(", ")}`);
        return;
      }
      SingletonNotice.show("Creating assistant...");
      e3.preventDefault();
      const assistantFiles = (_a5 = this.assistantFilesToAdd) == null ? void 0 : _a5.map((file) => {
        if (import_obsidian4.Platform.isMobile) {
          return file;
        } else {
          const slashToUse = this.plugin.os.platform() === "win32" ? "\\" : "/";
          const basePath = this.plugin.app.vault.adapter.basePath;
          return `${basePath}${slashToUse}${file}`;
        }
      });
      const hasFiles = ((_b = this.assistantFilesToAdd) == null ? void 0 : _b.length) >= 1;
      const assistantObj = {
        name: this.createAssistantName,
        instructions: this.createAssistantIntructions,
        model: this.createAssistantModel,
        tools: hasFiles ? [{ type: this.createAssistantToolType }] : null
      };
      const assistant2 = await createAssistant(
        assistantObj,
        this.plugin.settings.openAIAPIKey
      );
      if (hasFiles) {
        const vector_store_id = await createVectorAndUpdate(
          assistantFiles,
          assistant2,
          this.plugin.settings.openAIAPIKey,
          this.plugin.fileSystem
        );
        this.plugin.assistants.push({
          ...assistant2,
          modelType: assistant,
          tool_resources: {
            file_search: { vector_store_ids: [vector_store_id] }
          }
        });
      } else {
        this.plugin.assistants.push({
          ...assistant2,
          modelType: assistant
        });
      }
      if (assistant2) {
        new import_obsidian4.Notice("Assistant created successfully");
      }
      this.resetContainer(parentContainer);
    });
  }
  async updateAssistant(parentContainer) {
    const assistantsList = await listAssistants(
      this.plugin.settings.openAIAPIKey
    );
    let chosenAssistant;
    new import_obsidian4.Setting(parentContainer).setName("Assistants").setDesc("Which assistant do you want to update?").addDropdown((dropdown) => {
      dropdown.addOption("", "---Select an assistant---");
      assistantsList.map((assistant2) => {
        dropdown.addOption(assistant2.id, assistant2.name);
        dropdown.onChange((change) => {
          chosenAssistant = assistantsList.find(
            (assistant3) => assistant3.id === change
          );
          this.resetContainer(this.updateSettings, false);
          this.generateGenericSettings(
            this.updateSettings,
            "update",
            chosenAssistant
          );
          this.generateUpdateAssistants(
            this.updateSettings,
            chosenAssistant
          );
        });
      });
    });
    const updateSettings = parentContainer.createEl("div");
    updateSettings.addClass("llm-update-settings");
    this.updateSettings = updateSettings;
    this.generateGenericSettings(this.updateSettings, "update");
    this.generateUpdateAssistants(this.updateSettings);
    const buttonDiv = parentContainer.createDiv();
    buttonDiv.addClass("llm-flex", "update-button-div", "setting-item");
    const submitButton = new import_obsidian4.ButtonComponent(buttonDiv);
    submitButton.buttonEl.addClass("mod-cta", "llm-assistants-button");
    submitButton.buttonEl.textContent = "Update assistant";
    submitButton.onClick((event) => {
      event.preventDefault();
    });
  }
  deleteAssistant(parentContainer) {
    const assistants = this.plugin.settings.assistants;
    if (assistants.length < 1) {
      parentContainer.createEl("div", {
        text: "No assistants found",
        cls: "assistants-empty-state"
      });
    }
    assistants.map((assistant2, index) => {
      const item = parentContainer.createDiv();
      const text = item.createEl("p", {
        text: assistant2.name
      });
      const buttonsDiv = item.createDiv();
      buttonsDiv.addClass("history-buttons-div", "llm-flex");
      const deleteHistory = new import_obsidian4.ButtonComponent(buttonsDiv);
      deleteHistory.buttonEl.setAttr("style", "visibility: hidden");
      item.className = "setting-item";
      item.setAttr("contenteditable", "false");
      item.addClass("llm-history-item", "llm-flex");
      deleteHistory.buttonEl.addClass(
        "llm-delete-history-button",
        "mod-warning"
      );
      deleteHistory.buttonEl.id = "llm-delete-history-button";
      item.addEventListener("mouseenter", () => {
        if (text.contentEditable == "false" || text.contentEditable == "inherit") {
          deleteHistory.buttonEl.setAttr(
            "style",
            "visibility: visible"
          );
        }
      });
      item.addEventListener("mouseleave", () => {
        if (text.contentEditable == "false" || text.contentEditable == "inherit") {
          deleteHistory.buttonEl.setAttr(
            "style",
            "visibility: hidden"
          );
        }
      });
      deleteHistory.setIcon("trash");
      deleteHistory.onClick((e3) => {
        e3.stopPropagation();
        deleteAssistant(
          this.plugin.settings.openAIAPIKey,
          assistant2.id
        );
        this.resetContainer(parentContainer);
        let updatedAssistants = this.plugin.settings.assistants.filter(
          (item2, idx) => idx !== index
        );
        this.plugin.settings.assistants = updatedAssistants;
        this.plugin.saveSettings();
      });
    });
  }
  createSearch(parentContainer, assistantOption, needsReturn) {
    let filePathArray = [];
    const files = this.plugin.app.vault.getFiles();
    this.generateGenericSettings(parentContainer, "create");
    const file_ids = new import_obsidian4.Setting(parentContainer).setName("Search");
    let filesDiv = parentContainer.createEl("div");
    filesDiv.addClass("setting-item", "llm-vector-dropdown");
    let header = filesDiv.createEl("div");
    header.addClass("setting-item-info");
    let searchDiv = filesDiv.createEl("div");
    searchDiv.addClass("setting-item-control", "llm-vector-files");
    file_ids.addSearch((search) => {
      search.onChange((change) => {
        searchDiv.empty();
        if (change === "") {
          searchDiv.empty();
          return;
        }
        const options = files.filter(
          (file) => file.basename.toLowerCase().includes(change.toLowerCase())
        );
        options.map((option) => {
          const item = searchDiv.createEl("span", {
            text: option.name,
            cls: "llm-vector-file"
          });
          if (filePathArray.includes(option.path))
            item.addClass("llm-file-added");
          item.onClickEvent((click) => {
            if (filePathArray.includes(option.path)) {
              item.removeClass("llm-file-added");
              filePathArray = filePathArray.filter(
                (file_path) => file_path !== option.path
              );
            } else {
              item.addClass("llm-file-added");
              filePathArray = [...filePathArray, option.path];
            }
            assistantOption === assistant ? this.assistantFilesToAdd = filePathArray : this.vectorFilesToAdd = filePathArray;
          });
        });
      });
    });
    if (needsReturn) return file_ids;
  }
  createVector(parentContainer) {
    new import_obsidian4.Setting(parentContainer).setName("Vector storage name").setDesc("The name for your new vector storage").addText((text) => {
      text.onChange((change) => {
      });
    });
  }
  updateVector(parentContainer) {
  }
  async deleteVector(parentContainer) {
    const vectorStores = await listVectors(
      this.plugin.settings.openAIAPIKey
    );
    vectorStores.map((vectorStore, index) => {
      const item = parentContainer.createDiv();
      const text = item.createEl("p", {
        text: vectorStore.name
      });
      const buttonsDiv = item.createDiv();
      buttonsDiv.addClass("history-buttons-div", "llm-flex");
      const deleteHistory = new import_obsidian4.ButtonComponent(buttonsDiv);
      deleteHistory.buttonEl.setAttr("style", "visibility: hidden");
      item.className = "setting-item";
      item.setAttr("contenteditable", "false");
      item.addClass("llm-history-item", "llm-flex");
      deleteHistory.buttonEl.addClass(
        "llm-delete-history-button",
        "mod-warning"
      );
      deleteHistory.buttonEl.id = "llm-delete-history-button";
      item.addEventListener("mouseenter", () => {
        if (text.contentEditable == "false" || text.contentEditable == "inherit") {
          deleteHistory.buttonEl.setAttr(
            "style",
            "visibility: visible"
          );
        }
      });
      item.addEventListener("mouseleave", () => {
        if (text.contentEditable == "false" || text.contentEditable == "inherit") {
          deleteHistory.buttonEl.setAttr(
            "style",
            "visibility: hidden"
          );
        }
      });
      deleteHistory.setIcon("trash");
      deleteHistory.onClick((e3) => {
        e3.stopPropagation();
        deleteVector(this.plugin.settings.openAIAPIKey, vectorStore.id);
        this.resetContainer(parentContainer);
      });
    });
  }
  generateGenericSettings(parentContainer, option, assistant2) {
    new import_obsidian4.Setting(parentContainer).setName("Assistant name").setDesc("The name to be attributed to the new assistant").addText((text) => {
      if (assistant2) text.setValue(assistant2.name);
      text.inputEl.type = "text";
      text.onChange((change) => {
        option === "create" ? this.createAssistantName = change : this.updateAssistantName = change;
      });
    });
    new import_obsidian4.Setting(parentContainer).setName("Assistant instructions").setDesc("The system instructions for the assistant to follow.").addText((text) => {
      if (assistant2) text.setValue(assistant2.instructions);
      text.inputEl.type = "text";
      text.onChange((change) => {
        option === "create" ? this.createAssistantIntructions = change : this.updateAssistantIntructions = change;
      });
    });
    new import_obsidian4.Setting(parentContainer).setName("Assistant model").setDesc("Which LLM you want your assistant to use").addDropdown((dropdown) => {
      if (assistant2) dropdown.setValue(assistant2.model);
      dropdown.addOption("", "---Select model---");
      let keys = Object.keys(openAIModels);
      for (let model of keys) {
        dropdown.addOption(models[model].model, model);
      }
      dropdown.onChange((change) => {
        option === "create" ? this.createAssistantModel = change : this.updateAssistantModel = change;
      });
    });
    new import_obsidian4.Setting(parentContainer).setName("Assistant tool type").setDesc("File search or code review").addDropdown((dropdown) => {
      if (assistant2)
        dropdown.setValue(assistant2.tools[0].type);
      dropdown.addOption("", "---Tool type---");
      dropdown.addOption("file_search", "File Search");
      dropdown.onChange((change) => {
        if (option === "create") {
          this.createAssistantToolType = change;
          change === "file_search" ? this.filesSetting.settingEl.setAttr(
            "style",
            "display:flex"
          ) : this.filesSetting.settingEl.setAttr(
            "style",
            "display:none"
          );
        } else this.updateAssistantToolType = change;
      });
    });
  }
  generateUpdateAssistants(parentContainer, assistant2) {
    new import_obsidian4.Setting(parentContainer).setName("Tool resources").setDesc(
      "A set of resources that are used by the assistant's tools. The resources are specific to the type of tool. For example, the code_interpreter tool requires a list of file IDs, while the file_search tool requires a list of vector store IDs."
    ).addToggle((toggle) => {
      const trDiv = parentContainer.createEl("div");
      toggle.onChange((change) => {
        if (change) {
          new import_obsidian4.Setting(trDiv).setName("Vector store").setDesc(
            "The new vector store id to attach to ths assistant"
          ).addDropdown((dropdown) => {
            dropdown.addOption(
              "",
              "---Select vector store---"
            );
            dropdown.addOption("vectorStoreId", "ID");
            dropdown.onChange((change2) => {
              this.updateAssistantVectorStoreID = change2;
            });
          });
        }
        if (!change) {
          trDiv.empty();
        }
      });
    });
    new import_obsidian4.Setting(parentContainer).setName("Temperature").setDesc(
      "Defaults to 1. What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. We generally recommend altering this or top_p but not both."
    ).addText((text) => {
      if (assistant2) text.setValue(`${assistant2.temperature}`);
      text.inputEl.type = "number";
      text.onChange((change) => {
        this.updateAssistantTemperature = parseFloat(change);
      });
    });
    new import_obsidian4.Setting(parentContainer).setName("Top p").setDesc(
      "Defaults to 1. An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered."
    ).addText((text) => {
      if (assistant2) text.setValue(`${assistant2.top_p}`);
      text.inputEl.type = "number";
      text.onChange((change) => {
        this.updateAssistantTopP = parseFloat(change);
      });
    });
  }
  resetContainer(parentContainer, total = true) {
    parentContainer.empty();
    if (total) this.generateAssistantsContainer(parentContainer);
  }
};

// src/Plugin/Components/ChatContainer.ts
var import_obsidian7 = require("obsidian");

// src/Plugin/Errors/errors.ts
var import_obsidian5 = require("obsidian");
function settingsErrorHandling(params) {
  const settings = Object.keys(params);
  const errors = [];
  settings.map((setting) => {
    if (params[setting] === "quality") return;
    if (!params[setting]) {
      errors.push(`Request must include ${setting.toUpperCase()}`);
    }
  });
  return errors;
}
function errorMessages(error, params) {
  if (error.message === "Incorrect Settings") {
    settingsErrorHandling(params).forEach((wrongSetting) => {
      new import_obsidian5.Notice(wrongSetting);
    });
  }
  if (error.message === "Failed to fetch") {
    new import_obsidian5.Notice(
      "You must have GPT4All open with the API Server enabled"
    );
  }
  if (error.message === "No API Key") {
    new import_obsidian5.Notice("You must have an API key to access OpenAI models");
  }
  if (error.message === "GPT4All streaming") {
    new import_obsidian5.Notice("GPT4All is already working on another request. Please wait until that request is done to submit another prompt.");
  }
  if (error.message.includes("SDK installation failed")) {
    new import_obsidian5.Notice("Claude Code requires a one-time download of the runtime SDK (~69 MB). Please ensure npm is installed and you have an internet connection, then try again.");
  }
}

// src/utils/classNames.ts
var classNames = {
  modal: {
    "messages-div": "llm-modal-messages-div",
    "title-border": "llm-modal-title-border",
    "prompt-container": "llm-modal-prompt-container",
    "text-area": "llm-modal-chat-prompt-text-area",
    button: "llm-modal-send-button",
    "chat-message": "llm-modal-chat-message"
  },
  widget: {
    "messages-div": "llm-widget-messages-div",
    "title-border": "llm-widget-title-border",
    "prompt-container": "llm-widget-prompt-container",
    "text-area": "llm-widget-chat-prompt-text-area",
    button: "llm-widget-send-button",
    "chat-message": "llm-widget-chat-message"
  },
  "floating-action-button": {
    "messages-div": "fab-messages-div",
    "title-border": "fab-title-border",
    "prompt-container": "fab-prompt-container",
    "text-area": "fab-chat-prompt-text-area",
    button: "fab-send-button",
    "chat-message": "fab-chat-message"
  }
};

// src/Plugin/Components/AssistantLogo.ts
function assistantLogo() {
  const uniqueId = `paint0_linear_${Math.random().toString(36).substring(2, 9)}`;
  const svgNamespace = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(svgNamespace, "svg");
  svg.setAttribute("width", "24");
  svg.setAttribute("height", "24");
  svg.setAttribute("viewBox", "0 0 24 24");
  svg.setAttribute("fill", "none");
  const circle = document.createElementNS(svgNamespace, "circle");
  circle.setAttribute("cx", "12");
  circle.setAttribute("cy", "12");
  circle.setAttribute("r", "12");
  circle.setAttribute("fill", `url(#${uniqueId})`);
  svg.appendChild(circle);
  const defs = document.createElementNS(svgNamespace, "defs");
  const linearGradient = document.createElementNS(svgNamespace, "linearGradient");
  linearGradient.setAttribute("id", uniqueId);
  linearGradient.setAttribute("x1", "12");
  linearGradient.setAttribute("y1", "-0.000414185");
  linearGradient.setAttribute("x2", "12");
  linearGradient.setAttribute("y2", "24");
  linearGradient.setAttribute("gradientUnits", "userSpaceOnUse");
  const stop1 = document.createElementNS(svgNamespace, "stop");
  stop1.setAttribute("stop-color", "var(--color-accent)");
  linearGradient.appendChild(stop1);
  const stop2 = document.createElementNS(svgNamespace, "stop");
  stop2.setAttribute("offset", "1");
  stop2.setAttribute("stop-color", "var(--color-accent)");
  stop2.setAttribute("stop-opacity", "0.1");
  linearGradient.appendChild(stop2);
  defs.appendChild(linearGradient);
  svg.appendChild(defs);
  return svg;
}

// src/assets/LLMgal.svg
var LLMgal_default = '<svg width="97" height="71" viewBox="0 0 97 71" fill="none" xmlns="http://www.w3.org/2000/svg">\r\n<path fill-rule="evenodd" clip-rule="evenodd" d="M42.0185 0.5H44.6111H47.2037H49.7963H62.7593H65.3519V3.09259H62.7593H49.7963H47.2037H44.6111H42.0185V0.5ZM36.8333 5.68518V3.09259H39.4259H42.0185L42.0185 5.68518H39.4259H36.8333ZM34.2408 8.27778V5.68518H36.8333L36.8333 8.27778H34.2408ZM31.6482 10.8704V8.27778H34.2408V10.8704H31.6482ZM29.0556 13.463V10.8704H31.6482V13.463H29.0556ZM3.12964 18.6481V16.0556H5.72223H8.31483H10.9074H23.8704H26.463V13.463L29.0556 13.463V23.8333H26.463V18.6481H23.8704H10.9074H8.31483H5.72223H3.12964ZM3.12964 21.2407H0.537048V18.6481H3.12964V21.2407ZM5.72223 23.8333L3.12964 23.8333V21.2407H5.72223V23.8333ZM8.31483 26.4259H5.72223V23.8333H8.31483V26.4259ZM13.5 29.0185H10.9074H8.31483V26.4259H10.9074H13.5V29.0185ZM31.6482 34.2037V31.6111H23.8704V29.0185H16.0926H13.5L13.5 31.6111H16.0926H21.2778V34.2037H18.6852V36.7963L10.9074 36.7963H8.31483V39.3889H10.9074V41.9815L13.5 41.9815V44.5741H16.0926H18.6852V47.1667V49.7593L13.5 49.7593V47.1667H5.72223V49.7593L8.31483 49.7593V52.3519H10.9074V54.9444L13.5 54.9444V57.537H16.0926V60.1296H23.8704L23.8704 57.537H26.463V60.1296H29.0556V62.7222V65.3148H34.2408V67.9074H39.4259L44.6111 67.9074V70.5H47.2037H54.9815V67.9074L60.1667 67.9074V65.3148H62.7593L62.7593 62.7222H65.3519V65.3148H67.9445H78.3148V62.7222H80.9074V60.1296H78.3148V57.537H75.7222L75.7222 54.9444H73.1296V52.3518V44.5741H83.5H93.8704L93.8704 41.9815H96.463V39.3889V36.7963H93.8704V34.2037H88.6852V31.6111H86.0926H83.5V29.0185H80.9074V26.4259H78.3148V23.8333H75.7222L75.7222 10.8704H73.1296V8.27778H70.537V5.68518H67.9445V3.09259H65.3519V5.68518H67.9445L67.9445 8.27778H70.537V10.8704H73.1296V31.6111H75.7222L75.7222 26.4259H78.3148V29.0185H80.9074V31.6111H83.5V34.2037H86.0926H88.6852V36.7963L93.8704 36.7963V39.3889V41.9815L83.5 41.9815H73.1296V39.3889H62.7593L62.7593 36.7963H57.5741H49.7963H44.6111V34.2037H36.8333H31.6482ZM31.6482 47.1667V44.5741H34.2408V36.7963L31.6482 36.7963V34.2037H29.0556V41.9815L26.463 41.9815V34.2037H23.8704H21.2778V36.7963V39.3889H13.5L13.5 41.9815H16.0926H18.6852V44.5741H21.2778V47.1667H23.8704V49.7593H21.2778H18.6852V52.3519H13.5L13.5 49.7593H10.9074V52.3519H13.5L13.5 54.9444H16.0926V57.537H23.8704V54.9444L26.463 54.9444V52.3519V49.7593L29.0556 49.7593V52.3519V54.9444V57.537V60.1296H31.6482V62.7222L36.8333 62.7222V65.3148H39.4259H44.6111V67.9074H47.2037L52.3889 67.9074V65.3148H60.1667V62.7222L62.7593 62.7222V60.1296V57.537H65.3519V54.9444V52.3518L62.7593 52.3519V49.7593L62.7593 47.1667H65.3519V41.9815L62.7593 41.9815V44.5741V47.1667H60.1667V44.5741V41.9815V39.3889H57.5741H54.9815L54.9815 49.7593H52.3889V39.3889H49.7963H47.2037V41.9815V44.5741V47.1667H44.6111V52.3519H42.0185H39.4259H36.8333V49.7593H39.4259H42.0185L42.0185 47.1667V44.5741H44.6111V41.9815V39.3889V36.7963H42.0185V41.9815L42.0185 44.5741H39.4259V41.9815V36.7963H36.8333V44.5741L36.8333 49.7593H34.2408V47.1667H31.6482ZM31.6482 47.1667V49.7593H29.0556V47.1667H31.6482ZM36.8333 52.3519L36.8333 54.9444H34.2408V52.3519H36.8333ZM44.6111 52.3519H47.2037V54.9444H44.6111V52.3519ZM54.9815 54.9444V52.3519V49.7593H57.5741V52.3519H60.1667H62.7593L62.7593 54.9444H60.1667H57.5741H54.9815ZM54.9815 54.9444L54.9815 57.537H52.3889V54.9444L54.9815 54.9444ZM23.8704 47.1667L23.8704 41.9815H26.463V47.1667L23.8704 47.1667ZM73.1296 54.9444L70.537 54.9444V52.3518V41.9815H67.9445V52.3518V54.9444V57.537L67.9445 60.1296H65.3519V62.7222L67.9445 62.7222L78.3148 62.7222V60.1296H75.7222V57.537H73.1296V54.9444Z" fill="black"/>\r\n</svg>\r\n';

// src/services/ContextBuilder.ts
var import_obsidian6 = require("obsidian");
var ContextBuilder = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Build structured context from Obsidian vault based on settings
   */
  async buildContext(settings) {
    const context = {
      additionalFiles: []
    };
    let hasContext = false;
    if (settings.includeActiveFile) {
      const activeFile = this.app.workspace.getActiveFile();
      if (activeFile) {
        try {
          const content = await this.app.vault.read(activeFile);
          context.activeFile = {
            path: activeFile.path,
            name: activeFile.name,
            content
          };
          hasContext = true;
        } catch (error) {
          console.error("Error reading active file:", error);
        }
      }
    }
    if (settings.includeSelection) {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian6.MarkdownView);
      if (activeView == null ? void 0 : activeView.editor) {
        const selection = activeView.editor.getSelection();
        if (selection && selection.trim().length > 0) {
          context.selectedText = selection;
          hasContext = true;
        }
      }
    }
    if (settings.selectedFiles && settings.selectedFiles.length > 0) {
      for (const filePath of settings.selectedFiles) {
        try {
          const file = this.app.vault.getAbstractFileByPath(filePath);
          if (file instanceof import_obsidian6.TFile) {
            const content = await this.app.vault.read(file);
            context.additionalFiles.push({
              path: file.path,
              name: file.name,
              content
            });
            hasContext = true;
          }
        } catch (error) {
          console.error(`Error reading file ${filePath}:`, error);
        }
      }
    }
    return hasContext ? context : null;
  }
  /**
   * Format vault context as structured markdown
   */
  formatStructuredContext(context) {
    let formatted = "# Vault Context\n\n";
    if (context.activeFile) {
      formatted += `## Active File: ${context.activeFile.name}
`;
      formatted += `Path: \`${context.activeFile.path}\`

`;
      formatted += "```\n";
      formatted += context.activeFile.content;
      formatted += "\n```\n\n";
    }
    if (context.selectedText) {
      formatted += "## Selected Text\n\n";
      formatted += "```\n";
      formatted += context.selectedText;
      formatted += "\n```\n\n";
    }
    if (context.additionalFiles.length > 0) {
      formatted += "## Additional Files\n\n";
      for (const file of context.additionalFiles) {
        formatted += `### ${file.name}
`;
        formatted += `Path: \`${file.path}\`

`;
        formatted += "```\n";
        formatted += file.content;
        formatted += "\n```\n\n";
      }
    }
    return formatted;
  }
  /**
   * Truncate context to fit within token budget
   * Rough estimation: 1 token  4 characters
   */
  truncateToTokenLimit(contextString, maxTokens) {
    const maxChars = maxTokens * 4;
    if (contextString.length <= maxChars) {
      return contextString;
    }
    const truncated = contextString.substring(0, maxChars);
    const lastNewline = truncated.lastIndexOf("\n");
    const finalText = lastNewline > 0 ? truncated.substring(0, lastNewline) : truncated;
    return finalText + "\n\n[... Context truncated due to token limit ...]";
  }
  /**
   * Build and format context with token limit
   */
  async buildFormattedContext(settings, maxTokensForContext) {
    const context = await this.buildContext(settings);
    if (!context) {
      return null;
    }
    const formatted = this.formatStructuredContext(context);
    const truncated = this.truncateToTokenLimit(formatted, maxTokensForContext);
    return truncated;
  }
  /**
   * Calculate max tokens for context based on percentage
   */
  calculateContextTokenBudget(totalMaxTokens, contextPercent) {
    return Math.floor(totalMaxTokens * contextPercent / 100);
  }
};

// src/Plugin/Components/ChatContainer.ts
var ChatContainer = class {
  constructor(plugin, viewType, messageStore) {
    this.plugin = plugin;
    this.currentVaultContext = null;
    // Store context for current generation
    this.claudeCodeSessionId = null;
    this.viewType = viewType;
    this.messageStore = messageStore;
    this.messageStore.subscribe(this.updateMessages.bind(this));
    this.contextBuilder = new ContextBuilder(this.plugin.app);
  }
  updateMessages(message) {
    const currentIndex = this.plugin.settings.currentIndex;
    const fabIndex = this.plugin.settings.fabSettings.historyIndex;
    const widgetIndex = this.plugin.settings.widgetSettings.historyIndex;
    if (currentIndex > -1) {
      message = this.plugin.settings.promptHistory[currentIndex].messages;
    }
    if (this.viewType === this.plugin.settings.currentView) {
      this.resetChat();
      this.generateIMLikeMessages(message);
      return;
    }
    if (this.viewType === "floating-action-button" && fabIndex === currentIndex && currentIndex > -1) {
      this.resetChat();
      this.generateIMLikeMessages(message);
      return;
    }
    if (this.viewType === "widget" && widgetIndex === currentIndex && currentIndex > -1) {
      this.resetChat();
      this.generateIMLikeMessages(message);
      return;
    }
  }
  getMessages() {
    return this.messageStore.getMessages();
  }
  getParams(endpoint, model, modelType) {
    const settingType = getSettingType(this.viewType);
    const messagesForParams = this.getMessages();
    if (modelType === gemini) {
      const params = {
        // QUESTION -> Do we really want to send prompt when we are sending messages?
        prompt: this.prompt,
        // QUESTION -> how many messages do we really want to send?
        messages: messagesForParams,
        model,
        temperature: this.plugin.settings[settingType].chatSettings.temperature,
        tokens: this.plugin.settings[settingType].chatSettings.maxTokens,
        ...this.plugin.settings[settingType].chatSettings.gemini
      };
      return params;
    }
    if (modelType === assistant) {
      const params = {
        prompt: this.prompt,
        messages: messagesForParams,
        model
      };
      return params;
    }
    if (endpoint === "images") {
      const params = {
        prompt: this.prompt,
        messages: messagesForParams,
        model,
        ...this.plugin.settings[settingType].imageSettings
      };
      return params;
    }
    if (endpoint === chat) {
      if (modelType === GPT4All) {
        const params2 = {
          prompt: this.prompt,
          messages: messagesForParams,
          model,
          temperature: this.plugin.settings[settingType].chatSettings.temperature,
          tokens: this.plugin.settings[settingType].chatSettings.maxTokens,
          ...this.plugin.settings[settingType].chatSettings.GPT4All
        };
        return params2;
      }
      const params = {
        prompt: this.prompt,
        messages: messagesForParams,
        model,
        temperature: this.plugin.settings[settingType].chatSettings.temperature,
        tokens: this.plugin.settings[settingType].chatSettings.maxTokens,
        ...this.plugin.settings[settingType].chatSettings.openAI
      };
      return params;
    }
    if (endpoint === messages) {
      const params = {
        prompt: this.prompt,
        // The Claude API accepts the most recent user message
        // as well as an optional most recent assistant message.
        // This initial approach only sends the most recent user message.
        messages: messagesForParams.slice(-1),
        model,
        temperature: this.plugin.settings[settingType].chatSettings.temperature,
        tokens: this.plugin.settings[settingType].chatSettings.maxTokens
      };
      return params;
    }
  }
  async regenerateOutput() {
    const currentIndex = this.plugin.settings.currentIndex;
    if (currentIndex >= 0 && this.plugin.settings.promptHistory[currentIndex]) {
      const messages2 = this.plugin.settings.promptHistory[currentIndex].messages;
      this.messageStore.setMessages(messages2);
    }
    this.removeLastMessageAndHistoryMessage();
    this.handleGenerate();
  }
  async handleGenerate() {
    var _a5, _b, _c;
    this.previewText = "";
    const {
      model,
      endpointURL,
      modelEndpoint,
      modelType,
      assistantId,
      modelName
    } = getViewInfo(this.plugin, this.viewType);
    let shouldHaveAPIKey = modelType !== GPT4All && modelEndpoint !== claudeCodeEndpoint;
    const messagesForParams = this.getMessages();
    if (shouldHaveAPIKey) {
      const API_KEY = this.plugin.settings.openAIAPIKey || this.plugin.settings.claudeAPIKey || this.plugin.settings.geminiAPIKey;
      if (!API_KEY) {
        throw new Error("No API key");
      }
    }
    if (modelEndpoint === claudeCodeEndpoint) {
      if (!this.plugin.settings.claudeCodeOAuthToken) {
        throw new Error("No Claude Code OAuth token");
      }
    }
    const params = this.getParams(modelEndpoint, model, modelType);
    if (modelEndpoint === claudeCodeEndpoint) {
      this.setDiv(true);
      this.showThinkingAnimation();
      const vaultPath = this.plugin.app.vault.adapter.basePath;
      const path4 = require("path");
      const pluginDir = path4.join(vaultPath, this.plugin.manifest.dir);
      let stream;
      try {
        stream = await claudeCodeMessage(
          this.prompt,
          this.plugin.settings.claudeCodeOAuthToken,
          this.plugin.settings.linearWorkspaces,
          vaultPath,
          pluginDir,
          (_a5 = this.claudeCodeSessionId) != null ? _a5 : void 0
        );
      } catch (err) {
        throw err;
      }
      try {
        let firstText = true;
        for await (const message of stream) {
          if (!this.claudeCodeSessionId && message.session_id) {
            this.claudeCodeSessionId = message.session_id;
          }
          if (message.type === "assistant") {
            for (const block of message.message.content) {
              if (block.type === "text") {
                if (firstText) {
                  this.streamingDiv.empty();
                  firstText = false;
                }
                this.previewText += block.text;
                this.streamingDiv.textContent = this.previewText;
                this.historyMessages.scroll(0, 9999);
              }
            }
          }
        }
      } catch (err) {
        throw err;
      }
      this.streamingDiv.empty();
      import_obsidian7.MarkdownRenderer.render(
        this.plugin.app,
        this.previewText,
        this.streamingDiv,
        "",
        this.plugin
      );
      const copyButton = this.streamingDiv.querySelectorAll(
        ".copy-code-button"
      );
      copyButton.forEach((item) => {
        item.setAttribute("style", "display: none");
      });
      this.messageStore.addMessage({
        role: assistant,
        content: this.previewText
      });
      const message_context = {
        prompt: this.prompt,
        messages: this.getMessages(),
        model,
        temperature: 0,
        tokens: 0,
        modelName
      };
      this.historyPush(message_context, this.currentVaultContext);
      return true;
    }
    if (modelEndpoint === assistant) {
      const stream = await assistantsMessage(
        this.plugin.settings.openAIAPIKey,
        messagesForParams,
        assistantId
      );
      stream.on("textCreated", () => this.setDiv(true));
      stream.on("textDelta", (textDelta, snapshot) => {
        var _a6;
        if ((_a6 = textDelta.value) == null ? void 0 : _a6.includes("\u3010")) return;
        this.previewText += textDelta.value;
        this.streamingDiv.textContent = this.previewText;
        this.historyMessages.scroll(0, 9999);
      });
      return new Promise((resolve) => {
        stream.on("end", () => {
          this.streamingDiv.empty();
          import_obsidian7.MarkdownRenderer.render(
            this.plugin.app,
            this.previewText,
            this.streamingDiv,
            "",
            this.plugin
          );
          this.historyMessages.scroll(0, 9999);
          this.messageStore.addMessage({
            role: assistant,
            content: this.previewText
          });
          const message_context = {
            ...params,
            messages: this.getMessages(),
            assistant_id: assistantId,
            modelName
          };
          this.historyPush(message_context, this.currentVaultContext);
          resolve(true);
        });
      });
    }
    const isGeminiModel = [
      geminiModel,
      gemini2FlashModel,
      gemini2FlashThinkingModel,
      gemini2FlashStableModel,
      gemini2FlashLiteModel,
      gemini25ProModel,
      gemini25FlashModel,
      gemini25FlashLiteModel,
      gemini3ProPreviewModel,
      geminiFlashLatestModel,
      geminiFlashLiteLatestModel
    ].includes(model);
    if (isGeminiModel) {
      this.setDiv(true);
      this.showThinkingAnimation();
      const stream = await geminiMessage(
        params,
        this.plugin.settings.geminiAPIKey
      );
      try {
        let firstChunk = true;
        for await (const chunk of stream) {
          if (firstChunk) {
            this.streamingDiv.empty();
            firstChunk = false;
          }
          this.previewText += chunk.text || "";
          this.streamingDiv.textContent = this.previewText;
          this.historyMessages.scroll(0, 9999);
        }
      } catch (err) {
        console.error(err);
        return false;
      }
      this.streamingDiv.empty();
      import_obsidian7.MarkdownRenderer.render(
        this.plugin.app,
        this.previewText,
        this.streamingDiv,
        "",
        this.plugin
      );
      const copyButton = this.streamingDiv.querySelectorAll(
        ".copy-code-button"
      );
      copyButton.forEach((item) => {
        item.setAttribute("style", "display: none");
      });
      this.messageStore.addMessage({
        role: assistant,
        content: this.previewText
      });
      const message_context = {
        ...params,
        messages: this.getMessages()
      };
      this.historyPush(message_context, this.currentVaultContext);
      return true;
    }
    if (modelEndpoint === messages) {
      this.setDiv(true);
      this.showThinkingAnimation();
      const stream = await claudeMessage(
        params,
        this.plugin.settings.claudeAPIKey
      );
      let firstText = true;
      stream.on("text", (text) => {
        if (firstText) {
          this.streamingDiv.empty();
          firstText = false;
        }
        this.previewText += text || "";
        this.streamingDiv.textContent = this.previewText;
        this.historyMessages.scroll(0, 9999);
      });
      this.streamingDiv.empty();
      import_obsidian7.MarkdownRenderer.render(
        this.plugin.app,
        this.previewText,
        this.streamingDiv,
        "",
        this.plugin
      );
      const copyButton = this.streamingDiv.querySelectorAll(
        ".copy-code-button"
      );
      copyButton.forEach((item) => {
        item.setAttribute("style", "display: none");
      });
      this.messageStore.addMessage({
        role: assistant,
        content: this.previewText
      });
      const message_context = {
        ...params,
        messages: this.getMessages()
      };
      this.historyPush(message_context, this.currentVaultContext);
      return true;
    }
    if (modelType === GPT4All) {
      this.plugin.settings.GPT4AllStreaming = true;
      this.setDiv(false);
      messageGPT4AllServer(params, endpointURL).then(
        (response) => {
          this.streamingDiv.textContent = response.content;
          this.messageStore.addMessage(response);
          this.previewText = response.content;
          this.historyPush(params, this.currentVaultContext);
        }
      );
    } else if (modelEndpoint === chat) {
      const stream = await openAIMessage(
        params,
        this.plugin.settings.openAIAPIKey,
        endpointURL,
        modelEndpoint
      );
      this.setDiv(true);
      for await (const chunk of stream) {
        this.previewText += ((_c = (_b = chunk.choices[0]) == null ? void 0 : _b.delta) == null ? void 0 : _c.content) || "";
        this.streamingDiv.textContent = this.previewText;
        this.historyMessages.scroll(0, 9999);
      }
      this.streamingDiv.empty();
      import_obsidian7.MarkdownRenderer.render(
        this.plugin.app,
        this.previewText,
        this.streamingDiv,
        "",
        this.plugin
      );
      const copyButton = this.streamingDiv.querySelectorAll(
        ".copy-code-button"
      );
      copyButton.forEach((item) => {
        item.setAttribute("style", "display: none");
      });
      this.messageStore.addMessage({
        role: assistant,
        content: this.previewText
      });
      const message_context = {
        ...params,
        messages: this.messageStore.getMessages()
      };
      this.historyPush(message_context, this.currentVaultContext);
      return true;
    }
    return true;
  }
  async handleGenerateClick(header, sendButton) {
    header.disableButtons();
    sendButton.setDisabled(true);
    const {
      model,
      modelName,
      modelType,
      endpointURL,
      modelEndpoint,
      historyIndex
    } = getViewInfo(this.plugin, this.viewType);
    if (historyIndex > -1) {
      const messages2 = this.plugin.settings.promptHistory[historyIndex].messages;
      this.messageStore.setMessages(messages2);
    }
    const refreshButton = this.historyMessages.querySelector(
      ".llm-refresh-output"
    );
    refreshButton == null ? void 0 : refreshButton.remove();
    if (this.historyMessages.children.length < 1) {
      header.setHeader(modelName, this.prompt);
    }
    const settingType = getSettingType(this.viewType);
    const contextSettings = this.plugin.settings[settingType].contextSettings;
    const maxTokens = this.plugin.settings[settingType].chatSettings.maxTokens;
    const contextTokenBudget = this.contextBuilder.calculateContextTokenBudget(
      maxTokens,
      contextSettings.maxContextTokensPercent
    );
    let vaultContext = null;
    let contextString = null;
    if (modelEndpoint !== "images" && this.plugin.settings.enableFileContext) {
      try {
        contextString = await this.contextBuilder.buildFormattedContext(
          contextSettings,
          contextTokenBudget
        );
        if (contextString) {
          vaultContext = await this.contextBuilder.buildContext(contextSettings);
          this.currentVaultContext = vaultContext;
          const contextMessage = {
            role: "user",
            content: contextString
          };
          this.messageStore.addMessage(contextMessage);
        }
      } catch (error) {
        console.error("Error building vault context:", error);
      }
    }
    const userMessage = { role: "user", content: this.prompt };
    this.messageStore.addMessage(userMessage);
    if (this.viewType !== this.plugin.settings.currentView) {
      this.appendNewMessage(userMessage);
    }
    const params = this.getParams(modelEndpoint, model, modelType);
    try {
      this.previewText = "";
      if (modelEndpoint !== "images") {
        await this.handleGenerate();
        this.currentVaultContext = null;
      }
      if (modelEndpoint === "images") {
        this.setDiv(false);
        await openAIMessage(
          params,
          this.plugin.settings.openAIAPIKey,
          endpointURL,
          modelEndpoint
        ).then((response) => {
          this.streamingDiv.empty();
          let content = "";
          response.map((url) => {
            content += `![created with prompt ${this.prompt}](${url})`;
          });
          this.messageStore.addMessage({
            role: assistant,
            content
          });
          this.appendImage(response);
          this.historyPush(
            {
              ...params,
              messages: this.getMessages()
            },
            this.currentVaultContext
          );
        });
      }
      header.enableButtons();
      sendButton.setDisabled(false);
      const buttonsContainer = this.loadingDivContainer.querySelector(
        ".llm-assistant-buttons"
      );
      buttonsContainer == null ? void 0 : buttonsContainer.removeClass("llm-hide");
    } catch (error) {
      header.enableButtons();
      sendButton.setDisabled(false);
      this.plugin.settings.GPT4AllStreaming = false;
      this.prompt = "";
      errorMessages(error, params);
      if (this.getMessages().length > 0) {
        setTimeout(() => {
          this.removeMessage(header, modelName);
        }, 1e3);
      }
    }
  }
  historyPush(params, vaultContext) {
    const { modelName, historyIndex, modelEndpoint, assistantId } = getViewInfo(this.plugin, this.viewType);
    if (historyIndex > -1) {
      this.plugin.history.overwriteHistory(
        this.getMessages(),
        historyIndex
      );
      return;
    }
    if (modelEndpoint === chat || modelEndpoint === gemini || modelEndpoint === messages || modelEndpoint === claudeCodeEndpoint) {
      const chatParams = params;
      if (vaultContext) {
        chatParams.vaultContext = vaultContext;
      }
      this.plugin.history.push({
        ...chatParams,
        modelName
      });
    }
    if (modelEndpoint === "images") {
      this.plugin.history.push({
        ...params,
        modelName
      });
    }
    if (modelEndpoint === assistant) {
      this.plugin.history.push({
        ...params,
        modelName,
        assistant_id: assistantId
      });
    }
    const length = this.plugin.settings.promptHistory.length;
    setHistoryIndex(this.plugin, this.viewType, length);
    this.plugin.saveSettings();
    this.prompt = "";
  }
  auto_height(elem, parentElement) {
    elem.inputEl.setAttribute("style", "height: 50px");
    const height = elem.inputEl.scrollHeight - 5;
    if (!(height > parseInt(window.getComputedStyle(elem.inputEl).height)))
      return;
    elem.inputEl.setAttribute("style", `height: ${height}px`);
    elem.inputEl.setAttribute("style", `overflow: hidden`);
    parentElement.scrollTo(0, 9999);
  }
  displayNoChatView(parentElement) {
    parentElement.addClass("llm-justify-content-center");
    parentElement.addClass("center-llmgal");
    const llmGal = parentElement.createDiv();
    llmGal.addClass("llm-icon-wrapper");
    llmGal.addClass("llm-icon-new-chat");
    const parser = new DOMParser();
    const svgDoc = parser.parseFromString(LLMgal_default, "image/svg+xml");
    const svgElement = svgDoc.documentElement;
    llmGal.appendChild(svgElement);
  }
  async generateChatContainer(parentElement, header) {
    this.messageStore.setMessages([]);
    this.historyMessages = parentElement.createDiv();
    this.historyMessages.className = classNames[this.viewType]["messages-div"];
    if (this.getMessages().length === 0) {
      this.displayNoChatView(this.historyMessages);
    }
    const promptContainer = parentElement.createDiv();
    const promptField = new import_obsidian7.TextAreaComponent(promptContainer);
    const sendButton = new import_obsidian7.ButtonComponent(promptContainer);
    if (this.viewType === "floating-action-button") {
      promptContainer.addClass("llm-flex");
    }
    promptContainer.addClass(classNames[this.viewType]["prompt-container"]);
    promptField.inputEl.className = classNames[this.viewType]["text-area"];
    promptField.inputEl.id = "chat-prompt-text-area";
    promptField.inputEl.tabIndex = 0;
    promptContainer.addEventListener("input", () => {
      this.auto_height(promptField, parentElement);
    });
    sendButton.buttonEl.addClass(
      classNames[this.viewType].button,
      "llm-send-button"
    );
    sendButton.setIcon("up-arrow-with-tail");
    sendButton.setTooltip("Send prompt");
    promptField.setPlaceholder("Send a message...");
    promptField.onChange((change) => {
      this.prompt = change;
      promptField.setValue(change);
    });
    promptField.inputEl.addEventListener("keydown", (event) => {
      if (sendButton.disabled === true) return;
      if (event.code == "Enter") {
        event.preventDefault();
        this.handleGenerateClick(header, sendButton);
        promptField.inputEl.setText("");
        promptField.setValue("");
      }
    });
    sendButton.onClick(() => {
      this.handleGenerateClick(header, sendButton);
      promptField.inputEl.setText("");
      promptField.setValue("");
    });
    setTimeout(() => {
      promptField.inputEl.focus();
    }, 100);
  }
  setMessages(replaceChatHistory = false) {
    const { historyIndex } = getViewInfo(this.plugin, this.viewType);
    if (replaceChatHistory) {
      let history = this.plugin.settings.promptHistory;
      this.messageStore.setMessages(history[historyIndex].messages);
    }
    if (!replaceChatHistory) {
      this.messageStore.addMessage({
        role: "user",
        content: this.prompt
      });
    }
  }
  resetMessages() {
    this.messageStore.setMessages([]);
    this.claudeCodeSessionId = null;
  }
  setDiv(streaming) {
    const parent = this.historyMessages.createDiv();
    parent.addClass("llm-flex");
    const assistant2 = parent.createEl("div", { cls: "llm-assistant-logo" });
    assistant2.appendChild(assistantLogo());
    this.loadingDivContainer = parent.createDiv();
    this.streamingDiv = this.loadingDivContainer.createDiv();
    const buttonsContainer = this.loadingDivContainer.createEl("div", {
      cls: "llm-assistant-buttons llm-hide"
    });
    const copyToClipboardButton = new import_obsidian7.ButtonComponent(buttonsContainer);
    copyToClipboardButton.setIcon("files");
    const refreshButton = new import_obsidian7.ButtonComponent(buttonsContainer);
    refreshButton.setIcon("refresh-cw");
    copyToClipboardButton.buttonEl.addClass("llm-add-text");
    refreshButton.buttonEl.addClass("llm-refresh-output");
    if (streaming) {
      this.streamingDiv.empty();
    } else {
      const dots = this.streamingDiv.createEl("span");
      for (let i3 = 0; i3 < 3; i3++) {
        const dot = dots.createEl("span", { cls: "streaming-dot" });
        dot.textContent = ".";
      }
    }
    this.streamingDiv.addClass("im-like-message");
    this.loadingDivContainer.addClass(
      "llm-flex-end",
      "im-like-message-container",
      "llm-flex"
    );
    copyToClipboardButton.onClick(async () => {
      await navigator.clipboard.writeText(this.previewText);
      new import_obsidian7.Notice("Text copied to clipboard");
    });
    refreshButton.onClick(async () => {
      new import_obsidian7.Notice("Regenerating response...");
      this.regenerateOutput();
    });
  }
  showThinkingAnimation() {
    this.streamingDiv.empty();
    const thinkingContainer = this.streamingDiv.createEl("div", {
      cls: "llm-thinking-animation"
    });
    thinkingContainer.createEl("span", {
      cls: "llm-thinking-text",
      text: "Thinking"
    });
    const dots = thinkingContainer.createEl("span", { cls: "llm-thinking-dots" });
    for (let i3 = 0; i3 < 3; i3++) {
      const dot = dots.createEl("span", { cls: "streaming-dot" });
      dot.textContent = ".";
    }
  }
  appendImage(imageURLs) {
    imageURLs.map((url) => {
      const img = this.streamingDiv.createEl("img");
      img.src = url;
      img.alt = `image generated with ${this.prompt}`;
    });
  }
  createMessage(content, index, finalMessage, assistant2 = false) {
    const imLikeMessageContainer = this.historyMessages.createDiv();
    const imLikeMessage = imLikeMessageContainer.createDiv();
    const copyToClipboardButton = new import_obsidian7.ButtonComponent(
      imLikeMessageContainer
    );
    copyToClipboardButton.setIcon("files");
    if (assistant2) {
      const parent = imLikeMessage.createDiv();
      parent.addClass("llm-flex-reverse");
      const assistantMessage = parent.createDiv();
      assistantMessage.addClass("llm-flex-column");
      imLikeMessage.addClass("llm-flex");
      const assistant3 = parent.createEl("div", {
        cls: "llm-assistant-logo"
      });
      assistant3.appendChild(assistantLogo());
      import_obsidian7.MarkdownRenderer.render(
        this.plugin.app,
        content,
        assistantMessage,
        "",
        this.plugin
      );
    } else {
      import_obsidian7.MarkdownRenderer.render(
        this.plugin.app,
        content,
        imLikeMessage,
        "",
        this.plugin
      );
    }
    const copyButton = imLikeMessage.querySelectorAll(
      ".copy-code-button"
    );
    copyButton.forEach((item) => {
      item.setAttribute("style", "display: none");
    });
    imLikeMessageContainer.addClass(
      "im-like-message-container",
      "llm-flex"
    );
    copyToClipboardButton.buttonEl.addClass(
      "add-text",
      "llm-hide",
      "mt-auto"
    );
    imLikeMessage.addClass(
      "im-like-message",
      classNames[this.viewType]["chat-message"]
    );
    if (index % 2 === 0) {
      imLikeMessageContainer.addClass("llm-flex-start", "llm-flex");
    } else {
      imLikeMessageContainer.addClass("llm-flex-end", "llm-flex");
    }
    imLikeMessageContainer.addEventListener("mouseenter", () => {
      copyToClipboardButton.buttonEl.removeClass("llm-hide");
    });
    imLikeMessageContainer.addEventListener("mouseleave", () => {
      copyToClipboardButton.buttonEl.addClass("llm-hide");
    });
    copyToClipboardButton.setTooltip("Copy to clipboard");
    copyToClipboardButton.onClick(async () => {
      await navigator.clipboard.writeText(content);
      new import_obsidian7.Notice("Text copied to clipboard");
    });
    if (finalMessage) {
      const refreshButton = new import_obsidian7.ButtonComponent(imLikeMessageContainer);
      refreshButton.setIcon("refresh-cw");
      refreshButton.buttonEl.addClass("llm-refresh-output", "llm-hide");
      imLikeMessageContainer.addEventListener("mouseenter", () => {
        refreshButton.buttonEl.removeClass("llm-hide");
      });
      imLikeMessageContainer.addEventListener("mouseleave", () => {
        refreshButton.buttonEl.addClass("llm-hide");
      });
      refreshButton.onClick(async () => {
        new import_obsidian7.Notice("Regenerating response...");
        this.regenerateOutput();
      });
    }
  }
  generateIMLikeMessages(messages2) {
    let finalMessage = false;
    messages2.map(({ role, content }, index) => {
      if (index === messages2.length - 1) finalMessage = true;
      if (role === "assistant") {
        this.createMessage(content, index, finalMessage, true);
        return;
      }
      this.createMessage(content, index, finalMessage);
    });
    this.historyMessages.scroll(0, 9999);
  }
  appendNewMessage(message) {
    const length = this.historyMessages.childNodes.length;
    const { content } = message;
    this.createMessage(content, length, false);
  }
  removeLastMessageAndHistoryMessage() {
    var _a5;
    const messages2 = this.messageStore.getMessages();
    messages2.pop();
    this.messageStore.setMessages(messages2);
    (_a5 = this.historyMessages.lastElementChild) == null ? void 0 : _a5.remove();
    if (this.plugin.settings.currentIndex >= 0) {
      this.plugin.history.update(this.plugin.settings.currentIndex, messages2);
    }
  }
  removeMessage(header, modelName) {
    this.removeLastMessageAndHistoryMessage();
    if (this.historyMessages.children.length < 1) {
      header.setHeader(modelName, "LLM plugin");
    }
  }
  resetChat() {
    this.historyMessages.empty();
    this.historyMessages.removeClass("center-llmgal");
  }
  newChat() {
    this.historyMessages.empty();
    this.claudeCodeSessionId = null;
    this.displayNoChatView(this.historyMessages);
  }
};

// src/Plugin/Components/Header.ts
var import_obsidian8 = require("obsidian");
var Header = class {
  constructor(plugin, viewType) {
    this.plugin = plugin;
    this.viewType = viewType;
  }
  setHeader(modelName, title) {
    if (title) {
      this.titleEl.textContent = title;
    }
    this.modelEl.textContent = modelName;
  }
  resetHistoryButton() {
    this.chatHistoryButton.buttonEl.removeClass("is-active");
  }
  clickHandler(button, toggles) {
    if (button.buttonEl.classList.contains("is-active")) {
      button.buttonEl.removeClass("is-active");
    } else {
      if (!button.buttonEl.classList.contains("new-chat-button")) {
        button.buttonEl.addClass("is-active");
      }
      toggles.map((el) => {
        el.buttonEl.removeClass("is-active");
      });
    }
  }
  disableButtons() {
    this.chatHistoryButton.setDisabled(true);
    this.newChatButton.setDisabled(true);
    this.settingsButton.setDisabled(true);
    this.assistantsButton.setDisabled(true);
  }
  enableButtons() {
    this.chatHistoryButton.setDisabled(false);
    this.newChatButton.setDisabled(false);
    this.settingsButton.setDisabled(false);
    this.assistantsButton.setDisabled(false);
  }
  generateHeader(parentElement, chatContainerDiv, chatHistoryContainerDiv, settingsContainerDiv, assistantContainerDiv, chatContainer, historyContainer, settingsContainer, assistantsContainer) {
    const { modelName } = getViewInfo(this.plugin, this.viewType);
    const titleDiv = createDiv();
    const leftButtonDiv = titleDiv.createDiv();
    const titleContainer = titleDiv.createDiv();
    this.titleEl = titleContainer.createDiv();
    this.titleEl.addClass(`${this.viewType}-llm-title`);
    const rightButtonsDiv = titleDiv.createDiv();
    titleDiv.addClass("llm-title-div", "llm-flex");
    this.titleEl.textContent = "LLM";
    this.modelEl = titleContainer.createDiv();
    this.modelEl.addClass("llm-model-name");
    this.modelEl.textContent = modelName;
    this.chatHistoryButton = new import_obsidian8.ButtonComponent(leftButtonDiv);
    this.chatHistoryButton.setTooltip("Chats");
    this.chatHistoryButton.onClick(() => {
      historyContainer.resetHistory(chatHistoryContainerDiv);
      historyContainer.generateHistoryContainer(
        chatHistoryContainerDiv,
        this.plugin.settings.promptHistory,
        chatContainerDiv,
        chatContainer,
        this
      );
      this.clickHandler(this.chatHistoryButton, [
        this.settingsButton,
        this.assistantsButton
      ]);
      if (!chatHistoryContainerDiv.isShown()) {
        chatHistoryContainerDiv.show();
        settingsContainerDiv.hide();
        chatContainerDiv.hide();
        assistantContainerDiv.hide();
      } else {
        chatContainerDiv.show();
        chatHistoryContainerDiv.hide();
      }
    });
    this.assistantsButton = new import_obsidian8.ButtonComponent(rightButtonsDiv);
    this.assistantsButton.setTooltip("Assistants");
    assistantsContainer.generateAssistantsContainer(assistantContainerDiv);
    this.assistantsButton.onClick(() => {
      this.clickHandler(this.assistantsButton, [
        this.settingsButton,
        this.chatHistoryButton
      ]);
      if (!assistantContainerDiv.isShown()) {
        assistantContainerDiv.show();
        settingsContainerDiv.hide();
        chatContainerDiv.hide();
        chatHistoryContainerDiv.hide();
      } else {
        chatContainerDiv.show();
        assistantContainerDiv.hide();
      }
    });
    if (this.viewType === "floating-action-button") {
      this.newChatButton = new import_obsidian8.ButtonComponent(leftButtonDiv);
      this.settingsButton = new import_obsidian8.ButtonComponent(rightButtonsDiv);
    } else {
      this.newChatButton = new import_obsidian8.ButtonComponent(rightButtonsDiv);
      this.settingsButton = new import_obsidian8.ButtonComponent(leftButtonDiv);
    }
    this.settingsButton.setTooltip("Chat settings");
    this.settingsButton.onClick(() => {
      settingsContainer.resetSettings(settingsContainerDiv);
      settingsContainer.generateSettingsContainer(
        settingsContainerDiv,
        this
      );
      this.clickHandler(this.settingsButton, [
        this.chatHistoryButton,
        this.assistantsButton
      ]);
      if (!settingsContainerDiv.isShown()) {
        settingsContainerDiv.show();
        chatContainerDiv.hide();
        chatHistoryContainerDiv.hide();
        assistantContainerDiv.hide();
      } else {
        chatContainerDiv.show();
        settingsContainerDiv.hide();
      }
    });
    this.newChatButton.setTooltip("New chat");
    this.newChatButton.onClick(() => {
      const { modelName: modelName2 } = getViewInfo(this.plugin, this.viewType);
      this.clickHandler(this.newChatButton, [
        this.settingsButton,
        this.chatHistoryButton,
        this.assistantsButton
      ]);
      this.setHeader(modelName2, "New chat");
      chatContainerDiv.show();
      settingsContainerDiv.hide();
      chatHistoryContainerDiv.hide();
      assistantContainerDiv.hide();
      chatContainer.newChat();
      chatContainer.resetMessages();
      setHistoryIndex(this.plugin, this.viewType);
    });
    leftButtonDiv.addClass("llm-left-buttons-div", "llm-flex");
    rightButtonsDiv.addClass("llm-right-buttons-div", "llm-flex");
    titleContainer.addClass("llm-title", "llm-flex");
    this.chatHistoryButton.buttonEl.addClass(
      "clickable-icon",
      "chat-history"
    );
    this.settingsButton.buttonEl.addClass(
      "clickable-icon",
      "settings-button"
    );
    this.newChatButton.buttonEl.addClass(
      "clickable-icon",
      "new-chat-button"
    );
    this.assistantsButton.buttonEl.addClass("clickable-icon", "assistants");
    this.chatHistoryButton.setIcon("menu");
    this.settingsButton.setIcon("sliders-horizontal");
    this.newChatButton.setIcon("plus");
    this.assistantsButton.setIcon("bot");
    parentElement.prepend(titleDiv);
  }
};

// src/Plugin/Components/HistoryContainer.ts
var import_obsidian9 = require("obsidian");
var HistoryContainer = class {
  constructor(plugin, viewType) {
    this.plugin = plugin;
    this.viewType = viewType;
  }
  getChatContainerClassPrefix() {
    if (this.viewType === "floating-action-button") {
      return "fab";
    } else if (this.viewType === "widget") {
      return this.viewType;
    } else if (this.viewType === "modal") {
      return this.viewType;
    }
  }
  displayNoHistoryView(parentElement) {
    parentElement.addClass("llm-justify-content-center");
    const llmGal = parentElement.createDiv();
    llmGal.addClass("llm-icon-wrapper");
    llmGal.addClass("llm-icon-new-history");
    const parser = new DOMParser();
    const svgDoc = parser.parseFromString(LLMgal_default, "image/svg+xml");
    const svgElement = svgDoc.documentElement;
    llmGal.appendChild(svgElement);
    const cta = llmGal.createEl("div", {
      attr: {
        class: "empty-history-cta llm-font-size-medium llm-justify-content-center"
      },
      text: "Looking kind of empty. Start chatting and conversations will appear here."
    });
    cta.addClass("text-align-center");
    const createChatButton = new import_obsidian9.ButtonComponent(cta);
    createChatButton.setButtonText("New chat");
    createChatButton.setClass("llm-empty-history-button");
    createChatButton.setClass("mod-cta");
    createChatButton.onClick(() => {
      parentElement.hide();
      const activeHistoryButton = document.querySelector(
        ".chat-history.is-active"
      );
      activeHistoryButton == null ? void 0 : activeHistoryButton.classList.remove("is-active");
      const prefix = this.getChatContainerClassPrefix();
      const chatContainer = document.querySelector(
        `[class*="${prefix}-chat-container"]`
      );
      chatContainer.show();
      parentElement.classList.remove("llm-justify-content-center");
    });
  }
  generateHistoryContainer(parentElement, history, containerToShow, chat2, Header2) {
    if (!history.length) {
      this.displayNoHistoryView(parentElement);
      return;
    }
    const settingType = getSettingType(this.viewType);
    this.model = this.plugin.settings[settingType].model;
    this.modelName = this.plugin.settings[settingType].modelName;
    this.modelType = this.plugin.settings[settingType].modelType;
    this.modelType = this.plugin.settings[settingType].modelType;
    this.historyIndex = this.plugin.settings[settingType].historyIndex;
    const eventListener = () => {
      var _a5;
      chat2.resetChat();
      parentElement.hide();
      containerToShow.show();
      chat2.setMessages(true);
      const messages2 = chat2.getMessages();
      chat2.generateIMLikeMessages(messages2);
      (_a5 = containerToShow.querySelector(".messages-div")) == null ? void 0 : _a5.scroll(0, 9999);
      const index = this.historyIndex;
      this.plugin.settings.currentIndex = index;
      const header = this.plugin.settings.promptHistory[index].prompt;
      const modelName = this.plugin.settings.promptHistory[index].modelName;
      const model = this.plugin.settings.promptHistory[index].model;
      this.plugin.settings[settingType].modelName = modelName;
      if (!model.includes("asst")) {
        this.plugin.settings[settingType].model = models[modelName].model;
        this.plugin.settings[settingType].modelType = models[modelName].type;
        this.plugin.settings[settingType].modelEndpoint = models[modelName].endpoint;
        this.plugin.settings[settingType].endpointURL = models[modelName].url;
      } else {
        this.plugin.settings[settingType].model = this.plugin.settings.promptHistory[index].model;
        this.plugin.settings[settingType].modelName = this.plugin.settings.promptHistory[index].modelName;
        this.plugin.settings[settingType].modelType = assistant;
        this.plugin.settings[settingType].modelEndpoint = assistant;
        this.plugin.settings[settingType].endpointURL = "";
      }
      this.plugin.saveSettings();
      Header2.setHeader(modelName, header);
      Header2.resetHistoryButton();
    };
    eventListener.bind(this);
    const disableHistory = (collection, index, enabled) => {
      var _a5, _b;
      for (let i3 = 0; i3 < collection.length; i3++) {
        if (i3 !== index && !enabled) {
          (_a5 = collection.item(i3)) == null ? void 0 : _a5.addClass("llm-no-pointer");
        } else {
          (_b = collection.item(i3)) == null ? void 0 : _b.removeClass("llm-no-pointer");
        }
      }
    };
    const toggleContentEditable = (element, toggle) => {
      element.setAttr("contenteditable", toggle);
    };
    history.map((historyItem, index) => {
      var _a5;
      const item = parentElement.createDiv();
      const text = item.createEl("p");
      const displayHTML = (historyItem == null ? void 0 : historyItem.prompt) || ((_a5 = historyItem == null ? void 0 : historyItem.messages[0]) == null ? void 0 : _a5.content);
      text.textContent = displayHTML;
      const buttonsDiv = item.createDiv();
      buttonsDiv.addClass("history-buttons-div", "llm-flex");
      const editPrompt = new import_obsidian9.ButtonComponent(buttonsDiv);
      const savePrompt = new import_obsidian9.ButtonComponent(buttonsDiv);
      const deleteHistory = new import_obsidian9.ButtonComponent(buttonsDiv);
      savePrompt.buttonEl.setAttr(
        "style",
        "display: none; visibility: hidden"
      );
      editPrompt.buttonEl.setAttr("style", "visibility: hidden");
      deleteHistory.buttonEl.setAttr("style", "visibility: hidden");
      item.className = "setting-item";
      item.setAttr("contenteditable", "false");
      item.addClass("llm-history-item", "llm-flex");
      editPrompt.buttonEl.addClass("edit-prompt-button");
      savePrompt.buttonEl.addClass("save-prompt-button");
      editPrompt.setIcon("pencil");
      savePrompt.setIcon("save");
      deleteHistory.buttonEl.addClass(
        "llm-delete-history-button",
        "mod-warning"
      );
      deleteHistory.buttonEl.id = "llm-delete-history-button";
      item.addEventListener("click", () => {
        this.plugin.settings[settingType].historyIndex = index;
        this.historyIndex = index;
        this.plugin.saveSettings();
      });
      item.addEventListener("mouseenter", () => {
        if (text.contentEditable == "false" || text.contentEditable == "inherit") {
          editPrompt.buttonEl.setAttr("style", "visibility: visible");
          deleteHistory.buttonEl.setAttr(
            "style",
            "visibility: visible"
          );
        }
      });
      item.addEventListener("mouseleave", () => {
        if (text.contentEditable == "false" || text.contentEditable == "inherit") {
          editPrompt.buttonEl.setAttr("style", "visibility: hidden");
          deleteHistory.buttonEl.setAttr(
            "style",
            "visibility: hidden"
          );
        }
      });
      item.addEventListener("click", eventListener);
      deleteHistory.setIcon("trash");
      deleteHistory.onClick((e3) => {
        e3.stopPropagation();
        this.resetHistory(parentElement);
        let updatedHistory = this.plugin.settings.promptHistory.filter(
          (item2, idx) => idx !== index
        );
        this.plugin.settings.promptHistory = updatedHistory;
        this.plugin.saveSettings();
        this.generateHistoryContainer(
          parentElement,
          this.plugin.settings.promptHistory,
          containerToShow,
          chat2,
          Header2
        );
        chat2.resetChat();
        chat2.resetMessages();
        Header2.setHeader(this.modelName, "Local LLM plugin");
        this.plugin.settings[settingType].historyIndex = DEFAULT_SETTINGS[settingType].historyIndex;
        this.plugin.saveSettings();
      });
      editPrompt.onClick((e3) => {
        e3.stopPropagation();
        item.removeEventListener("click", eventListener);
        toggleContentEditable(text, true);
        text.focus();
        editPrompt.buttonEl.setAttr("style", "display: none");
        savePrompt.buttonEl.setAttr("style", "display: inline-flex");
        disableHistory(parentElement.children, index, false);
      });
      savePrompt.onClick((e3) => {
        e3.stopPropagation();
        if (item.textContent) {
          this.plugin.settings.promptHistory[index].prompt = item.textContent;
          this.plugin.saveSettings();
        } else {
          new import_obsidian9.Notice("Prompt length must be greater than 0");
          return;
        }
        item.addEventListener("click", eventListener);
        toggleContentEditable(text, false);
        editPrompt.buttonEl.setAttr("style", "display: inline-flex");
        savePrompt.buttonEl.setAttr("style", "display: none");
        disableHistory(parentElement.children, index, true);
      });
    });
  }
  resetHistory(parentContainer) {
    parentContainer.empty();
  }
};

// src/Plugin/Components/SettingsContainer.ts
var import_obsidian11 = require("obsidian");

// src/Plugin/Components/FileSelector.ts
var import_obsidian10 = require("obsidian");
var FileSelector = class extends import_obsidian10.Modal {
  constructor(app, plugin, viewType, currentSelection, onFilesSelected) {
    super(app);
    this.searchQuery = "";
    this.plugin = plugin;
    this.viewType = viewType;
    this.selectedFiles = new Set(currentSelection);
    this.onFilesSelected = onFilesSelected;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Select Files for Context" });
    new import_obsidian10.Setting(contentEl).setName("Search files").setDesc("Filter files by name or path").addText((text) => {
      text.setPlaceholder("Search...");
      text.onChange((value) => {
        this.searchQuery = value.toLowerCase();
        this.renderFileList();
      });
    });
    const fileListContainer = contentEl.createDiv({
      cls: "llm-file-selector-list"
    });
    fileListContainer.style.maxHeight = "400px";
    fileListContainer.style.overflowY = "auto";
    fileListContainer.style.marginTop = "1em";
    fileListContainer.style.marginBottom = "1em";
    this.renderFileList(fileListContainer);
    const buttonContainer = contentEl.createDiv({
      cls: "llm-file-selector-buttons"
    });
    buttonContainer.style.display = "flex";
    buttonContainer.style.justifyContent = "flex-end";
    buttonContainer.style.gap = "0.5em";
    buttonContainer.style.marginTop = "1em";
    const cancelButton = buttonContainer.createEl("button", {
      text: "Cancel"
    });
    cancelButton.addEventListener("click", () => {
      this.close();
    });
    const confirmButton = buttonContainer.createEl("button", {
      text: "Confirm",
      cls: "mod-cta"
    });
    confirmButton.addEventListener("click", () => {
      this.onFilesSelected(Array.from(this.selectedFiles));
      this.close();
    });
  }
  renderFileList(container) {
    const fileListContainer = container || this.contentEl.querySelector(
      ".llm-file-selector-list"
    );
    if (!fileListContainer) return;
    fileListContainer.empty();
    const allFiles = this.app.vault.getFiles();
    const filteredFiles = allFiles.filter((file) => {
      const searchLower = this.searchQuery.toLowerCase();
      return file.name.toLowerCase().includes(searchLower) || file.path.toLowerCase().includes(searchLower);
    });
    filteredFiles.sort((a, b3) => a.path.localeCompare(b3.path));
    if (filteredFiles.length === 0) {
      fileListContainer.createEl("p", {
        text: "No files found",
        cls: "llm-text-muted"
      });
      return;
    }
    for (const file of filteredFiles) {
      const fileItem = fileListContainer.createDiv({
        cls: "llm-file-selector-item"
      });
      fileItem.style.display = "flex";
      fileItem.style.alignItems = "center";
      fileItem.style.padding = "0.5em";
      fileItem.style.borderBottom = "1px solid var(--background-modifier-border)";
      const checkbox = fileItem.createEl("input", {
        type: "checkbox"
      });
      checkbox.checked = this.selectedFiles.has(file.path);
      checkbox.style.marginRight = "0.5em";
      checkbox.addEventListener("change", () => {
        if (checkbox.checked) {
          this.selectedFiles.add(file.path);
        } else {
          this.selectedFiles.delete(file.path);
        }
      });
      const fileInfo = fileItem.createDiv();
      fileInfo.style.flex = "1";
      const fileName = fileInfo.createEl("div", {
        text: file.name
      });
      fileName.style.fontWeight = "500";
      const filePath = fileInfo.createEl("div", {
        text: file.path,
        cls: "llm-text-muted"
      });
      filePath.style.fontSize = "0.9em";
    }
    const countDiv = fileListContainer.createDiv({
      cls: "llm-file-selector-count"
    });
    countDiv.style.marginTop = "1em";
    countDiv.style.textAlign = "center";
    countDiv.style.fontWeight = "500";
    countDiv.setText(`Selected: ${this.selectedFiles.size} file(s)`);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/Plugin/Components/SettingsContainer.ts
var SettingsContainer = class {
  constructor(plugin, viewType) {
    this.plugin = plugin;
    this.viewType = viewType;
  }
  async generateSettingsContainer(parentContainer, Header2) {
    this.resetSettings(parentContainer);
    this.generateModels(parentContainer, Header2);
    this.generateModelSettings(parentContainer);
  }
  generateModels(parentContainer, Header2) {
    const settingType = getSettingType(this.viewType);
    const viewSettings = this.plugin.settings[settingType];
    new import_obsidian11.Setting(parentContainer).setName("Models").setDesc("The model you want to use to generate a chat response.").addDropdown((dropdown) => {
      dropdown.addOption("", "---Select assistant---");
      const assistants = this.plugin.settings.assistants;
      assistants.map((assistant2) => {
        dropdown.addOption(`${assistant2.id}`, `${assistant2.name}`);
      });
      dropdown.addOption("", "---Select model---");
      let keys = Object.keys(models);
      for (let model of keys) {
        if (models[model].type === GPT4All) {
          const gpt4AllPath = getGpt4AllPath(this.plugin);
          const fullPath = `${gpt4AllPath}/${models[model].model}`;
          const exists = this.plugin.fileSystem.existsSync(fullPath);
          if (exists) {
            dropdown.addOption(models[model].model, model);
          }
        } else {
          dropdown.addOption(models[model].model, model);
        }
      }
      dropdown.onChange((change) => {
        const { historyIndex } = getViewInfo(
          this.plugin,
          this.viewType
        );
        const index = historyIndex;
        if (change.includes("asst")) {
          viewSettings.assistant = true;
          this.plugin.saveSettings();
        } else {
          viewSettings.assistant = false;
          viewSettings.assistantId = "";
          this.plugin.saveSettings();
        }
        if (!viewSettings.assistant) {
          const modelName = modelNames[change];
          viewSettings.model = change;
          viewSettings.modelName = modelName;
          viewSettings.modelType = models[modelName].type;
          viewSettings.endpointURL = models[modelName].url;
          viewSettings.modelEndpoint = models[modelName].endpoint;
          if (index > -1) {
            this.plugin.settings.promptHistory[index].model = change;
            this.plugin.settings.promptHistory[index].modelName = modelName;
          }
          this.plugin.saveSettings();
          Header2.setHeader(modelName);
        }
        if (viewSettings.assistant) {
          viewSettings.assistantId = change;
          const assistant2 = getAssistant(
            this.plugin,
            viewSettings.assistantId
          );
          viewSettings.model = assistant2.id;
          viewSettings.modelName = assistant2.name;
          viewSettings.modelType = assistant2.modelType;
          viewSettings.endpointURL = "";
          viewSettings.modelEndpoint = assistant;
          if (index > -1) {
            this.plugin.settings.promptHistory[index].model = assistant2.model;
            this.plugin.settings.promptHistory[index].modelName = modelNames[assistant2.model];
          }
          this.plugin.saveSettings();
          Header2.setHeader(assistant2.name);
        }
        this.generateSettingsContainer(parentContainer, Header2);
      });
      dropdown.setValue(viewSettings.model);
    });
  }
  resetSettings(parentContainer) {
    parentContainer.empty();
  }
  generateModelSettings(parentContainer) {
    const settingType = getSettingType(this.viewType);
    const viewSettings = this.plugin.settings[settingType];
    const endpoint = viewSettings.modelEndpoint;
    const modelType = viewSettings.modelType;
    if (endpoint === "images") {
      this.generateImageSettings(parentContainer, viewSettings.model);
    }
    if (endpoint === "moderations") {
      this.generateModerationsSettings(parentContainer);
    }
    if (endpoint === claudeCodeEndpoint) {
      return;
    }
    if (endpoint === chat || messages) {
      this.generateChatSettings(parentContainer, modelType);
      this.generateContextSettings(parentContainer);
    }
  }
  generateImageSettings(parentContainer, model) {
    const settingType = getSettingType(this.viewType);
    const viewSettings = this.plugin.settings[settingType];
    const imageSizes = {
      dallE2: ["256x256", "512x512", "1024x1024"],
      dallE3: ["1024x1024", "1792x1024", "1024x1792"]
    };
    new import_obsidian11.Setting(parentContainer).setName("Number of images").setDesc(
      "The number of images generated by the model. Must be between 1 and 10. For Dall-E 3, only 1 image can be generated."
    ).addText((text) => {
      text.setValue(`${viewSettings.imageSettings.numberOfImages}`);
      text.inputEl.type = "number";
      text.onChange((change) => {
        viewSettings.imageSettings.numberOfImages = parseInt(change);
        this.plugin.saveSettings();
      });
    });
    new import_obsidian11.Setting(parentContainer).setName("Response format").setDesc(
      "The format in which the generated images are returned. Must be one of url or b64_json. URLs are only valid for 60 minutes after the image has been generated."
    ).addDropdown((dropdown) => {
      dropdown.addOption("", "Select a Format");
      dropdown.addOption("url", "URL");
      dropdown.addOption("b64_json", "Base64 JSON");
      dropdown.onChange((change) => {
        viewSettings.imageSettings.response_format = change;
        this.plugin.saveSettings();
      });
    });
    new import_obsidian11.Setting(parentContainer).setName("Image size").setDesc(
      "The size of the generated images. Must be one of 256x256, 512x512, or 1024x1024 for dall-e-2. Must be one of 1024x1024, 1792x1024, or 1024x1792 for dall-e-3 models."
    ).addDropdown((dropdown) => {
      if (model === "dall-e-2") {
        dropdown.addOption("", "Dall-E 2 sizes");
        imageSizes["dallE2"].map((size) => {
          dropdown.addOption(size, size);
        });
      }
      if (model === "dall-e-3") {
        dropdown.addOption("", "Dall-E 3 sizes");
        imageSizes["dallE3"].map((size) => {
          dropdown.addOption(size, size);
        });
      }
      dropdown.onChange((change) => {
        viewSettings.imageSettings.size = change;
        this.plugin.saveSettings();
      });
    });
    if (model === "dall-e-3") {
      new import_obsidian11.Setting(parentContainer).setName("Image style").setDesc(
        "Defaults to vivid. Must be one of vivid or natural. Vivid causes the model to lean towards generating hyper-real and dramatic images. Natural causes the model to produce more natural, less hyper-real looking images. This param is only supported for dall-e-3."
      ).addDropdown((dropdown) => {
        dropdown.addOption("", "Select style");
        dropdown.addOption("natural", "Natural");
        dropdown.addOption("vivid", "Vivid");
        dropdown.onChange((change) => {
          viewSettings.imageSettings.style = change;
          this.plugin.saveSettings();
        });
      });
      new import_obsidian11.Setting(parentContainer).setName("Quality").setDesc(
        "The quality of the image that will be generated. hd creates images with finer details and greater consistency across the image. This param is only supported for dall-e-3."
      ).addToggle((value) => {
        value.onChange(async (value2) => {
          if (value2) {
            viewSettings.imageSettings.quality = "hd";
          } else {
            viewSettings.imageSettings.quality = "standard";
          }
          this.plugin.saveSettings();
        });
      });
    }
  }
  generateChatSettings(parentContainer, modelType) {
    const settingType = getSettingType(this.viewType);
    const viewSettings = this.plugin.settings[settingType];
    new import_obsidian11.Setting(parentContainer).setName("Temperature").setDesc(
      modelType !== GPT4All ? "Defaults to 1. What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. We generally recommend altering this or top_p but not both." : "Higher temperatures (eg., 1.2) increase randomness, resulting in more imaginative and diverse text. Lower temperatures (eg., 0.5) make the output more focused, predictable, and conservative. A safe range would be around 0.6 - 0.85"
    ).addText((text) => {
      text.setValue(`${viewSettings.chatSettings.temperature}`);
      text.inputEl.type = "number";
      text.onChange((change) => {
        viewSettings.chatSettings.temperature = parseFloat(change);
        this.plugin.saveSettings();
      });
    });
    new import_obsidian11.Setting(parentContainer).setName("Tokens").setDesc("Maximum number of tokens in the response. Higher values allow longer responses. Recommended: 4096-8192 for Gemini models.").addText((text) => {
      text.setValue(`${viewSettings.chatSettings.maxTokens}`);
      text.inputEl.type = "number";
      text.onChange((change) => {
        viewSettings.chatSettings.maxTokens = parseInt(change);
        this.plugin.saveSettings();
      });
    });
    if (modelType === openAI) {
      new import_obsidian11.Setting(parentContainer).setName("Frequency penalty").setDesc(
        "Defaults to 0. Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim."
      ).addText((text) => {
        var _a5;
        text.setValue(
          `${(_a5 = viewSettings.chatSettings.openAI) == null ? void 0 : _a5.frequencyPenalty}`
        );
        text.inputEl.type = "number";
        text.onChange((change) => {
          viewSettings.chatSettings.openAI.frequencyPenalty = parseFloat(change);
          this.plugin.saveSettings();
        });
      });
      new import_obsidian11.Setting(parentContainer).setName("Log probs").setDesc(
        "Defaults to false. Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message."
      ).addToggle((value) => {
        value.onChange((change) => {
          viewSettings.chatSettings.openAI.logProbs = change;
          this.plugin.saveSettings();
        });
      });
      new import_obsidian11.Setting(parentContainer).setName("Top log probs").setDesc(
        "An integer between 0 and 5 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used."
      ).addText((text) => {
        var _a5;
        text.setValue(
          `${(_a5 = viewSettings.chatSettings.openAI) == null ? void 0 : _a5.topLogProbs}`
        );
        text.inputEl.type = "number";
        text.onChange((change) => {
          viewSettings.chatSettings.openAI.topLogProbs = parseFloat(change);
          this.plugin.saveSettings();
        });
      });
      new import_obsidian11.Setting(parentContainer).setName("Presence penalty").setDesc(
        "Defaults to 0. Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics."
      ).addText((text) => {
        var _a5;
        text.setValue(
          `${(_a5 = viewSettings.chatSettings.openAI) == null ? void 0 : _a5.presencePenalty}`
        );
        text.inputEl.type = "number";
        text.onChange((change) => {
          viewSettings.chatSettings.openAI.presencePenalty = parseFloat(change);
          this.plugin.saveSettings();
        });
      });
      new import_obsidian11.Setting(parentContainer).setName("Response format").setDesc(
        `An object specifying the format that the model must output. Compatible with GPT-4 turbo and all GPT-3.5 turbo models newer than gpt-3.5-turbo-1106. Setting to { "type": "json_object" } enables JSON mode, which guarantees the message the model generates is valid JSON.`
      ).addText((text) => {
        var _a5;
        text.setValue(
          `${(_a5 = viewSettings.chatSettings.openAI) == null ? void 0 : _a5.responseFormat}`
        );
        text.onChange((change) => {
          viewSettings.chatSettings.openAI.responseFormat = change;
          this.plugin.saveSettings();
        });
      });
      new import_obsidian11.Setting(parentContainer).setName("Top p").setDesc(
        "Defaults to 1. An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered."
      ).addText((text) => {
        var _a5;
        text.setValue(`${(_a5 = viewSettings.chatSettings.openAI) == null ? void 0 : _a5.topP}`);
        text.inputEl.type = "number";
        text.onChange((change) => {
          viewSettings.chatSettings.openAI.topP = parseFloat(change);
          this.plugin.saveSettings();
        });
      });
    }
  }
  generateContextSettings(parentContainer) {
    const settingType = getSettingType(this.viewType);
    const viewSettings = this.plugin.settings[settingType];
    const contextSettings = viewSettings.contextSettings;
    const contextHeader = parentContainer.createEl("h3", {
      text: "Context Settings"
    });
    contextHeader.style.marginTop = "1.5em";
    contextHeader.style.marginBottom = "0.5em";
    new import_obsidian11.Setting(parentContainer).setName("Include active file").setDesc(
      "Automatically include the content of the currently active file in the context sent to the AI."
    ).addToggle((toggle) => {
      toggle.setValue(contextSettings.includeActiveFile).onChange(async (value) => {
        contextSettings.includeActiveFile = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian11.Setting(parentContainer).setName("Include selected text").setDesc(
      "Automatically include any text selected in the editor in the context sent to the AI."
    ).addToggle((toggle) => {
      toggle.setValue(contextSettings.includeSelection).onChange(async (value) => {
        contextSettings.includeSelection = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian11.Setting(parentContainer).setName("Context token budget (%)").setDesc(
      "Percentage of max tokens to allocate for context (0-100). The remaining percentage is reserved for the AI's response. For example, 70% means 70% for context and 30% for the response."
    ).addText((text) => {
      text.setValue(`${contextSettings.maxContextTokensPercent}`);
      text.inputEl.type = "number";
      text.inputEl.min = "0";
      text.inputEl.max = "100";
      text.onChange((change) => {
        const value = parseInt(change);
        if (!isNaN(value) && value >= 0 && value <= 100) {
          contextSettings.maxContextTokensPercent = value;
          this.plugin.saveSettings();
        }
      });
    });
    const selectFilesSetting = new import_obsidian11.Setting(parentContainer).setName("Additional files").setDesc(
      "Select additional files from your vault to include in the context."
    ).addButton((button) => {
      button.setButtonText("Select Files").onClick(() => {
        const modal = new FileSelector(
          this.plugin.app,
          this.plugin,
          this.viewType,
          contextSettings.selectedFiles,
          (files) => {
            contextSettings.selectedFiles = files;
            this.plugin.saveSettings();
            this.updateSelectedFilesDisplay(
              parentContainer,
              selectFilesSetting.settingEl
            );
          }
        );
        modal.open();
      });
    });
    this.updateSelectedFilesDisplay(parentContainer, selectFilesSetting.settingEl);
  }
  updateSelectedFilesDisplay(parentContainer, selectFilesSetting) {
    const settingType = getSettingType(this.viewType);
    const contextSettings = this.plugin.settings[settingType].contextSettings;
    const existingDisplay = parentContainer.querySelector(
      ".llm-selected-files-display"
    );
    if (existingDisplay) {
      existingDisplay.remove();
    }
    if (contextSettings.selectedFiles.length > 0) {
      const displayDiv = document.createElement("div");
      displayDiv.className = "llm-selected-files-display";
      displayDiv.style.marginLeft = "2em";
      displayDiv.style.marginTop = "0.5em";
      displayDiv.style.fontSize = "0.9em";
      const title = displayDiv.createEl("div", {
        text: `Selected files (${contextSettings.selectedFiles.length}):`
      });
      title.style.fontWeight = "500";
      title.style.marginBottom = "0.25em";
      const fileList = displayDiv.createEl("ul");
      fileList.style.margin = "0";
      fileList.style.paddingLeft = "1.5em";
      for (const filePath of contextSettings.selectedFiles) {
        const fileItem = fileList.createEl("li");
        fileItem.style.marginBottom = "0.25em";
        const fileText = fileItem.createEl("span", {
          text: filePath
        });
        fileText.style.color = "var(--text-muted)";
        const removeButton = fileItem.createEl("button", {
          text: "\xD7"
        });
        removeButton.style.marginLeft = "0.5em";
        removeButton.style.padding = "0 0.5em";
        removeButton.style.cursor = "pointer";
        removeButton.addEventListener("click", () => {
          contextSettings.selectedFiles = contextSettings.selectedFiles.filter(
            (f) => f !== filePath
          );
          this.plugin.saveSettings();
          this.updateSelectedFilesDisplay(
            parentContainer,
            selectFilesSetting
          );
        });
      }
      selectFilesSetting.after(displayDiv);
    }
  }
  generateModerationsSettings(parentContainer) {
  }
};

// src/Plugin/FAB/FAB.ts
var import_obsidian12 = require("obsidian");
var ROOT_WORKSPACE_CLASS = ".mod-vertical.mod-root";
var FAB = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  generateFAB() {
    var _a5;
    const fabContainer = createDiv();
    fabContainer.addEventListener("mouseenter", () => {
      const { historyIndex } = getViewInfo(
        this.plugin,
        "floating-action-button"
      );
      setView(this.plugin, "floating-action-button");
      this.plugin.settings.currentIndex = historyIndex;
      this.plugin.saveSettings();
    });
    fabContainer.setAttribute("class", `floating-action-button`);
    fabContainer.setAttribute("id", "_floating-action-button");
    const viewArea = fabContainer.createDiv();
    viewArea.addClass("fab-view-area");
    viewArea.setAttr("style", "display: none");
    const header = new Header(this.plugin, "floating-action-button");
    const chatContainer = new ChatContainer(
      this.plugin,
      "floating-action-button",
      this.plugin.messageStore
    );
    const historyContainer = new HistoryContainer(
      this.plugin,
      "floating-action-button"
    );
    const settingsContainer = new SettingsContainer(
      this.plugin,
      "floating-action-button"
    );
    const assistantsContainer = new AssistantsContainer(
      this.plugin,
      "floating-action-button"
    );
    const lineBreak = viewArea.createDiv();
    const chatContainerDiv = viewArea.createDiv();
    const chatHistoryContainer = viewArea.createDiv();
    const settingsContainerDiv = viewArea.createDiv();
    const assistantsContainerDiv = viewArea.createDiv();
    header.generateHeader(
      viewArea,
      chatContainerDiv,
      chatHistoryContainer,
      settingsContainerDiv,
      assistantsContainerDiv,
      chatContainer,
      historyContainer,
      settingsContainer,
      assistantsContainer
    );
    let history = this.plugin.settings.promptHistory;
    settingsContainerDiv.setAttr("style", "display: none");
    settingsContainerDiv.addClass("fab-settings-container", "llm-flex");
    assistantsContainerDiv.setAttr("style", "display: none");
    assistantsContainerDiv.addClass("fab-assistants-container", "llm-flex");
    chatHistoryContainer.setAttr("style", "display: none");
    chatHistoryContainer.addClass("fab-chat-history-container", "llm-flex");
    lineBreak.className = classNames["floating-action-button"]["title-border"];
    chatContainerDiv.addClass("fab-chat-container", "llm-flex");
    chatContainer.generateChatContainer(chatContainerDiv, header);
    historyContainer.generateHistoryContainer(
      chatHistoryContainer,
      history,
      chatContainerDiv,
      chatContainer,
      header
    );
    settingsContainer.generateSettingsContainer(
      settingsContainerDiv,
      header
    );
    let button = new import_obsidian12.ButtonComponent(fabContainer);
    button.setIcon("bot-message-square").setClass("buttonItem").onClick(() => {
      if (!viewArea.isShown()) {
        viewArea.setAttr("style", "display: block");
      } else {
        viewArea.hide();
      }
    });
    (_a5 = document.body.querySelector(ROOT_WORKSPACE_CLASS)) == null ? void 0 : _a5.insertAdjacentElement("afterbegin", fabContainer);
  }
  removeFab() {
    const FAB2 = document.getElementById("_floating-action-button");
    if (FAB2) {
      FAB2.remove();
    }
  }
  regenerateFAB() {
    this.removeFab();
    this.generateFAB();
  }
};

// src/Plugin/Modal/ChatModal2.ts
var import_obsidian13 = require("obsidian");
var ChatModal2 = class extends import_obsidian13.Modal {
  constructor(plugin) {
    super(plugin.app);
    this.plugin = plugin;
  }
  onOpen() {
    this.modalEl.getElementsByClassName("modal-close-button")[0].setAttr("style", "display: none");
    const { contentEl } = this;
    const header = new Header(this.plugin, "modal");
    const chatContainer = new ChatContainer(
      this.plugin,
      "modal",
      this.plugin.messageStore
    );
    const historyContainer = new HistoryContainer(this.plugin, "modal");
    const settingsContainer = new SettingsContainer(this.plugin, "modal");
    const assistantsContainer = new AssistantsContainer(
      this.plugin,
      "modal"
    );
    const lineBreak = contentEl.createDiv();
    const chatContainerDiv = contentEl.createDiv();
    const chatHistoryContainer = contentEl.createDiv();
    const settingsContainerDiv = contentEl.createDiv();
    const assistantsContainerDiv = contentEl.createDiv();
    header.generateHeader(
      contentEl,
      chatContainerDiv,
      chatHistoryContainer,
      settingsContainerDiv,
      assistantsContainerDiv,
      chatContainer,
      historyContainer,
      settingsContainer,
      assistantsContainer
    );
    let history = this.plugin.settings.promptHistory;
    settingsContainerDiv.setAttr("style", "display: none");
    settingsContainerDiv.addClass("llm-modal-settings-container", "llm-flex");
    assistantsContainerDiv.setAttr("style", "display: none");
    assistantsContainerDiv.addClass("llm-modal-assistants-container", "llm-flex");
    chatHistoryContainer.setAttr("style", "display: none");
    chatHistoryContainer.addClass("llm-modal-chat-history-container", "llm-flex");
    lineBreak.className = classNames["modal"]["title-border"];
    chatContainerDiv.addClass("llm-modal-chat-container", "llm-flex");
    chatContainer.generateChatContainer(chatContainerDiv, header);
    historyContainer.generateHistoryContainer(
      chatHistoryContainer,
      history,
      chatContainerDiv,
      chatContainer,
      header
    );
    settingsContainer.generateSettingsContainer(
      settingsContainerDiv,
      header
    );
  }
};

// src/Plugin/Widget/Widget.ts
var import_obsidian14 = require("obsidian");
var TAB_VIEW_TYPE = "tab-view";
var WidgetView = class extends import_obsidian14.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
  }
  getViewType() {
    return TAB_VIEW_TYPE;
  }
  getDisplayText() {
    return "LLM";
  }
  async onOpen() {
    this.icon = "bot-message-square";
    const container = this.containerEl.children[1];
    const history = this.plugin.settings.promptHistory;
    container.addEventListener("mouseenter", () => {
      const { historyIndex } = getViewInfo(
        this.plugin,
        "widget"
      );
      setView(this.plugin, "widget");
      this.plugin.settings.currentIndex = historyIndex;
      this.plugin.saveSettings();
    });
    container.empty();
    const header = new Header(this.plugin, "widget");
    const chatContainer = new ChatContainer(
      this.plugin,
      "widget",
      this.plugin.messageStore
    );
    const historyContainer = new HistoryContainer(this.plugin, "widget");
    const settingsContainer = new SettingsContainer(this.plugin, "widget");
    const assistantsContainer = new AssistantsContainer(
      this.plugin,
      "widget"
    );
    const lineBreak = container.createDiv();
    const chatContainerDiv = container.createDiv();
    const chatHistoryContainer = container.createDiv();
    const settingsContainerDiv = container.createDiv();
    const assistantContainerDiv = container.createDiv();
    settingsContainerDiv.setAttr("style", "display: none");
    settingsContainerDiv.addClass(
      "llm-widget-settings-container",
      "llm-flex"
    );
    assistantContainerDiv.setAttr("style", "display: none");
    assistantContainerDiv.addClass(
      "llm-widget-assistant-container",
      "llm-flex",
      "llm-widget-tab-assistants"
    );
    chatHistoryContainer.setAttr("style", "display: none");
    chatHistoryContainer.addClass(
      "llm-widget-chat-history-container",
      "llm-flex"
    );
    lineBreak.className = classNames["widget"]["title-border"];
    chatContainerDiv.addClass("llm-widget-chat-container", "llm-flex");
    header.generateHeader(
      container,
      chatContainerDiv,
      chatHistoryContainer,
      settingsContainerDiv,
      assistantContainerDiv,
      chatContainer,
      historyContainer,
      settingsContainer,
      assistantsContainer
    );
    chatContainer.generateChatContainer(chatContainerDiv, header);
    historyContainer.generateHistoryContainer(
      chatHistoryContainer,
      history,
      chatContainerDiv,
      chatContainer,
      header
    );
    settingsContainer.generateSettingsContainer(
      settingsContainerDiv,
      header
    );
    assistantsContainer.generateAssistantsContainer(settingsContainerDiv);
  }
  async onClose() {
  }
};

// src/Settings/SettingsView.ts
var import_obsidian15 = require("obsidian");

// src/assets/LLMguy.svg
var LLMguy_default = '<svg width="40" height="81" viewBox="0 0 40 81" fill="none" xmlns="http://www.w3.org/2000/svg">\n<path fill-rule="evenodd" clip-rule="evenodd" d="M26 0H14V1H13V2H12V3H11V5H10V7H9V8H8H7V7H4V8H1V9H0V10V13H1V14H2V15H3V16V17H5V18H6V26H7V33H8V34H9V35H10V36H11V37H9V38H7V39H6V40H5V41H4V58H3V60H4V61H5V62H6H7V63H8V64H9V65H10V71H9V73H6V74H4H3V75H2V76H1V78H2V79H14V80H17V79H20V80H23V81H32V80H33V78V77H28V76H24V75H23V74H22V67V66H24V65H25V64H26V66H27H28V67H32V66H33V65V63H34V58H33V51H32V47H33V43H32V41V40H31V39H29V38H28V37H27V36H28V35H29V34H30V33H31V29H32V23H36V22H39H40V17V16H39V15H38V14H36V13H32V12H30V5H29V3H28V2H27V1H26V0ZM15 1H25V2H27V4H28V6H29V17H30V13H31V14H35V15H37V16H38V17H39V21H36V22H25V21H19V20H15V19H13V18H12H9V17H6V16H4V15H3V14H2V12H1V10H2V9H5V8H6V9H8V11H7V13H8V11H9V9H10V7H11V5H12V4H13V2H15V1ZM15 20V21V22H14V23H13V20H15ZM24 29V30H21V29V22H19V21H17V22V23V28H16V29H15H13V28H12V27V24V23V19H8V18H7V26H8V32H9V33H10V34H11V35H13V36H17V37H11V38H9V39H8V40H6V42H5V60H6V61H7V59H8V62H9V63H10V64H11H12V65H16V66H22V65H24V63H25V58H26V61H28V62H33V58H32V51H31V46H32V43H31V41H30V40H29V39H28V38H27H26V37H22V36H26V35H27H28V34H29V33H30V29H31V23H26V28H25V23V22H24V25H23H22V29H24ZM24 29V28H25V29H24ZM22 37V38H17V37H22ZM24 76H23H22V75H21V67H17V76H18V78H20V79H23V80H32V78H27V77H24V76ZM14 79H16V67H15V66H12H11V72H10V73V74H6V75H4V76H3V78H14V79ZM13 27H14V28H15V27H16V23H15V24H13V27ZM29 65V66H31V65H32V63H27V65H29ZM22 22H23V24H22V22Z" fill="currentColor"/>\n</svg>\n';

// src/Settings/SettingsView.ts
var SettingsView = class extends import_obsidian15.PluginSettingTab {
  constructor(app, plugin, fab) {
    super(app, plugin);
    this.currentApiInput = null;
    this.apiKeyConfigs = {
      claude: {
        name: "Claude API key",
        desc: "Claude models require an API key for authentication.",
        key: "claudeAPIKey",
        generateUrl: "https://console.anthropic.com/settings/keys"
      },
      gemini: {
        name: "Gemini API key",
        desc: "Gemini models require an API key for authentication.",
        key: "geminiAPIKey",
        generateUrl: "https://aistudio.google.com/app/apikey"
      },
      openai: {
        name: "OpenAI API key",
        desc: "OpenAI models require an API key for authentication.",
        key: "openAIAPIKey",
        generateUrl: "https://platform.openai.com/api-keys"
      }
    };
    this.plugin = plugin;
    this.fab = fab;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian15.Setting(containerEl).setName("Reset chat history").setDesc("This will delete previous prompts and chat contexts").addButton((button) => {
      button.setButtonText("Reset history");
      button.onClick(() => {
        this.plugin.history.reset();
      });
    });
    const apiKeySection = containerEl.createDiv();
    new import_obsidian15.Setting(apiKeySection).setName("Manage API keys").setDesc("Select which API key you want to view or modify").addDropdown((dropdown) => {
      dropdown.addOption("", "Select API to configure");
      Object.keys(this.apiKeyConfigs).forEach((key) => {
        dropdown.addOption(key, this.apiKeyConfigs[key].name);
      });
      dropdown.onChange((value) => {
        this.showApiKeyInput(value, apiKeySection);
      });
    });
    new import_obsidian15.Setting(containerEl).setClass("default-model-selector").setName("Set default model").setDesc("Sets the default LLM you want to use for the plugin").addDropdown((dropdown) => {
      let valueChanged = false;
      dropdown.addOption(
        modelNames[this.plugin.settings.defaultModel],
        "Select default model"
      );
      let keys = Object.keys(models);
      for (let model of keys) {
        if (models[model].type === GPT4All) {
          const gpt4AllPath = getGpt4AllPath(this.plugin);
          const fullPath = `${gpt4AllPath}/${models[model].model}`;
          const exists = this.plugin.fileSystem.existsSync(fullPath);
          if (exists) {
            dropdown.addOption(models[model].model, model);
          }
        } else {
          dropdown.addOption(models[model].model, model);
        }
      }
      dropdown.onChange((change) => {
        valueChanged = true;
        changeDefaultModel(change, this.plugin);
      });
      dropdown.selectEl.addEventListener("blur", () => {
        if (valueChanged) {
          this.plugin.saveSettings();
          valueChanged = false;
        }
      });
      dropdown.setValue(this.plugin.settings.modalSettings.model);
    });
    new import_obsidian15.Setting(containerEl).setName("Toggle FAB").setDesc("Toggles the LLM floating action button").addToggle((value) => {
      value.setValue(this.plugin.settings.showFAB).onChange(async (value2) => {
        this.fab.removeFab();
        this.plugin.settings.showFAB = value2;
        await this.plugin.saveSettings();
        if (value2) {
          this.fab.regenerateFAB();
        }
      });
    });
    const claudeCodeSection = containerEl.createDiv();
    claudeCodeSection.createEl("h3", { text: "Claude Code" });
    new import_obsidian15.Setting(claudeCodeSection).setName("Claude Code OAuth token").setDesc("OAuth token for authenticating with Claude Code (CLAUDE_CODE_OAUTH_TOKEN).").addText((text) => {
      text.inputEl.type = "password";
      text.setValue(this.plugin.settings.claudeCodeOAuthToken);
      text.onChange((value) => {
        this.plugin.settings.claudeCodeOAuthToken = value;
        this.plugin.saveSettings();
      });
    });
    const linearSection = claudeCodeSection.createDiv();
    linearSection.createEl("h4", { text: "Linear Workspaces (Claude Code only)" });
    const desc = linearSection.createEl("p", { cls: "setting-item-description" });
    desc.appendText("Add Linear workspaces with their ");
    desc.createEl("a", {
      text: "API keys",
      href: "https://linear.app/settings/account/security"
    });
    desc.appendText(". Each workspace gets its own MCP server.");
    const workspaceListEl = linearSection.createDiv({ cls: "linear-workspace-list" });
    this.renderWorkspaceList(workspaceListEl);
    new import_obsidian15.Setting(linearSection).setName("Add workspace").addButton((button) => {
      button.setButtonText("+ Add Linear workspace");
      button.onClick(() => {
        this.plugin.settings.linearWorkspaces.push({ name: "", apiKey: "" });
        this.plugin.saveSettings();
        this.renderWorkspaceList(workspaceListEl);
      });
    });
    new import_obsidian15.Setting(containerEl).setName("Enable file context").setDesc("Enable the file context feature that allows AI to access vault files. When disabled, AI will not have access to any files from your vault.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.enableFileContext).onChange(async (value) => {
        this.plugin.settings.enableFileContext = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian15.Setting(containerEl).setName("Donate").setDesc("Consider donating to support development.").addButton((button) => {
      button.setButtonText("Donate");
      button.onClick(() => {
        window.open("https://www.buymeacoffee.com/johnny1093");
      });
    });
    const llmGuy = containerEl.createDiv();
    llmGuy.addClass("llm-icon-wrapper");
    const parser = new DOMParser();
    const svgDoc = parser.parseFromString(LLMguy_default, "image/svg+xml");
    const svgElement = svgDoc.documentElement;
    llmGuy.appendChild(svgElement);
    const credits = llmGuy.createEl("div", {
      attr: { id: "llm-settings-credits" }
    });
    const creditsHeader = credits.createEl("p", {
      text: "LLM plugin",
      attr: { id: "llm-hero-credits" }
    });
    credits.appendChild(creditsHeader);
    const creditsNames = credits.createEl("p", {
      text: "By Johnny\u2728, Ryan Mahoney, and Evan Harris",
      attr: { class: "llm-hero-names llm-text-muted" }
    });
    credits.appendChild(creditsNames);
    const creditsVersion = credits.createEl("span", {
      text: `v${this.plugin.manifest.version}`,
      attr: { class: "llm-text-muted version" }
    });
    credits.appendChild(creditsVersion);
  }
  renderWorkspaceList(containerEl) {
    containerEl.empty();
    const workspaces = this.plugin.settings.linearWorkspaces;
    workspaces.forEach((ws, index) => {
      const row = new import_obsidian15.Setting(containerEl).addText((text) => {
        text.setPlaceholder("Workspace name");
        text.setValue(ws.name);
        text.onChange((value) => {
          this.plugin.settings.linearWorkspaces[index].name = value;
          this.plugin.saveSettings();
        });
      }).addText((text) => {
        text.setPlaceholder("API key");
        text.inputEl.type = "password";
        text.setValue(ws.apiKey);
        text.onChange((value) => {
          this.plugin.settings.linearWorkspaces[index].apiKey = value;
          this.plugin.saveSettings();
        });
      }).addButton((button) => {
        button.setIcon("trash");
        button.setTooltip("Remove workspace");
        button.onClick(() => {
          this.plugin.settings.linearWorkspaces.splice(index, 1);
          this.plugin.saveSettings();
          this.renderWorkspaceList(containerEl);
        });
      });
      row.setName(ws.name || `Workspace ${index + 1}`);
    });
  }
  showApiKeyInput(type, containerEl) {
    const existingSettings = containerEl.querySelector(".api-key-input");
    if (existingSettings) {
      existingSettings.remove();
    }
    if (!type) return;
    const config = this.apiKeyConfigs[type];
    const settingContainer = containerEl.createDiv();
    settingContainer.addClass("api-key-input");
    new import_obsidian15.Setting(settingContainer).setName(config.name).setDesc(config.desc).addText((text) => {
      this.currentApiInput = text;
      text.setValue(this.plugin.settings[config.key]);
      text.onChange((value) => {
        if (value.trim().length) {
          this.plugin.settings[config.key] = value;
          this.plugin.saveSettings();
        }
      });
    }).addButton((button) => {
      button.setButtonText("Generate token");
      button.onClick(() => {
        window.open(config.generateUrl);
      });
    });
  }
};

// src/Plugin/Components/MessageStore.ts
var MessageStore = class {
  constructor() {
    this.messages = [];
    this.subscribers = [];
  }
  addMessage(message) {
    this.messages.push(message);
    this.notifySubscribers();
  }
  setMessages(messages2) {
    this.messages = messages2;
  }
  getMessages() {
    return [...this.messages];
  }
  subscribe(subscriber) {
    this.subscribers.push(subscriber);
  }
  unsubscribe(subscriber) {
    this.subscribers = this.subscribers.filter((sub) => sub !== subscriber);
  }
  notifySubscribers() {
    this.subscribers.forEach((sub) => sub(this.getMessages()));
  }
};

// src/services/OperatingSystem.ts
var MobileOperatingSystem = class {
  homedir() {
    return "";
  }
  platform() {
    return "";
  }
};
var DesktopOperatingSystem = class {
  constructor() {
    this.os = require("os");
  }
  homedir() {
    return this.os.homedir();
  }
  platform() {
    return this.os.platform();
  }
};

// src/services/FileSystem.ts
var DesktopFileSystem = class {
  constructor() {
    this.fs = require("fs");
  }
  existsSync(path4) {
    return this.fs.existsSync(path4);
  }
  async createReadStream(path4) {
    return new Promise((resolve) => {
      const nodeStream = this.fs.createReadStream(path4);
      resolve(new ReadableStream({
        start(controller) {
          nodeStream.on("data", (chunk) => controller.enqueue(chunk));
          nodeStream.on("end", () => controller.close());
          nodeStream.on("error", (err) => controller.error(err));
        }
      }));
    });
  }
};
var MobileFileSystem = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  existsSync(path4) {
    return false;
  }
  async createReadStream(path4) {
    const buffer = await this.plugin.app.vault.adapter.readBinary(path4);
    return new ReadableStream({
      start(controller) {
        controller.enqueue(buffer);
        controller.close();
      }
    });
  }
};

// src/main.ts
var defaultSettings = {
  assistant: false,
  assistantId: "",
  model: "gpt-3.5-turbo",
  modelName: "ChatGPT-3.5 turbo",
  modelType: "openAI",
  modelEndpoint: chat,
  endpointURL: "/chat/completions",
  historyIndex: -1,
  imageSettings: {
    numberOfImages: 1,
    response_format: "url",
    size: "1024x1024",
    style: "vivid",
    quality: "standard"
  },
  chatSettings: {
    maxTokens: 4096,
    temperature: 0.65,
    GPT4All: {},
    openAI: {
      frequencyPenalty: 0,
      logProbs: false,
      topLogProbs: null,
      presencePenalty: 0,
      responseFormat: "",
      topP: 1
    }
  },
  contextSettings: {
    includeActiveFile: true,
    includeSelection: true,
    selectedFiles: [],
    maxContextTokensPercent: 70
    // 70% for context, 30% for response
  }
};
var DEFAULT_SETTINGS = {
  currentIndex: -1,
  currentView: null,
  modalSettings: {
    ...defaultSettings
  },
  widgetSettings: {
    ...defaultSettings
  },
  fabSettings: {
    ...defaultSettings
  },
  promptHistory: [],
  assistants: [],
  openAIAPIKey: "",
  claudeAPIKey: "",
  claudeCodeOAuthToken: "",
  linearWorkspaces: [],
  geminiAPIKey: "",
  GPT4AllStreaming: false,
  //this setting determines whether or not fab is shown by default
  showFAB: false,
  enableFileContext: false,
  defaultModel: ""
};
var LLMPlugin2 = class extends import_obsidian16.Plugin {
  async onload() {
    this.fileSystem = import_obsidian16.Platform.isDesktop ? new DesktopFileSystem() : new MobileFileSystem(this);
    this.os = import_obsidian16.Platform.isDesktop ? new DesktopOperatingSystem() : new MobileOperatingSystem();
    await this.loadSettings();
    await this.checkForAPIKeyBasedModel();
    this.registerRibbonIcons();
    this.registerCommands();
    this.messageStore = new MessageStore();
    this.settings.currentIndex = -1;
    this.messageStore.setMessages([]);
    this.saveSettings();
    this.registerView(TAB_VIEW_TYPE, (tab) => new WidgetView(tab, this));
    this.fab = new FAB(this);
    this.addSettingTab(new SettingsView(this.app, this, this.fab));
    if (this.settings.showFAB) {
      setTimeout(() => {
        this.fab.regenerateFAB();
      }, 500);
    }
    this.history = new History(this);
    this.assistants = new Assistants(this);
  }
  onunload() {
    this.fab.removeFab();
  }
  registerCommands() {
    this.addCommand({
      id: "open-llm-modal",
      name: "Open modal",
      callback: () => {
        new ChatModal2(this).open();
      }
    });
    this.addCommand({
      id: "open-LLM-widget-tab",
      name: "Open chat in tab",
      callback: () => {
        this.activateTab();
      }
    });
    this.addCommand({
      id: "toggle-LLM-fab",
      name: "Toggle FAB",
      callback: () => {
        const currentFABState = this.settings.showFAB;
        this.settings.showFAB = !currentFABState;
        this.saveSettings();
        this.settings.showFAB ? this.fab.regenerateFAB() : this.fab.removeFab();
      }
    });
  }
  registerRibbonIcons() {
    this.addRibbonIcon("bot", "Ask a question", (evt) => {
      new ChatModal2(this).open();
    });
  }
  async activateTab() {
    const { workspace } = this.app;
    let tab = null;
    const tabs = workspace.getLeavesOfType(TAB_VIEW_TYPE);
    if (tabs.length > 0) {
      tab = tabs[0];
    } else {
      tab = workspace.getLeaf("tab");
      await tab.setViewState({ type: TAB_VIEW_TYPE, active: true });
    }
    workspace.revealLeaf(tab);
  }
  async loadSettings() {
    const dataJSON = await this.loadData();
    if (dataJSON) {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, dataJSON);
      this.settings.fabSettings.historyIndex = -1;
      this.settings.widgetSettings.historyIndex = -1;
      if (dataJSON.linearApiKey && !dataJSON.linearWorkspaces) {
        this.settings.linearWorkspaces = [
          { name: "Linear", apiKey: dataJSON.linearApiKey }
        ];
        delete this.settings.linearApiKey;
        await this.saveSettings();
      }
    } else {
      this.settings = Object.assign({}, DEFAULT_SETTINGS);
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async validateActiveModelsAPIKeys() {
    let activeClaudeModel, activeGeminiModel, activeOpenAIModel;
    const settingsObjects = [
      this.settings.modalSettings,
      this.settings.widgetSettings,
      this.settings.fabSettings
    ];
    settingsObjects.forEach((settings) => {
      const model = settings.model;
      switch (model) {
        case "claude-code":
          break;
        case claudeSonnetJuneModel:
          activeClaudeModel = model === claudeSonnetJuneModel;
          break;
        case geminiModel:
        case gemini2FlashModel:
        case gemini2FlashThinkingModel:
        case gemini2FlashStableModel:
        case gemini2FlashLiteModel:
        case gemini25ProModel:
        case gemini25FlashModel:
        case gemini25FlashLiteModel:
        case gemini3ProPreviewModel:
        case geminiFlashLatestModel:
        case geminiFlashLiteLatestModel:
          activeGeminiModel = true;
          break;
        case openAIModel:
          activeOpenAIModel = model === openAIModel;
          break;
      }
    });
    const providerKeyPairs = [
      {
        provider: openAI,
        key: this.settings.openAIAPIKey,
        isActive: activeOpenAIModel
      },
      {
        provider: claude,
        key: this.settings.claudeAPIKey,
        isActive: activeClaudeModel
      },
      {
        provider: gemini,
        key: this.settings.geminiAPIKey,
        isActive: activeGeminiModel
      }
    ];
    const filteredPairs = providerKeyPairs.filter(({ key, isActive }) => {
      if (!key) return;
      if (!isActive) return;
      return key;
    });
    const promises = filteredPairs.map(async (pair) => {
      const result = await getApiKeyValidity(pair);
      return result;
    });
    const results = await Promise.all(promises);
    const hasValidOpenAIAPIKey = results.some((result) => {
      if (result) {
        return result.valid && result.provider === openAI;
      }
    });
    if (hasValidOpenAIAPIKey) await generateAssistantsList(this.settings);
  }
  async checkForAPIKeyBasedModel() {
    const isGeminiModel = (model) => [
      geminiModel,
      gemini2FlashModel,
      gemini2FlashThinkingModel,
      gemini2FlashStableModel,
      gemini2FlashLiteModel,
      gemini25ProModel,
      gemini25FlashModel,
      gemini25FlashLiteModel,
      gemini3ProPreviewModel,
      geminiFlashLatestModel,
      geminiFlashLiteLatestModel
    ].includes(model);
    const fabModelRequiresKey = this.settings.fabSettings.model === openAIModel || this.settings.fabSettings.model === claudeSonnetJuneModel || this.settings.fabSettings.model === "claude-code" || isGeminiModel(this.settings.fabSettings.model);
    const widgetModelRequresKey = this.settings.widgetSettings.model === openAIModel || this.settings.widgetSettings.model === claudeSonnetJuneModel || this.settings.widgetSettings.model === "claude-code" || isGeminiModel(this.settings.widgetSettings.model);
    const modalModelRequresKey = this.settings.modalSettings.model === openAIModel || this.settings.modalSettings.model === claudeSonnetJuneModel || this.settings.modalSettings.model === "claude-code" || isGeminiModel(this.settings.modalSettings.model);
    const activeModelRequiresKey = fabModelRequiresKey || widgetModelRequresKey || modalModelRequresKey;
    if (activeModelRequiresKey) await this.validateActiveModelsAPIKeys();
  }
  // end refactor into utils section
};
/*! Bundled license information:

@google/genai/dist/web/index.mjs:
@google/genai/dist/web/index.mjs:
@google/genai/dist/web/index.mjs:
@google/genai/dist/web/index.mjs:
@google/genai/dist/web/index.mjs:
  (**
   * @license
   * Copyright 2025 Google LLC
   * SPDX-License-Identifier: Apache-2.0
   *)
*/

/* nosourcemap */